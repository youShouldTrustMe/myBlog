<!doctype html>
<html
  lang="zh-cn" 
  
    data-theme-mode="auto"
  
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>







  

<title>
  UDS | TrustMe
</title>
<meta
  name="description"
  content="你要信我啊"
/>










<script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"clipboard\":{\"copyright\":{\"content\":\"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\",\"count\":50,\"enable\":false},\"fail\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"success\":\"复制成功(*^▽^*)\"},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_0khxww3tj3q9\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":\"本文最后更新于 {time}，请注意文中内容可能已经发生变化。\"}}");
</script>











  
  
  
    
  

  
  
  
    
  

  
    

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>






  <link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_0khxww3tj3q9.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  />



  






 <link rel="stylesheet" href="/css/loader.css" />




  <meta property="og:type" content="website" />
  <meta property="og:title" content="UDS | TrustMe" />
  <meta
    property="og:description"
    content="你要信我啊"
  />
  <meta property="og:url" content="http://localhost:1313/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/" />
  <meta
    property="og:site_name"
    content="TruestMe&#39;s Blog"
  />
  <meta
    property="og:image"
    content="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/10_16_55_30_202407101655309.png"
  />
  <meta property="article:author" content="TrustMe" />
  <meta property="article:published_time" content="2025-03-01T00:00:00&#43;00:00" />
  <meta property="article:modified_time" content="2025-03-01T00:00:00&#43;00:00" />
  
    <meta property="article:tag" content="通信协议" />
  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/10_16_55_30_202407101655309.png" />
  
  
  
  
  




<link rel="shortcut icon" href="/favicon.ico">







 <link rel="stylesheet" href="/css/main.css" />





  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />






  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />








  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"
  ></script>





  


  <link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" />





  </head>
  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <img src="/images/loadImage.png" alt="loading" />
        
      </div>
      <div class="loading-word">赖东东得加载一会....</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        
<div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon '>
          
            &#xe61b;
          
        </div>
        <a class="main-nav-link" href="/">首页</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon '>
          
            &#xe623;
          
        </div>
        <a class="main-nav-link" href="/archives">归档</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon '>
          
            &#xe621;
          
        </div>
        <a class="main-nav-link" href="/about">关于</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon '>
          
            &#xe639;
          
        </div>
        <a class="main-nav-link" href="/friend">友链</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
      <a id="nav-search-btn" class="nav-icon popup-trigger" title="搜索"></a>
    
  </nav>
</div>
<header id="header">
  
    
    <picture></picture>
      <img fetchpriority="high" src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/10_16_55_30_202407101655309.png" alt="UDS">
    
  

  <div id="header-outer">
    <div id="header-title">
      
        
        
          
        
  
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">UDS</h1>
          </a>
        
      
  
      
        
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>
        <div id="content"
          class="sidebar-left"
            >
          <aside id="sidebar">
  
  
  <div class="sidebar-wrapper wrap-sticky">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    >
      
        <div class="sidebar-toc-sidebar">
          <div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#不同层的数据格式">不同层的数据格式</a></li>
    <li><a href="#uds协议栈的实现">UDS协议栈的实现</a></li>
  </ul>

  <ul>
    <li><a href="#obdon-board-diagnostic">OBD（On-Board Diagnostic）</a></li>
    <li><a href="#udsunified-diagnostic-services">UDS（Unified diagnostic services）</a></li>
  </ul>

  <ul>
    <li><a href="#service-idsid">Service ID（SID）</a></li>
    <li><a href="#诊断请求">诊断请求</a></li>
    <li><a href="#正负响应">正负响应</a>
      <ul>
        <li><a href="#正响应报文格式">正响应报文格式</a></li>
        <li><a href="#负响应报文格式">负响应报文格式</a></li>
      </ul>
    </li>
    <li><a href="#dtc">DTC</a>
      <ul>
        <li><a href="#dtc结构">DTC结构</a></li>
        <li><a href="#dtc状态">DTC状态</a></li>
        <li><a href="#dtc快照信息">DTC快照信息</a></li>
        <li><a href="#dtc拓展数据信息">DTC拓展数据信息</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#诊断和通信管理类">诊断和通信管理类</a></li>
    <li><a href="#数据传输类">数据传输类</a></li>
    <li><a href="#存储数据传输类">存储数据传输类</a></li>
    <li><a href="#io控制类">IO控制类</a></li>
    <li><a href="#例程功能类-调用ecu内部预置函数">例程功能类-调用ECU内部预置函数</a></li>
    <li><a href="#上传下载类">上传下载类</a></li>
  </ul>

  <ul>
    <li><a href="#0x10诊断会话控制">0x10：诊断会话控制</a>
      <ul>
        <li><a href="#简介-1">简介</a></li>
        <li><a href="#数据包格式">数据包格式</a></li>
        <li><a href="#通信示例">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x11ecu复位">0x11：ECU复位</a>
      <ul>
        <li><a href="#简介-2">简介</a></li>
        <li><a href="#数据包格式-1">数据包格式</a></li>
        <li><a href="#通信示例-1">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x14清除故障码">0x14:清除故障码</a>
      <ul>
        <li><a href="#简介-3">简介</a></li>
        <li><a href="#数据包格式-2">数据包格式</a></li>
        <li><a href="#通信示例-2">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x19读取故障码">0x19：读取故障码</a>
      <ul>
        <li><a href="#简介-4">简介</a></li>
        <li><a href="#常用子功能介绍">常用子功能介绍</a></li>
      </ul>
    </li>
    <li><a href="#0x28通讯控制">0x28：通讯控制</a>
      <ul>
        <li><a href="#简介-5">简介</a></li>
        <li><a href="#数据包格式-8">数据包格式</a></li>
        <li><a href="#通信示例-8">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x27安全访问">0x27：安全访问</a>
      <ul>
        <li><a href="#简介-6">简介</a></li>
        <li><a href="#数据包格式-9">数据包格式</a></li>
        <li><a href="#通信示例-9">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x31例程控制">0x31：例程控制</a>
      <ul>
        <li><a href="#简介-7">简介</a></li>
        <li><a href="#数据包格式-10">数据包格式</a></li>
        <li><a href="#示例">示例</a></li>
      </ul>
    </li>
    <li><a href="#0x34请求下载">0x34：请求下载</a>
      <ul>
        <li><a href="#简介-8">简介</a></li>
        <li><a href="#数据包格式-11">数据包格式</a></li>
      </ul>
    </li>
    <li><a href="#0x36数据传输">0x36：数据传输</a>
      <ul>
        <li><a href="#简介-9">简介</a></li>
        <li><a href="#数据包格式-12">数据包格式</a></li>
      </ul>
    </li>
    <li><a href="#0x37请求退出">0x37：请求退出</a>
      <ul>
        <li><a href="#简介-10">简介</a></li>
        <li><a href="#数据包格式-13">数据包格式</a></li>
        <li><a href="#通信示例-10">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x85控制dtc设置">0x85：控制DTC设置</a>
      <ul>
        <li><a href="#简介-11">简介</a></li>
        <li><a href="#数据包格式-14">数据包格式</a></li>
      </ul>
    </li>
    <li><a href="#0x3d通过地址写内存">0x3D：通过地址写内存</a>
      <ul>
        <li><a href="#简介-12">简介</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
        </div>
        <div class="sidebar-common-sidebar hidden">
          
<div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="TrustMe"
    class="lazyload"
  />
  <div class="sidebar-author-name">TrustMe</div>
  <div class="sidebar-description">你要信我啊</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    
    <div class="sidebar-state-number">60</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">7</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-bilibili sidebar-social-icon">
      <a
        href="https://space.bilibili.com/yourname"
        itemprop="url"
        target="_blank"
        aria-label="bilibili"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/youShouldTrustMe"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="首页"
      ></a>
      <div class='sidebar-menu-icon icon '>
        
          &#xe61b;
        
      </div>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="归档"
      ></a>
      <div class='sidebar-menu-icon icon '>
        
          &#xe623;
        
      </div>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="关于"
      ></a>
      <div class='sidebar-menu-icon icon '>
        
          &#xe621;
        
      </div>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="友链"
      ></a>
      <div class='sidebar-menu-icon icon '>
        
          &#xe639;
        
      </div>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>

        </div>
      

      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  <div class="sidebar-widget">
    
  </div>
</aside>

          <section id="main">
  <article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta">
      <div class="article-date">
  <span
    class="article-date-link"
    data-aos="zoom-in"
  >
    <time datetime="2025-03-01 00:00:00 &#43;0000 UTC" itemprop="datePublished"
      >2025-03-01</time
    >
    <time style="display: none;" id="post-update-time"
      >2025-03-01</time
    >
  </span>
</div>

      <div class="article-category">
  
</div>

    </div>
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="参考链接">
<a class="header-anchor" href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5"></a>
参考链接
</h1><p><a href="https://blog.csdn.net/qq_40309666/article/details/130831416">《UDS协议从入门到精通（UDS速查手册）》（完结撒花版）_obdonuds-CSDN博客</a></p>
<h1 id="简介">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b"></a>
简介
</h1><p>UDS (Unified Diagnostic Services) 是一种标准化的==车辆诊断协议==，广泛应用于汽车电子控制单元（ECU）的诊断和维修。它是ISO 14229标准的一部分，主要用于车辆诊断、故障排除、软件更新和其他与车辆维护相关的服务。</p>
<h1 id="uds协议栈">
<a class="header-anchor" href="#uds%e5%8d%8f%e8%ae%ae%e6%a0%88"></a>
UDS协议栈
</h1><p>UDS（Unified Diagnostic Services）协议栈是实现UDS协议功能的分层架构，确保汽车电子控制单元（ECU）与诊断工具之间的通信。UDS协议栈通常包括以下几层：</p>
<ol>
<li>应用层（Application Layer）：应用层是UDS协议栈的最高层，负责实现具体的诊断服务。它定义了各种诊断服务，如读取数据、清除故障码、重置ECU等。这一层的功能由==ISO 14229标准==规定。</li>
<li>传输层（Transport Layer）：传输层负责数据的分段、重组和流量控制。UDS协议通常使用ISO 15765-2（CAN TP）作为其传输层协议。传输层处理较大的诊断消息，通过将它们分成较小的帧进行传输，然后在接收端重组这些帧。</li>
<li>网络层（Network Layer）：网络层管理数据包的寻址和路由。在UDS协议中，网络层通常依赖于ISO 15765-3标准，这一标准定义了如何在CAN网络上传输诊断信息。网络层确保诊断消息能够正确到达目标ECU。</li>
<li>数据链路层（Data Link Layer）：数据链路层负责物理网络上的数据帧传输和错误检测。在UDS协议中，数据链路层通常基于CAN（Controller Area Network）协议，由ISO 11898标准定义。数据链路层处理数据帧的发送和接收，并提供基本的错误检测和恢复机制。</li>
<li>物理层（Physical Layer）：物理层定义了实际的硬件接口和信号传输特性。在UDS协议中，物理层通常是基于CAN总线的物理层，由ISO 11898标准定义。这一层包括信号的电气特性、连接器和传输介质（如电缆）的规范。</li>
</ol>
<h2 id="不同层的数据格式">
<a class="header-anchor" href="#%e4%b8%8d%e5%90%8c%e5%b1%82%e7%9a%84%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f"></a>
不同层的数据格式
</h2><ol>
<li>
<p><strong>物理层</strong>：比特（Bit）：物理层传输的是原始的二进制数据，即 0 和 1 的比特流。</p>
</li>
<li>
<p><strong>数据链路层</strong>：帧（Frame）：数据链路层的 PDU 是帧，它包括数据包的开始和结束标志、帧同步信息、地址信息、控制信息以及实际的数据负载。</p>
</li>
<li>
<p><strong>网络层</strong>：包（Packet）：网络层的 PDU 是包，它包括源和目的地址、生存时间（TTL）、协议类型等信息，以及数据负载。</p>
</li>
<li>
<p><strong>传输层</strong>：段（Segment）：传输层的 PDU 是段，它包括端口号、序列号、确认号、控制位和其他传输控制信息，以及数据负载。</p>
</li>
<li>
<p><strong>会话层</strong>：会话（Session）：会话层的 PDU 通常指的是会话，它负责建立、管理和终止应用程序之间的会话。</p>
</li>
<li>
<p><strong>表示层</strong>：消息（Message）：表示层的 PDU 是消息，它负责数据的表示、安全和压缩。</p>
</li>
<li>
<p><strong>应用层</strong>：数据（Data）：应用层的 PDU 通常指的是数据，它直接与应用程序交互，包括各种 API 调用和协议特定的数据格式。</p>
</li>
</ol>
<blockquote>
<p>[!TIP]</p>
<p>PDU 是 &ldquo;Protocol Data Unit&rdquo; 的缩写，意为协议数据单元。在计算机网络和通信系统中，PDU 是在不同层次之间传输的数据单位。PDU 的概念在 OSI（Open Systems Interconnection）模型中尤为重要，每个层次都会定义自己的 PDU 格式和用途。</p></blockquote>
<h2 id="uds协议栈的实现">
<a class="header-anchor" href="#uds%e5%8d%8f%e8%ae%ae%e6%a0%88%e7%9a%84%e5%ae%9e%e7%8e%b0"></a>
UDS协议栈的实现
</h2><blockquote>
<p>现假设诊断仪向测试ECU发送了一个0x1001的报文，该诊断仪的CAN id是0x7E0</p></blockquote>
<p>协议栈的组成及数据包格式如下：</p>
<pre class="mermaid">block-beta
columns 3
  app("应用层") space appData("0x10 01")
  trans("传输层") space transData("0x02 + 0x10 01")
  router("router(路由)交换数据") space space
  net("网络层") space netData("0x7E0 + 0x10 00 + 0x02 10 01 00 00 00 00 00")
  data("数据链路层") switch("switch（交换机）") space
  phy("物理层") space phyData("使用总线上的显性隐性电平表示")

  style router  stroke-dasharray: 5
  style switch  stroke-dasharray: 5
</pre>
<p>传输层次==细节==：</p>
<p><em><code>应用</code>层</em></p>
<ul>
<li><strong>应用层数据</strong>：<code>0x1001</code></li>
</ul>
<p><em><code>传输</code>层</em></p>
<ul>
<li><strong>数据格式</strong>：<code>N_PCI</code> + <code>0x1001</code>
<ul>
<li><strong>N_PCI（Network Protocol Control Information）</strong>：<code>0x02</code>，表示这是一个单帧（SF, Single Frame），并且该帧中的数据长度为 2 字节。N_PCI有以下的选择：</li>
<li><strong>完整的传输层数据</strong>：<code>0x02 0x10 0x01</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>[!TIP]</p>
<p>N_PCI:</p>
<ol>
<li>
<p><strong>SF（Single Frame，单帧）：<code>0x0x</code></strong></p>
<ul>
<li>用于表示一个单帧传输，数据长度不超过 7 个字节。</li>
<li><strong>N_PCI 格式</strong>：<code>0x0L</code>，其中 <code>L</code> 表示数据的字节数（最多为 7 字节）。
<ul>
<li><code>0x02</code>：表示单帧，数据长度为 2 字节。</li>
<li><code>0x05</code>：表示单帧，数据长度为 5 字节。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>FF（First Frame，首帧）：<code>0x1x</code></strong></p>
<ul>
<li>用于表示多帧传输的首帧，当数据长度超过 7 字节时使用。</li>
<li><strong>N_PCI 格式</strong>：<code>0x1L</code>，其中 <code>L</code> 表示总的数据长度的高 12 位（最大 4095 字节）。
<ul>
<li>FF 的前两个字节用于传输总的数据长度。</li>
<li>剩下的 6 个字节用于传输首帧中的数据。</li>
<li>例如，<code>0x10 0x12</code> 表示该报文的总数据长度为 18 字节（<code>0x12</code>），后面的 6 个字节是数据。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>CF（Consecutive Frame，连续帧）：<code>0x2x</code></strong></p>
<ul>
<li>用于在首帧之后，继续发送剩余的数据。</li>
<li><strong>N_PCI 格式</strong>：<code>0x2S</code>，其中 <code>S</code> 表示帧序号（从 1 开始，每帧递增，循环计数到 15 然后归 0）。
<ul>
<li>例如，<code>0x21</code> 表示这是第一段连续帧，<code>0x22</code> 是第二段，依此类推。</li>
<li>CF 帧的前一个字节是帧序号，接下来的 7 个字节是数据。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>FC（Flow Control Frame，流控制帧）：<code>0x3x</code></strong></p>
<ul>
<li>用于控制发送方的流量，以便接收方处理数据。</li>
<li><strong>N_PCI 格式</strong>：<code>0x30 SS BS STmin</code>
<ul>
<li><strong>SS</strong>（流控制状态）：表示接收端的反馈状态
<ul>
<li><code>0x00</code>：继续发送（Clear to send, CTS）。</li>
<li><code>0x01</code>：等待（Wait, WAIT）。</li>
<li><code>0x02</code>：中止传输（Abort, ABORT）。</li>
</ul>
</li>
<li><strong>BS</strong>（Block Size）：发送端可以在不等待流控制的情况下连续发送的帧数量。<code>0x00</code> 表示无限制。</li>
<li><strong>STmin</strong>（Separation Time minimum）：指示发送帧之间的最小时间间隔（以毫秒为单位）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>示例:</p>
<ol>
<li>
<p><strong>单帧（Single Frame，SF）</strong>：</p>
<ul>
<li>N_PCI = <code>0x02</code>，表示一个 2 字节的数据包。</li>
<li><strong>数据</strong>：假设数据为 <code>0x1001</code>，完整 N_PCI 数据为：<code>0x02 0x10 0x01</code>。</li>
</ul>
</li>
<li>
<p><strong>首帧（First Frame，FF）</strong>：</p>
<ul>
<li>N_PCI = <code>0x10 0x12</code>，表示该报文的数据总长度为 18 字节。</li>
<li><strong>数据</strong>：首帧中最多可传输 6 字节，剩下的数据会分多帧传输。</li>
</ul>
</li>
<li>
<p><strong>连续帧（Consecutive Frame，CF）</strong>：</p>
<ul>
<li>N_PCI = <code>0x21</code>，表示这是第一段连续帧。</li>
<li><strong>数据</strong>：7 字节数据从 <code>0x07</code> 开始。</li>
</ul>
</li>
<li>
<p><strong>流控制帧（Flow Control Frame，FC）</strong>：</p>
<ul>
<li>N_PCI = <code>0x30 0x00 0x05 0x01</code>：
<ul>
<li><code>0x30</code>：流控制帧，状态为 CTS（Clear to Send）。</li>
<li><code>0x00</code>：Block Size 为无限制，发送端可以连续发送。</li>
<li><code>0x05</code>：每个连续帧之间必须间隔至少 5 毫秒。</li>
</ul>
</li>
</ul>
</li>
</ol></blockquote>
<p><em><code>网络</code>层</em></p>
<ul>
<li><strong>数据</strong>：<code>CAN ID + DLC + 数据</code>
<ul>
<li><strong>CAN ID</strong>：<code>0x7E0</code>，表示这是诊断仪器发往 ECU 的消息。</li>
<li><strong>DLC（Data Length Code）</strong>：<code>8</code>，表示数据长度为 8 个字节（尽管实际数据可能少于 8 字节，DLC 通常为 8）。</li>
<li><strong>数据</strong>：<code>0x02 0x10 0x01 0x00 0x00 0x00 0x00 0x00</code>（CAN 总线允许的最大数据长度是 8 字节，短数据帧会用 <code>0x00</code> 填充）。</li>
<li><strong>网络层数据格式</strong>：
<ul>
<li><code>CAN ID = 0x7E0</code></li>
<li><code>DLC = 8</code></li>
<li><code>数据 = 0x02 0x10 0x01 0x00 0x00 0x00 0x00 0x00</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em><code>物理</code>层</em></p>
<ul>
<li><strong>电压信号</strong>：物理层会将网络层的数据转换为电压信号，传输到 CAN 总线上。
<ul>
<li>在 CAN 总线上，数据会以位级别的电压信号传输，其中 CAN 帧的每一位都通过电压变化（主导电平和隐性电平）来表示。</li>
</ul>
</li>
</ul>
<hr>
<p>最终完整的报文传输：</p>
<table>
  <thead>
      <tr>
          <th>层次</th>
          <th>报文内容</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>应用层</td>
          <td><code>0x1001</code></td>
          <td>发送一个诊断请求，应用层负责生成具体的报文内容</td>
      </tr>
      <tr>
          <td>传输层</td>
          <td><code>0x02 0x10 0x01</code></td>
          <td>N_PCI 表示单帧传输，数据长度为 2 字节，携带 <code>0x1001</code> 数据</td>
      </tr>
      <tr>
          <td>网络层</td>
          <td>CAN ID: <code>0x7E0</code>, DLC: <code>8</code>, 数据: <code>0x02 0x10 0x01 0x00 0x00 0x00 0x00 0x00</code></td>
          <td>CAN 数据帧，CAN ID 为 <code>0x7E0</code>，数据为单帧格式，DLC 为 8</td>
      </tr>
      <tr>
          <td>物理层</td>
          <td>电压信号</td>
          <td>CAN 总线上的电压变化用于物理传输数据</td>
      </tr>
  </tbody>
</table>
<h1 id="两种常见的诊断协议">
<a class="header-anchor" href="#%e4%b8%a4%e7%a7%8d%e5%b8%b8%e8%a7%81%e7%9a%84%e8%af%8a%e6%96%ad%e5%8d%8f%e8%ae%ae"></a>
两种常见的诊断协议
</h1><ul>
<li>OBD</li>
<li>UDS</li>
</ul>
<p>OBD和UDS是两种常见的诊断协议，它们在目标和应用领域上存在一些区别。OBD协议主要用于监测车辆的排放情况，通过读取车辆的故障码来判断是否符合排放标准。而UDS协议则更加全面和灵活，在各个ECU上是一种通用型的协议。</p>
<h2 id="obdon-board-diagnostic">
<a class="header-anchor" href="#obdon-board-diagnostic"></a>
OBD（On-Board Diagnostic）
</h2><p>主要用于跟汽车排放系统相关的ECU（电子控制单元，汽车上的板级控制器）的诊断。OBD协议分为两种：OBD-I和OBD-II。OBD-I是由美国为当时制造的加州汽车所制定的排放法规，随后这套法规被逐渐标准化，于是又提出了OBDII标准，包括：标准化的车载ECU数据诊断接口（SAE-J1962，也就是现在常说的OBD接口）、标准化的诊断解码工具（SAE-J1978）、标准化的诊断协议（ISO 9141-2、ISO 14230-4、ISO 15765-4）、标准化的故障码定义（SAE-J2012、ISO 15031-6）、标准化的维修服务指南（SAE-J2000），OBD-II在1996年开始实施，目前已经成为全球汽车行业的标准。<strong>因此，OBD标准可以看作一系列标准的集合，是具有强制标准需要参照的，是由法规要求的，其最初目的是环保，用于汽车排放系统相关的ECU上</strong>。</p>
<h2 id="udsunified-diagnostic-services">
<a class="header-anchor" href="#udsunified-diagnostic-services"></a>
UDS（Unified diagnostic services）
</h2><p>UDS（Unified Diagnostic Services）与OBD最大的区别就在于“Unified“上，是面向整车所有ECU的。单就UDS而言，它只是一个应用层协议（ISO 14229-1），不关心应用层以下的实现，比如执行该协议的应用层程序不关心通过何种物理传输方式实现与ECU硬件的通信，因此它既可以基于CAN线通信去实现，也能在Ethernet上实现。并且，UDS提供的是一个诊断服务的基本框架，定义了一系列的诊断服务和通用化的诊断流程，主机厂和零部件供应商可以根据实际情况选择实现其中的一部分或是自定义出一些私有化的诊断服务来，所以基于UDS协议的诊断又常常被称为Enhanced diagnosic（增强型诊断）。<strong>可见，UDS不是法规要求的，没有统一实现标准，可以基于该协议提供的诊断请求及响应格式进行二次开发</strong>。</p>
<p><strong>简言之，UDS服务主要用于诊断设备Tester（Client）和ECU（Server）之间的诊断通信，诊断设备（Tester）发送诊断请求（request），ECU给出诊断响应（response），通过这种“一问一答”的形式让目标ECU执行一些期望的操作，而UDS就是为不同类型诊断功能的request和response定义了统一的内容和格式。</strong></p>
<h1 id="相关术语介绍">
<a class="header-anchor" href="#%e7%9b%b8%e5%85%b3%e6%9c%af%e8%af%ad%e4%bb%8b%e7%bb%8d"></a>
相关术语介绍
</h1><h2 id="service-idsid">
<a class="header-anchor" href="#service-idsid"></a>
Service ID（SID）
</h2><p>在UDS协议中，Service ID（SID）是指服务标识符，用于标识要执行的服务。每个服务都有一个唯一的SID，在诊断会话中通过SID来区分要执行/响应哪种服务请求。14229-1中定义了26种服务并将这些服务分为6大类：诊断和通信管理类、数据传输类、存储数据传输类、输入输出控制类、例程功能类、上传下载类。</p>
<table>
  <thead>
      <tr>
          <th>大类</th>
          <th>SID (Hex)</th>
          <th>诊断服务名</th>
          <th>服务Service</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>诊断和通信管理类</td>
          <td>10</td>
          <td>诊断会话控制</td>
          <td>Diagnostic Session Control</td>
      </tr>
      <tr>
          <td>:</td>
          <td>11</td>
          <td>ECU复位</td>
          <td>ECU Reset</td>
      </tr>
      <tr>
          <td>:</td>
          <td>27</td>
          <td>安全访问</td>
          <td>Security Access</td>
      </tr>
      <tr>
          <td>:</td>
          <td>28</td>
          <td>通讯控制</td>
          <td>Comunication Control</td>
      </tr>
      <tr>
          <td>:</td>
          <td>3E</td>
          <td>待机握手</td>
          <td>Tester Present</td>
      </tr>
      <tr>
          <td>:</td>
          <td>83</td>
          <td>访问时间参数</td>
          <td>Access Timing Parameter</td>
      </tr>
      <tr>
          <td>:</td>
          <td>84</td>
          <td>安全数据传输</td>
          <td>Secured Data Transmission</td>
      </tr>
      <tr>
          <td>:</td>
          <td>85</td>
          <td>控制DTC的设置</td>
          <td>Control DTC Setting</td>
      </tr>
      <tr>
          <td>:</td>
          <td>86</td>
          <td>事件响应</td>
          <td>Response On Event</td>
      </tr>
      <tr>
          <td>:</td>
          <td>87</td>
          <td>链路控制</td>
          <td>Link Control</td>
      </tr>
      <tr>
          <td>数据传输类</td>
          <td>22</td>
          <td>通过ID读数据</td>
          <td>Read Data By Identifier</td>
      </tr>
      <tr>
          <td>:</td>
          <td>23</td>
          <td>通过地址读取内存</td>
          <td>Read Memory By Adress</td>
      </tr>
      <tr>
          <td>:</td>
          <td>24</td>
          <td>通过ID读比例数据</td>
          <td>Read Scaling Data By Identifier</td>
      </tr>
      <tr>
          <td>:</td>
          <td>2A</td>
          <td>通过周期ID读取数据</td>
          <td>Read Data By Periodic Identifier</td>
      </tr>
      <tr>
          <td>:</td>
          <td>2C</td>
          <td>动态定义标识符</td>
          <td>Dynamically Define Data Identifier</td>
      </tr>
      <tr>
          <td>:</td>
          <td>2E</td>
          <td>通过ID写数据</td>
          <td>Write Data By Identifier</td>
      </tr>
      <tr>
          <td>:</td>
          <td>3D</td>
          <td>通过地址写内存</td>
          <td>Write Memory By Adress</td>
      </tr>
      <tr>
          <td>存储数据传输类</td>
          <td>14</td>
          <td>清除诊断信息</td>
          <td>Clear Diagnostic Infomation</td>
      </tr>
      <tr>
          <td>:</td>
          <td>19</td>
          <td>读取故障码信息</td>
          <td>Read DTC Infomation</td>
      </tr>
      <tr>
          <td>输入输出控制类</td>
          <td>2F</td>
          <td>通过ID控制输入输出</td>
          <td>Input/Output Control By Identifier</td>
      </tr>
      <tr>
          <td>例程功能类</td>
          <td>31</td>
          <td>例行程序控制</td>
          <td>Routine Control</td>
      </tr>
      <tr>
          <td>上传下载类</td>
          <td>34</td>
          <td>请求下载</td>
          <td>Request Download</td>
      </tr>
      <tr>
          <td>:</td>
          <td>35</td>
          <td>请求上传</td>
          <td>Request Upload</td>
      </tr>
      <tr>
          <td>:</td>
          <td>36</td>
          <td>数据传输</td>
          <td>Transfer Data</td>
      </tr>
      <tr>
          <td>:</td>
          <td>37</td>
          <td>请求退出传输</td>
          <td>Request Transfer Exit</td>
      </tr>
      <tr>
          <td>:</td>
          <td>38</td>
          <td>请求文件传输</td>
          <td>Request File Transfer</td>
      </tr>
  </tbody>
</table>
<h2 id="诊断请求">
<a class="header-anchor" href="#%e8%af%8a%e6%96%ad%e8%af%b7%e6%b1%82"></a>
诊断请求
</h2><p>诊断请求是指诊断工具向车辆发送的请求消息，用于请求执行某个服务。诊断请求消息由三个部分组成：</p>
<ul>
<li>
<p>SID：用于标识要执行的服务</p>
</li>
<li>
<p>子功能：这个服务还能更进一步的划分或者具有启动/暂停之类的子功能</p>
</li>
<li>
<p>实际数据</p>
</li>
</ul>
<p>尽管服务类型不尽相同，但UDS针对这些服务定义了统一的诊断请求包的格式，每个诊断请求由1个Byte的SID + 1个Byte的 sub-function（实际上是1bit spr + 7bit sub-function）+ 不定长的实际数据构成，其格式如下所示：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/10_16_55_30_202407101655309.png" alt="诊断请求"></p>
<p>spr存在的目的是告诉ECU针对某个服务请求是否需要发送正响应数据，用于减少ECU发送不必要的响应，节约系统资源：</p>
<ul>
<li>spr=1， 抑制正响应，即ECU不给出正响应；</li>
<li>spr=0， 需要ECU给出正响应，如果某个服务没有sub-function，即没有第二个字节，那默认是要发正响应的。</li>
</ul>
<h2 id="正负响应">
<a class="header-anchor" href="#%e6%ad%a3%e8%b4%9f%e5%93%8d%e5%ba%94"></a>
正负响应
</h2><p>诊断工具向车辆发送服务请求后，如果服务执行成功，则返回的响应消息称为正响应，反之返回的响应消息称为负响应。</p>
<h3 id="正响应报文格式">
<a class="header-anchor" href="#%e6%ad%a3%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f"></a>
正响应报文格式
</h3><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/18_15_21_5_202502181521753.png" alt="正响应报文格式"></p>
<p>举个栗子：</p>
<p>0x10-诊断会话控制服务</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/10_17_0_20_202407101700348.png" alt="带SID的例子"></p>
<p>再举个不带sub-function的例子：0x22-通过DID读数据（实际上SID和sub function都是固定的，这里的例子就是不带有sub function的报文）</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/10_17_2_44_202407101702608.png" alt="不带SID的例子"></p>
<h3 id="负响应报文格式">
<a class="header-anchor" href="#%e8%b4%9f%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f"></a>
负响应报文格式
</h3><p>负响应消息由两部分组成：SID和负响应码（NRC）。SID用于标识响应的服务，负响应码指示服务执行失败的原因。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_13_30_19_202407111330814.png" alt="负响应报文格式"></p>
<p>——还是拿0x10-诊断会话控制服务来举例：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_13_31_28_202407111331343.png" alt="负响应例子"></p>
<h4 id="负响应码negative-response-code---nrc">
<a class="header-anchor" href="#%e8%b4%9f%e5%93%8d%e5%ba%94%e7%a0%81negative-response-code---nrc"></a>
负响应码（Negative Response Code - NRC）
</h4><p>在UDS协议中，负响应码用于指示服务执行失败的原因。NRC用一个字节表示，每个取值都对应一种不同的错误类型。</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>NRC码</td>
          <td>含义</td>
          <td>NRC码</td>
          <td>含义</td>
      </tr>
      <tr>
          <td>0x01 - 0x0f</td>
          <td>暂保留；</td>
          <td>0x78</td>
          <td>收到请求，延迟响应；</td>
      </tr>
      <tr>
          <td>0x10</td>
          <td>未知错误，服务被拒绝；</td>
          <td>0x79 - 0x7d</td>
          <td>暂保留；</td>
      </tr>
      <tr>
          <td>0x11</td>
          <td>不支持该服务请求；</td>
          <td>0x7e</td>
          <td>当前会话下子功能不支持；</td>
      </tr>
      <tr>
          <td>0x12</td>
          <td>不支持子功能；</td>
          <td>0x7f</td>
          <td>当前会话下服务不支持；</td>
      </tr>
      <tr>
          <td>0x13</td>
          <td>消息长度或格式错误；</td>
          <td>0x80</td>
          <td>暂保留；</td>
      </tr>
      <tr>
          <td>0x14</td>
          <td>请求信息长度超出；</td>
          <td>0x81</td>
          <td>rpm（每分钟转速）太高；</td>
      </tr>
      <tr>
          <td>0x15 - 0x20</td>
          <td>暂保留；</td>
          <td>0x82</td>
          <td>rpm太低；</td>
      </tr>
      <tr>
          <td>0x21</td>
          <td>服务端正忙；</td>
          <td>0x83</td>
          <td>当前引擎正在运行；</td>
      </tr>
      <tr>
          <td>0x22</td>
          <td>条件不满足；</td>
          <td>0x84</td>
          <td>当前引擎未运行；</td>
      </tr>
      <tr>
          <td>0x23</td>
          <td>暂保留；</td>
          <td>0x85</td>
          <td>截止当前时间引擎运行时间太短；</td>
      </tr>
      <tr>
          <td>0x24</td>
          <td>请求顺序错误；</td>
          <td>0x86</td>
          <td>温度过高；</td>
      </tr>
      <tr>
          <td>0x25</td>
          <td>指令已经被接收，但是未被执行；</td>
          <td>0x87</td>
          <td>温度过低；</td>
      </tr>
      <tr>
          <td>0x26</td>
          <td>失败的操作导致当前操作无法执行；</td>
          <td>0x88</td>
          <td>车速过高；</td>
      </tr>
      <tr>
          <td>0x27 - 0x30</td>
          <td>暂保留；</td>
          <td>0x89</td>
          <td>车速过低；</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>参数错误；</td>
          <td>0x8a</td>
          <td>油门/踏板过高（超过了当前要求的最大阈值）；</td>
      </tr>
      <tr>
          <td>0x32</td>
          <td>暂保留；</td>
          <td>0x8b</td>
          <td>油门/踏板过低；</td>
      </tr>
      <tr>
          <td>0x33</td>
          <td>安全校验未通过；</td>
          <td>0x8c</td>
          <td>变速器档位不在空档；</td>
      </tr>
      <tr>
          <td>0x34</td>
          <td>暂保留；</td>
          <td>0x8d</td>
          <td>变速器档位不在排挡；</td>
      </tr>
      <tr>
          <td>0x35</td>
          <td>密钥不匹配；</td>
          <td>0x8e</td>
          <td>暂保留；</td>
      </tr>
      <tr>
          <td>0x36</td>
          <td>已达到解锁最大错误次数；</td>
          <td>0x8f</td>
          <td>制动开关没有关闭</td>
      </tr>
      <tr>
          <td>0x37</td>
          <td>超时时间未到；</td>
          <td>0x90</td>
          <td>换挡杆不在驻车档；</td>
      </tr>
      <tr>
          <td>0x38 - 0x4f</td>
          <td>由扩展数据链路安全性保留；</td>
          <td>0x91</td>
          <td>变矩器离合器锁定；</td>
      </tr>
      <tr>
          <td>0x50 - 0x6f</td>
          <td>暂保留；</td>
          <td>0x92</td>
          <td>电压过高；</td>
      </tr>
      <tr>
          <td>0x70</td>
          <td>不允许上传下载；</td>
          <td>0x93</td>
          <td>电压过低；</td>
      </tr>
      <tr>
          <td>0x71</td>
          <td>数据传输中断；</td>
          <td>0x94 - 0xef</td>
          <td>暂保留（特定条件下）；</td>
      </tr>
      <tr>
          <td>0x72</td>
          <td>擦除或烧写内存错误；</td>
          <td>0xf0 - 0xfe</td>
          <td>为汽车制造商保留；</td>
      </tr>
      <tr>
          <td>0x73</td>
          <td>块序列计数错误；</td>
          <td>0xff</td>
          <td>暂保留；</td>
      </tr>
      <tr>
          <td>0x74 - 0x77</td>
          <td>暂保留；</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h2 id="dtc">
<a class="header-anchor" href="#dtc"></a>
DTC
</h2><p>DTC(Diagnostic Trouble Code,诊断故障码)是指车辆电子控制单元(ECU)存储的车辆故障代码，它是一种数字编码，用于标识车辆的故障问题。每个DTC都与特定的故障相关联，这些故障可能会导致车辆的某些系统无法正常工作。</p>
<p>车辆在运行过程中ECU会持续监控车辆运行状态，检测到故障时，它会记录相应的DTC,并将其存储在车辆的故障存储器中。通过读取故障存储器中的DTC,可以快速确定车辆的故障问题，并采取相应的修复措施（涉及DTC的读取和清除：<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x14%ef%bc%9a%e6%b8%85%e9%99%a4%e6%95%85%e9%9a%9c%e7%a0%81">0x14服务</a>和<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x19%ef%bc%9a%e8%af%bb%e5%8f%96%e6%95%85%e9%9a%9c%e7%a0%81">0x19服务</a>)。</p>
<h3 id="dtc结构">
<a class="header-anchor" href="#dtc%e7%bb%93%e6%9e%84"></a>
DTC结构
</h3><p>DTC的格式定义是依据几个标准来的，比如ISO-14229-1,SAEJ2012 OBD DTC和SAEJ1939-73等。就学习DTC来说，我们不必关注各个标准间的异同和细节，只需了解DTC分为non OBD和OBD两种格式，具体格式如下所示：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/18_15_35_34_202502181535130.png" alt="DTC结构"></p>
<p>可以清晰地看到DTC由四个字节组成，最高字节均保留未使用，剩下三个字节我们标记为：</p>
<ol>
<li>DTC HighByte</li>
<li>DTC MiddleByte</li>
<li>DTC LowByte。</li>
</ol>
<blockquote>
<p>[!tip]</p>
<p>DTC HighByte和DTC MiddleBytei两个字节表示故障内码，对应5位标准故障码（一位字母+四位数字）。</p>
<p>DTC LowByte描述了故障的种类和子类型（可以参考IS015031-6以及SAEJ2012-DA,比如常见的timeout)应该用0x87,信号无效为0x81等等)，简单理解就是对故障类别作进一步的区分/描述，未使用这个字节的可以用0x00填充，比如OBD格式的最低字节未使用，默认为0x00。</p></blockquote>
<p>举例DTC:B100016</p>
<ul>
<li>其中&quot;B1000&quot;表示故障内码，对应5位标准故障码；</li>
<li>&ldquo;16&quot;是DTCLowByte的内容。</li>
</ul>
<p>故障内码与5位标准故障码的对应关系如下：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/18_15_39_43_202502181539679.png" alt="故障内码和5位标准码所对应的关系"></p>
<p>看完上面的DTC五位标准故障码的构成，再来看个例子：</p>
<p><code>DTC-P010016</code>:</p>
<ul>
<li>第一位是P代表此故障码和动力系统相关；</li>
<li>第二位是0，是ISO标准中定义的故障类型；</li>
<li>第三位是1，表示燃油和空气供应的测量相关；</li>
<li>第四位和第五位是都是0,是具体的故障对象和类型的一个编码；</li>
<li>第六位和第七位16则是DTCLowByt的内容。</li>
</ul>
<p>在车载操作系统的代码中，DTC码通常作为十六进制数处理，将P010016转换为16进制数如下所示：</p>
<p>二进制表示为：<code>P</code>(00) <code>0</code>(00) <code>1</code>(0001) <code>0</code>(0000) <code>0</code>(0000) <code>1</code>(0001) <code>6</code>(0110)
十六进制表示：0x10016</p>
<blockquote>
<p>[!tip]</p>
<p>不必疑惑有些位到底表示什么故障类型，更具体的含义是什么，通常制造商会提供他们每个编码的具体含义。</p></blockquote>
<p>完成上面对DTC码的学习后，我们可以根据DTC大致知道是哪个系统什么类型的故障但不能清晰得知故障是什么时候发生的，是什么原因触发的这个故障、现在是否已经恢复发生过几次，恢复过几次等细节性信息，因此还需要其他信息：比如DTC状态(DTC status)、DTC快照信息(Snapshot)和DTC扩展数据信息(Extended data)。只有发生故障的时候存储下了这些关键信息，才能有助于故障的解决。</p>
<h3 id="dtc状态">
<a class="header-anchor" href="#dtc%e7%8a%b6%e6%80%81"></a>
DTC状态
</h3><p>DTC状态为1个字节，其8个bit位含义各不相同，如下表所示：</p>
<table>
  <thead>
      <tr>
          <th>bit位</th>
          <th>名称</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>testFailed</td>
          <td>通常来说，ECU内部以循环的方式不断地针对预先定义好的错误路径进行测试，如 果在最近的一次测试中，==在某个错误路径中发现了故障，则相应DTC的这一个状态位就 要被置1，表征出错。== <!-- raw HTML omitted -->虽然此时DTC的testFailed位被置1，但是它不一定被ECU存储到非易失性存储中， 只有当pendingDTC或confirmedDTC被置1时DTC才会被存储。而pendingDTC或 confirmedDTC被置1的条件应该是检测到错误出现的次数或时间满足某个预定义的门限。当错误消失或者诊断仪执行了清除DTC指令时，testFailed会再次被置为0。</td>
      </tr>
      <tr>
          <td>1</td>
          <td>testFailedThisOperationCycle</td>
          <td>==该bit用于标识某个DTC在当前的operationcycle中是否出现过testFailed置1的情 况，即是否出现过错误。== <!-- raw HTML omitted -->operation cycle的起始点是ECU通过网络管理唤醒到ECU通过网络管理进入睡眠， 对于没有网络管理的ECU，这个起始点就是KL15通断。通过bit 0我们无法判断某个DTC 是否出现过，比如，当前testFailed=0，说明当前这个DTC没有出错，如果 testFailedThisOperationCycle=1的话，就说明这个DTC在当前这个operationcycle中 出过错，但是当前错误又消失了。</td>
      </tr>
      <tr>
          <td>2</td>
          <td>pendingDTC</td>
          <td>根据规范的解释，==pendingDTC=1表示某个DTC在当前或者上一个operationcycle 中是否出现过。== <!-- raw HTML omitted -->pendingDTC位其实是位于testFailed和confirmedDTC之间的一个状态，有的DTC被确认的判定条件比较严苛，需要在多个operationcycle中出现才可以被判定为 confirmed的状态，此时就需要借助于pendingDTC位。 pendingDTC=1的时候，DTC就要被存储下来了，如果接下来的两个operation cycle中这个DTC都还存在，那么confirmedDTC就要置1了。如果当前operationcycle 中，故障发生，pendingDTC=1，但是在下一个operationcycle中，故障没有了， pendingDTC仍然为1，再下一个operationcycle中，故障仍然不存在，那么pending DTC就可以置0了。</td>
      </tr>
      <tr>
          <td>3</td>
          <td>confirmedDTC</td>
          <td>==当confirmedDTC=1时，则说明某个DTC已经被存储到ECU的非易失性存储中==，说明这个DTC曾经满足了被confirmed的条件。 但是请注意，confirmedDTC=1时，并不意味着当前这个DTC仍然出错，如果confirmedDTC=1，但testFailed=0，则说明这个DTC表示的故障目前已经消失了。 将confirmedDTC重新置0的方法只有删除DTC，对应UDS的<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x14%ef%bc%9a%e6%b8%85%e9%99%a4%e6%95%85%e9%9a%9c%e7%a0%81">0x14服务</a>服务。</td>
      </tr>
      <tr>
          <td>4</td>
          <td>testNotCompletedSinceLastCear</td>
          <td>该bit用于标识自从上次调用了清理DTC的服务（UDS0x14服务）之后，==是否成功地执行了对某个DTC的测试==（不管测试结果是什么，只关心是否测了）。因为很多DTC的测试也是需要满足某些边界条件的，并不是ECU上电就一定会对DTC进行检测。<!-- raw HTML omitted --> testNotCompletedSinceLastClear=1：自清理DTC后还没有完成过针对该DTC的测试。<!-- raw HTML omitted -->testNotCompletedSinceLastClear=0：自清理DTC之后已经完成过针对该DTC的测试。</td>
      </tr>
      <tr>
          <td>5</td>
          <td>testFailedSinceLastClear</td>
          <td>这个位与bit1：testFailedThisOperationCycle有些类似，后者标识某个DTC在当前 的operationcycle中是否出现过testFailed置1的情况，而testFailedSinceLastClear标识的是在==上次执行过清理DTC之后某个DTC是否出过错==。 testFailedSinceLastClear=0，自从清理DTC之后该DTC没有出过错。<!-- raw HTML omitted -->testFailedSinceLastClear=1，自从清理DTC之后该DTC出过至少一次错。</td>
      </tr>
      <tr>
          <td>6</td>
          <td>testNotCompletedThisOperationCycle</td>
          <td>这个位与bit4：testNotCompletedSinceLastClear类似，后者标识自从上次调用了 清理DTC的服务之后，是否成功地执行了对某个DTC的测试。而该参数则标识==在当前 operationcycle中是否成功地执行了对某个DTC的测试==。 <!-- raw HTML omitted -->testNotCompletedThisOperationCycle=1：未成功完成过测试。<!-- raw HTML omitted -->testNotCompletedThisOperationCycle=0：成功完成过测试。</td>
      </tr>
      <tr>
          <td>7</td>
          <td>warningIndicatorRequested</td>
          <td>==某些比较严重的DTC会与用户可见的警告指示相关联==，比如仪表上的报警灯，或者 是文字，或者是声音。这个warningIndicatorRequested就用于此类DTC。<!-- raw HTML omitted -->warningIndicatorRequested=1：ECU请求激活警告指示。<!-- raw HTML omitted -->warningIndicatorRequested=0：ECU不请求激活警告指示。 <!-- raw HTML omitted -->注意，如果这个DTC不支持警告指示，则这个位永远置0。</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>[!tip]</p>
<p>是不是testfailed一被置1，pendingdtc也会马上被置1?</p>
<p>在车载系统的UDS协议中，DTC(Diagnostic Trouble Codes)状态位的管理是错误监控和故障诊断过程的一部分。这些位的设置与清除取决于特定的条件和故障检测逻辑。testFailed位和pendingDTC位代表了故障检测的不同阶段：</p>
<ol>
<li>testFailed位通常是实时的，在最近的一次监测周期中，如果某个ECU监测的参数不在预期的范围内，就会将这一位设置为1。这表明在最近的检测周期中，该ECU监测到了一个故障。但这并不意味着故障会立即被记录下来，因为它可能是暂时的或偶发的。</li>
<li>pendingDTC位则是在故障符合一定条件后才被置为1，通常是在故障在一个或多个操作周期中被检测到。pendingDTC为1意味着故障已经被记录下来，但还未达到confirmedDTC(确认DTC)的标准。</li>
</ol></blockquote>
<blockquote>
<p>[!tip]</p>
<p>testFailed位被置为1并不会自动导致pending DTC置为1。pendingDTC的置位通常需要故障在连续的操作周期中持续出现。具体的置位条件由制造商根据监测策略和法规要求定义。</p>
<p>举个例子：</p>
<p>假设有一个监测策略，它要求一个故障必须在两个连续的操作周期检测到才能将pendingDTC置为1。</p>
<ul>
<li>第一个操作周期：故障首次被检测到，testFailed被置为1，但pendingDTC保持为0，因为我们还没有达到故障记录的条件。</li>
<li>第二个操作周期：故障再次被检测到，testFailed仍然为1。因为这个故障现在已经在连续两个操作周期中被检测到了，pendingDTC将被置为1，表明故障已经被记录下来，但还未确认。</li>
<li>第三个操作周期：如果故障未被检测到，testFailed位将被清除（置0），但pendingDTC可能仍然保持为1，因为它通常需要多个操作周期的故障消失来清除。</li>
</ul>
<p>因此，pendingDTC的置位是一个基于监测策略的累积过程，而不是简单地跟随testFailed位的状态。</p></blockquote>
<h3 id="dtc快照信息">
<a class="header-anchor" href="#dtc%e5%bf%ab%e7%85%a7%e4%bf%a1%e6%81%af"></a>
DTC快照信息
</h3><p>==DTC和Event==</p>
<p>DTC是某类故障的统称，能够大体定位到某个模块的故障，而Event则是故障监控的基本单元，能够定位某个模块中的某个具体故障；Event可以由基础模块自行定义监控策略，当发生故障Event时，需要完成这个Event的上报、去抖（防止故障误报）、存储等过程，这些处理流程由DEM模块负责管理(Diagnostic Event Management)。</p>
<p>DTC和Event之间的区别和联系如下：</p>
<ul>
<li>多个Event可以mapping同一个DTC,而同一个Event不能mapping多个DTC;</li>
<li>DTC直接可见，但Event需通过进一步手段才能看到（比如通过UDS服务获取DTC关联的Event信息)，有时仅对ECU供应商可见。</li>
<li>DTC代表某类Event集中表现，而Event则是某个DTC的具体实例：</li>
<li>Event的优先级决定了DTC的优先级，Event之间的依赖关系决定了DTC的依赖关系；</li>
<li>DTC的1字节状态位是其mapping的所有Event的状态位的或集。</li>
</ul>
<p>==快照信息==</p>
<p>DTC快照信息(Snapshot Record)就类似照相机一样，在故障发生的时刻，对整车信息按下快门，做个记录，以便后续分析问题。其所记录ECU发生故障时运行状态信息可以包括多个方面的数据，笼统的说比如故障码、故障条件、传感器数据、控制单元状态等。常见些数据有：</p>
<ol>
<li>故障发生时的时间戳</li>
<li>ECU电压值</li>
<li>电流值</li>
<li>温度或者由故障Evnt引起的相应DTC</li>
<li>等等</li>
</ol>
<blockquote>
<p>[!tip]</p>
<p>快照信息存在的意义由于一个DTC可由多种故障Event触发（多个Eventi可以mapping同一个DTC),因此需要通过快照信息进一步区分这个DTC具体是由哪个Event触发的。</p></blockquote>
<blockquote>
<p>[!note]</p>
<p>DTC、Event、快照信息和DID之间的关系：</p>
<p>整车系统中可能存在各种故障Event,比如电池低压/过压事件、通信丢失事件、胎压故障事件等。为了更好的区分故障类型，整车制造商会将这些事件关联(mapping)到不同的DTC。同时，为了维修人员更快、更准确的识别故障事件，还需要提供一些额外的辅助信息，比如故障发生时的时间、ECU供电电压、相关传感器数据等。为了获取这些信息，可以将这些信息设置一个快照信息组(Snapshot Group),为了区分不同的Snapshot
Group,可以为每个Snapshot Group:分配一个识别号，即==DTCSnapshotRecordNumber==.</p>
<p>UDS要求，DTCSnapshotRecordNumber由1byte组成，0x00一般预留给OBD协议使用，0xFF表示ECU一次将所有的快照数据上报，0x01~0xFE由OEM自行设定。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_9_52_27_202502190952468.png" alt="映射关系"></p>
<p>每个DTCSnapshotRecordNumbert包含一组快照信息，一组快照信息中可以包含多个DID,每个DID侧包含具体的信息。</p></blockquote>
<h3 id="dtc拓展数据信息">
<a class="header-anchor" href="#dtc%e6%8b%93%e5%b1%95%e6%95%b0%e6%8d%ae%e4%bf%a1%e6%81%af"></a>
DTC拓展数据信息
</h3><p>和DTC快照信息的功能类似，由于DTC中8bit位可以承载的信息是有限的，仅能说明故障是当前故障还是历史故障。故障发生时的其他重要信息还需要额外的数据存储，常见的一些扩展数据如下所示：</p>
<table>
  <thead>
      <tr>
          <th>常见扩展数据</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>DTC Malfunction Indicator counter</td>
          <td>DTC故障指示灯计数器，用于传输故障激活时系统已经运行的时间（发动机的工作时间）。</td>
      </tr>
      <tr>
          <td>DTC aging counter</td>
          <td>DTC老化计数器，处于老化中DTC的计数； 用于计算自最后一次失败后的测试循环，不包括未报告TestPassed或者TestFailed的测试循环。</td>
      </tr>
      <tr>
          <td>Test failed counter</td>
          <td>测试失败计数器，用于计算TestFailed报告的数量； 它与DTC事件计数器不同的是更加强调故障发生的次数。</td>
      </tr>
      <tr>
          <td>DTC occurrence counter</td>
          <td>DTC事件计数器，用于计算报告了测试失败（Test Failed）的测试循环数量。</td>
      </tr>
      <tr>
          <td>uncompleted testcounters</td>
          <td>未完成测试计数器，用于计算最后一次完成测试之后（即自发出TestPassed或TestFailed测试报告后），剩余测试循环的数量。</td>
      </tr>
      <tr>
          <td>DTC aged counter</td>
          <td>表示完成老化的DTC的数量。</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>[!tip]</p>
<p>这些DTC信息、状态位信息、快照信息、扩展帧信息都可以通过UDS协议中的<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x19%ef%bc%9a%e8%af%bb%e5%8f%96%e6%95%85%e9%9a%9c%e7%a0%81">0x19服务</a>服务读取。</p></blockquote>
<h1 id="uds服务概览">
<a class="header-anchor" href="#uds%e6%9c%8d%e5%8a%a1%e6%a6%82%e8%a7%88"></a>
UDS服务概览
</h1><h2 id="诊断和通信管理类">
<a class="header-anchor" href="#%e8%af%8a%e6%96%ad%e5%92%8c%e9%80%9a%e4%bf%a1%e7%ae%a1%e7%90%86%e7%b1%bb"></a>
诊断和通信管理类
</h2><p>诊断和通信管理类是UDS服务的核心部分，它提供了与ECU进行通信以及执行诊断操作的基本功能。这些功能包括诊断会话的建立和终止、ECU的重置和诊断通信的管理。通过诊断和通信管理类，技术人员可以与ECU进行交互，获取ECU的状态信息，并执行各种诊断操作。主要包括如下服务：</p>
<table>
  <thead>
      <tr>
          <th>Service</th>
          <th>功能简述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/#0x10%ef%bc%9a%e8%af%8a%e6%96%ad%e4%bc%9a%e8%af%9d%e6%8e%a7%e5%88%b6">0x10：诊断会话控制</a></td>
          <td>客户端控制目标ECU的诊断会话状态。</td>
      </tr>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/#0X11:ECU%e5%a4%8d%e4%bd%8d">0x11：ECU复位</a></td>
          <td>客户端强制让目标ECU执行复位操作。</td>
      </tr>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/#0X27:%e5%ae%89%e5%85%a8%e8%ae%bf%e9%97%ae">0x27：安全访问</a></td>
          <td>客户端请求解锁受保护的目标ECU。</td>
      </tr>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x28%ef%bc%9a%e9%80%9a%e8%ae%af%e6%8e%a7%e5%88%b6">0x28：通讯控制</a></td>
          <td>客户端控制目标ECU的通信行为 (在特定情况下启用或禁用ECU的某些通信功能)。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/133753250?spm=1001.2014.3001.5501">0x3E：待机握手</a></td>
          <td>客户端向目标ECU表明它仍然存在。</td>
      </tr>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x85%ef%bc%9a%e6%8e%a7%e5%88%b6DTC%e8%ae%be%e7%bd%ae">0x85：控制DTC的设置</a></td>
          <td>客户端控制目标ECU中dtc的设置。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/140093917">0x83：访问时间参数</a></td>
          <td>客户端使用此服务读取/修改当前通信的定时参数。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/140144010">0x84：安全数据传输</a></td>
          <td>客户端使用此服务执行具有扩展数据链路安全性的数据传输。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/133753311">0x86：事件响应</a></td>
          <td>客户端请求设置和/或控制目标ECU中的事件机制。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/133753337?spm=1001.2014.3001.5501">0x87：链路控制</a></td>
          <td>客户端请求控制通信波特率。</td>
      </tr>
  </tbody>
</table>
<h2 id="数据传输类">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e7%b1%bb"></a>
数据传输类
</h2><p>数据传输类是用于在ECU和诊断工具之间传输数据的UDS服务类别。它提供了可靠的数据传输机制，确保数据的完整性和准确性。数据传输类包括数据的读取和写入功能，允许技术人员读取和修改ECU中的数据。此外，数据传输类还支持数据的块传输，以提高数据传输的效率。主要包括如下服务：</p>
<table>
  <thead>
      <tr>
          <th>Service</th>
          <th>功能简述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/133888416?spm=1001.2014.3001.5501">0x22：通过ID读数据</a></td>
          <td>客户端请求读取由提供的DID标识的记录的当前值。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/133888945?spm=1001.2014.3001.5501">0x2E：通过ID写数据</a></td>
          <td>客户端请求写入由提供的DID指定的记录数据。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/139211263?spm=1001.2014.3001.5501">0x23：通过地址读内存</a></td>
          <td>客户端请求读取所提供内存范围的当前值。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/139500633">0x24：通过ID读缩放数据/换算信息</a></td>
          <td>客户端请求读取由提供的DID标识的比例数据。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/139797796?spm=1001.2014.3001.5501">0x2A：通过周期读ID数据</a></td>
          <td>客户端请求调度目标ECU中的数据进行周期性传输。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/139946708">0x2C：动态定义标识符</a></td>
          <td>客户端请求动态定义数据标识符，这些标识符随后可能被0x22-读DID服务读取。</td>
      </tr>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x3D%ef%bc%9a%e9%80%9a%e8%bf%87%e5%9c%b0%e5%9d%80%e5%86%99%e5%86%85%e5%ad%98">0x3D：通过地址写内存</a></td>
          <td>客户端请求覆盖提供的内存范围。</td>
      </tr>
  </tbody>
</table>
<h2 id="存储数据传输类">
<a class="header-anchor" href="#%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e7%b1%bb"></a>
存储数据传输类
</h2><p>存储数据传输类是一种特殊的数据传输类别，用于在ECU和诊断工具之间传输存储数据。存储数据可以是ECU的配置信息、故障码或日志文件等。通过存储数据传输类，技术人员可以读取和清除ECU中的存储数据，以便进行故障诊断和维修。所涉及的两个服务都是常用服务类型。主要包括如下服务：</p>
<table>
  <thead>
      <tr>
          <th>Service</th>
          <th>功能简述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x14:%e6%b8%85%e9%99%a4%e6%95%85%e9%9a%9c%e7%a0%81">0x14：清除诊断信息</a></td>
          <td>允许客户端从目标ECU清除诊断信息(包括dtc、捕获的数据等)。</td>
      </tr>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x19%ef%bc%9a%e8%af%bb%e5%8f%96%e6%95%85%e9%9a%9c%e7%a0%81">0x19：读取故障码信息</a></td>
          <td>允许客户端从目标ECU请求诊断信息(包括dtc、捕获数据等)。</td>
      </tr>
  </tbody>
</table>
<h2 id="io控制类">
<a class="header-anchor" href="#io%e6%8e%a7%e5%88%b6%e7%b1%bb"></a>
IO控制类
</h2><p>IO控制类是用于控制ECU输入输出（IO）功能的UDS服务类别。它提供了对ECU输入输出功能的访问和控制，包括读取和设置ECU的输入输出状态。通过IO控制类，技术人员可以与ECU的IO功能进行交互，实现对车辆系统的控制和监控。主要包括如下服务：</p>
<table>
  <thead>
      <tr>
          <th>Service</th>
          <th>功能简述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/133888989?spm=1001.2014.3001.5501">0x2F：通过ID控制输入输出</a></td>
          <td>客户端请求控制特定于目标ECU的输入/输出。</td>
      </tr>
  </tbody>
</table>
<h2 id="例程功能类-调用ecu内部预置函数">
<a class="header-anchor" href="#%e4%be%8b%e7%a8%8b%e5%8a%9f%e8%83%bd%e7%b1%bb-%e8%b0%83%e7%94%a8ecu%e5%86%85%e9%83%a8%e9%a2%84%e7%bd%ae%e5%87%bd%e6%95%b0"></a>
例程功能类-调用ECU内部预置函数
</h2><p>例程功能类是一种特殊的UDS服务类别，它允许技术人员调用ECU内部预置的函数。这些函数可以执行特定的操作，如执行自检、执行校准或执行特殊功能。通过例程功能类，技术人员可以利用ECU内部的功能来进行诊断和维修。主要包括如下服务：</p>
<table>
  <thead>
      <tr>
          <th>Service</th>
          <th>功能简述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x31%ef%bc%9a%e4%be%8b%e7%a8%8b%e6%8e%a7%e5%88%b6">0x31：例行程序控制</a></td>
          <td>客户端请求启动、停止目标ECU中的例程（简单理解就是个函数）或请求例程结果。</td>
      </tr>
  </tbody>
</table>
<h2 id="上传下载类">
<a class="header-anchor" href="#%e4%b8%8a%e4%bc%a0%e4%b8%8b%e8%bd%bd%e7%b1%bb"></a>
上传下载类
</h2><p>上传下载类是用于在ECU和诊断工具之间进行数据上传和下载的UDS服务类别。它提供了将数据从ECU上传到诊断工具或将数据从诊断工具下载到ECU的功能。上传下载类可用于备份和恢复ECU配置、更新ECU软件或执行其他数据传输操作。主要包括如下服务：</p>
<table>
  <thead>
      <tr>
          <th>Service</th>
          <th>功能简述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x34:%e8%af%b7%e6%b1%82%e4%b8%8b%e8%bd%bd">0x34：请求下载</a></td>
          <td>客户端请求协商从客户端到目标ECU的数据传输。</td>
      </tr>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x36%ef%bc%9a%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93">0x36：数据传输</a></td>
          <td>客户端向目标ECU发送数据(下载)或向目标ECU请求数据(上传)。</td>
      </tr>
      <tr>
          <td><a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/##0x37%ef%bc%9a%e8%af%b7%e6%b1%82%e9%80%80%e5%87%ba">0x37：请求退出传输</a></td>
          <td>客户端请求终止数据传输。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/139973558">0x35：请求上传</a></td>
          <td>客户端请求从目标ECU到客户端的数据传输。</td>
      </tr>
      <tr>
          <td><a href="https://blog.csdn.net/qq_40309666/article/details/140022899?spm=1001.2014.3001.5501">0x38：请求文件传输</a></td>
          <td>客户端请求在目标ECU和客户端之间进行文件传输。</td>
      </tr>
  </tbody>
</table>
<h1 id="uds服务详述">
<a class="header-anchor" href="#uds%e6%9c%8d%e5%8a%a1%e8%af%a6%e8%bf%b0"></a>
UDS服务详述
</h1><h2 id="0x10诊断会话控制">
<a class="header-anchor" href="#0x10%e8%af%8a%e6%96%ad%e4%bc%9a%e8%af%9d%e6%8e%a7%e5%88%b6"></a>
0x10：诊断会话控制
</h2><h3 id="简介-1">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-1"></a>
简介
</h3><p>会话模式是诊断领域非常重要的一个状态机，不同的会话模式是用来区分诊断服务执行权限的，而该服务正是为了实现会话模式的切换。即该服务可以通过控制ECU在不同的会话模式之间切换从而为ECU使能一组特定的服务以及功能，至于每种会话模式下使能哪些服务/功能，由遵循该协议标准的用户去决定。</p>
<p><strong>UDS协议定义了三种会话模式：</strong></p>
<ol>
<li>默认会话</li>
<li>编程会话</li>
<li>扩展会话</li>
</ol>
<p><strong>不同会话模式间可以互相切换，但在一个ECU中应该始终只有一个诊断会话处于活动状态。</strong> ECU在上电时应始终启动默认会话。如果没有启动其他会话则默认会话将在ECU通电期间一直运行。举例来说：</p>
<ul>
<li>ECU通常处于默认会话状态（Default Session），但很多服务需要切换到扩展会话模式中才能执行（Extended Session），当需要进行软件刷写时，则需要切换到编程会话模式（Programming Session）。</li>
<li>此外，当ECU处于非默认会话时，如果一段时间没有诊断操作，将会回退到默认会话，这时候如果想要保持在某种会话状态，可以通过<a href="https://blog.csdn.net/qq_40309666/article/details/133753250?spm=1001.2014.3001.5501">0x3E会话保持服务</a>实现。</li>
</ul>
<h4 id="会话模式切换时ecu要做什么">
<a class="header-anchor" href="#%e4%bc%9a%e8%af%9d%e6%a8%a1%e5%bc%8f%e5%88%87%e6%8d%a2%e6%97%b6ecu%e8%a6%81%e5%81%9a%e4%bb%80%e4%b9%88"></a>
会话模式切换时，ECU要做什么
</h4><p>14229-1标准文件中给出如下一幅图并针对各个标号过程中ECU的处理给出如下一些解释。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_13_52_20_202407111352466.png" alt="会话切换"></p>
<ol>
<li>
<p>当ECU处于默认会话状态，客户端请求启动默认会话时，ECU应完全重新初始化默认会话（不包括编程到非易失性存储器中的相关内容的初始化）。</p>
</li>
<li>
<p>当ECU从默认会话转换到任意其他会话模式时，ECU需要停止在默认会话期间通过Response On Event（0x86）服务在ECU中配置的事件（即暂停事件响应服务）。</p>
</li>
<li>
<p>当ECU从默认会话以外的任何诊断会话转换到默认会话以外的另一个会话时，ECU应重新初始化诊断会话，这意味着：</p>
<ul>
<li>
<p>通过Response On Event（0x86）服务在ECU中配置的每个事件都应停止；</p>
</li>
<li>
<p>锁定安全访问</p>
<blockquote>
<p>[!TIP]</p>
<p>该操作应重置那些依赖于要解锁安全访问的诊断功能，如DID的输入输出控制（0x2F）；</p></blockquote>
</li>
<li>
<p>在新会话中受支持且不依赖安全访问的所有功能都应保持不变。例如，任何配置的周期性调度程序在从一个非默认会话转换到另一个不管是否相同的非默认会话时都应保持活动状态；再比如，通信控制（0x28）和控制DTC设置（0x85）服务的状态不应受到影响，即会话切换后的状态应该跟切换前保持一致。</p>
</li>
</ul>
</li>
<li>
<p>当ECU从默认会话以外的任何诊断会话转换到默认会话时，应停止通过0x86服务在ECU中配置的每个事件，并启用安全访问，同时默认会话中不支持的任何其他功能应终止。</p>
</li>
</ol>
<h4 id="不同的会话模式分别支持哪些服务">
<a class="header-anchor" href="#%e4%b8%8d%e5%90%8c%e7%9a%84%e4%bc%9a%e8%af%9d%e6%a8%a1%e5%bc%8f%e5%88%86%e5%88%ab%e6%94%af%e6%8c%81%e5%93%aa%e4%ba%9b%e6%9c%8d%e5%8a%a1"></a>
不同的会话模式分别支持哪些服务
</h4><p> 不同会话模式支持的服务范围也不同，默认会话有很多不支持的服务，如下表所示（“x“表示支持该服务，“not applicable“表示不支持该服务）：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/18_15_26_47_202502181526341.png" alt="不同的会话模式所支持的不同的服务"></p>
<p>上表默认会话中有些支持的服务添加了一些备注（xa、b、c、d、e），其实就是说明下为什么默认会话下需要支持这几个服务，或者即使支持该服务也是有特定的场景或者限制的，具体含义如下所示：
  $x^a$：在默认会话模式中是否也允0x86服务是特定于实现的，即不一定支持该服务；
  $x^b$：如果是访问安全相关的DID则需基于安全访问服务，因此如果是该情况下要进非默认会话；
  $x^c$：如果是访问安全相关的内存区域则需要安全访问服务，因此如果是该情况下要进非默认会话；
  $x^d$：可以在默认和非默认会话中动态定义DID，因此非默认会话也支持这个服务；
  $x^e$：如果是安全相关例程需安全访问服务，因此需要非默认会话模式；需要客户端主动停止的例程也需要非默认会话模式。</p>
<h3 id="数据包格式">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f"></a>
数据包格式
</h3><h4 id="服务请求格式">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f"></a>
服务请求格式
</h4><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_13_58_58_202407111358515.png" alt="0x10的报文格式"></p>
<p>SessionType的取值及对应含义如下（主要用的就是标出的那三个）：</p>
<table>
  <thead>
      <tr>
          <th>SessionType</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00</td>
          <td>保留未使用（ISOSAE Reserved）</td>
      </tr>
      <tr>
          <td>0x01</td>
          <td>默认会话模式（Default Session），一般ECU上电后的默认状态就是这个，该会话模式不需要0x3E服务维持。</td>
      </tr>
      <tr>
          <td>0x02</td>
          <td>编程会话模式（Programming Session），主要用于ECU软件的升级刷写，刷写流程涉及多类UDS服务， 没有接触过软件升级刷写的可能不太会接触到这种会话模式，暂时不用深究。</td>
      </tr>
      <tr>
          <td>0x03</td>
          <td>扩展会话模式（Extended Diagnostic Session），用于解锁需要高权限的诊断服务，基本覆盖各类服务， 最常见的就是读写DID前先进扩展会话模式。</td>
      </tr>
      <tr>
          <td>0x04</td>
          <td>安全模式（Safety System Diagnostic Session）使能所有跟车载系统安全相关的服务，比如安全气囊。</td>
      </tr>
      <tr>
          <td>0x05 - 0x3F</td>
          <td>保留未使用（ISOSAE Reserved ）</td>
      </tr>
      <tr>
          <td>0x40 - 0x5F</td>
          <td>保留未使用，整车厂自定义使用（Vehicle Manufacturer Specific）</td>
      </tr>
      <tr>
          <td>0x60 - 0x7E</td>
          <td>保留未使用，ECU供应商/系统供应商自定义使用（System Supplier Specific）</td>
      </tr>
      <tr>
          <td>0x7F</td>
          <td>保留未使用（ISOSAE Reserved）</td>
      </tr>
  </tbody>
</table>
<h4 id="服务响应格式">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f"></a>
服务响应格式
</h4><h5 id="正响应">
<a class="header-anchor" href="#%e6%ad%a3%e5%93%8d%e5%ba%94"></a>
正响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_14_2_27_202407111402269.png" alt="0x10正响应"></p>
<p>SessionType的取值同上，SessionParameterRecord的4个字节含义如下：</p>
<table>
  <thead>
      <tr>
          <th>Byte1</th>
          <th>Byte2</th>
          <th>Byte3</th>
          <th>Byte4</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>$P2_{ServerMax}$ (high byte)</td>
          <td>$P2_{ServerMax}$(low byte)</td>
          <td>$P2^*_{ServerMax}$ (high byte)</td>
          <td>$P2^*_{ServerMax}$(low byte)</td>
      </tr>
  </tbody>
</table>
<p>这四个字节实际上是两个时间参数的值（$P2_{ServerMax}$ &amp; $P2^*_{ServerMax}$），可以简单理解为Server端接收到请求后如果未在指定的时间参数内给出响应，则需要执行超时操作。</p>
<h5 id="负响应">
<a class="header-anchor" href="#%e8%b4%9f%e5%93%8d%e5%ba%94"></a>
负响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_14_4_21_202407111404271.png" alt="0x10负响应"></p>
<p>可能出现的NRC及其含义如下：</p>
<table>
  <thead>
      <tr>
          <th>NRC</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x12</td>
          <td>子功能参数不受支持</td>
      </tr>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x22</td>
          <td>不满足请求标准/条件</td>
      </tr>
  </tbody>
</table>
<h3 id="通信示例">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b"></a>
通信示例
</h3><p>假设现在诊断设备控制目标ECU进入编程会话模式，发送请求时设置spr位为0（即不抑制正响应），同时假设目标ECU中设置的时间参数分别为：$P2_{ServerMax}$ = 50ms (0x0032)，$P2^*_{ServerMax}$ = 5000ms (0x01F4)，通信数据包如下所示：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_14_5_36_202407111405928.png" alt="0x10通信样例"></p>
<h2 id="0x11ecu复位">
<a class="header-anchor" href="#0x11ecu%e5%a4%8d%e4%bd%8d"></a>
0x11：ECU复位
</h2><h3 id="简介-2">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-2"></a>
简介
</h3><h4 id="kl15和kl30">
<a class="header-anchor" href="#kl15%e5%92%8ckl30"></a>
KL15和KL30
</h4><p>在详细介绍该服务之前，首先了解一些基础知识：汽车上的ECU都需要供电，通常有两类供应电源，一类是长期处于电池包供电状态的常电电源，另一类可以称为唤醒电或者钥匙电，顾名思义就是用于钥匙开关启动车辆后才会被正常供电的ECU；在汽车行业中，常听到的KL15和KL30就跟他们有关，实际上KL15和KL30是指电线规格或线束的命名，这两条电线在汽车的电路系统中起着不同的作用，KL15线提供点火开关激活时的电源，而KL30线提供持久的电源供应。</p>
<p><strong>KL15线</strong> 通常用于汽车电路中的&quot;常电&quot;或&quot;ACC电源&rdquo;，指的是在汽车点火开关处提供电源的线路。当点火开关处于ON或ACC档位时，KL15线会激活电路，使得车辆的电子设备（如收音机、电脑等）可以正常工作。KL15线的电压通常为12V。</p>
<p><strong>KL30线</strong> 则是指汽车电路中的&quot;主电&quot;或&quot;电池正极&quot;，它是直接连接到车辆电池正极的电线。KL30线提供持久的电源供应，使得车辆的主要电子设备（如发动机控制单元、空调系统、灯光等）可以正常工作。KL30线的电压通常也为12V。</p>
<h4 id="ecu复位服务">
<a class="header-anchor" href="#ecu%e5%a4%8d%e4%bd%8d%e6%9c%8d%e5%8a%a1"></a>
ECU复位服务
</h4><p>该服务请求ECU根据请求消息中的ResetType参数的值执行不同类型的ECU重置。重置成功后（ECU正响应该服务请求），进入Default Session（默认会话模式）。</p>
<p>2020版的ISO14229-1标准中指出，当Client向Server发送0x11服务请求时，Server可在复位行为完成之后或者开始复位行为之前给到Client诊断响应，但14229-1强烈推荐的一种做法是：“<strong>当Server接收到来自Client的0x11服务请求时，Server应当先给出诊断响应然后开始重启行为</strong>（==先响应后重启==）“。</p>
<ul>
<li>一方面，几乎所有ECU软件设计中一旦走复位重启流程，已经不记得之前发生过什么，不知道收到什么请求，又要给谁发响应；</li>
<li>另一方面，如果请求11诊断服务时未抑制正响应，在复位完成之前，一般都会先回复NRC 0x78让Client进行等待，那么Client需要根据不同的ECU节点的回复做超时监控，这无疑增加了Client的负担，对于Client而言，最为简单的方法就是发送完请求，各ECU节点回复正响应，然后各自完成复位操作即可。</li>
</ul>
<p>此外，建议在复位操作执行期间，ECU不要接受任何请求消息以及不要发送任何响应消息，避免发生意料之外的问题。</p>
<h4 id="ecu复位服务应用场景">
<a class="header-anchor" href="#ecu%e5%a4%8d%e4%bd%8d%e6%9c%8d%e5%8a%a1%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af"></a>
ECU复位服务应用场景
</h4><p>一般而言，对于0X11诊断服务，主要应用场合如下：</p>
<ul>
<li>ECU被刷写新的软件后，此时需要通过0X11服务重启该ECU使其恢复到初始状态；</li>
<li>在产线下线标定的过程中，对于KL30供电的ECU存在一些仅在下电时存储的数据，此时需要通过0X11诊断服务使ECU走下电流程进而完成相应数据的保存；</li>
<li>为满足特定功能的需要，输入相关标定参数给到ECU后，只有通过发送服务0X11才能使得标定参数生效的场景；</li>
<li>对于KL30供电的ECU节点，可以使用诊断服务0X11使ECU快速进入休眠的场景。</li>
</ul>
<h3 id="数据包格式-1">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-1"></a>
数据包格式
</h3><h4 id="服务请求格式-1">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f-1"></a>
服务请求格式
</h4><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_14_27_58_202407111427617.png" alt="0x11数据包格式"></p>
<p>对于请求消息中Reset Type的取值及其含义如下表所示：</p>
<table>
  <thead>
      <tr>
          <th>复位类型</th>
          <th>取值</th>
          <th>含义/复位特点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>&mdash;-</td>
          <td>0x00</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>HardReset (硬复位)</td>
          <td>0x01</td>
          <td>模拟KL30电源的重上电，该复位基本可以等同于Server直接掉电然后重启， 主要用于需要彻底复位的场景，比如刷写之后的复位</td>
      </tr>
      <tr>
          <td>KeyOffOnReset (点火开关复位)</td>
          <td>0x02</td>
          <td>模拟KL15点火钥匙的重启，此类复位用于模拟点火开关从off–&gt;on的过程， 一般而言NVM数据会保持不变，VM将重新初始化</td>
      </tr>
      <tr>
          <td>SoftReset (软复位)</td>
          <td>0x03</td>
          <td>效果同上，只是复位没有那么彻底，在无需初始化任何数据的前提下 重置PC指针重新运行应用程序，即RAM中的内容不会重置</td>
      </tr>
      <tr>
          <td>enableRapidPowerShutDown (使能快速休眠流程)</td>
          <td>0x04</td>
          <td>即开启ECU的休眠功能，该子功能适用于非点火上电而仅采用电池供电（KL30供电）的ECU。 对于这类ECU通常情况下，当关闭钥匙电后，过段时间ECU会进入PowerOff状态（即整体下电）， 当通过0x11服务请求使用该子功能后，关闭钥匙电不会使ECU进入下电状态，而是进入休眠状态， 这种状态下，ECU可以被快速唤醒。相对于整体下电状态，休眠状态的进入和退出都更加迅速， 但同时这种状态也会多一些功耗。</td>
      </tr>
      <tr>
          <td>disableRapidPowerShutDown (抑制快速休眠流程)</td>
          <td>0x05</td>
          <td>适用于非点火上电而仅采用电池供电（KL30供电）的ECU，抑制其进入下电休眠流程</td>
      </tr>
      <tr>
          <td>vehicleManufacturerSpecific (供整车制造商使用的自定义复位类型)</td>
          <td>0x40 - 0x5F</td>
          <td>整车厂自定义</td>
      </tr>
      <tr>
          <td>systemSupplierSpecific (供系统供应商使用的自定义复位类型)</td>
          <td>0x60 - 0x7E</td>
          <td>零部件供应商自定义</td>
      </tr>
      <tr>
          <td>&mdash;-</td>
          <td>7F</td>
          <td>保留</td>
      </tr>
  </tbody>
</table>
<h4 id="服务响应格式-1">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f-1"></a>
服务响应格式
</h4><h5 id="正响应-1">
<a class="header-anchor" href="#%e6%ad%a3%e5%93%8d%e5%ba%94-1"></a>
正响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_14_32_1_202407111432258.png" alt="0x11正响应"></p>
<p>ResetType：取值及对应含义与上表相同；
  powerDownTime：该参数仅在subfunction(即ResetType)=0x04时才会有，指的是ECU断电过程中保持待机状态的最小时间，即指示这个ECU至少要多久才能进入休眠状态。其他情况下，Server只回复前两个字节，该参数取值范围为0x00-0xFE(254s)，0xFF为无效值。</p>
<h5 id="负响应-1">
<a class="header-anchor" href="#%e8%b4%9f%e5%93%8d%e5%ba%94-1"></a>
负响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_14_33_32_202407111433526.png" alt="0x11负响应"></p>
<table>
  <thead>
      <tr>
          <th>NRC</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x12</td>
          <td>子功能参数不受支持</td>
      </tr>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x22</td>
          <td>不满足请求标准/条件</td>
      </tr>
      <tr>
          <td>0x33</td>
          <td>由于复位操作影响ECU正常功能或者状态，有一定的危险性，所以标准中对于这个服务提供了该NRC， 主机厂在实现该协议时可以（而不是必须）将复位请求定义在安全解锁状态下才能执行， 如果ECU未被解锁，请求重置将受到保护（Server在响应复位请求时处于security lock状态），就回复这个NRC。</td>
      </tr>
  </tbody>
</table>
<h3 id="通信示例-1">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-1"></a>
通信示例
</h3><p>假设现在目标ECU处于钥匙电上电状态，但不应处于运行模式（毕竟不能在开车过程中复位，即如果是燃油车，动力源为发动机，发动机应关闭；如果是混动车，发动机和ISG电机都要关闭。）诊断仪发送复位请求，发送请求时设置spr位为0（即不抑制正响应），通信数据包如下所示：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_14_34_43_202407111434740.png" alt="0x11通信示例"></p>
<h2 id="0x14清除故障码">
<a class="header-anchor" href="#0x14%e6%b8%85%e9%99%a4%e6%95%85%e9%9a%9c%e7%a0%81"></a>
0x14:清除故障码
</h2><h3 id="简介-3">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-3"></a>
简介
</h3><p>Tester可以通过该服务清除一个或多个目标ECU中的的DTC信息。目标ECU完成清除操作后，应发送一个正响应。即使没有存储任何DTC,也应发送正响应。</p>
<p>通过此服务重置/清除的DTC信息包括但不限于以下内容：</p>
<ul>
<li>DTC状态字节(DTC Status)</li>
<li>捕获的DTC快照数据(DTC Snapshot Data),</li>
<li>捕获的DTC扩展数据(DTC Extended Data)</li>
<li>与DTC相关的其他数据，例如第一个/最近的DTC、标志、计数器、定时器等。</li>
</ul>
<p>常用的一个场景是：ECU刷写新软件后，会通过该服务清除下DTC然后再读取，从而查看是否存在异常的DTC,保证系统监控正常。</p>
<h3 id="数据包格式-2">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-2"></a>
数据包格式
</h3><h4 id="服务请求格式-2">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f-2"></a>
服务请求格式
</h4><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_13_9_40_202502191309237.png" alt="0x14数据包格式"></p>
<blockquote>
<p>[!tip]</p>
<p>该服务不存在sub-function</p></blockquote>
<p>该服务请求消息包含一个参数：groupOfDTC,这个参数允许客户端清除一组DTC(例如动力总成、车身、底盘等)或特定的DTC。其取值及相应含义如下表所示：</p>
<table>
  <thead>
      <tr>
          <th>groupOfDTC取值</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x000000~0x0000FF</td>
          <td>保留未使用</td>
      </tr>
      <tr>
          <td>车辆制造商定义</td>
          <td>动力系统组：发动机和传动装置</td>
      </tr>
      <tr>
          <td>：</td>
          <td>动力系统DTC</td>
      </tr>
      <tr>
          <td>：</td>
          <td>底盘组</td>
      </tr>
      <tr>
          <td>：</td>
          <td>底盘DTC</td>
      </tr>
      <tr>
          <td>：</td>
          <td>车身组</td>
      </tr>
      <tr>
          <td>：</td>
          <td>车身DTC</td>
      </tr>
      <tr>
          <td>：</td>
          <td>网络通信组</td>
      </tr>
      <tr>
          <td>：</td>
          <td>网络通信DTC</td>
      </tr>
      <tr>
          <td>0xFFFF00~0xFFFFFE</td>
          <td>低字节的00~FE的具体取值一定要遵循下面一张表中规定的 FunctionalGroupldentifiers定义。 <!-- raw HTML omitted -->比如，OxFFFF33为排放组，OxFFFFD0为安全组。</td>
      </tr>
      <tr>
          <td>0xFFFFFF</td>
          <td>三个字节全FF，清除所有DTC</td>
      </tr>
  </tbody>
</table>
<p>低字节可选的值如下表：</p>
<table>
  <thead>
      <tr>
          <th>Byte Value</th>
          <th>Description</th>
          <th>Cvt</th>
          <th>Mnemonic</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00-0x32</td>
          <td>ISO/SAE reserved<!-- raw HTML omitted --> This range of values is reserved by this document for future defintion.</td>
          <td>M</td>
          <td>ISOSAERESRVD</td>
      </tr>
      <tr>
          <td>0x33</td>
          <td>Emissions-system group<!-- raw HTML omitted -->This value Identifies the Emisslons system in a server.</td>
          <td>M</td>
          <td>EMSYSGRP</td>
      </tr>
      <tr>
          <td>0x34-0xCF</td>
          <td>ISO/SAE reserved<!-- raw HTML omitted -->This range of values is reserved by this document for future definition.</td>
          <td>M</td>
          <td>ISOSAERESRVD</td>
      </tr>
      <tr>
          <td>0xD0</td>
          <td>Safety-system group<!-- raw HTML omitted -->This value identifies the Safety system in a server.</td>
          <td>M</td>
          <td>SAFESYSGRP</td>
      </tr>
      <tr>
          <td>0XD1-0xDF</td>
          <td>Legislative system group<!-- raw HTML omitted -->This range of values is reserved for legislative required group identifiers by this document for future definition.</td>
          <td>M</td>
          <td>LEGSYSGRP</td>
      </tr>
      <tr>
          <td>0xE0-0xFD</td>
          <td>ISO/SAE reserved<!-- raw HTML omitted -->This range of values is reserved by this document for future definition.</td>
          <td>M</td>
          <td>ISOSAERESRVD</td>
      </tr>
      <tr>
          <td>OxFE</td>
          <td>VOBD system<!-- raw HTML omitted -->This value identies the VOBD system device.Depending on the VOBD strategy which is implemented, only a gateway, adedicated VOBD ECU or any other ECU which has the VOBD function implemented（e.g.engine controller) may respond.</td>
          <td>M</td>
          <td>VOBDSYSGRP</td>
      </tr>
      <tr>
          <td>OxFF</td>
          <td>All functional system groups<!-- raw HTML omitted -->This value ldentifies all functional system groups as listed in this table in a server.</td>
          <td></td>
          <td>ALLFCTSYSGRP</td>
      </tr>
  </tbody>
</table>
<h4 id="服务响应格式-2">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f-2"></a>
服务响应格式
</h4><h5 id="正响应-2">
<a class="header-anchor" href="#%e6%ad%a3%e5%93%8d%e5%ba%94-2"></a>
正响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_13_38_12_202502191338592.png" alt="0x14正响应"></p>
<h5 id="负响应-2">
<a class="header-anchor" href="#%e8%b4%9f%e5%93%8d%e5%ba%94-2"></a>
负响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_13_39_19_202502191339204.png" alt="0x14的负响应"></p>
<p>NRC可能的含义为：</p>
<table>
  <thead>
      <tr>
          <th>NRC</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x22</td>
          <td>当前条件不满足</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>请求参数不受支持，参数错误</td>
      </tr>
      <tr>
          <td>0x72</td>
          <td>通用编程错误，一般写入内存出错就报这个NRC</td>
      </tr>
  </tbody>
</table>
<p>NRC的处理流程如下图所示（推荐错误情况检查顺序）：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_13_42_34_202502191342553.png" alt="0x14NRC处理流程"></p>
<h3 id="通信示例-2">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-2"></a>
通信示例
</h3><pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:14 FF FF FF
	note right of 诊断仪:诊断仪发送请求：第一个字节为SID，剩下三个字节是groupOfDTC，全F表示清除所有DTC
	目标ECU ->> 诊断仪:54
	note left of 目标ECU:目标ECU给出正响应：只有一个字节为SID+0x40
</pre>
<h2 id="0x19读取故障码">
<a class="header-anchor" href="#0x19%e8%af%bb%e5%8f%96%e6%95%85%e9%9a%9c%e7%a0%81"></a>
0x19：读取故障码
</h2><h3 id="简介-4">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-4"></a>
简介
</h3><p>0x19服务的子服务类型最多，也是最复杂的以及最重要诊断服务之一，同时也是最能体现“诊断”一词的服务。通过对DTC相关内容的学习我们知道：通过DTC及其附属信息，我们可以了解到目标ECU何时何地何种场景下发生了什么样的错误，这些信息存储在目标ECU的故障存储器中，0x19服务存在的意义就是可以通过不同的子功能来读取目标ECU中存储的这些故障信息（可以理解为通过各种过滤规侧读取这些故障信息）</p>
<p>下表罗列了该服务最常用的几个子功能（推荐按顺序阅读）：</p>
<table>
  <thead>
      <tr>
          <th>sub-function</th>
          <th>功能简述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Ox01: reportNumberOfDTCByStatusMask</td>
          <td>检索匹配状态掩码的DTC数</td>
      </tr>
      <tr>
          <td>Ox02: reportDTCByStatusMask</td>
          <td>检索匹配状态掩码的DTC列表</td>
      </tr>
      <tr>
          <td>0x04: reportDTCSnapshotRecordByDTCNumber</td>
          <td>检索匹配DTC状态掩码的 DTCSnapshot记录数据</td>
      </tr>
      <tr>
          <td>0x06: reportDTCExtDataRecordByDTCNumber</td>
          <td>根据客户定义的DTC掩码和 DTCExtendedData记录编号检索 DTCExtendedData记录数据</td>
      </tr>
      <tr>
          <td>0x0A: reportSupportedDTC</td>
          <td>检索目标ECU支持的所有DTC的状态</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>[!tip]</p>
<p>该服务目的是从目标ECU中读取故障信息，因此禁止肯定响应是没有意义的，所以SPR位通常都为0。</p></blockquote>
<h3 id="常用子功能介绍">
<a class="header-anchor" href="#%e5%b8%b8%e7%94%a8%e5%ad%90%e5%8a%9f%e8%83%bd%e4%bb%8b%e7%bb%8d"></a>
常用子功能介绍
</h3><h4 id="reportnumberofdtcbystatusmask-19-01">
<a class="header-anchor" href="#reportnumberofdtcbystatusmask-19-01"></a>
reportNumberOfDTCByStatusMask (19 01)
</h4><p>DTC状态(DTC status)是DTC的关键附属信息之一，如果我们想知道符合特定的DTC状态的DTC数量，就需要通过sub-function为01的请求，所说的这个特定的DTC状态就叫做DTC状态掩码(DTC Status Mask)。</p>
<p>在该子服务中，该掩码作为请求参数给到目标ECU,目标ECU将其与自身存储的DTC的Statusi进行“与”运算，并返回&quot;与&quot;运算之后结果不为0的DTC的数量（比如某故障码的实际状态位为”1”，请求信息的DTC状态掩码中的相应位也为“1”，与运算得1，认为两者匹配，此时符合DTC状态的DTC数量+1)。通过该子功能，Tester能够得知目标ECU中DTC状态与DTC状态掩码相匹配的DTC个数。</p>
<p>DTC的Status用一个byte表示，其中的8个bit分别代表DTC的不同状态，比如，bit0表示这个是否检测到了这个DTC对应的故障，bit3表示这个DTC是否已经被confirm了，如果DTC的状态是confirm,则说明该DTC已经被ECU存储下来了。</p>
<h5 id="数据包格式-3">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-3"></a>
数据包格式
</h5><p>==请求==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_14_1_1_202502191401463.png" alt="0x1901请求格式"></p>
<p>DTCStatusMask(1Byte):DTC状态掩码，Serverl收到该请求后，将筛选符合该掩码的DTC数量。</p>
<p>==肯定响应==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_14_17_7_202502191417721.png" alt="0x1901的肯定响应"></p>
<ul>
<li>
<p>DTCStatusAvailabilityMask(1Byte)：用于表示目标ECU支持的状态位，跟DTCStatusMask结构一样，8个bit,bit值为0表示目标ECU不支持这个状态位，为1则表示支持。跟请求中的DTC状态掩码没有关系！！</p>
</li>
<li>
<p>DTCFormatldentifier(1Byte):指示了目标ECU所用的DTC的格式，一个ECU只能使用一种格式。具体有以下几种：</p>
<table>
  <thead>
      <tr>
          <th>DTCFormatldentifier 取值</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00</td>
          <td>SAE_J2012-DA_DTCFormat_00（在ISO 15031-6中定义 的格式)</td>
      </tr>
      <tr>
          <td>0x01</td>
          <td>ISO_14229-1_DTCFormat（在ISO 14229-1中定义的格 式）</td>
      </tr>
      <tr>
          <td>0x02</td>
          <td>SAE_J1939-73_DTCFormat（在SAEJ1939-73中定义的 格式)</td>
      </tr>
      <tr>
          <td>0x03</td>
          <td>ISO_11992-4_DTCFormat（在ISO 11992-4中定义的格 式）</td>
      </tr>
      <tr>
          <td>0x04</td>
          <td>SAE_J2012-DA_DTCFormat_04(在ISO 27145-2中定义 的格式)</td>
      </tr>
      <tr>
          <td>0x05-0xFF</td>
          <td>保留未使用</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>DTCCount(2Byte):表示符合请求中DTC状态掩码的DTC数量。</p>
</li>
</ul>
<p>==否定响应==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_14_29_5_202502191429772.png" alt="0x1901的否定响应"></p>
<p>可能出现的NRC如下（其他子服务都是一样的，后面就不赘述了）：</p>
<table>
  <thead>
      <tr>
          <th>NRC</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x12</td>
          <td>sub-function不受支持</td>
      </tr>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>请求参数不受支持，参数错误</td>
      </tr>
  </tbody>
</table>
<h5 id="通信示例-3">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-3"></a>
通信示例
</h5><p>假设有以下的一些前置背景：</p>
<ol>
<li>请求消息中设置的状态掩码DTCStatusMask8个bit为：0000 0001(十六进制0x01)</li>
<li>目标ECU的DTCStatusAvailabilityMask为：11111111（十六进制OxFF,即支特所有状态位)</li>
<li>目标ECU DTCFormatldentifier为：0x00(即目标ECU使用的DTC格式遵循标准J2012-DATACF00)</li>
<li>假设目标ECU中存储了四个DTC,对应的DTC状态位(8个bt)取值如下所示：
DTC1:00101111
DTC2:00101111
DTC3:00101100
DTC4:00101110</li>
</ol>
<pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:19 01 01
	note right of 诊断仪:诊断仪发送请求：<br>第一个字节为SID,<br>第二个字节是子功能01<br>第三个字节是DTCStatusMask
	目标ECU ->> 诊断仪:59 01 FF 00 00 02
	note left of 目标ECU:将4个DTC对应的状态位取值分别与DTCStatusMask做“"位与”操作，<br>DTC1:00101111 & 00000001=00000001(0x01)<br>DTC2:00101111 & 00000001=00000001(0x01)<br>DTC3:00101100 & 00000001=00000000(0x00)<br>DTC4:00101110 & 00000001=00000000(0x00)<br>共计两个DTC状态与后结果不为零的(DTC1和DTC2)
	note left of 目标ECU:目标ECU给出正响应：<br>第一个字节为SID+0x40,<br>第二字节是子功能01<br>第三字节是DTCStatusAvailabilityMask<br>第四字节是DTCFormatldentifier,<br>第五六字节分别是DTCCounti高低字节
	
</pre>
<h4 id="reportdtcbystatusmask-19-02">
<a class="header-anchor" href="#reportdtcbystatusmask-19-02"></a>
reportDTCByStatusMask (19 02)
</h4><p>该子功能用于读取符合特定条件的DTC列表，这个特定条件仍然是DTC状态掩码（参见<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/####reportNumberOfDTCByStatusMask" title="19 01">0x1901</a>)，该掩码作为请求参数给到目标ECU,目标ECU将其与自身存储的DTC的Statusi进行“与”运算，并返回&quot;与&quot;运算之后结果不为0的DTC列表（回复匹配的DTC本身而非数量)</p>
<h5 id="数据包格式-4">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-4"></a>
数据包格式
</h5><p>==请求==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_14_49_53_202502191449466.png" alt="0x1902请求"></p>
<p>请求与<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/####reportNumberOfDTCByStatusMask" title="19 01">0x1901</a>一致，不再赘述。</p>
<p>==正响应==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_14_50_51_202502191450258.png" alt="0x1902正响应"></p>
<p>相对于1901，新增了一种参数类型：</p>
<ul>
<li>DTCAndStatusRecord(不定长：n*4Byte):包含一条条DTC及其状态。对于大部分定义DTC格式的标准来说，每条记录的格式为“DTC高字节+DTC中字节+DTC低字节+DTC相应状态”。</li>
</ul>
<h5 id="通信示例-4">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-4"></a>
通信示例
</h5><p>沿用<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/####reportNumberOfDTCByStatusMask" title="19 01">0x1901</a>中通信示例的部分背景，假设如下：</p>
<ol>
<li>请求读取所有状态为active的DTC的数量，即请求消息中设置的DTCStatusMask8个bit为：00000001（十六进制0x01)</li>
<li>目标ECU的DTCStatusAvailabilityMask为：11111111（十六进制OxFF,即支特所有状态位)</li>
<li>假设目标ECU中存储了四个DTC,对应的DTC状态位(8个bit)取值如下所示.：
DTC1.00101111
DTC2.00101111
DTC3:00101100
DTC4.00101110</li>
</ol>
<pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:19 02 01
	note right of 诊断仪:诊断仪发送请求：<br>第一个字节为SID<br>第二字节是子功能02<br>第三个字是DTCStatusMask
	目标ECU ->> 诊断仪:59 02 FF DTC1 2f DTC2 2F
	note left of 目标ECU:将4个DTC对应的状态位取值分别与DTCStatusMask做"位与”操作，<br>DTC1:00101111 & 00000001=00000001(0x01)<br>DTC2:00101111 & 00000001=00000001(0x01)<br>DTC3:00101100 & 00000001=00000000(0x00) <br>DTC4:00101110 & 00000001=00000000(0x00)<br>共计两个DTC状态与后结果不为零的(DTC1和DTC2)
	note left of 目标ECU:目标ECU给出正响应：<br>第个字节为SID+0x40,<br>第二字节是子功能02<br>第三字节是DTCStatusAvailabilityMask<br>第四五六、七字节分别是DTC1(3字节)及其状态0x2F<br>第八九十、十一字节分别是DTC2(3字节)及其状态0x2F
</pre>
<h4 id="reportdtcsnapshotrecordbydtcnumber-19-04">
<a class="header-anchor" href="#reportdtcsnapshotrecordbydtcnumber-19-04"></a>
reportDTCSnapshotRecordByDTCNumber (19 04)
</h4><p>为了方便快速定位故障，目标ECU会记录故障发生时候的快照信息（也称冻结帧）。DTC快照信息(Snapshot Record)就类似照相机一样，在故障发生的时刻，对整车信息按下快门，做个记录，以便后续分析问题。</p>
<p>常见一些数据有：故障发生时的时间戳、ECU电压值、电流值、温度或者由故障Event引起的相应DTC等等。关于DTC快照的更多内容，建议
先阅读<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/###DTC%e5%bf%ab%e7%85%a7%e4%bf%a1%e6%81%af">DTC快照信息</a>。</p>
<p>通过04子功能，目标ECU根据请求中指定的故障码(DTC),，查找并返回其对应的快照信息，来分析故障原因。</p>
<h5 id="数据包格式-5">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-5"></a>
数据包格式
</h5><p>==请求==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_15_4_15_202502191504099.png" alt="0x1904请求格式"></p>
<ul>
<li>
<p>DTCMaskRecord(1Byte):DTC掩码（实际上就是某个具体DTC),目标ECU会查我跟这个值匹配的DTC。(注意该参数跟DTCStatusMask没有任何关系，别看花眼了)</p>
</li>
<li>
<p>DTCSnapshotRecordNumber(1Byte)：表示特定的DTC快照数据记录编号。</p>
<p>DTC快照可以分为不同的组，每个组包含不同的快照信息，并使用快照记录编号区分每个组。这个参数就是表示请求的是哪组快照。例如当我们需要记录某个DTC第一次发生（假设编号为1)和最近一次发生的快照数据时（假设编号为2）；那么当DTCSnapshotRecordNumber为1时，则表示请求该DTC第一次发生时的快照信息。这个编号需要目标ECU提前定义，比如该参数设置为0xFF,则表示读取所有的快照数据组。取值情况及对应含义在标准中的预定义情况如下所示：</p>
<table>
  <thead>
      <tr>
          <th>取值</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00</td>
          <td>保留用于法定目的(如WWH-OBD)</td>
      </tr>
      <tr>
          <td>0x01-0xFE</td>
          <td>供车辆制造商使用</td>
      </tr>
      <tr>
          <td>0xFF</td>
          <td>一次性报告所有存储的DTCSnapshot数据记录</td>
      </tr>
  </tbody>
</table>
</li>
</ul>
<p>==肯定响应==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_15_22_46_202502191522227.png" alt="0x1904的肯定响应"></p>
<p>相对于之前的子功能，在响应的最后，携带了一个或多个快照数据（比如请求中的DTCSnapshotRecordNumber为0xFF,则表示读取所有的快照数据组，这里就会返回所有的快照数据)，每个快照数据组的构成如上图大方框所示，这里我们把它称为DTCSnapshotData(标准中没有这个称呼)，他由以下三部分组成：</p>
<ul>
<li>DTCSnapshotRecordNumber(1Byte):第几组快照记录数据，其取值符合1904请求中的第六个字节含义。</li>
<li>DTCSnapshotRecordNumberOfldentifiers(1Byte):对应快照信息中记录的信息条目的数量。</li>
<li>DTCSnapshotRecord(不定长)：每个信息条目成员的ID信息(DID)及其相应数据。</li>
</ul>
<blockquote>
<p>[!tip]</p>
<ol>
<li>如果诊断仪请求的DTC或快照数据编号是目标ECU不支持的，属于参数错误，目标ECU应回NRC 0x31:</li>
<li>如果DTC和快照记录编号都受支持，但目标ECU中当前没有存储这个DTC的快照信息（例如这个DTC对应的故障没有发生），那么ECU应返回肯定响应，但响应只包含59+04+DTC+DTC状态，不包含后面携带的快照记录信息。</li>
</ol></blockquote>
<h5 id="通信示例-5">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-5"></a>
通信示例
</h5><pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:19 04 81 00 16 01
	note right of 诊断仪:诊断仪发送请求：<br>第一个字节为SID<br>第二字节是子功能04<br>第三四五字节是指定的DTC码<br>最后表示请求的快照数据组号
	目标ECU ->> 诊断仪:59 04 81 00 16 2F<br> 01 05<br> 01 12 00<br> E1 01 00 00 64<br> D0 01 22<br> 01 0B 16 00 00 03<br> 01 0C 00
	note left of 目标ECU:根据请求中的DTC查找对应的快照信息，返回相应组号的快照信息
	note left of 目标ECU:目标ECU给出正响应：<br>第一个字节为SID+0x40,<br>第二字节是子功能04，<br>第三四五字节是指定的DTC码<br>2F是DTC当前的状态位取值情况<br>0105表示当前取快照信息组01，其中包含5条数据，<br>剩下五行的前两个字节是DID,后面剩余字节是对应数据<br>(不同DID对应数据长度不确定，由目标ECU决定)
</pre>
<h4 id="reportdtcextdatarecordbydtcnumber-19-06">
<a class="header-anchor" href="#reportdtcextdatarecordbydtcnumber-19-06"></a>
reportDTCExtDataRecordByDTCNumber (19 06)
</h4><p>除了前面的快照信息，一般还会再定义一个扩展信息，用于记录故障的一些其他信息，比如故障发生的次数、老化次数、已老化次数等。通过06子功能，目标ECU根据请求中指定的故障码(DTC)，查找并返回其对应的扩展信息，来分析故障原因。</p>
<h5 id="数据包格式-6">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-6"></a>
数据包格式
</h5><p>==请求==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_15_38_20_202502191538476.png" alt="0x1906请求格式"></p>
<p>此时parameter为4个byte,前三个byte用于标识我们要读取的DTC,第四个byte用于标识要读取的环境数据的范围，UDS规定使用0xFF来表示读取所有的扩展帧数据，各厂家可以要根据自己的需求定义其他的值来代表要读取的扩展数据的范围。环境数据包括DTC状态，优先级，发生次数，老化计数器，时间戳，里程等，厂家还可以根据自己的需求定义一些此DTC产生时的其他测量数据。</p>
<ul>
<li>DTCExtDataRecordNumber(1Byte):扩展数据记录码，该参数用于指定要获取的特定扩展数据记录。取值情况及对应含义如下所示：
<table>
  <thead>
      <tr>
          <th>取值</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00</td>
          <td>保留用于法定目的(如WWH-OBD)</td>
      </tr>
      <tr>
          <td>0x01-0xFE</td>
          <td>供车辆制造商使用</td>
      </tr>
      <tr>
          <td>0xFF</td>
          <td>一次性报告所有存储的DTC扩展数据记录</td>
      </tr>
  </tbody>
</table>
</li>
</ul>
<p>==肯定响应==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_15_41_20_202502191541335.png" alt="0x1906肯定响应"></p>
<p>与前面的1904十分类以，在响应的最后，携带了一个或多个扩展数据（比如请求中的DTCExtDataRecordNumber为0xFF,则表示读取所有的扩展数据记录，这里就会返回所有的扩展数据)，每个扩展数据记录（扩展帧）的构成如上图所示，这里我们把它称为DTCExtData,(标准中没有这个称呼)，他由以下两部分组成：</p>
<ul>
<li>DTCExtDataRecordNumber(1Byte):标识是哪一个扩展记录数据，其取值符合1906请求中的第六个字节含义。</li>
<li>DTCExtDataRecord(不定长)：每个信息条目成员的ID信息(DlD)及其相应数据。</li>
</ul>
<h5 id="通信示例-6">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-6"></a>
通信示例
</h5><p>假设存在如下测试背景：</p>
<ol>
<li>目标ECU中DTC 0x123456存储了两条扩展帧数据，两个扩展帧的记录编号及其对应数据分别是0x05-0x17和0x10-0x79</li>
<li>当前这个DTC的状态是：00100100（十六进制0x24)</li>
<li>请求读取DTC 0x123456的所有扩展数据</li>
</ol>
<pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:19 06 12 34 56 FF
	note right of 诊断仪:诊断仪发送请求：<br>第一个字节为SID<br>第二字节是子功能06<br>第三四五字节是指定的DTC码<br>最后表示请求所有拓展帧
	目标ECU ->> 诊断仪:59 06 12 34 56 24<br> 05 17<br> 10 79
	note left of 目标ECU:根据请求中的DTC查找对应的拓展帧信息，返回相应所有的拓展帧
	note left of 目标ECU:目标ECU给出正响应：<br>第一个字节为SID+0x40,<br>第二字节是子功能06，<br>第三四五字节是指定的DTC码<br>24是DTC当前的状态位取值情况<br>05 17表示当前取拓展帧记录号为05，其中数据为17<br>10 79表示当前取拓展帧记录号10，其中数据为79
</pre>
<h4 id="reportsupporteddtc-19-0a">
<a class="header-anchor" href="#reportsupporteddtc-19-0a"></a>
reportSupportedDTC (19 0A)
</h4><p>检索目标ECU所有支持的DTC信息(3字节的DTC标识符+1字节的DTC状态位)，其响应报文与02服务一致；但要区分，该服务返回的是所有DTC的信息；而02服务是返回与请求时状态掩码相与不为0的DTC信息。注意：不论DTC状态如何，故障是否发生，都要返回。通常用来测试ECU中实际支持的DTC和预定义的DTC列表是否相符。</p>
<h5 id="数据包格式-7">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-7"></a>
数据包格式
</h5><p>==请求==</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_15_51_29_202502191551921.png" alt="0x190A请求报文"></p>
<p>请求无需额外的参数。</p>
<p>==肯定响应==</p>
<p>响应格式和1902保持一致，详细解释可以直接参考<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/####reportDTCByStatusMask" title="19 02">1902</a>的响应格式。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_15_51_59_202502191551795.png" alt="0x190A的肯定响应"></p>
<h5 id="通信示例-7">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-7"></a>
通信示例
</h5><p>请参考<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/####reportDTCByStatusMask" title="19 02">1902的通信示例</a></p>
<h2 id="0x28通讯控制">
<a class="header-anchor" href="#0x28%e9%80%9a%e8%ae%af%e6%8e%a7%e5%88%b6"></a>
0x28：通讯控制
</h2><h3 id="简介-5">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-5"></a>
简介
</h3><p>首先了解如下信息：整车网络中各个ECU之间存在大量的通信报文，这些报文从功能上可以划分为不同的类型，总的来说可以分为:</p>
<ol>
<li>应用报文</li>
<li>网络管理报文</li>
</ol>
<p>通常情况下，各类报文充斥在整个通信网络中。</p>
<p>0x28就是一个通信控制的服务，你可以用它决定让什么类型的报文进行通信或者不让其进行通信。举个常见的例子：用UDS进行软件升级刷写时需要传输大量的软件镜像数据，这时需要将can总线资源让出来，降低CAN总线的负载率和MCU的负载，减少CAN总线的通信报文数量，提高传输效率。就可以通过0x28服务功能寻址关闭某类通讯发送报文到can总线上，待下载升级或传输数据完成后再通过0x28服务将通讯开启即可。</p>
<p>当然，有时候为了排查问题或者满足特殊的测试场景，也需要使能或者失能某类报文的收发，这时候也需要使用0x28服务。总之，0x28就是一个通信控制的服务，根据需求可以通过该服务开关ECU对特定类型报文的传送和接收。</p>
<h3 id="数据包格式-8">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-8"></a>
数据包格式
</h3><h4 id="服务请求格式-3">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f-3"></a>
服务请求格式
</h4><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_16_47_24_202502191647692.png" alt="0x28请求报文格式"></p>
<ul>
<li>
<p>controlType表示通信控制类型，即采取什么样的控制，取值及含义如下表所示：</p>
<table>
  <thead>
      <tr>
          <th>controlType取值</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00 (enableRxAndTx)</td>
          <td>使能 communicationType 所指定的报文类型的 发送与接收</td>
      </tr>
      <tr>
          <td>0x01 (enableRxAndDisableTx)</td>
          <td>使能 communicationType 所指定的报文类型的 接收，但抑制其发送</td>
      </tr>
      <tr>
          <td>0x02 (disableRxAndEnableTx)</td>
          <td>使能 communicationType 所指定的报文类型的 发送，但抑制其接收</td>
      </tr>
      <tr>
          <td>0x03 (disableRxAndTx)</td>
          <td>抑制 communicationType 所指定的报文类型的 发送与接收</td>
      </tr>
      <tr>
          <td>0x04 (enableRxAndDisableTxWithEnhancedAddresslnformation)</td>
          <td>需要对应子网节点切 换到诊断模式</td>
      </tr>
      <tr>
          <td>0x05 (enableRxAndTxWithEnhancedAddresslnformation)</td>
          <td>需要对应子网节点切 换到应用模式</td>
      </tr>
      <tr>
          <td>0x06-0x3F</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>0x40-0x5F</td>
          <td>整车厂商自定义</td>
      </tr>
      <tr>
          <td>0x60-0x7E</td>
          <td>系统供应商自定义</td>
      </tr>
      <tr>
          <td>0x7F</td>
          <td>保留</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>communicationType表示控制的通信报文的类型，即要控制哪类报文，共计占用一个字节，8个Bit,各个Bit的含义如下表所示：</p>
<table>
  <thead>
      <tr>
          <th>Bit范围</th>
          <th>取值及含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Bit0 - 1</td>
          <td>值为1：表示正常应用报文；<!-- raw HTML omitted --> 值为2：表示网络管理报文；<!-- raw HTML omitted --> 值为3：表示正常应用报文和网络管理报文；</td>
      </tr>
      <tr>
          <td>Bit2 - 3</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>Bit4 - 7</td>
          <td>取值范围0x0～0xF，表示对Bit0－1所示的报文类型进行的控制类型进行进 一步分类：<!-- raw HTML omitted --> 值为0x0：使能/抑制所有通道；<!-- raw HTML omitted --> 值为0x1~0xE：使能/抑制指定通道；<!-- raw HTML omitted --> 值为0xF：仅控制接收该请求的通道。</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>nodeldentificationNumber:2Byte,分别是寻址节点lD的高子节和低字节。用于识别车辆子网络节点，只在controlType为0x04或者0x05时可以使用。</p>
</li>
</ul>
<h4 id="服务响应格式-3">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f-3"></a>
服务响应格式
</h4><h5 id="肯定响应">
<a class="header-anchor" href="#%e8%82%af%e5%ae%9a%e5%93%8d%e5%ba%94"></a>
肯定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_16_52_35_202502191652270.png" alt="0x28的肯定响应"></p>
<p>sub-function(controlType)的取值与请求中的值保持一致即可。</p>
<h5 id="否定响应">
<a class="header-anchor" href="#%e5%90%a6%e5%ae%9a%e5%93%8d%e5%ba%94"></a>
否定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_16_53_8_202502191653935.png" alt="0x28的否定响应"></p>
<p>可能出现的NRC及其含义如下：</p>
<table>
  <thead>
      <tr>
          <th>NRC</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x12</td>
          <td>子功能参数不受支持</td>
      </tr>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x22</td>
          <td>不满足请求标准/条件</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>参数错误，请求中携带的数据是无效的</td>
      </tr>
  </tbody>
</table>
<h3 id="通信示例-8">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-8"></a>
通信示例
</h3><p>示例1：诊断仪发送请求抑制网络管理报文的发送，不抑制肯定响应。</p>
<pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:28 01 02
	note right of 诊断仪:诊断仪发送请求：<br>byte1是SID<br>byte2表示控制类型为抑制报文发送<br>byte3表示抑制所有通道的网络管理报文
	目标ECU ->> 诊断仪:68 01
	note left of 目标ECU:目标ECU给出正响应：<br>byte1的68是SID+0x40<br>byte2是subFunction-表示控制类型
	诊断仪 ->> 目标ECU:28 02 12
	note right of 诊断仪:诊断仪发送请求：<br>byte1是SID<br>byte2表示控制类型为使能报文发送<br>byte3表示使能指定通道的网络管理报文<br>使能通道代号为高四位'1'<br>比如其可以代指can通道1，具体含义取决于ECU设计
	目标ECU ->> 诊断仪:68 02
	note left of 目标ECU:目标ECU给出正响应：<br>byte1的68是SID+0x40<br>byte2是subFunction-表示控制类型
	
</pre>
<blockquote>
<p>[!tip]</p>
<p>除正常的响应规则外，当目标ECU已经处在被请求的状态，如已经停止了网络管理报文发送，此时又被请求停止网络管理报文发送，服务端应当也给予肯定响应。</p></blockquote>
<p>示例2：控制远程特定地址的节点（因此需要指定寻址节点D)进入仅诊断模式，同样不抑制肯定响应，假设寻址节点的D为0x000A。</p>
<pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:28 04 01 00 0A
	note right of 诊断仪:诊断仪发送请求：<br>byte1是SID<br>byte2表示控制类型为抑制报文发送，使能接收<br>(需要对应子网节点切换到诊断模式)<br>byte3表示抑制所有通道的正常应用报文<br>最后两个byte表示针对的那个特定节点的ID
	目标ECU ->> 诊断仪:68 04
	note left of 目标ECU:目标ECU给出正响应：<br>byte1的68是SID+0x40<br>byte2是subFunction-表示控制类型
</pre>
<h2 id="0x27安全访问">
<a class="header-anchor" href="#0x27%e5%ae%89%e5%85%a8%e8%ae%bf%e9%97%ae"></a>
0x27：安全访问
</h2><h3 id="简介-6">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-6"></a>
简介
</h3><h4 id="安全访问服务">
<a class="header-anchor" href="#%e5%ae%89%e5%85%a8%e8%ae%bf%e9%97%ae%e6%9c%8d%e5%8a%a1"></a>
安全访问服务
</h4><p>车载ECU中的一些数据或者操作是比较重要的，对于这种企业敏感的数据或者操作肯定不是人人都能访问的，诊断服务0x27应运而生。它主要用于车载ECU数据上传或者下载，传递重要信息以及敏感操作等过程中。即对请求执行操作的人进行鉴权，只有正确解锁对应的安全等级，才能访问该安全等级的数据，否则无法访问。</p>
<h4 id="应用场景">
<a class="header-anchor" href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af"></a>
应用场景
</h4><ul>
<li>通常在向Flash中写数据时，都需要先执行0x27安全解锁之后才能进行安全写入，最常见的就是对ECU进行软件刷写时，需要先通过0x27安全解锁才能进行后续重编程操作，否则将对ECU造成极大的安全风险；</li>
<li>使用0x31服务执行十分重要的routine时，需要优先执行0x27进行安全解锁之后才能够执行对应的routine；</li>
<li>在产线写入较为重要的版本或者标定等信息过程中，需要先使用0x27服务才能使用写操作的诊断指令，如0x2E服务；</li>
</ul>
<h4 id="基本原理">
<a class="header-anchor" href="#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86"></a>
基本原理
</h4><p>第一回合：</p>
<ol>
<li>Tester向目标ECU请求种子（“种子“：简单理解它就是个随机数）</li>
<li>目标ECU向Tester发送种子</li>
</ol>
<p>第二回合：</p>
<ol>
<li>Tester基于接收到来自目标ECU的种子计算出对应的key并发送给目标ECU</li>
<li>目标ECU接收来自Tester算出来的key并与内部算出的key比较，如果一致则解锁成功，否则解锁不成功</li>
</ol>
<p>  请求+响应为一组，共两个来回，用图示方式看起来更直观一些：</p>
<pre class="mermaid">sequenceDiagram
	Tester ->> 目标ECU:发送请求，索要随机数种子
	note over 目标ECU:使用随机数生成算法生成随机数种子
	目标ECU ->> Tester:回复随机数种子
	note over Tester:使用安全算法根据随机数种子计算密钥key1
	note over 目标ECU:使用相同的安全算法根据这个种子计算密钥key2
	Tester ->> 目标ECU:发送上一步计算出来的key1
	note over 目标ECU:key1 == key2 ? 正响应：负响应
	目标ECU ->> Tester:回复响应
	note over Tester:得知解锁成功还是失败
	
</pre>
<h3 id="数据包格式-9">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-9"></a>
数据包格式
</h3><h4 id="服务请求格式-4">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f-4"></a>
服务请求格式
</h4><p>该服务共两次请求+响应，两次请求数据包的格式不一样:</p>
<p><strong>请求种子数据包:</strong></p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_14_55_45_202407111455767.png" alt="0x27请求种子格式"></p>
<p><strong>发送 key数据包:</strong></p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_14_56_45_202407111456373.png" alt="0x27发送key数据包"></p>
<p>Tips📌：两个请求中sub-function: securityAccessType的含义</p>
<ul>
<li>“请求种子“数据包中，该字段必须为奇数；“发送key“数据包中该字段必须为偶数，不同的数字代表不同的安全等级</li>
<li>每一次完整的0x27服务流程中，“请求种子“和“发送key“两个数据包中该字段数值必须存在一个定量关系，即：
“请求种子“ 的securityAccessType + 1 == “发送key“ 的securityAccessType
例如： “请求种子“ 的securityAccessType= 0x01 ——&gt; “发送key“ 的securityAccessType= 0x02</li>
</ul>
<p>Tips📌：两次请求携带的数据含义</p>
<ul>
<li>securityAccessDataRecord: 传输到目标ECU端的标识性信息，一般不使用</li>
<li>securityKey: Tester通过安全算法根据随机数种子计算出来的密钥值，发送给目标ECU</li>
</ul>
<h4 id="服务响应格式-4">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f-4"></a>
服务响应格式
</h4><h5 id="正响应-3">
<a class="header-anchor" href="#%e6%ad%a3%e5%93%8d%e5%ba%94-3"></a>
正响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/11_15_0_3_202407111500291.png" alt="0x27正响应"></p>
<p>securityAccessType：取值与请求中的sub-function值保持一致即可；</p>
<p>securitySeed：该参数仅在对应请求的sub-function为奇数(即“请求种子“)时才会有，其他情况下，目标ECU只会回复前两个字节（0x67 &amp; sub-function），该参数取值范围只能为0x00-0x7F。</p>
<h5 id="负响应-3">
<a class="header-anchor" href="#%e8%b4%9f%e5%93%8d%e5%ba%94-3"></a>
负响应
</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/93d66d305dd6d0fae455d2b1a8fc9bad.png#pic_center" alt="0x27负响应"></p>
<p>可能出现的 NRC 及其含义如下：</p>
<table>
  <thead>
      <tr>
          <th>NRC含义</th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x12</td>
          <td>子功能参数不受支持</td>
      </tr>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x22</td>
          <td>不满足请求标准/条件</td>
      </tr>
      <tr>
          <td>0x24</td>
          <td>请求顺序错误，比如应该先发送请求种子，而不是先发送密钥数据</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>请求中携带的数据是无效的</td>
      </tr>
      <tr>
          <td>0x35</td>
          <td>密钥不匹配，即Tester计算出来的key和目标ECU计算出来的不一样：若始终不匹配还不断尝试， ECU会回复下面的NRC=36，告诉你已经超过失败的次数了，不能再请求安全解锁了</td>
      </tr>
      <tr>
          <td>0x36</td>
          <td>超过最大试错次数，已达到解锁最大错误次数，若你执意再请求，ECU就会回复你下面的NRC=37， 意思是ECU现在不接受安全访问，这就是ECU锁死的现象，需等待一定时间后才可继续请求安全访问</td>
      </tr>
      <tr>
          <td>0x37</td>
          <td>当前服务器处于延时状态，超时时间未到</td>
      </tr>
  </tbody>
</table>
<p>Tips📌：</p>
<ul>
<li>ECU 上电后，保持上锁状态，<a href="https://blog.csdn.net/qq_40309666/article/details/133752052?spm=1001.2014.3001.5501#diff-service">一般进入扩展会话才能请求 0x27 服务</a>，而编程会话的安全等级与扩展会话的安全的等级不一致。所以如果想进行 ECU 软件刷写操作 flash，那进入编程会话后一般还需要再请求 0x27 服务进入另一个安全等级。</li>
<li>若已成功解锁安全等级，再请求相同层级的解锁服务，ECU 一般会回复的种子（随机数）为 0。而未解锁的安全等级下，27 服务中目标 ECU 发送来的随机数种子是不允许为 0 的。因此，可以通过判断种子的值得知当前安全等级是否处于解锁状态。</li>
<li>同一时刻，只允许有一个安全等级处于解锁状态。</li>
<li>安全等级的值没有特别的含义，不存在高低之分，比如解锁 level3 并不需要先处于 level2。</li>
</ul>
<h3 id="通信示例-9">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-9"></a>
通信示例
</h3><p>假设现在需要解锁目标 ECU 的安全等级 1，并且此时目标 ECU 的这个等级处于上锁状态：</p>
<pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:27 01
	note right of 诊断仪:诊断仪 目标 ECU 27 01 1 诊断仪发送请求：<br> 向 ECU 索要随机数种子， 请求解锁安全等级 1
	目标ECU ->> 诊断仪:67 01 36 57
	note left of 目标ECU:根据随机数生成算法生成随机数种子，<br> 假设生成的是（36 57)同时也会根据该随机数种子用安全算法计算密钥。<br>目标 ECU 给出响应： byte1 是 SID+0x40 = 67， byte2 是 sub-funtion：<br>安全等级 其他 byte 是生成的随机数种子
	诊断仪 ->> 目标ECU:27 02 C9 A9
	note right of 诊断仪:使用相同的安全算法根据随机数种子计算密钥， 假设算出来的是（C9 A9)
</pre>
<p>在上一步成功解锁安全等级 1 的基础上，继续发送解锁目标 ECU 的安全等级 1 的请求：</p>
<pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:27 01
	note right of 诊断仪:诊断仪发送请求： 向 ECU 索要随机数种子， 请求解锁安全等级 1
	目标ECU ->> 诊断仪:67 01 00 00
	note left of 目标ECU:ECU 已经处于解锁状态，直接回复正响应,目标 ECU 给出正响应： 随机数种子的值都是 0
</pre>
<h2 id="0x31例程控制">
<a class="header-anchor" href="#0x31%e4%be%8b%e7%a8%8b%e6%8e%a7%e5%88%b6"></a>
0x31：例程控制
</h2><h3 id="简介-7">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-7"></a>
简介
</h3><p>所谓“例程”，简单理解你可以认为就是个函数或者一段执行逻辑，而“例程控制”就是控制这段执行逻辑的启动、停止或者获取其执行结果，这就是0x31-例行程序控制服务的作用。每个“例程”都有一个唯一的标识，称为Routine ID(RID),以便在Ox31服务的请求中区分请求执行的是哪一个”例程”。</p>
<p>该服务具有很大的灵活性，但典型的使用方式有擦除内存、重置或学习自适应数据、运行自检、控制目标ECU值随时间变化等。通常情况下，该服务用于更复杂类型的输出控制，而0x2F-通过D控制输入输出用于相对简单的输出控制，大多情况下0x2F服务的功能都能够通过0x31服务来实现，不过一般不这么做，属于杀鸡用牛刀的做法。</p>
<h3 id="数据包格式-10">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-10"></a>
数据包格式
</h3><h4 id="服务请求格式-5">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f-5"></a>
服务请求格式
</h4><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/31_13_47_47_202410311347022.png" alt="例程控制请求报文"></p>
<p>各个参数的含义如下所示：</p>
<ol>
<li>
<p>routineControlType(1Byte):表示要对routine进行何种控制（启动、停止、获取执行结果），取值及相应含义如下所示：</p>
<table>
  <thead>
      <tr>
          <th>取值</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>0x01</td>
          <td>启动由 routineldentifier 标识的 routine</td>
      </tr>
      <tr>
          <td>0x02</td>
          <td>停止由 routineldentifier 标识的routine</td>
      </tr>
      <tr>
          <td>0x03</td>
          <td>请求目标 ECU返回由routineldentifier 标识的routine的执行结果</td>
      </tr>
      <tr>
          <td>0x04 - 0x7F</td>
          <td>保留</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>routineldentifier(2Byte):该参数和数据传输类服务中的DID参数类似，我们可以称它为RID,也是用来标识具体的功能的，可以理解为给各种要执行的操作(routine)一个代号。有个别RID在标准中是有明确定义的，RID相关取值如下表所示：</p>
<table>
  <thead>
      <tr>
          <th>取值</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x0000 - 0x00FF</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>0x0100 - 0x01FF</td>
          <td>该范围的值被保留来表示行车记录仪的测试结果值。</td>
      </tr>
      <tr>
          <td>0x0200 - 0xDFFF</td>
          <td>此值范围保留给特定的汽车制造商使用。</td>
      </tr>
      <tr>
          <td>0xE000 - 0xE1FF</td>
          <td>这个范围的值被保留来表示OBD/EOBD 测试结果值。</td>
      </tr>
      <tr>
          <td>0xE200</td>
          <td>此值应使用用于启动先前选择的点火回路的部署。</td>
      </tr>
      <tr>
          <td>0xE201 - 0xE2FF</td>
          <td>保留的， 以便将来定义安全相关系统中实施的例行程序。</td>
      </tr>
      <tr>
          <td>0xE300 - 0xEFFF</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>0xF000   0xFEFF</td>
          <td>系统供应商定义</td>
      </tr>
      <tr>
          <td>0xFF00</td>
          <td>该值用于启动目标ECU的内存擦除操作。（常用于 ECU软件升级刷写中）</td>
      </tr>
      <tr>
          <td>0xFF01</td>
          <td>该值用于检查目标 ECU的内存编程依赖关系。 比如版本检查、crc 检查等。（常用于 ECU 软件升级刷写中)</td>
      </tr>
      <tr>
          <td>0xFF02</td>
          <td>该值用于擦除目标ECU 的镜像内存 dtc。</td>
      </tr>
      <tr>
          <td>0xFF03 - 0xFFFF</td>
          <td>保留</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>routineControlOptionRecord(不定长)：该参数是可选的，需要根据routine的具体设计决定，比如有些routine需要额外的数据，就可以通过这个参数来传递，比如routine是用来进行数据校验的，需要把标准值告诉目标ECU,这样目标ECU就可以根据自身计算结果和接收到的标准值进行比较，来判断校验结果。</p>
</li>
</ol>
<h4 id="服务响应格式-5">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f-5"></a>
服务响应格式
</h4><h5 id="肯定响应-1">
<a class="header-anchor" href="#%e8%82%af%e5%ae%9a%e5%93%8d%e5%ba%94-1"></a>
肯定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/31_14_0_8_202410311400211.png" alt="例程控制肯定响应"></p>
<ol>
<li>routineControlType和routineldentifier的定义跟请求消息中的保持一致。</li>
<li>routinelnfo(1Byte)：该参数是可选的，用于在执行相应routine后，返回routine相关信息，具体该参数用做什么由制造商做决定。</li>
<li>routineStatusRecord(不定长)：该参数也是可选的，用于在执行相应routine后，返回目标ECU相关信息（比如通过3102服务请求目标ECU停止routine时，目标ECU可以通过该参数返回该routine运行时间等信息)，可根据实际需要进行使用，很少用到。</li>
</ol>
<h5 id="否定响应-1">
<a class="header-anchor" href="#%e5%90%a6%e5%ae%9a%e5%93%8d%e5%ba%94-1"></a>
否定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/31_14_3_36_202410311403154.png" alt="例程控制否定响应"></p>
<p>可能出现的NRC的含义：</p>
<table>
  <thead>
      <tr>
          <th>NRC C</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x12</td>
          <td>子功能不受支持</td>
      </tr>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x22</td>
          <td>当前条件不满足</td>
      </tr>
      <tr>
          <td>0x24</td>
          <td>三种情况下返回该 NRC：<!-- raw HTML omitted --> ①当收到“startRoutine”子功能时， 流程当前正在进行且无法重新启动 （是否可以在活动状态下重新启动取决于车辆制造商）；<!-- raw HTML omitted --> ②当收到“stopRoutine”子功能时， 流程当前未处于活动状态；<!-- raw HTML omitted --> ③当收到“requestRoutineResults”子功能时， 流程结果不可用（例如，所请求的流程标识从未启动）。</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>请求参数不受支持，参数错误</td>
      </tr>
      <tr>
          <td>0x33</td>
          <td>未通过安全访问</td>
      </tr>
      <tr>
          <td>0x72</td>
          <td>如果目标ECU在执行与其内部存储器访问有关的流程时检测到错误， 0x72返回该NRC。例如，当流程擦除或编程永久存储器设备(如Flash存储器)中的某个内存位置时，访问该内存位置失败。</td>
      </tr>
  </tbody>
</table>
<p>NRC的处理流程如下：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/31_14_6_29_202410311406760.png" alt="例程控制的NRC处理"></p>
<h3 id="示例">
<a class="header-anchor" href="#%e7%a4%ba%e4%be%8b"></a>
示例
</h3><p>Tester分别发送启动、停l止、返回执行结果三类routine控制请求，不抑制正响应，通信流程如下所示：</p>
<pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:31 01 20 01
	note over 诊断仪:诊断发送请求：请求ECU执行RID为0x0201的routine
	目标ECU ->> 诊断仪:71 01 02 01 32
	note over 目标ECU:目标ECU给出响应：<br>byte1是SID+0x41<br>byte2的01是启动routine<br>02 01是RID<br>32是制造商自定义的返回目标ECU的一些附加信息
	诊断仪 ->> 目标ECU:31 02 02 01
	note over 诊断仪:诊断仪发送请求:请求ECU停止RID为02 01的routine
	目标ECU ->> 诊断仪:71 02 02 01 30
	note over 目标ECU:目标ECU给出响应：<br>byte1是SID+0x41<br>byte2的01是停止routine<br>02 01是RID<br>32是制造商自定义的返回目标ECU的一些附加信息
	诊断仪 ->> 目标ECU:31 03 02 01
	note over 诊断仪:诊断仪发送请求:请求ECU返回RID为02 01的routine的执行结果
	目标ECU ->> 诊断仪:71 03 02 01 30 33 .... 8f
	note over 目标ECU:目标ECU给出响应：<br>byte1是SID+0x41<br>byte2的01是停止routine<br>02 01是RID<br>剩下的数据表示routine执行的返回结果
</pre>
<h2 id="0x34请求下载">
<a class="header-anchor" href="#0x34%e8%af%b7%e6%b1%82%e4%b8%8b%e8%bd%bd"></a>
0x34：请求下载
</h2><h3 id="简介-8">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-8"></a>
简介
</h3><h4 id="为何需要上传下载类服务">
<a class="header-anchor" href="#%e4%b8%ba%e4%bd%95%e9%9c%80%e8%a6%81%e4%b8%8a%e4%bc%a0%e4%b8%8b%e8%bd%bd%e7%b1%bb%e6%9c%8d%e5%8a%a1"></a>
为何需要上传下载类服务？
</h4><p>参加过嵌入式软件开发工作的同志应该知道，MCU中的资源是有限的。在复杂的车载操作系统中，为了尽可能的降低汽车开发成本，在ECU的芯片选型上通常也比较严格，软件开发代码的编写也会考虑资源的利用效率，比如芯片RAM空间的使用情况。</p>
<p>例如用于缓存ECU诊断数据的那块buffer通常是有限的，为了向ECU中写入数据，可以使用我们前面提到过的0x2E服务（通过ID写数据）。但当要写入的数据块很大时（最常见的就是升级ECU软件，通常数据量是要上KByte甚至MByte的)，为诊断数据定义的buffer已经不能满足使用需求。于是，上传下载类服务应运而生，他们主要用于大块数据的读取或写入。</p>
<h4 id="0x34服务的作用">
<a class="header-anchor" href="#0x34%e6%9c%8d%e5%8a%a1%e7%9a%84%e4%bd%9c%e7%94%a8"></a>
0x34服务的作用
</h4><p>该服务用于启动数据传输服务，传输方向是Tester(Client)→目标ECU(Server),向目标ECU发送该请求的==主要作用就是告知目标ECU&quot;我(Tester)准备向你传输数据了，请你（目标ECU)准备接收数据”==。</p>
<p>目标ECU正确收到该请求消息后，可以发送响应告诉Tester自己是否允许传输数据，以及自己的接受能力是多大，如果可以传输，目标ECU应采取一切必要措施接收数据，然后再发送肯定响应消息。</p>
<h3 id="数据包格式-11">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-11"></a>
数据包格式
</h3><h4 id="服务请求格式-6">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f-6"></a>
服务请求格式
</h4><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_11_35_42_202410301135301.png" alt="请求下载请求格式"></p>
<p>==该服务不支持sub-function==。部分参数的含义如下所示：</p>
<ol>
<li>dataFormatldentifier(1Byte):这个单字节里面标识了数据格式相关的信息，每半个字节分别编码，==高半字节==指定“==数据压缩方法==”，而==低半字节==则指定“==数据加密方法==”。如果该字节取值为0x00,则表示既不使用加密方法也不适用压缩方法，其他取值情况有整车制造商或者供应商决定，可以用约定好用不同的取值代表数据是否有压缩，是否有加密，用的又是什么算法等等。</li>
<li>addressAndLengthFormatldentifier(1Byte):该参数含义在图中标识的已经比较清晰，不再赘述。比如memoryAddressa参数占用m个字节，memorySize参数占用n个字节，则该参数取值为0x(nm)。</li>
<li>memoryAddress(mByte):对于即将启动的数据传输，该参数指明了向ECU内存写入数据的逻辑地址。比如Tester请求将数据写入ECU内存地址为0x12345678的地方（该地址占4个字节)，则memoryAddress值为0x12345678,对应addressAndLengthFormatldentifier参数低4Bits值为0x04。</li>
<li>memorySize(nByte):对于即将启动的数据传输，该参数指明了向ECU内存写入数据的字节数。比如Testeri请求写入ECU数据的字节数为0x01234567(即memorySize占4字节)，则memorySize值为0x01234567,对应的addressAndLengthFormatldentifier高4Bits值为0x40。</li>
</ol>
<h4 id="服务响应格式-6">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f-6"></a>
服务响应格式
</h4><h5 id="肯定响应-2">
<a class="header-anchor" href="#%e8%82%af%e5%ae%9a%e5%93%8d%e5%ba%94-2"></a>
肯定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_11_45_7_202410301145456.png" alt="请求下载肯定响应"></p>
<ol>
<li>lengthFormatldentifier(1Byte):该字节每半个字节单独编码，高4Bits为maxNumberOfBlockLength有效字节长度，低4Bits保留为0。</li>
<li>maxNumberOfBlockLength:字节长度不定，取值长度取决于lengthFormatldentifier的高半字节，表示0x36服务一次传输一个block的最大的字节数。比如该参数取值为0x202,则使用0x36服务时，一次最多发送字节数为0x202(字节数：0x202&gt;=36(1Byte)+parameter(x个Bytes)）。</li>
</ol>
<h5 id="否定响应-2">
<a class="header-anchor" href="#%e5%90%a6%e5%ae%9a%e5%93%8d%e5%ba%94-2"></a>
否定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_11_48_51_202410301148839.png" alt="请求下载的否定响应"></p>
<p>可能出现的NRC：</p>
<table>
  <thead>
      <tr>
          <th>NRC</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x22</td>
          <td>当前条件不满足</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>请求参数不受支持，参数错误</td>
      </tr>
      <tr>
          <td>0x33</td>
          <td>未通过安全访问</td>
      </tr>
      <tr>
          <td>0x70</td>
          <td>由于某些故障导致无法下载到目标ECU的指定内存中（比如没有执行擦除就直接 写入）</td>
      </tr>
  </tbody>
</table>
<p>NRC的处理流程如下（推荐的错误情况检查顺序）：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_11_50_33_202410301150669.png" alt="请求下载的NRC检查错误流程"></p>
<h2 id="0x36数据传输">
<a class="header-anchor" href="#0x36%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93"></a>
0x36：数据传输
</h2><h3 id="简介-9">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-9"></a>
简介
</h3><p>该服务用于在Tester和目标ECU之间传输数据，可以是从Tester向目标ECU传输（下载)或从目标ECU向Tester传输（上传)。数据传输方向由前面的0x34-RequestDownload或0x35-RequestUpload)服务定义。==即0x36服务必须在0x34或0x35服务之后才能正常执行==。</p>
<ul>
<li>如果Tester发起了0x34-RequestDownload请求，则要下载的数据包含在该服务请求消息中的transferRequestParameter参数中；</li>
<li>如果Tester发起了0x35-RequestUpload请求，则要上传的数据包含在该服务响应消息中的transferResponseParameter参数中。</li>
</ul>
<h3 id="数据包格式-12">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-12"></a>
数据包格式
</h3><h4 id="服务请求格式-7">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f-7"></a>
服务请求格式
</h4><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_11_59_13_202410301159270.png" alt="数据传输的请求"></p>
<p>==该服务不支持sub-function==。部分参数的含义如下所示：</p>
<ol>
<li>blockSequenceCounter(1Byte):参数的初始值为0x01,从RequestDownload(0x34)或RequestUpload(0x35)服务后的第一个TransferData请求开始。每个后续的TransferData请求，blockSequenceCounter的值递增1。当blockSequenceCounter的值达到0xFF时，它将重新变为0x00,然后随着下一个TransferData请求继续递增。
以数据下载过程中该服务的使用为例，可以看到该参数的作用：
<ul>
<li>如果下载数据的TransferData请求在目标ECU中已经被正确接收和处理，但目标ECU发出的正响应消息未能到达Tester,则Tester会检测到超时，并重复相同的请求（包括相同的blockSequenceCounter)。于是目标ECU会接收到重复的TransferDatai请求，并根据包含的blockSequenceCounteri确定这是一个重复的请求。这是目标ECU会立即发送正响应消息，而无需再次写入数据到其内存中。</li>
<li>如果下载数据的TransferData请求在目标ECU中未能正确接收，则目标ECU不会发送正响应消息。于是Tester端会检测到超时，并重复相同的请求（包括相同的blockSequenceCounter)。目标ECU会接收到重复的TransferData请求，并根据包含的blockSequenceCountert确定这是一个新的请求。服务器会处理该服务，并发送正响应消息。</li>
</ul>
</li>
<li>transferResponseParameterRecord(不定长)：这个参数记录包含目标ECU需要支持数据传输的参数。这些参数的格式和长度是由车辆制造商指定的。例如，在下载操作中，transferRequestParameterRecord包含要传输的数据。</li>
</ol>
<h4 id="服务响应格式-7">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f-7"></a>
服务响应格式
</h4><h5 id="肯定响应-3">
<a class="header-anchor" href="#%e8%82%af%e5%ae%9a%e5%93%8d%e5%ba%94-3"></a>
肯定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_13_8_58_202410301308294.png" alt="数据传输肯定响应"></p>
<ol>
<li>blockSequenceCounter(1Byte):跟请求消息中的保持一致。</li>
<li>transferResponseParameterRecord(不定长)：这个参数的格式和长度是由车辆制造商指定的。例如，在下载操作中（上一条请求是0x34)，那么该参数可能包含目标ECU根据请求下载的数据计算得出的校验和。在上传操作中（上一条请求是0x35)，该参数包含要上传的数据。在下载操作中，该参数不应与transferRequestParameterRecord重复。</li>
</ol>
<h5 id="否定响应-3">
<a class="header-anchor" href="#%e5%90%a6%e5%ae%9a%e5%93%8d%e5%ba%94-3"></a>
否定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_13_14_15_202410301314441.png" alt="数据传输的否定响应"></p>
<p>可能出现的NRC及其含义如下：</p>
<table>
  <thead>
      <tr>
          <th>NRC</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x24</td>
          <td>两种情况会回复这个NRC： ①收到0x36请求时，0x34/0x35服务未处于活动状态，也就是在这之前没 收到上传下载请求； ②之前收到了上传下载请求，但目标ECU已根据上一次请求中的 memorySize参数接收到了所有的数据；</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>请求参数不受支持，参数错误</td>
      </tr>
      <tr>
          <td>0x71</td>
          <td>如果下载模块的长度不符合0x34-请求下载服务请求消息中的 memorySize参数的要求，则应返回此NRC。</td>
      </tr>
      <tr>
          <td>0x72</td>
          <td>一 般的刷写错误，比如写flash出错</td>
      </tr>
      <tr>
          <td>0x73</td>
          <td>如果目标ECU检测到blockSequenceCounter的序列错误，应返回此 NRC。 注意，如果请求消息的blockSequenceCounter与前一个请求消息中的 blockSequenceCounter相等， 则目标ECU应接受重复的那个TransferData请求消息。</td>
      </tr>
      <tr>
          <td>0x92/0x93</td>
          <td>电压条件不满足，比如目标ECU的主电源引脚上测量到的电压超出了下载 数据到其永久存储器（例如闪存）的可接受范围</td>
      </tr>
  </tbody>
</table>
<p>NRC的处理流程如下：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_13_17_1_202410301317979.png" alt="输出传输NRC检查流程"></p>
<h2 id="0x37请求退出">
<a class="header-anchor" href="#0x37%e8%af%b7%e6%b1%82%e9%80%80%e5%87%ba"></a>
0x37：请求退出
</h2><h3 id="简介-10">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-10"></a>
简介
</h3><p>不管是数据上传还是下载过程，该服务由Tester发起，==用于终止Tester和目标ECU之间的数据传输==。</p>
<h3 id="数据包格式-13">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-13"></a>
数据包格式
</h3><h4 id="服务请求格式-8">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f-8"></a>
服务请求格式
</h4><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_13_19_16_202410301319786.png" alt="请求退出请求报文格式"></p>
<p>格式很简单，没什么要做特别说明的，其中transferRequestParameterRecord参数应包含目标ECU需要支持数据传输所需的参数。该参数的格式和长度是是由车辆制造商决定的。</p>
<h4 id="服务响应格式-8">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f-8"></a>
服务响应格式
</h4><h5 id="肯定响应-4">
<a class="header-anchor" href="#%e8%82%af%e5%ae%9a%e5%93%8d%e5%ba%94-4"></a>
肯定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_13_20_43_202410301320673.png" alt="请求退出肯定响应"></p>
<p>跟请求消息一样，格式很简单，没什么要做特别说明的，其中transferResponseParameterRecord参数应包含Tester需要支持数据传输所需的参数。该参数的格式和长度是也是由车辆制造商决定的。</p>
<h5 id="否定响应-4">
<a class="header-anchor" href="#%e5%90%a6%e5%ae%9a%e5%93%8d%e5%ba%94-4"></a>
否定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_13_21_39_202410301321050.png" alt="请求退出的否定响应"></p>
<p>可能出现的NRC及其含义：</p>
<table>
  <thead>
      <tr>
          <th>NRC</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x24</td>
          <td>两种情况会回复这个NRC： ①0x36传输过程还没结束就收到这个请求； ②之前压根儿没收到过上传下载请求（0x34or0x35）；</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>请求参数不受支持，参数错误</td>
      </tr>
      <tr>
          <td>0x72</td>
          <td>一般的刷写错误，比如目标ECU在终止数据传输时发生错误</td>
      </tr>
  </tbody>
</table>
<p>NRC的处理流程：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/30_13_22_36_202410301322849.png" alt="请求退出的NRC处理"></p>
<h3 id="通信示例-10">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-10"></a>
通信示例
</h3><p>基于对0x34、0x36、0x37三个服务的学习，这里举一个完整的例子，该示例实现：==通过Tester将数据下载到目标ECU中==，该示例最为常用的场景就是在车载ECU软件升级过程中更新目标ECU flash中的软件。数据下载到目标ECU的过程分三步：</p>
<ol>
<li>Tester通过0x34-请求下载服务向目标ECU发送请求，该请求消息中将包括数据的格式信息（是否压缩、加解密信息）、数据要往哪个地址写、要写入多少字节的数据。目标ECU收到该请求后将通过响应告诉Tester:“我（目标ECU)每次最多能接收多少自字节”，即目标ECU会表明自己每次的接收能力。</li>
<li>Tester得知目标ECU每次接收能力后，将要传输过去的数据按照目标ECU接收能力拆分成一个个数据块(block)，通过0x36-数据传输服务将数据一块块的传输到目标ECU。</li>
<li>Tester端数据传输完成后，通过发送0x37-退出传输服务请求来终止数据传输过程。</li>
</ol>
<p>在钥匙电开启，发动机关闭，车速为0的背景下，Tester7和目标ECU间的通信过程如下图所示：</p>
<pre class="mermaid">sequenceDiagram
	Tester ->> 目标ECU:34 11 33 60 20 00 00 FF FF
	note right of Tester: 通过0x34-请求下载服务向目标ECU发送请求
	note right of Tester:34：Service ID<br>11：标识数据压缩及解密算法信息<br>33:表明地址和大小信息占用几个字节<br>602000：地址信息，下载到目标ECU中地址为0行0x602000<br>00 FF FF：大小信息，要下载的数据大小是0x00FFFF（65535字节）
	目标ECU ->> Tester:74 20 00 81
	note left of 目标ECU:目标ECU通过响应表明自己的接收能力<br>74:service + 40<br>20：高四位2表示每次最大接收数据长度为2字节，低四位默认为0<br>00 81：每次最多接收0x0081（129字节）数据
	loop 通过36服务传输每个数据块，共计要传输：65535/127=516...3，516次不能传完，要再来一次
		Tester ->> 目标ECU:36 01（xxxxxxx实际数据共127字节）
		note right of Tester:通过0x36-数据传输服务将数据一块一块的传输到目标ECU
		note right of Tester:36：Service ID<br>01：标识这是第几块数据块（block），剩下的127字节：实际数据<br>上一步目标ECU回复的最大接收能力是包括36和01两个字节的
		目标ECU ->> Tester:76 01
		note left of 目标ECU:针对每一次0x36传输请求都回复正响应<br>76:Service + 40<br>01:标识这是针对第几个传输数据块（block）的响应
	end
	Tester ->> 目标ECU:37
	note right of Tester:通过0x37-退出传输服务来终止数据传输过程，发送退出传输请求，不跟其他参数也可以，由制造商决定
	目标ECU ->> Tester:77
	note left of 目标ECU:给出正响应，不跟其他参数也可以，由制造商决定
</pre>
<h2 id="0x85控制dtc设置">
<a class="header-anchor" href="#0x85%e6%8e%a7%e5%88%b6dtc%e8%ae%be%e7%bd%ae"></a>
0x85：控制DTC设置
</h2><h3 id="简介-11">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-11"></a>
简介
</h3><p>在正常情况下，服务端（目标ECU)的故障检测功能模块会根据故障检测结果实时更新每个DTC的状态。而该服务就是让目标ECU停止或者恢复DTC状态位的更新。</p>
<p>这个服务通常和0x28服务一起使用，比如在开始写参数之前，为了获得更快的传输速度我们使用0x28服务把所有ECU的通信给关闭了，但此时很多ECU由于收不到相关报文，会没必要地存储很多DTC,这时如果我们使用0x85服务把ECU存储DTC的功能暂时性地禁用掉，则不会产生这种麻烦。</p>
<p>最常见的应用场景就是在用UDS进行ECU软件刷写时，由于刷写通常是针对某一个ECU单独进行的，此时其他ECU正常工作，因此应当通过功能寻址发送给其他各个ECU请求他们停止更新/记录DTC状态，待刷写完成后再启用状态更新即可。</p>
<blockquote>
<p>[!note]</p>
<ol>
<li>当目标ECU接收到0x85请求后，如果控制信息是请求关闭DTC状态更新，则目标ECU应该立即停止DTC的状态更新。即从此刻起，DTC的状态信息保持不变，无论是发生了新的故障，还是已有的故障有了新的状态，目标ECU中的DTC数量、状态信息都不会更新。如果控制信息是启用更新，那么如果先前是关闭状态，就立即恢复到正常的状态，如果先前就是启用更新的状态，则保持状态不变。</li>
<li>无论是启用还是禁用状态更新，目标ECU在正确处理请求之后都要给出肯定响应，如果无法正确处理，需要给出否定响应并明确响应失败的NRC。
<ol>
<li>该服务需在非默认会话状态下才受支持，当ECU重回到默认回话模式时，该服务的功能就会恢复到默认状态，即恢复启用DTC更新状态。</li>
<li>虽然该服务控制DTC状态更新的使能/失能，但并不影响通过0x14服务(ClearDTCInformation)请求清除故障信息。</li>
<li>如果某event没有对应DTC(没有mapping DTC),那0x85请求不会对这个event做任何处理，因为该服务基本对象是DTC。</li>
<li>如果某event触发安全行为，这时执行0x85请求以及0x14请求清除了DTC,那这个安全行为可能就失效了，这种情况下建议触发的安全行为不应该被同步抑制。</li>
</ol>
</li>
</ol></blockquote>
<h3 id="数据包格式-14">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f-14"></a>
数据包格式
</h3><h4 id="服务请求格式-9">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e6%a0%bc%e5%bc%8f-9"></a>
服务请求格式
</h4><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_16_25_14_202502191625105.png" alt="0x85请求格式"></p>
<ul>
<li>
<p>DTCSettingTypel取值及含义如下表所示：</p>
<table>
  <thead>
      <tr>
          <th>DTCSettingType</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>0x01</td>
          <td>启用DTC状态更新</td>
      </tr>
      <tr>
          <td>0x02</td>
          <td>禁用DTC状态更新</td>
      </tr>
      <tr>
          <td>0x03 - 0x3F</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>0x40 - 0x5F</td>
          <td>整车厂商自定义</td>
      </tr>
      <tr>
          <td>0x60 - 0x7E</td>
          <td>系统供应商自定义</td>
      </tr>
      <tr>
          <td>0x7F</td>
          <td>保留</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>DTCSettingControlOptionRecord：一般这个参数不使用，可以设置为传递需要控制的DTC列表之类的。</p>
</li>
</ul>
<h4 id="服务响应格式-9">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f-9"></a>
服务响应格式
</h4><h5 id="肯定响应-5">
<a class="header-anchor" href="#%e8%82%af%e5%ae%9a%e5%93%8d%e5%ba%94-5"></a>
肯定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_16_29_1_202502191629718.png" alt="0x85肯定响应"></p>
<p>DTCSettingType的取值与请求中的值保持一致即可。</p>
<h5 id="否定响应-5">
<a class="header-anchor" href="#%e5%90%a6%e5%ae%9a%e5%93%8d%e5%ba%94-5"></a>
否定响应
</h5><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/19_16_29_54_202502191629208.png" alt="0x85否定响应"></p>
<p>可能出现的NRC及其含义如下：</p>
<table>
  <thead>
      <tr>
          <th>NRC</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x12</td>
          <td>子功能参数不受支持</td>
      </tr>
      <tr>
          <td>0x13</td>
          <td>消息长度错误</td>
      </tr>
      <tr>
          <td>0x22</td>
          <td>不满足请求标准/条件</td>
      </tr>
      <tr>
          <td>0x31</td>
          <td>参数错误，请求中携带的数据是无效的</td>
      </tr>
  </tbody>
</table>
<h4 id="通信示例-11">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b-11"></a>
通信示例
</h4><pre class="mermaid">sequenceDiagram
	诊断仪 ->> 目标ECU:85 02
	note right of 诊断仪:诊断发送请求：关闭DTC更新，不抑制肯定响应
	目标ECU ->> 诊断仪:C5 02
	note left of 目标ECU:目标ECU给出正响应
	诊断仪 ->> 目标ECU:85 01
	note right of 诊断仪:诊断发送请求：关闭DTC更新，不抑制肯定响应
	目标ECU ->> 诊断仪:C5 01
	note left of 目标ECU:目标ECU给出正响应
</pre>
<h2 id="0x3d通过地址写内存">
<a class="header-anchor" href="#0x3d%e9%80%9a%e8%bf%87%e5%9c%b0%e5%9d%80%e5%86%99%e5%86%85%e5%ad%98"></a>
0x3D：通过地址写内存
</h2><h3 id="简介-12">
<a class="header-anchor" href="#%e7%ae%80%e4%bb%8b-12"></a>
简介
</h3>
      
    </div>
    <footer class="article-footer">
      

      

      
        

<div class="share-wrapper">
  
    <a href="http://connect.qq.com/widget/shareqq/index.html?url=http://localhost:1313/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/&amp;title=UDS&amp;desc=%20%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5%20%e3%80%8aUDS%e5%8d%8f%e8%ae%ae%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%ef%bc%88UDS%e9%80%9f%e6%9f%a5%e6%89%8b%e5%86%8c%ef%bc%89%e3%80%8b%ef%bc%88%e5%ae%8c%e7%bb%93%e6%92%92%e8%8a%b1%e7%89%88%ef%bc%89_obdonuds-CSDN%e5%8d%9a%e5%ae%a2%0a%e7%ae%80%e4%bb%8b%20UDS%20%28Unified%20Diagnostic%20Services%29%20%e6%98%af%e4%b8%80%e7%a7%8d%e6%a0%87%e5%87%86%e5%8c%96%e7%9a%84==%e8%bd%a6%e8%be%86%e8%af%8a%e6%96%ad%e5%8d%8f%e8%ae%ae==%ef%bc%8c%e5%b9%bf%e6%b3%9b%e5%ba%94%e7%94%a8%e4%ba%8e%e6%b1%bd%e8%bd%a6%e7%94%b5%e5%ad%90%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83%ef%bc%88ECU%ef%bc%89%e7%9a%84%e8%af%8a%e6%96%ad%e5%92%8c%e7%bb%b4%e4%bf%ae%e3%80%82%e5%ae%83%e6%98%afISO%2014229%e6%a0%87%e5%87%86%e7%9a%84%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%8c%e4%b8%bb%e8%a6%81%e7%94%a8%e4%ba%8e%e8%bd%a6%e8%be%86%e8%af%8a%e6%96%ad%e3%80%81%e6%95%85%e9%9a%9c%e6%8e%92%e9%99%a4%e3%80%81%e8%bd%af%e4%bb%b6%e6%9b%b4%e6%96%b0%e5%92%8c%e5%85%b6%e4%bb%96%e4%b8%8e%e8%bd%a6%e8%be%86%e7%bb%b4%e6%8a%a4%e7%9b%b8%e5%85%b3%e7%9a%84%e6%9c%8d%e5%8a%a1%e3%80%82%0aUDS%e5%8d%8f%e8%ae%ae%e6%a0%88%20UDS%ef%bc%88Unified%20Diagnostic%20Services%ef%bc%89%e5%8d%8f%e8%ae%ae%e6%a0%88%e6%98%af%e5%ae%9e%e7%8e%b0UDS%e5%8d%8f%e8%ae%ae%e5%8a%9f%e8%83%bd%e7%9a%84%e5%88%86%e5%b1%82%e6%9e%b6%e6%9e%84%ef%bc%8c%e7%a1%ae%e4%bf%9d%e6%b1%bd%e8%bd%a6%e7%94%b5%e5%ad%90%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83%ef%bc%88ECU%ef%bc%89%e4%b8%8e%e8%af%8a%e6%96%ad%e5%b7%a5%e5%85%b7%e4%b9%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1%e3%80%82UDS%e5%8d%8f%e8%ae%ae%e6%a0%88%e9%80%9a%e5%b8%b8%e5%8c%85%e6%8b%ac%e4%bb%a5%e4%b8%8b%e5%87%a0%e5%b1%82%ef%bc%9a%0a%e5%ba%94%e7%94%a8%e5%b1%82%ef%bc%88Application%20%e2%80%a6&amp;source=http://localhost:1313/" target="_blank" rel="noopener noreferrer" title="UDS">
      <div class="share-icon icon icon-qq">
        
      </div>
    </a>
  
    <a href="javascript:;"  title="UDS">
      <div class="share-icon icon icon-weixin">
        
          <div id="share-weixin">
            <div class="share-weixin-dom">
              <div class="share-weixin-content">
                <img id="share-weixin-banner"> 
                <div id="share-weixin-title"></div>
                <div id="share-weixin-desc"></div>
              </div>
              <div class="share-weixin-qrcode">
                <div class="share-weixin-info">
                  <div id="share-weixin-author"></div>
                  <div id="share-weixin-theme">Powered By hugo-theme-reimu</div>
                </div>
                <img id="share-weixin-qr" >
              </div>
            </div>
            <div class="share-weixin-canvas"></div>
          </div>
        
      </div>
    </a>
  
</div>
      

      

      

      

      

      
      <ul class="article-tag-list" itemprop="keywords">
  
    <li class="article-tag-list-item" data-aos="zoom-in">
      <a
        class="article-tag-list-link"
        href="/tags/%e9%80%9a%e4%bf%a1%e5%8d%8f%e8%ae%ae"
        rel="tag"
        >通信协议</a
      >
    </li>
  
</ul>

    </footer>
  </div>
  
    
  <nav
    id="article-nav"
    data-aos="fade-up"
  >
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          <img
            data-src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/9_11_51_52_202407091151823.png"
            data-sizes="auto"
            alt="USART"
            class="lazyload"
          />
        
        <a href="http://localhost:1313/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/usart/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            USART
          
        </h3>
      </div>
    

    
      <div class="article-nav-link-wrap article-nav-link-right">
        
          <img
            data-src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/07/5_17_26_23_202407051726672.png"
            data-sizes="auto"
            alt="Timer"
            class="lazyload"
          />
        
        <a href="http://localhost:1313/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/timer/"></a>
        <div class="article-nav-caption">后一篇</div>
        <h3 class="article-nav-title">
          
            Timer
          
        </h3>
      </div>
    
  </nav>


  
</article>










</section>
        </div>
        
        
        



  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



<footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
      2020 -
      2025
      <span class="footer-info-sep rotate"></span>
      TrustMe
    </div>
    
      <div>
        基于&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div>
    
    
      <div>
        <span class="icon-brush"
          >&nbsp;
            59.8k
          </span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;
          
          

          05:12
        </span>
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >总访问量&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >总访客量&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar">
        <div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#不同层的数据格式">不同层的数据格式</a></li>
    <li><a href="#uds协议栈的实现">UDS协议栈的实现</a></li>
  </ul>

  <ul>
    <li><a href="#obdon-board-diagnostic">OBD（On-Board Diagnostic）</a></li>
    <li><a href="#udsunified-diagnostic-services">UDS（Unified diagnostic services）</a></li>
  </ul>

  <ul>
    <li><a href="#service-idsid">Service ID（SID）</a></li>
    <li><a href="#诊断请求">诊断请求</a></li>
    <li><a href="#正负响应">正负响应</a>
      <ul>
        <li><a href="#正响应报文格式">正响应报文格式</a></li>
        <li><a href="#负响应报文格式">负响应报文格式</a></li>
      </ul>
    </li>
    <li><a href="#dtc">DTC</a>
      <ul>
        <li><a href="#dtc结构">DTC结构</a></li>
        <li><a href="#dtc状态">DTC状态</a></li>
        <li><a href="#dtc快照信息">DTC快照信息</a></li>
        <li><a href="#dtc拓展数据信息">DTC拓展数据信息</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#诊断和通信管理类">诊断和通信管理类</a></li>
    <li><a href="#数据传输类">数据传输类</a></li>
    <li><a href="#存储数据传输类">存储数据传输类</a></li>
    <li><a href="#io控制类">IO控制类</a></li>
    <li><a href="#例程功能类-调用ecu内部预置函数">例程功能类-调用ECU内部预置函数</a></li>
    <li><a href="#上传下载类">上传下载类</a></li>
  </ul>

  <ul>
    <li><a href="#0x10诊断会话控制">0x10：诊断会话控制</a>
      <ul>
        <li><a href="#简介-1">简介</a></li>
        <li><a href="#数据包格式">数据包格式</a></li>
        <li><a href="#通信示例">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x11ecu复位">0x11：ECU复位</a>
      <ul>
        <li><a href="#简介-2">简介</a></li>
        <li><a href="#数据包格式-1">数据包格式</a></li>
        <li><a href="#通信示例-1">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x14清除故障码">0x14:清除故障码</a>
      <ul>
        <li><a href="#简介-3">简介</a></li>
        <li><a href="#数据包格式-2">数据包格式</a></li>
        <li><a href="#通信示例-2">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x19读取故障码">0x19：读取故障码</a>
      <ul>
        <li><a href="#简介-4">简介</a></li>
        <li><a href="#常用子功能介绍">常用子功能介绍</a></li>
      </ul>
    </li>
    <li><a href="#0x28通讯控制">0x28：通讯控制</a>
      <ul>
        <li><a href="#简介-5">简介</a></li>
        <li><a href="#数据包格式-8">数据包格式</a></li>
        <li><a href="#通信示例-8">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x27安全访问">0x27：安全访问</a>
      <ul>
        <li><a href="#简介-6">简介</a></li>
        <li><a href="#数据包格式-9">数据包格式</a></li>
        <li><a href="#通信示例-9">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x31例程控制">0x31：例程控制</a>
      <ul>
        <li><a href="#简介-7">简介</a></li>
        <li><a href="#数据包格式-10">数据包格式</a></li>
        <li><a href="#示例">示例</a></li>
      </ul>
    </li>
    <li><a href="#0x34请求下载">0x34：请求下载</a>
      <ul>
        <li><a href="#简介-8">简介</a></li>
        <li><a href="#数据包格式-11">数据包格式</a></li>
      </ul>
    </li>
    <li><a href="#0x36数据传输">0x36：数据传输</a>
      <ul>
        <li><a href="#简介-9">简介</a></li>
        <li><a href="#数据包格式-12">数据包格式</a></li>
      </ul>
    </li>
    <li><a href="#0x37请求退出">0x37：请求退出</a>
      <ul>
        <li><a href="#简介-10">简介</a></li>
        <li><a href="#数据包格式-13">数据包格式</a></li>
        <li><a href="#通信示例-10">通信示例</a></li>
      </ul>
    </li>
    <li><a href="#0x85控制dtc设置">0x85：控制DTC设置</a>
      <ul>
        <li><a href="#简介-11">简介</a></li>
        <li><a href="#数据包格式-14">数据包格式</a></li>
      </ul>
    </li>
    <li><a href="#0x3d通过地址写内存">0x3D：通过地址写内存</a>
      <ul>
        <li><a href="#简介-12">简介</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
      </div>
      <div class="sidebar-common-sidebar hidden">
        
<div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="TrustMe"
    class="lazyload"
  />
  <div class="sidebar-author-name">TrustMe</div>
  <div class="sidebar-description">你要信我啊</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    
    <div class="sidebar-state-number">60</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">7</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-bilibili sidebar-social-icon">
      <a
        href="https://space.bilibili.com/yourname"
        itemprop="url"
        target="_blank"
        aria-label="bilibili"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
    <div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/youShouldTrustMe"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener external nofollow noreferrer"
      ></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="首页"
      ></a>
      <div class='sidebar-menu-icon icon '>
        
          &#xe61b;
        
      </div>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="归档"
      ></a>
      <div class='sidebar-menu-icon icon '>
        
          &#xe623;
        
      </div>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="关于"
      ></a>
      <div class='sidebar-menu-icon icon '>
        
          &#xe621;
        
      </div>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="友链"
      ></a>
      <div class='sidebar-menu-icon icon '>
        
          &#xe639;
        
      </div>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>

      </div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
      <div class="site-search">
        <div class="reimu-popup popup">
          <div class="reimu-search">
            <div class="reimu-search-input-icon"></div>
            <div class="reimu-search-input" id="reimu-search-input"></div>
            <div class="popup-btn-close"></div>
          </div>
          <div class="reimu-results">
            <div id="reimu-stats"></div>
            <div id="reimu-hits"></div>
            <div id="reimu-pagination" class="reimu-pagination"></div>
          </div>
          <img class="reimu-bg" src="/images/reimu.png" />
        </div>
      </div>
    
    






  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"
  ></script>




  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"
  ></script>









  
      
      <script src="/js/main.js" ></script>
      



  





  
      
      <script src="/js/aos.js" ></script>
      

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script>








  
      
      <script src="/js/pjax_main.js" data-pjax></script>
      



  <script>
    var ALGOLIA_CONFIG = {
      logo: '\/images\/algolia_logo.svg',
      algolia: {
        applicationID: "60WEPCQQJ9",
        apiKey: "b3a7464ce9c969570301e3e4287d752e",
        indexName: "",
        hits: {
          "per_page": parseInt("10")
        },
        labels: {
          "input_placeholder": "搜索.....",
          "hits_empty": "未发现与 「${query}」相关内容",
          "hits_stats": "找到${hits}条结果（用时 ${time} ms）"
        }
      }
    };
  </script>
  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/algoliasearch@4.17.1/dist/algoliasearch-lite.umd.js"
    defer
    
    
    
    integrity="sha384-xvLS0jfKuoREs7pqkRI/OI8GcqohO5S&#43;jQz7ZBtQXnsXmD&#43;9jDOOY4cL6dCPzlrk" crossorigin="anonymous"
  ></script>


  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/instantsearch.js@4.56.1/dist/instantsearch.production.min.js"
    defer
    
    
    
    integrity="sha384-hHJCflT4KBLQyHfKO9vpstIcFKn/Y&#43;KHTORelMMEn7mOp2AVPp&#43;7fr03dLgZiV3J" crossorigin="anonymous"
  ></script>


  





  
      
      <script src="/js/algolia_search.js" ></script>
      




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/mouse-firework@0.1.0/dist/index.umd.js"
    
    
    
    
    integrity="sha384-KM6i7tu43nYd6e0beIljxHMC5tZc58XBDu7pPA58w50h18Jsx7gLdimfS09RXlKv" crossorigin="anonymous"
  ></script>


<script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"#ff5252\",\"#ff7c7c\",\"#ffafaf\",\"#ffd0d0\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"#ff0000\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>





<script>
  function initLive2d() {
    live2d.init('https:\/\/fastly.jsdelivr.net\/gh\/D-Sketon\/plugin-live2d\/', {themeTipsPath: ""});
  }
</script> 

  
  
  
  
  
  
  <script
    src="https://fastly.jsdelivr.net/gh/D-Sketon/plugin-live2d/js/live2d-autoload.js"
    
    async
    
    onload="initLive2d()"
    
  ></script>






<div id="lazy-script">
  <div>
    
      
      
        
      
      <script data-pjax>
        window.REIMU_POST = {
          author: "TrustMe",
          title: "UDS",
          url: "http:\/\/localhost:1313\/post\/%E5%B5%8C%E5%85%A5%E5%BC%8F\/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\/uds\/",
          description: " 参考链接 《UDS协议从入门到精通（UDS速查手册）》（完结撒花版）_obdonuds-CSDN博客\n简介 UDS (Unified Diagnostic Services) 是一种标准化的==车辆诊断协议==，广泛应用于汽车电子控制单元（ECU）的诊断和维修。它是ISO 14229标准的一部分，主要用于车辆诊断、故障排除、软件更新和其他与车辆维护相关的服务。\nUDS协议栈 UDS（Unified Diagnostic Services）协议栈是实现UDS协议功能的分层架构，确保汽车电子控制单元（ECU）与诊断工具之间的通信。UDS协议栈通常包括以下几层：\n应用层（Application …",
          cover: "https:\/\/gitlab.com\/18355291538\/picture\/-\/raw\/main\/pictures\/2024\/07\/10_16_55_30_202407101655309.png",
        };
      </script>
    
    
    
      





  
      
      <script src="/js/insert_highlight.js" data-pjax></script>
      

      
      
      
      
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      












      
        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/qrcode@1.4.4/build/qrcode.min.js"
    defer
    
    data-pjax
    
    integrity="sha384-0RsG1yo/crf/1Qc14sho26SXXOTngNCjgJw7fuvXBt9W/OChF/Ijx&#43;aUuBDqQwEk" crossorigin="anonymous"
  ></script>


        

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/html-to-image@1.11.11/dist/html-to-image.js"
    defer
    
    data-pjax
    
    integrity="sha384-UbfRVKN3/elS1r7JcK2FhmPP&#43;KlJ4CvYwbyYD7tH&#43;uTkbT9bNJr9eJeQ0FoFbAgz" crossorigin="anonymous"
  ></script>


      
    
    
  </div>
</div>




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"
  ></script>





  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>


<script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script>




  </body>
</html>
