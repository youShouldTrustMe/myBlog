<!doctype html>
<html
  lang="zh-cn" 
  
    data-theme-mode="auto"
  
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>







  

<title>
  Bluetooth | TrustMe
</title>
<meta
  name="description"
  content="你要信我啊"
/>










<script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"clipboard\":{\"copyright\":{\"content\":\"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\",\"count\":50,\"enable\":false},\"fail\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"success\":\"复制成功(*^▽^*)\"},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_0khxww3tj3q9\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":\"本文最后更新于 {time}，请注意文中内容可能已经发生变化。\"}}");
</script>











  
  
  
    
  

  
  
  
    
  

  
    

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>






  <link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_0khxww3tj3q9.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  />



  






 <link rel="stylesheet" href="/css/loader.css" />




  <meta property="og:type" content="website" />
  <meta property="og:title" content="Bluetooth | TrustMe" />
  <meta
    property="og:description"
    content="你要信我啊"
  />
  <meta property="og:url" content="http://localhost:1313/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/bluetooth/" />
  <meta
    property="og:site_name"
    content="TruestMe&#39;s Blog"
  />
  <meta
    property="og:image"
    content="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_8_59_202412091408388.png"
  />
  <meta property="article:author" content="TrustMe" />
  <meta property="article:published_time" content="2025-03-01T00:00:00&#43;00:00" />
  <meta property="article:modified_time" content="2025-03-01T00:00:00&#43;00:00" />
  
    <meta property="article:tag" content="通信协议" />
  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_8_59_202412091408388.png" />
  
  
  
  
  




<link rel="shortcut icon" href="/favicon.ico">







 <link rel="stylesheet" href="/css/main.css" />





  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />






  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />








  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"
  ></script>





  


  <link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" />





  </head>
  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff5252" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="#ff5252" />
          </svg>
        
      </div>
      <div class="loading-word">你要信我啊...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        
<div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="/">首页</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="/archives">归档</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="/about">关于</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="/friend">友链</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
      <a id="nav-search-btn" class="nav-icon popup-trigger" title="搜索"></a>
    
  </nav>
</div>
<header id="header">
  
    
    <picture></picture>
      <img fetchpriority="high" src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_8_59_202412091408388.png" alt="Bluetooth">
    
  

  <div id="header-outer">
    <div id="header-title">
      
        
        
          
        
  
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">Bluetooth</h1>
          </a>
        
      
  
      
        
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>
        <div id="content"
          
          class="sidebar-right"  >
          <aside id="sidebar">
  
  
  <div class="sidebar-wrapper wrap-sticky">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    >
      
        <div class="sidebar-toc-sidebar">
          <div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#名称由来">名称由来</a></li>
    <li><a href="#发展历史">发展历史</a></li>
    <li><a href="#技术特点">技术特点</a></li>
    <li><a href="#系统组成">系统组成</a></li>
    <li><a href="#蓝牙协议规范">蓝牙协议规范</a></li>
    <li><a href="#硬件接口">硬件接口</a></li>
    <li><a href="#协议栈">协议栈</a></li>
  </ul>

  <ul>
    <li><a href="#广播方式">广播方式</a></li>
    <li><a href="#连接方式">连接方式</a></li>
    <li><a href="#封包过程">封包过程</a>
      <ul>
        <li><a href="#广播方式-1">广播方式</a></li>
        <li><a href="#连接方式-1">连接方式</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#ll">LL</a>
      <ul>
        <li><a href="#广播信道">广播信道</a></li>
        <li><a href="#数据信道">数据信道</a></li>
      </ul>
    </li>
    <li><a href="#gap">GAP</a></li>
    <li><a href="#l2cap">L2CAP</a>
      <ul>
        <li><a href="#cid-的取值范围">CID 的取值范围</a></li>
        <li><a href="#cid-的使用场景">CID 的使用场景</a></li>
        <li><a href="#cid-的分配过程"><strong>CID 的分配过程</strong></a></li>
      </ul>
    </li>
    <li><a href="#attgatt">ATT/GATT</a>
      <ul>
        <li><a href="#uuid">UUID</a></li>
        <li><a href="#handle">Handle</a></li>
      </ul>
    </li>
    <li><a href="#hci">HCI</a></li>
    <li><a href="#smp">SMP</a>
      <ul>
        <li><a href="#常见的code">常见的code</a></li>
        <li><a href="#不同的data格式">不同的data格式</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#广播">广播</a></li>
    <li><a href="#扫描请求和扫描响应">扫描请求和扫描响应</a></li>
    <li><a href="#建立连接">建立连接</a></li>
    <li><a href="#连接事件">连接事件</a></li>
    <li><a href="#配对和绑定">配对和绑定</a>
      <ul>
        <li><a href="#配对特征交换">配对特征交换</a></li>
        <li><a href="#密钥生成">密钥生成</a></li>
        <li><a href="#配对方法">配对方法</a></li>
        <li><a href="#分发密钥">分发密钥</a></li>
      </ul>
    </li>
    <li><a href="#数据传输">数据传输</a></li>
    <li><a href="#连接失败">连接失败</a></li>
    <li><a href="#gap角色">GAP角色</a></li>
  </ul>

  <ul>
    <li><a href="#传输协议">传输协议</a>
      <ul>
        <li><a href="#射频协议">射频协议</a></li>
        <li><a href="#基带与链路控制协议">基带与链路控制协议</a></li>
        <li><a href="#链路管理器">链路管理器</a></li>
      </ul>
    </li>
    <li><a href="#中介协议">中介协议</a>
      <ul>
        <li><a href="#主机控制接口协议hci">主机控制接口协议（HCI）</a></li>
        <li><a href="#逻辑链路控制与适配协议l2cap">逻辑链路控制与适配协议（L2CAP）</a></li>
        <li><a href="#服务发现协议sdp">服务发现协议（SDP）</a></li>
        <li><a href="#串口仿真协议rfcomm">串口仿真协议（RFCOMM）</a></li>
      </ul>
    </li>
    <li><a href="#应用协议">应用协议</a>
      <ul>
        <li><a href="#irda互操作协议">IrDA互操作协议</a></li>
        <li><a href="#音频与电话控制协议">音频与电话控制协议</a></li>
        <li><a href="#网络封装协议bnep">网络封装协议（BNEP）</a></li>
        <li><a href="#音频分发协议avdtp">音频分发协议（AVDTP）</a></li>
        <li><a href="#音视频控制传输协议avctp">音视频控制传输协议（AVCTP）</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
        </div>
        <div class="sidebar-common-sidebar hidden">
          
<div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="TrustMe"
    class="lazyload"
  />
  <div class="sidebar-author-name">TrustMe</div>
  <div class="sidebar-description">你要信我啊</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    
    <div class="sidebar-state-number">59</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">7</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="首页"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="归档"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="关于"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="友链"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>

        </div>
      

      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  <div class="sidebar-widget">
    
  </div>
</aside>

          <section id="main">
  <article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta">
      <div class="article-date">
  <span
    class="article-date-link"
    data-aos="zoom-in"
  >
    <time datetime="2025-03-01 00:00:00 &#43;0000 UTC" itemprop="datePublished"
      >2025-03-01</time
    >
    <time style="display: none;" id="post-update-time"
      >2025-03-01</time
    >
  </span>
</div>

      <div class="article-category">
  
</div>

    </div>
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="参考链接">
<a class="header-anchor" href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5"></a>
参考链接
</h1><p><a href="https://blog.csdn.net/lanhuazui10/article/details/144194112">深入浅出低功耗蓝牙(BLE)协议栈及蓝牙连接过程_蓝牙芯片的寄存器组为什么需要分为两块-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/xubin341719/article/details/38145507?spm=1001.2014.3001.5502">蓝牙核心技术概述（一）:蓝牙概述_蓝牙技术-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/xubin341719/article/details/38303881?spm=1001.2014.3001.5502">蓝牙核心技术概述（三）： 蓝牙协议规范（射频、基带链路控制、链路管理）_蓝牙3.0技术规范-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/xubin341719/article/details/38305331">蓝牙核心技术概述（四）：蓝牙协议规范（HCI、L2CAP、SDP、RFOCMM）_蓝牙通信帧分类-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/xubin341719/article/details/38335533">蓝牙核心技术概述（五）：蓝牙协议规范（irOBEX、BNEP、AVDTP、AVCTP）_蓝牙核心bnep-CSDN博客</a></p>
<p><a href="http://www.giraffexiu.love/index.php/2024/10/22/ble%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/">BLE协议学习 – 学习笔记 (giraffexiu.love)</a></p>
<p><a href="https://www.bilibili.com/opus/697239519074713670">ESP32教程第二章讲义 - 哔哩哔哩 (bilibili.com)</a></p>
<p><a href="http://rfc.nop.hu/bluetooth/AssignedNumbersGenericAccessProfile.pdf">Bluetooth.org - Generic Access Profile (nop.hu)</a></p>
<p><a href="https://www.bluetooth.com/specifications/specs/core-specification-6-0/">Core Specification | Bluetooth® Technology Website</a></p>
<p><a href="https://www.bluetooth.com/specifications/assigned-numbers/">Assigned Numbers | Bluetooth® Technology Website</a></p>
<p><a href="https://blog.csdn.net/zzfenglin/article/details/51303211">低功耗蓝牙BLE之连接建立_低功耗蓝牙的连接过程-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/zzfenglin/article/details/51304084">低功耗蓝牙BLE之连接事件、连接参数和更新方法_蓝牙设备为什么拼命发包-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/yxyy3604/article/details/112857135">蓝牙配对安全机制解析：防止中间人与被动监听攻击-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/lim11/p/11158153.html">深入理解低功耗蓝牙的配对过程- Part 1 Pairing Feature Exchange - SZ_LM - 博客园</a></p>
<p><a href="https://www.cnblogs.com/lim11/p/11168601.html">深入理解低功耗蓝牙的配对过程- Part 2 Key Generation Methods - SZ_LM - 博客园</a></p>
<p><a href="https://www.cnblogs.com/iini/p/12801242.html">低功耗蓝牙配对绑定解读和实践 - iini - 博客园</a></p>
<p><a href="https://blog.csdn.net/qwe5959798/article/details/134310315">蓝牙安全管理(SM:Security Manager)规范详解_蓝牙csrk-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/guoqx/article/details/132841376">蓝牙 - 什么是Man-in-the-middle protection_蓝牙中间人攻击-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/strtoul/article/details/138186417">了解低功耗蓝牙中的安全密钥_irk ltk-CSDN博客</a></p>
<h1 id="传输原理">
<a class="header-anchor" href="#%e4%bc%a0%e8%be%93%e5%8e%9f%e7%90%86"></a>
传输原理
</h1><!-- raw HTML omitted -->
<p>蓝牙的传输频率是2.4GHZ，也就是说一秒钟之内蓝牙信号可以改变24亿次。</p>
<p>蓝牙的通信模式有两种：</p>
<ol>
<li>
<p>经典蓝牙：一帧数据包有357个字节</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_1_45_202412091401409.png" alt="经典蓝牙报文帧"></p>
<ol>
<li>
<p>前9字节是访问地址用于区分不同的蓝牙设备</p>
</li>
<li>
<p>标头是确保数据的可靠性和稳定性</p>
</li>
<li>
<p>可以承载0-399字节的数据位，不同的报文会承载不同长度的数据</p>
</li>
<li>
<p>最后两字节用于CRC校验，用于校验一帧数据的正确性</p>
</li>
</ol>
</li>
<li>
<p>低功耗蓝牙：一帧数据包有261个字节</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_6_0_202412091406390.png" alt="低功耗蓝牙数据报文"></p>
<ol>
<li>第一个字节是预补码，用于时钟同步和信道估计</li>
<li>后四个字节是访问地址，用于区分不同的蓝牙设备</li>
<li>2-253字节的数据位</li>
<li>最后三个字节用于CRC校验</li>
</ol>
</li>
</ol>
<p>实际上，蓝牙通过高频信号和低频信号来表达0和1</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_8_59_202412091408388.png" alt="载波信号"></p>
<p>所以说，虽然蓝牙的通信协议的频率为2.4GHZ，但是实际上蓝牙的传输速率最快也就是3MB/S</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_10_51_202412091410028.png" alt="调制解调蓝牙信号"></p>
<p>所以说蓝牙需要两种频率才能传输数据，2.4GHz只是一个大概频率，蓝牙利用的是高斯频移键控（Gaussian Frequency Shift Keying ，GFSK）技术。</p>
<p>低功耗蓝牙的GFSK的偏移量一般为$\pm$185KHz，首先确定一个中心频率，比如中心频率为2.402GHz，那么</p>
<ol>
<li>逻辑1是在中心频率的基础上加185KHz</li>
<li>逻辑0是在中心频率的基础上减185KHz</li>
</ol>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_20_8_202412091420580.png" alt="电平表示"></p>
<p>但是在同一个空间中，所有的蓝牙都是使用的是2.402GHz作为中心频率，那么蓝牙的通信不就是全乱的吗，实际上并不会。</p>
<p>蓝牙采用了多信道通信，如低功耗蓝牙有40个信道，信道范围从2.402GHz到2.480GHz，每个信道的间隔是==2MHz==。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_23_27_202412091423825.png" alt="信道演示"></p>
<p>比如在2.402GHz内通信，那么它实际传输的就是刚刚通过GFSK计算的频率，经典蓝牙的每个信道的间隔是==1MHz==，并且他们会频繁的在不同的信道之间开始通信，一秒之内可以达到上百次跳频</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_29_25_202412091429310.png" alt="不同蓝牙的信道数量"></p>
<h1 id="概述">
<a class="header-anchor" href="#%e6%a6%82%e8%bf%b0"></a>
概述
</h1><h2 id="名称由来">
<a class="header-anchor" href="#%e5%90%8d%e7%a7%b0%e7%94%b1%e6%9d%a5"></a>
名称由来
</h2><p>蓝牙这个名称来自于第十世纪的一位丹麦国王哈洛德·布美塔特（（Harald Blåtand），丹麦语的Blåtand翻译成英语就是 Bluetooth，因此这位国王又叫哈拉尔蓝牙王（Harald Bluetooth）。因为国王喜欢吃蓝莓，牙龈每天都是蓝色的所以叫蓝牙。<strong>蓝牙的标志是一个结合符文，它融合了卢恩字母（古北欧人使用的一类字母，现已灭绝）中的H（ᚼ）和B（ᛒ）符文，同时也是哈拉尔国王名字的首字母缩写。</strong></p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_14_50_20_202412091450861.png" alt="蓝牙logo"></p>
<p>在行业协会筹备阶段，需要一个极具有表现力的名字来命名这项高新技术。行业组织人员，在经过一夜关于欧洲历史和未来无线技术发展的讨论后，有些人认为用Blatand国王的名字命名再合适不过了。Blatand国王将挪威，瑞典和丹麦统一起来；他的口齿伶俐,善于交际,就如同这项即将面世的技术，技术将被定义为允许不同工业领域之间的协调工作，保持着各个系统领域之间的良好交流，例如计算机，手机和汽车行业之间的工作。</p>
<h2 id="发展历史">
<a class="header-anchor" href="#%e5%8f%91%e5%b1%95%e5%8e%86%e5%8f%b2"></a>
发展历史
</h2><ol>
<li>1994年爱立信公司研发；</li>
<li>1997年爱立信联系其他设备生产商；</li>
<li>1998年二月，诺基亚、苹果、三星组成的一个特殊兴趣小组SIG(Special Interest Group)；</li>
<li>1998年5月，爱立信、诺基亚、东芝、IBM和英特尔公司等五家著名厂商，联合开发；</li>
<li>1999年下半年，微软、摩托罗拉、三星、朗讯等主流设备商广泛推广蓝牙技术应用；</li>
<li>2006年10月13日，Bluetooth SIG（蓝牙技术联盟）发展到200多家联盟成员公司以及约6000家应用成员企业。</li>
</ol>
<h2 id="技术特点">
<a class="header-anchor" href="#%e6%8a%80%e6%9c%af%e7%89%b9%e7%82%b9"></a>
技术特点
</h2><ol>
<li>工作频段：2.4GHz（ISM）频段，无需申请许可证。大多数国家使用79个频点，载频为(2402+k)MHz（k=0，1, 2…78），载频间隔1MHz。采用TDD时分双工方式。</li>
<li>传输速率：1Mb/s（V2.0以上版本）</li>
<li>调试方式：BT=0.5的GFSK调制，调制指数为0.28-0.35。</li>
<li>采用跳频技术：跳频速率为1600跳/秒，在建链时（包括寻呼和查询）提高为3200跳/秒。蓝牙通过快跳频和短分组技术减少同频干扰，保证传输的可靠性。</li>
<li>语音调制方式：连续可变斜率增量调制（CVSD，ContinuousVariable Slope Delta Modulation），抗衰落性强，即使误码率达到4%，话音质量也可接受。</li>
<li>支持电路交换和分组交换业务：蓝牙支持实时的同步定向联接（SCO链路）和非实时的异步不定向联接（ACL链路），前者主要传送语音等实时性强的信息，后者以数据包为主。语音和数据可以单独或同时传输。蓝牙支持一个异步数据通道，或三个并发的同步话音通道，或同时传送异步数据和同步话音的通道。每个话音通道支持64kbps的同步话音；异步通道支持723.2/57.6kbps的非对称双工通信或433.9kbps的对称全双工通信。</li>
<li>支持点对点及点对多点通信：蓝牙设备按特定方式可组成两种网络：微微网(Piconet)和分布式网络(Scatternet)，其中微微网的建立由两台设备的连接开始，最多可由八台设备组成。在一个微微网中，只有一台为主设备（Master），其它均为从设备（Slave），不同的主从设备对可以采用不同的链接方式，在一次通信中，链接方式也可以任意改变。几个相互独立的微微网以特定方式链接在一起便构成了分布式网络。所有的蓝牙设备都是对等的，所以在蓝牙中没有基站的概念。</li>
<li>工作距离：蓝牙设备分为三个功率等级，分别是：100mW（20dBm）、2.5mW（4dBm）和1mW（0dBm），相应的有效工作范围为：100米、10米和1米。</li>
</ol>
<h2 id="系统组成">
<a class="header-anchor" href="#%e7%b3%bb%e7%bb%9f%e7%bb%84%e6%88%90"></a>
系统组成
</h2><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_13_44_8_202412111344891.png" alt="蓝牙协议系统组成"></p>
<ol>
<li>
<p>应用程序（Application）</p>
<ul>
<li>应用程序层位于蓝牙协议栈的顶层</li>
<li>直接与用户交互和上层应用程序进行通信（定义了蓝牙设备的具体功能和应用，如文件传输、音频/视频传输、设备控制等）</li>
<li>应用程序层向高层协议（如FTP、HFP、A2DP等）提供服务，转换用户需求为协议栈可以处理的操作指令</li>
</ul>
</li>
<li>
<p>高层协议（Higher Layer Protocols）</p>
<p>高层协议位于应用程序层之下（负责定义和管理特定的应用通信协议）</p>
<ul>
<li>FTP（File Transfer Protocol）：用于文件传输</li>
<li>HFP（Hands-Free Profile）：用于蓝牙耳机和车载电话的通话控制</li>
<li>A2DP（Advanced Audio Distribution Profile）：用于高质量音频传输</li>
<li>AVRCP（Audio/Video Remote Control Profile）：用于远程控制音视频设备</li>
<li>OPP（Object Push Profile）：用于简单对象的传输</li>
</ul>
</li>
<li>
<p>主机控制接口（HCI，Host Controller Interface）</p>
<ul>
<li>HCI是主机软件与蓝牙硬件控制器之间的接口协议（定义了主机与控制器之间的命令和事件传输机制，使主机能够向控制器发送控制命令，如设备初始化、连接管理、链路状态查询等）</li>
<li>控制器通过HCI向主机报告事件，如连接状态改变、数据接收等</li>
</ul>
</li>
<li>
<p>主机控制（Host Control）</p>
<p>主机控制层位于蓝牙协议栈中主机端的核心部分，负责协调和管理整个协议栈的运行</p>
<p>接收来自应用程序层的请求，通过HCI与蓝牙控制器进行通信，并处理各种协议的状态管理和数据传输控制</p>
</li>
<li>
<p>链路管理(Link Manager)</p>
<p>链路管理层负责管理蓝牙设备之间的连接建立、维护和释放</p>
<ul>
<li>连接请求和响应：处理设备之间的连接请求，协商连接参数</li>
<li>链路质量管理：监测和维护连接的质量，包括信号强度、误码率等</li>
<li>能量管理：优化设备的电源消耗，通过动态调整传输功率和时钟频率来降低能耗</li>
</ul>
</li>
<li>
<p>蓝牙音频（Audio）</p>
<p>蓝牙音频层专门用于音频数据的传输和处理（音频数据的编解码方式、传输格式和同步机制，使得蓝牙设备能够支持高质量音频的无线传输，如音乐播放、电话通话）</p>
</li>
<li>
<p>基带或链路控制单元(Link Controller)</p>
<p>负责管理和控制蓝牙通信中的基础数据链路（蓝牙协议栈的核心部分之一）</p>
<ul>
<li>数据包的生成和解析：定义数据包的格式和结构</li>
<li>错误检测与纠正：通过CRC（循环冗余校验）等方法检测和纠正数据传输中的错误</li>
<li>链路管理：协调和管理设备之间的连接，包括连接的建立、维护和断开</li>
</ul>
</li>
<li>
<p>无线射频单元(Radio)</p>
<p>射频层是蓝牙协议栈的最底层，负责实际的无线通信</p>
<ul>
<li>物理层和调制解调器（控制射频信号的发送和接收）</li>
<li>射频层使用频率跳跃扩频技术（FHSS），在2.4GHz ISM频段内工作，以提高通信稳定性和抗干扰能力</li>
</ul>
</li>
</ol>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_13_44_48_202412111344470.png" alt="蓝牙细节"></p>
<h2 id="蓝牙协议规范">
<a class="header-anchor" href="#%e8%93%9d%e7%89%99%e5%8d%8f%e8%ae%ae%e8%a7%84%e8%8c%83"></a>
蓝牙协议规范
</h2><ol>
<li>
<p>传输协议</p>
<p>负责蓝牙设备间，互相确认对方的位置，以及建立和管理蓝牙设备间的物理链路；</p>
<ul>
<li>底层传输协议： 蓝牙射频（Radio）部分、基带链路管理控制器（Baseband&amp;Link Controller）、链路管理协议（Link Manager Protocol LMP）。负责语言、数据无线传输的物理实现以及蓝牙设备间的联网组网。</li>
<li>高层传输协议： 逻辑链路控制与适配器（Logical Link Control and Adaptation Protocol）L2CAP 、主机控制接口（Host Control Interface，HCI）。为高层应用屏蔽了跳频序列选择等底层传输操作，为高层程序提供有效、有利于实现数据分组格式。</li>
</ul>
</li>
<li>
<p>中介协议</p>
<p>为高层应用协议或者程序，在蓝牙逻辑链路上工作提供必要的支持，为应用提供不同标准接口。</p>
<ul>
<li>串口仿真协议：RFCOMM</li>
<li>服务发现协议：SDP</li>
<li>互操作协议：IrDA</li>
<li>网络访问协议：PPP、IP、TCP、UDP</li>
<li>电话控制协议：TCS、AT指令集。</li>
</ul>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_13_50_58_202412111350260.png" alt="image-20241211135058152"></p>
</li>
<li>
<p>应用协议</p>
<p>蓝牙协议栈之上的应用软件和所涉及到的协议，如：拨号上网、语言功能的应用程序。蓝牙的应用框架如下：</p>
<ol>
<li>通用应用类框架：提供基本的服务发现、连接建立和数据传输功能</li>
<li>蓝牙电话应用类框架：支持电话控制和语音通信功能</li>
<li>蓝牙连网应用类框架：支持蓝牙设备与互联网的连接和数据交换</li>
<li>对象交互服务类框架：支持与其他设备（如IrDA设备）之间的对象交换协议（OBEX）</li>
<li>蓝牙音视频控制类框架：支持音频和视频设备的远程控制和数据传输</li>
</ol>
</li>
</ol>
<h2 id="硬件接口">
<a class="header-anchor" href="#%e7%a1%ac%e4%bb%b6%e6%8e%a5%e5%8f%a3"></a>
硬件接口
</h2><p>一般蓝牙芯片通过UART、USB、SDIO、I2S、PcCard和主控芯片通信。如下图所示，通过UART和主控芯片通信。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_14_30_41_202412111430619.png" alt="硬件接口"></p>
<h2 id="协议栈">
<a class="header-anchor" href="#%e5%8d%8f%e8%ae%ae%e6%a0%88"></a>
协议栈
</h2><blockquote>
<p>[!note]</p>
<p>下面以BLE（低功耗蓝牙）为例</p></blockquote>
<p>协议栈如下图所示：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_14_38_39_202412131438642.png" alt="蓝牙协议栈"></p>
<p>如上图所述，要实现一个BLE应用，首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后在协议栈上开发自己的应用。可以看出BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。</p>
<p>那BLE协议栈具体包含哪些功能呢？简单来说，BLE协议栈主要用来对你的应用数据进行<strong>层层封包</strong>，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。具体来说，BLE协议栈主要由如下几部分组成：</p>
<ul>
<li>PHY<strong>层</strong>（Physical layer物理层）。PHY层用来指定BLE所用的无线频段，调制解调方式和方法等。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。</li>
<li>LL<strong>层</strong>（Link Layer链路层）。LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。像Nordic的BLE协议栈能同时支持20个link（连接），就是LL层的功劳。LL层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者GATT。</li>
<li>HCI（Host controller interface）。HCI是可选的（<a href="http://www.cnblogs.com/iini/p/8834970.html">具体请参考文章： 三种蓝牙架构实现方案（蓝牙协议栈方案）</a>），HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。</li>
<li>GAP<strong>层</strong>（Generic access profile）。GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。</li>
<li>L2CAP<strong>层</strong>（Logic link control and adaptation protocol）。L2CAP对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。</li>
<li>SMP（Secure manager protocol）。SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。</li>
<li><strong>ATT</strong>（Attribute protocol）。简单来说，ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE协议栈中，开发者接触最多的就是ATT。<strong>BLE引入了attribute概念，用来描述一条一条的数据</strong>。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。</li>
<li><strong>GATT</strong>（Generic attribute profile ）。GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品。</li>
</ul>
<h1 id="发送方式">
<a class="header-anchor" href="#%e5%8f%91%e9%80%81%e6%96%b9%e5%bc%8f"></a>
发送方式
</h1><blockquote>
<p>[!note]</p>
<p>假设有设备A和设备B，设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B，该怎么做呢？</p></blockquote>
<p>作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的API就能完成这件事，比如send(0x53)，实际上我们的BLE协议栈就是这样设计的，开发者只需调用send(0x53)就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去，就如下图所示：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_15_21_43_202412131521020.png" alt="物理层发送"></p>
<p>这种方式初看起来挺美的，但由于很多细节没有考虑到，实际是不可行的。</p>
<ol>
<li>首先，它没有考虑用哪一个射频信道来进行传输，在不更改API的情况下，我们只能对协议栈进行分层，为此引入LL层，开发者还是调用send(0x53)，send(0x53)再调用send_LL(0x53,2402M)（注：2402M为信道频率）。</li>
<li>这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入==access address==概念，用来指明接收者身份，其中，<code>0x8E89BED6</code>这个access address比较特殊，它表示要发给周边所有设备，即广播。</li>
<li>如果你要一对一的进行通信（BLE协议将其称为<strong>连接</strong>），即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须生成一个独特的<strong>随机</strong>access address以标识设备A和设备B两者之间的连接。</li>
</ol>
<h2 id="广播方式">
<a class="header-anchor" href="#%e5%b9%bf%e6%92%ad%e6%96%b9%e5%bc%8f"></a>
广播方式
</h2><p>低功耗蓝牙工作在2.4GHz频段，频率范围为 2402MHz – 2480 MHz，每2MHz一个信道，共40个信道，其中为3个广播信道，剩余的37为个数据信道。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/01/6_11_21_59_202501061121777.png" alt="广播通道"></p>
<blockquote>
<p>[!tip]</p>
<p>之所以会选择相距很远的通道，是为了防止干扰</p></blockquote>
<p>我们先来看一下简单的广播情况，这种情况下，我们把设备A叫<strong>advertiser</strong>（广播者），设备B叫<strong>scanner</strong>或者<strong>observer</strong>（扫描者）。</p>
<ol>
<li>广播状态下设备A的LL层API将变成send_LL(0x53,2402M, 0x8E89BED6)。</li>
<li>由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的device address（0xE1022AAB753B）以确认该广播包来自设备A，为此send_LL参数需要变成(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)。</li>
<li>LL层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入CRC24对数据包进行检验 (假设为0xB2C78E) 。</li>
<li>同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble（前导帧），preamble一般为0x55或者0xAA。这样，整个空中包就变成（注：<strong>空中包用小端模式表示！</strong>）：<code>AAD6BE898E3B75AB2A02E1538EC7B2</code></li>
</ol>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_15_59_9_202412131559898.png" alt="广播发送"></p>
<p>上面这个数据包还有如下问题：</p>
<ol>
<li>没有对数据包进行分类组织，设备B无法找到自己想要的数据0x53。为此我们需要<strong>在access address之后加入两个字段：LL header和长度字节</strong>。LL header用来表示数据包的LL类型，长度字节用来指明payload的长度</li>
<li>设备B什么时候开启射频窗口以接收空中数据包？如上图case1所示，当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；同样对case2来说，当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有case3的情况，通信才能成功，即设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，LL层还必须定义通信时序。</li>
<li>当设备B拿到数据0x53后，该如何解析这个数据呢？它到底表示湿度还是电量，还是别的意思？这个就是GAP层要做的工作，<strong>GAP层引入了LTV（Length-Type-Value）结构来定义数据</strong>，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值。由于==广播包最大只能为31个字节==，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，只能使用<strong>供应商自定义数据类型0xFF，即04FF590053</strong>，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。</li>
</ol>
<p>最终空中传输的数据包将会变成：</p>
<p><code>AA D6BE898E 60 0E 3B75AB2A02E1 020105 04FF5900 53 8EC7B2</code></p>
<ul>
<li>AA – 前导帧(preamble)</li>
<li>D6BE898E – 访问地址(access address)</li>
<li>60 – LL帧头字段(LL header)</li>
<li>0E – 有效数据包长度(payload length)</li>
<li>3B75AB2A02E1 – 广播者本身的设备地址(advertiser address)</li>
<li>02010504FF5900<strong>53 –</strong> <strong>广播数据（LTV结构数据+供应商自定义数据+广播发送的真正数据）</strong></li>
<li>8EC7B2 – CRC24校验值</li>
</ul>
<p>有了PHY，LL和GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：</p>
<ol>
<li>无法进行一对一双向通信 （广播是一对多通信，而且是单方向的通信）</li>
<li>由于不支持组包和拆包，因此无法传输大数据</li>
<li>通信不可靠及效率低下。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) /38(2426MHz) /39(2480MHz)三个信道进行广播和扫描，因此==广播不支持跳频==。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。</li>
<li>扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37/38/39三个通道进行扫描，这样功耗就会比较高。</li>
</ol>
<h2 id="连接方式">
<a class="header-anchor" href="#%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f"></a>
连接方式
</h2><p>到底什么叫连接(connection)？像有线UART，很容易理解，就是用线（Rx和Tx等）把设备A和设备B相连，即为连接。用“线”把两个设备相连，实际是让2个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，所谓设备A和设备B建立蓝牙连接，就是指设备A和设备B<strong>两者一对一“同步”成功</strong>，其具体包含以下几方面：</p>
<ul>
<li>
<p>设备A和设备B对接下来要使用的物理信道达成一致</p>
</li>
<li>
<p>设备A和设备B双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点</p>
</li>
<li>
<p>设备A和设备B两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包</p>
</li>
<li>
<p>连接成功后，设备A和设备B通信流程如下所示：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_16_52_28_202412131652198.png" alt="连接方式的发送数据"></p>
</li>
</ul>
<p>如上图所示，一旦设备A和设备B连接成功（此种情况下，我们把设备A称为<strong>Master</strong>或者<strong>Central</strong>，把设备B称为<strong>Slave</strong>或者<strong>Peripheral</strong>），设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包。同时按照蓝牙spec要求，设备B收到设备A数据包150us<strong>后</strong>，设备B切换到发送状态，把自己的数据发给设备A；设备A则切换到接收状态，接收设备B发过来的数据。由此可见，连接状态下，设备A和设备B的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大降低系统功耗并大大提高系统效率。</p>
<p>现在我们看看连接状态下是如何把数据0x53发送出去的，从中大家可以体会到<a href="https://so.csdn.net/so/search?q=%e8%93%9d%e7%89%99%e5%8d%8f%e8%ae%ae%e6%a0%88&amp;spm=1001.2101.3001.7020">蓝牙协议栈</a>分层的妙处。</p>
<p>以下是数据一层层封装的过程</p>
<ul>
<li>
<p>对开发者来说，很简单，他只需要调用send(0x53)</p>
</li>
<li>
<p>GATT层定义数据的类型和分组，方便起见，我们用0x0013表示电量这种数据类型，这样GATT层把数据打包成130053（<strong>小端模式</strong>！）</p>
</li>
<li>
<p>ATT层用来选择具体的通信命令，比如读/写/notify通知/indicate等，这里选择<strong>notify命令0x1B</strong>，这样数据包变成了：1B130053</p>
</li>
<li>
<p>L2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定<strong>逻辑通道编号0004（表示ATT命令）</strong>，最后把<strong>ATT数据长度0x0004</strong>加在包头，这样数据就变为：040004001B130053</p>
</li>
<li>
<p>LL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个Access address</p>
<p>（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：</p>
<ul>
<li>AAAB5D65501E08040004001B130053D550F6
<ul>
<li>AA – 前导帧(preamble)</li>
<li>0x50655DAB – 访问地址(access address)</li>
<li>1E – LL帧头字段(LL header)</li>
<li>08 – 有效数据包长度(payload length)</li>
<li>04000400 – ATT数据长度，以及L2CAP通道编号</li>
<li>1B – notify command</li>
<li>0x0013 – 电量数据handle</li>
<li>0x53 – 真正要发送的电量数据</li>
<li>0xF650D5 – CRC24值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>虽然开发者只调用了 send(0x53)，但由于低功耗蓝牙协议栈层层打包，最后空中实际传输的数据将变成下图所示的模样，这就既满足了低功耗蓝牙通信的需求，又让用户API变得简单，可谓一箭双雕！</p>
<p><img src="https://i-blog.csdnimg.cn/img_convert/ab71a8ff58c198b8353bd06c7d661d11.png" alt="img"></p>
<h2 id="封包过程">
<a class="header-anchor" href="#%e5%b0%81%e5%8c%85%e8%bf%87%e7%a8%8b"></a>
封包过程
</h2><p>假设现在要发送<code>0x53</code>，以下是封包的过程：</p>
<h3 id="广播方式-1">
<a class="header-anchor" href="#%e5%b9%bf%e6%92%ad%e6%96%b9%e5%bc%8f-1"></a>
广播方式
</h3><p>封包过程中走了以下协议：<em>==应用层&gt;GAP层&gt;LL层&gt;物理层==</em></p>
<p>==应用层==</p>
<ul>
<li>数据：<code>0x53</code></li>
<li>广播参数：
<ul>
<li>广播类型：可连接的非定向广播（ADV_IND）。</li>
<li>广播设备地址：<code>0xAABBCCDDEEFF</code>（假设为公共地址）。</li>
<li>广播数据：包含 <code>0x53</code>。</li>
</ul>
</li>
</ul>
<p>==GAP 层==</p>
<ul>
<li>
<p>将 <code>0x53</code> 封装到广播数据中。</p>
</li>
<li>
<p>广播数据格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Length</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">AD</span> <span class="n">Type</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">AD</span> <span class="n">Data</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div></li>
<li>
<p>假设使用自定义的 AD Type（例如 <code>0xFF</code> 表示厂商自定义数据）。</p>
</li>
<li>
<p>广播数据示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Length = 2 | AD Type = 0xFF | AD Data = 0x53 |
</span></span></code></pre></div></li>
<li>
<p><strong>广播数据</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">02 FF 53
</span></span></code></pre></div></li>
</ul>
<p>==LL 层==</p>
<ul>
<li>
<p>广播信道 PDU 格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Header</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Payload</span> <span class="p">(</span><span class="mi">6</span><span class="o">-</span><span class="mi">37</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div></li>
<li>
<p><strong>Header 字段</strong>：</p>
<ul>
<li>PDU Type：<code>0000</code>（ADV_IND，可连接的非定向广播）。</li>
<li>RFU：<code>0</code>。</li>
<li>ChSel：<code>1</code>（支持信道选择算法）。</li>
<li>TxAdd：<code>0</code>（公共地址）。</li>
<li>RxAdd：<code>0</code>（公共地址）。</li>
<li>Length：<code>9</code>（Payload 长度为 9 字节）。</li>
</ul>
</li>
<li>
<p><strong>Payload 字段</strong>：</p>
<ul>
<li>AdvA：<code>AA BB CC DD EE FF</code>（广播设备地址）。</li>
<li>AdvData：<code>02 FF 53</code>（广播数据）。</li>
</ul>
</li>
<li>
<p><strong>封装后的广播信道 PDU</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Header = 0x40 0x09 | AdvA = 0xAA 0xBB 0xCC 0xDD 0xEE 0xFF | AdvData = 0x02 0xFF 0x53 |
</span></span></code></pre></div></li>
<li>
<p><strong>完整 PDU</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">40 09 AA BB CC DD EE FF 02 FF 53
</span></span></code></pre></div></li>
</ul>
<p>==物理层==</p>
<ul>
<li>
<p>物理层数据包格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Preamble (1 byte) | Access Address (4 bytes) | PDU (2-39 bytes) | CRC (3 bytes) |
</span></span></code></pre></div></li>
<li>
<p><strong>封装步骤</strong>：</p>
<ol>
<li><strong>Preamble</strong>：<code>0xAA</code>（假设 Access Address 的 LSB 为 0）。</li>
<li><strong>Access Address</strong>：广播信道的 Access Address 固定为 <code>0x8E89BED6</code>。</li>
<li><strong>PDU</strong>：<code>40 09 AA BB CC DD EE FF 02 FF 53</code>。</li>
<li><strong>CRC</strong>：假设为 <code>0x55 0x55 0x55</code>。</li>
</ol>
</li>
<li>
<p><strong>封装后的物理层数据包</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">AA D6 BE 89 8E 40 09 AA BB CC DD EE FF 02 FF 53 55 55 55
</span></span></code></pre></div></li>
</ul>
<h3 id="连接方式-1">
<a class="header-anchor" href="#%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f-1"></a>
连接方式
</h3><p>==应用层==</p>
<ul>
<li>数据：<code>0x53</code></li>
</ul>
<p>==ATT 层==</p>
<ul>
<li>
<p>Opcode：<code>0x12</code>（ATT_HANDLE_VALUE_NOTI，通知操作）。</p>
</li>
<li>
<p>Parameters：<code>0x53</code>。</p>
</li>
<li>
<p><strong>ATT 数据包</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">12 53
</span></span></code></pre></div></li>
</ul>
<p>==L2CAP 层==</p>
<ul>
<li>
<p>L2CAP 数据包格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Length</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Channel</span> <span class="n">ID</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Payload</span> <span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">65535</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div></li>
<li>
<p><strong>封装步骤</strong>：</p>
<ol>
<li><strong>Length</strong>：<code>0x0002</code>（2 字节）。</li>
<li><strong>Channel ID</strong>：<code>0x0004</code>（ATT 通道）。</li>
<li><strong>Payload</strong>：<code>12 53</code>。</li>
</ol>
</li>
<li>
<p><strong>L2CAP 数据包</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">02 00 04 00 12 53
</span></span></code></pre></div></li>
</ul>
<p>==LL 层==</p>
<ul>
<li>
<p>数据信道 PDU 格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Header</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Payload</span> <span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">251</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div></li>
<li>
<p><strong>Header 字段</strong>：</p>
<ul>
<li>LLID：<code>01</code>（LL Data PDU）。</li>
<li>NESN：<code>0</code>。</li>
<li>SN：<code>0</code>。</li>
<li>MD：<code>0</code>。</li>
<li>Length：<code>0x06</code>（6 字节）。</li>
</ul>
</li>
<li>
<p><strong>Payload 字段</strong>：</p>
<ul>
<li>L2CAP 数据包：<code>02 00 04 00 12 53</code>。</li>
</ul>
</li>
<li>
<p><strong>LL PDU</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">09 06 02 00 04 00 12 53
</span></span></code></pre></div></li>
</ul>
<p>==物理层==</p>
<ul>
<li>
<p>物理层数据包格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Preamble (1 byte) | Access Address (4 bytes) | PDU (2-257 bytes) | CRC (3 bytes) |
</span></span></code></pre></div></li>
<li>
<p><strong>封装步骤</strong>：</p>
<ol>
<li><strong>Preamble</strong>：<code>0xAA</code>（假设 Access Address 的 LSB 为 0）。</li>
<li><strong>Access Address</strong>：连接的唯一标识符，假设为 <code>0xD6 BE 89 8E</code>。</li>
<li><strong>PDU</strong>：<code>09 06 02 00 04 00 12 53</code>。</li>
<li><strong>CRC</strong>：假设为 <code>0x55 0x55 0x55</code>。</li>
</ol>
</li>
<li>
<p><strong>封装后的物理层数据包</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">AA D6 BE 89 8E 09 06 02 00 04 00 12 53 55 55 55
</span></span></code></pre></div></li>
</ul>
<h1 id="pdu格式">
<a class="header-anchor" href="#pdu%e6%a0%bc%e5%bc%8f"></a>
PDU格式
</h1><p>蓝牙协议数据单元（PDU）格式是蓝牙通信中用于传输控制信息和数据的基本结构。PDU格式根据蓝牙协议的不同层次（如LL、L2CAP、ATT、GATT等）有所差异。</p>
<h2 id="ll">
<a class="header-anchor" href="#ll"></a>
LL
</h2><h3 id="广播信道">
<a class="header-anchor" href="#%e5%b9%bf%e6%92%ad%e4%bf%a1%e9%81%93"></a>
广播信道
</h3><p>完整的广播信道报文格式为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Preamble (1 byte) | Access Address (4 bytes) | PDU (2-39 bytes) | CRC (3 bytes) |
</span></span></code></pre></div><p>广播信道的PDU格式为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Header</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Payload</span> <span class="p">(</span><span class="mi">6</span><span class="o">-</span><span class="mi">37</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div><h4 id="header-字段">
<a class="header-anchor" href="#header-%e5%ad%97%e6%ae%b5"></a>
Header 字段
</h4><ul>
<li><strong>PDU Type (4 bits)</strong>：指示PDU类型，例如：
<ul>
<li><code>0000</code>：ADV_IND（可连接的非定向广播）</li>
<li><code>0001</code>：ADV_DIRECT_IND（可连接的定向广播）</li>
<li><code>0010</code>：ADV_NONCONN_IND（不可连接的非定向广播）</li>
<li><code>0110</code>：SCAN_REQ（扫描请求）</li>
<li><code>0111</code>：SCAN_RSP（扫描响应）</li>
<li><code>1000</code>：CONNECT_IND（连接请求）</li>
</ul>
</li>
<li><strong>RFU (1 bit)</strong>：保留位。</li>
<li><strong>ChSel (1 bit)</strong>：指示是否支持信道选择算法（LE Channel Selection Algorithm #2）。</li>
<li><strong>TxAdd (1 bit)</strong>：指示广播地址是公共地址（0）还是随机地址（1）。</li>
<li><strong>RxAdd (1 bit)</strong>：指示目标地址是公共地址（0）还是随机地址（1）。</li>
<li><strong>Length (6 bits)</strong>：有效载荷的长度（6-37字节）。</li>
</ul>
<h4 id="payload-字段">
<a class="header-anchor" href="#payload-%e5%ad%97%e6%ae%b5"></a>
Payload 字段
</h4><ul>
<li><strong>AdvA (6 bytes)</strong>：广播设备的地址。</li>
<li><strong>TargetA (6 bytes，可选)</strong>：目标设备的地址（仅用于定向广播）。</li>
<li><strong>AdvData (0-31 bytes)</strong>：广播数据（包含GAP相关的信息，如设备名称、服务UUID等）。</li>
</ul>
<p>广播信道 PDU 的类型决定了广播设备的行为和目标设备的响应方式。以下是常见的 PDU 类型：</p>
<ol>
<li>
<p>ADV_IND：用于广播设备向所有设备发送广播数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Header | AdvA (6 bytes) | AdvData (0-31 bytes) |
</span></span></code></pre></div></li>
<li>
<p>ADV_DIRECT_IND：用于广播设备向特定目标设备发送广播数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Header | AdvA (6 bytes) | TargetA (6 bytes) |
</span></span></code></pre></div></li>
<li>
<p>ADV_NONCONN_IND：用于广播设备发送不可连接的广播数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Header | AdvA (6 bytes) | AdvData (0-31 bytes) |
</span></span></code></pre></div></li>
<li>
<p>SCAN_REQ：用于扫描设备向广播设备请求扫描响应数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Header | ScanA (6 bytes) | AdvA (6 bytes) |
</span></span></code></pre></div></li>
<li>
<p>SCAN_RSP：用于广播设备响应扫描请求。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Header | AdvA (6 bytes) | ScanRspData (0-31 bytes) |
</span></span></code></pre></div></li>
<li>
<p>CONNECT_IND:连接请求</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Packet</span> <span class="n">Header</span> <span class="p">(</span><span class="mi">2</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">InitA</span> <span class="p">(</span><span class="mi">6</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">AdvA</span> <span class="p">(</span><span class="mi">6</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">LLData</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div><ol>
<li>
<p><strong>报头（Header）</strong>  ：包含指令类型和其他控制信息。对于CONNECT_REQ，报头类型值为5。</p>
<ol>
<li><strong>有效数据长度（Length）</strong>  ：表示后续数据字段的长度。</li>
</ol>
</li>
<li>
<p><strong>发起者地址（InitA）</strong>  ：主设备的MAC地址，即发起者的地址。</p>
</li>
<li>
<p><strong>广播数据地址（AdvA）</strong>  ：从设备的MAC地址，即广告者的地址。</p>
</li>
<li>
<p><strong>LL Data</strong>：</p>
<table>
  <thead>
      <tr>
          <th>宇段名称</th>
          <th>长度 (宇节) L</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>AA</td>
          <td>4</td>
          <td>访问地址（Access Address），用于连接后的通信。</td>
      </tr>
      <tr>
          <td>CRCInit</td>
          <td>3</td>
          <td>CRC 初始值，用于校验。</td>
      </tr>
      <tr>
          <td>WinSize</td>
          <td>1</td>
          <td>传输窗口大小（Transmit Window Size），单位为1.25 ms。</td>
      </tr>
      <tr>
          <td>Winoffset</td>
          <td>2</td>
          <td>传输窗口偏移（Transmit Window Offset），单位为1.25 ms。</td>
      </tr>
      <tr>
          <td>Interval</td>
          <td>2</td>
          <td>连接间隔 (Connection Interval)，单位为 1.25 ms。</td>
      </tr>
      <tr>
          <td>Latency</td>
          <td>2</td>
          <td>从设备延迟（Slave Latency），表示从设备可以跳过的连接事件次数。</td>
      </tr>
      <tr>
          <td>Timeout</td>
          <td>2</td>
          <td>连接超时时间（Connection Timeout），单位为 10 ms。</td>
      </tr>
      <tr>
          <td>ChM</td>
          <td>5</td>
          <td>信道映射（Channel Map），指示使用的数据信道。</td>
      </tr>
      <tr>
          <td>Hop</td>
          <td>1</td>
          <td>跳频增量（Hop Increment），用于计算下一个连接事件的信道。</td>
      </tr>
      <tr>
          <td>SCA</td>
          <td>1</td>
          <td>睡眠时钟精度（Sleep Clock Accuracy），表示主设备的时钟精度</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
</li>
<li></li>
</ol>
<h3 id="数据信道">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e4%bf%a1%e9%81%93"></a>
数据信道
</h3><p>完整的数据信道报文格式为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">| Preamble (1 byte) | Access Address (4 bytes) | PDU (2-257 bytes) | CRC (3 bytes) |
</span></span></code></pre></div><p>在连接建立后，数据信道PDU的格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Header</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Payload</span> <span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">251</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div><h4 id="header-字段-1">
<a class="header-anchor" href="#header-%e5%ad%97%e6%ae%b5-1"></a>
Header 字段
</h4><ul>
<li>
<p><strong>LLID (2 bits)</strong>：逻辑链路标识符（Logical Link Identifier），标识数据包类型。</p>
<table>
  <thead>
      <tr>
          <th>LLID 值</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>00</td>
          <td>RFU (Reserved)</td>
          <td>保留字段，未使用。</td>
      </tr>
      <tr>
          <td>01</td>
          <td>LL Data PDU (Continuation Fragment)</td>
          <td>表示这包数据需要进行分段。</td>
      </tr>
      <tr>
          <td>10</td>
          <td>LL Data PDU (Start of an L2CAP Message)</td>
          <td>表示这包数据不需要进行分段。</td>
      </tr>
      <tr>
          <td>11</td>
          <td>LL Control PDU</td>
          <td>表示这是一个控制PDU（Control PDU），用于链路层控制信息。</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>NESN (1 bit)</strong>：下一个预期序列号。</p>
</li>
<li>
<p><strong>SN (1 bit)</strong>：序列号。</p>
</li>
<li>
<p><strong>MD (1 bit)</strong>：更多数据标志。指示是否有更多的数据需要传输。</p>
</li>
<li>
<p>RFU（3 bit）：保留字段</p>
</li>
<li>
<p><strong>Length (8 bits)</strong>：有效载荷的长度（0-251字节）。</p>
</li>
</ul>
<p>假设一个 Packet Header 的值为 <code>0x1A2B</code>，其二进制表示为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">000 1 1 0 10 | 00101011
</span></span></code></pre></div><ul>
<li><strong>LLID</strong>：<code>10</code>（表示数据 PDU 的PDU起始分片）。</li>
<li><strong>NESN</strong>：<code>0</code>（表示接收方期望的下一个序列号为 0）。</li>
<li><strong>SN</strong>：<code>1</code>（表示当前数据包的序列号为 1）。</li>
<li><strong>MD</strong>：<code>1</code>（表示发送方还有更多数据需要传输）。</li>
<li><strong>RFU</strong>：<code>000</code>（保留字段）。</li>
<li><strong>Length</strong>：<code>0x2B</code>（表示有效载荷长度为 43 字节）。</li>
</ul>
<p>不同的LLID有着不同的PDU，实际上共有两种类型：</p>
<ol>
<li>控制报文</li>
<li>数据报文</li>
</ol>
<h4 id="payload-字段-1">
<a class="header-anchor" href="#payload-%e5%ad%97%e6%ae%b5-1"></a>
Payload 字段
</h4><ul>
<li><strong>L2CAP数据或LL控制信息</strong>：承载GAP相关的数据或控制信息。</li>
</ul>
<h4 id="控制报文">
<a class="header-anchor" href="#%e6%8e%a7%e5%88%b6%e6%8a%a5%e6%96%87"></a>
控制报文
</h4><p>两台设备连接成功之后，首先会先进行沟通，设备之间会通过==链路层（Link Layer, LL）==交换一系列控制信息，以协商连接参数、确认支持的功能以及管理连接状态。当数据报文是控制信息，那么LLID应该为<code>11</code>。</p>
<p>所有 LL 控制报文都以一个 <strong>Opcode</strong> 开头，用于标识报文的类型。通用格式如下：</p>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td>控制报文的操作码（Opcode），用于标识报文的类型。</td>
      </tr>
      <tr>
          <td><strong>Payload</strong></td>
          <td>可变</td>
          <td>与 Opcode 相关的数据字段，长度和内容取决于具体的控制报文类型。</td>
      </tr>
  </tbody>
</table>
<p>Opcode的可选如下：</p>
<table>
  <thead>
      <tr>
          <th><strong>Opcode</strong></th>
          <th><strong>名称</strong></th>
          <th><strong>描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>0x00</code></td>
          <td>LL_CONNECTION_UPDATE_IND</td>
          <td>用于更新连接参数（如连接间隔、延迟等）。</td>
      </tr>
      <tr>
          <td><code>0x01</code></td>
          <td>LL_CHANNEL_MAP_IND</td>
          <td>用于指示信道映射的更新。</td>
      </tr>
      <tr>
          <td><code>0x02</code></td>
          <td>LL_TERMINATE_IND</td>
          <td>用于终止连接。</td>
      </tr>
      <tr>
          <td><code>0x03</code></td>
          <td>LL_ENC_REQ</td>
          <td>用于请求加密连接的启动。</td>
      </tr>
      <tr>
          <td><code>0x04</code></td>
          <td>LL_ENC_RSP</td>
          <td>用于响应加密请求。</td>
      </tr>
      <tr>
          <td><code>0x05</code></td>
          <td>LL_START_ENC_REQ</td>
          <td>用于启动加密过程。</td>
      </tr>
      <tr>
          <td><code>0x06</code></td>
          <td>LL_START_ENC_RSP</td>
          <td>用于响应加密启动请求。</td>
      </tr>
      <tr>
          <td><code>0x07</code></td>
          <td>LL_UNKNOWN_RSP</td>
          <td>用于响应未知或不支持的控制报文。</td>
      </tr>
      <tr>
          <td><code>0x08</code></td>
          <td>LL_FEATURE_REQ</td>
          <td>用于请求对端设备的支持特性。</td>
      </tr>
      <tr>
          <td><code>0x09</code></td>
          <td>LL_FEATURE_RSP</td>
          <td>用于响应特性请求，返回支持的特性列表。</td>
      </tr>
      <tr>
          <td><code>0x0A</code></td>
          <td>LL_PAUSE_ENC_REQ</td>
          <td>用于请求暂停加密。</td>
      </tr>
      <tr>
          <td><code>0x0B</code></td>
          <td>LL_PAUSE_ENC_RSP</td>
          <td>用于响应暂停加密请求。</td>
      </tr>
      <tr>
          <td><code>0x0C</code></td>
          <td>LL_VERSION_IND</td>
          <td>用于交换链路层版本信息。</td>
      </tr>
      <tr>
          <td><code>0x0D</code></td>
          <td>LL_REJECT_IND</td>
          <td>用于拒绝某个请求或指示。</td>
      </tr>
      <tr>
          <td><code>0x0E</code></td>
          <td>LL_SLAVE_FEATURE_REQ</td>
          <td>用于从设备请求主设备的支持特性。</td>
      </tr>
      <tr>
          <td><code>0x0F</code></td>
          <td>LL_CONNECTION_PARAM_REQ</td>
          <td>用于请求更新连接参数（如连接间隔、延迟等）。</td>
      </tr>
      <tr>
          <td><code>0x10</code></td>
          <td>LL_CONNECTION_PARAM_RSP</td>
          <td>用于响应连接参数更新请求。</td>
      </tr>
      <tr>
          <td><code>0x11</code></td>
          <td>LL_REJECT_EXT_IND</td>
          <td>用于拒绝扩展指示。</td>
      </tr>
      <tr>
          <td><code>0x12</code></td>
          <td>LL_PING_REQ</td>
          <td>用于发送 Ping 请求，测试连接状态。</td>
      </tr>
      <tr>
          <td><code>0x13</code></td>
          <td>LL_PING_RSP</td>
          <td>用于响应 Ping 请求。</td>
      </tr>
      <tr>
          <td><code>0x14</code></td>
          <td>LL_LENGTH_REQ</td>
          <td>用于请求最大数据长度（支持 LE Data Length Extension）。</td>
      </tr>
      <tr>
          <td><code>0x15</code></td>
          <td>LL_LENGTH_RSP</td>
          <td>用于响应最大数据长度请求。</td>
      </tr>
      <tr>
          <td><code>0x16</code></td>
          <td>LL_PHY_REQ</td>
          <td>用于请求 PHY 更新（如 1M、2M 或 Coded PHY）。</td>
      </tr>
      <tr>
          <td><code>0x17</code></td>
          <td>LL_PHY_RSP</td>
          <td>用于响应 PHY 更新请求。</td>
      </tr>
      <tr>
          <td><code>0x18</code></td>
          <td>LL_PHY_UPDATE_IND</td>
          <td>用于指示 PHY 更新已完成。</td>
      </tr>
      <tr>
          <td><code>0x19</code></td>
          <td>LL_MIN_USED_CHANNELS_IND</td>
          <td>用于指示最小使用的信道数量。</td>
      </tr>
      <tr>
          <td><code>0x1A</code></td>
          <td>LL_CTE_REQ</td>
          <td>用于请求发送 Constant Tone Extension（CTE）。</td>
      </tr>
      <tr>
          <td><code>0x1B</code></td>
          <td>LL_CTE_RSP</td>
          <td>用于响应 CTE 请求。</td>
      </tr>
  </tbody>
</table>
<h5 id="连接管理">
<a class="header-anchor" href="#%e8%bf%9e%e6%8e%a5%e7%ae%a1%e7%90%86"></a>
连接管理
</h5><ol>
<li>
<p><code>LL_CONNECTION_UPDATE_IND</code>：用于更新连接参数。</p>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x02</code></td>
      </tr>
      <tr>
          <td><strong>WinSize</strong></td>
          <td>1</td>
          <td>传输窗口大小（Transmit Window Size），单位为 1.25 ms。</td>
      </tr>
      <tr>
          <td><strong>WinOffset</strong></td>
          <td>2</td>
          <td>传输窗口偏移（Transmit Window Offset），单位为 1.25 ms。</td>
      </tr>
      <tr>
          <td><strong>Interval</strong></td>
          <td>2</td>
          <td>连接间隔（Connection Interval），单位为 1.25 ms。</td>
      </tr>
      <tr>
          <td><strong>Latency</strong></td>
          <td>2</td>
          <td>从设备延迟（Slave Latency），表示从设备可以跳过的连接事件次数。</td>
      </tr>
      <tr>
          <td><strong>Timeout</strong></td>
          <td>2</td>
          <td>连接超时时间（Connection Timeout），单位为 10 ms。</td>
      </tr>
      <tr>
          <td><strong>Instant</strong></td>
          <td>2</td>
          <td>更新生效的事件计数（Instant）。</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><code>LL_CHANNEL_MAP_IND</code>：用于更新信道映射。</p>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x03</code></td>
      </tr>
      <tr>
          <td><strong>ChM</strong></td>
          <td>5</td>
          <td>信道映射（Channel Map），指示哪些信道可用于数据传输。</td>
      </tr>
      <tr>
          <td><strong>Instant</strong></td>
          <td>2</td>
          <td>更新生效的事件计数（Instant）。</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><code>LL_TERMINATE_IND</code>：用于终止连接。</p>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x04</code></td>
      </tr>
      <tr>
          <td><strong>Error Code</strong></td>
          <td>1</td>
          <td>终止原因（Error Code），例如超时、用户请求等。</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<h5 id="加密管理">
<a class="header-anchor" href="#%e5%8a%a0%e5%af%86%e7%ae%a1%e7%90%86"></a>
加密管理
</h5><ol>
<li>
<p><code>LL_ENC_REQ</code>：用于启动加密过程。</p>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x05</code></td>
      </tr>
      <tr>
          <td><strong>Rand</strong></td>
          <td>8</td>
          <td>随机数（Random Number）。</td>
      </tr>
      <tr>
          <td><strong>EDIV</strong></td>
          <td>2</td>
          <td>加密差分（Encryption Diversifier）。</td>
      </tr>
      <tr>
          <td><strong>SKDm</strong></td>
          <td>8</td>
          <td>主设备会话密钥差分（Session Key Diversifier Master）。</td>
      </tr>
      <tr>
          <td><strong>IVm</strong></td>
          <td>4</td>
          <td>主设备初始化向量（Initialization Vector Master）。</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><code>LL_ENC_RSP</code>：用于响应加密请求。</p>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x06</code></td>
      </tr>
      <tr>
          <td><strong>SKDs</strong></td>
          <td>8</td>
          <td>从设备会话密钥差分（Session Key Diversifier Slave）。</td>
      </tr>
      <tr>
          <td><strong>IVs</strong></td>
          <td>4</td>
          <td>从设备初始化向量（Initialization Vector Slave）。</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><code>LL_START_ENC_REQ</code>：用于确认加密已启动。</p>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x07</code></td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><code>LL_START_ENC_RSP</code>：用于响应加密启动请求。</p>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x08</code></td>
      </tr>
  </tbody>
</table>
<h5 id="特性交换">
<a class="header-anchor" href="#%e7%89%b9%e6%80%a7%e4%ba%a4%e6%8d%a2"></a>
特性交换
</h5><p><code>LL_FEATURE_REQ</code> 和 <code>LL_FEATURE_RSP</code>:用于交换支持的特性。</p>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x09</code>（<code>LL_FEATURE_REQ</code>）或 <code>0x0A</code>（<code>LL_FEATURE_RSP</code>）</td>
      </tr>
      <tr>
          <td><strong>FeatureSet</strong></td>
          <td>8</td>
          <td>支持的特性集合（Feature Set），每个比特表示一个特性。</td>
      </tr>
  </tbody>
</table>
<p><strong>Feature Set</strong> 是一个 64 位的字段，用于表示设备支持的蓝牙特性。每一位代表一个特定的功能或特性支持状态。如果某一位被设置为 <code>1</code>，则表示该设备支持该功能；如果为 <code>0</code>，则表示不支持。</p>
<p>以下是标准蓝牙规范中定义的 Feature Set 的每个位的含义（根据 <a href="https://www.bluetooth.com/specifications/">Bluetooth Core Specification</a>）：</p>
<table>
  <thead>
      <tr>
          <th>位位置</th>
          <th>功能名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>LE Encryption</td>
          <td>支持蓝牙低功耗加密功能</td>
      </tr>
      <tr>
          <td>1</td>
          <td>Connection Parameters Request</td>
          <td>支持连接参数请求过程</td>
      </tr>
      <tr>
          <td>2</td>
          <td>Extended Reject Indication</td>
          <td>支持扩展拒绝指示</td>
      </tr>
      <tr>
          <td>3</td>
          <td>Slave-initiated Features Exchange</td>
          <td>支持从设备发起特性交换</td>
      </tr>
      <tr>
          <td>4</td>
          <td>LE Ping</td>
          <td>支持低功耗 Ping 操作</td>
      </tr>
      <tr>
          <td>5</td>
          <td>LE Data Packet Length Extension</td>
          <td>支持低功耗数据包长度扩展</td>
      </tr>
      <tr>
          <td>6</td>
          <td>LL Privacy</td>
          <td>支持链路层隐私功能</td>
      </tr>
      <tr>
          <td>7</td>
          <td>Extended Scanner Filter Policies</td>
          <td>支持扩展扫描器过滤策略</td>
      </tr>
      <tr>
          <td>8</td>
          <td>LE 2M PHY</td>
          <td>支持低功耗 2M PHY（物理层）</td>
      </tr>
      <tr>
          <td>9</td>
          <td>Stable Modulation Index - TX</td>
          <td>支持稳定的调制索引（发射）</td>
      </tr>
      <tr>
          <td>10</td>
          <td>Stable Modulation Index - RX</td>
          <td>支持稳定的调制索引（接收）</td>
      </tr>
      <tr>
          <td>11</td>
          <td>LE Coded PHY</td>
          <td>支持低功耗编码 PHY</td>
      </tr>
      <tr>
          <td>12</td>
          <td>LE Extended Advertising</td>
          <td>支持低功耗扩展广告</td>
      </tr>
      <tr>
          <td>13</td>
          <td>LE Periodic Advertising</td>
          <td>支持低功耗周期性广告</td>
      </tr>
      <tr>
          <td>14</td>
          <td>Channel Selection Algorithm #2</td>
          <td>支持信道选择算法 #2</td>
      </tr>
      <tr>
          <td>15</td>
          <td>LE Power Class 1</td>
          <td>支持低功耗功率等级 1</td>
      </tr>
      <tr>
          <td>16</td>
          <td>Minimum Number of Used Channels</td>
          <td>支持最少使用信道数设置</td>
      </tr>
      <tr>
          <td>17</td>
          <td>Connection CTE Request</td>
          <td>支持连接 CTE（连续时间误差）请求</td>
      </tr>
      <tr>
          <td>18</td>
          <td>Connection CTE Response</td>
          <td>支持连接 CTE 响应</td>
      </tr>
      <tr>
          <td>19</td>
          <td>Connectionless CTE Transmitter</td>
          <td>支持无连接 CTE 发送</td>
      </tr>
      <tr>
          <td>20</td>
          <td>Connectionless CTE Receiver</td>
          <td>支持无连接 CTE 接收</td>
      </tr>
      <tr>
          <td>21</td>
          <td>Antenna Switching During CTE TX</td>
          <td>支持 CTE 发射期间天线切换</td>
      </tr>
      <tr>
          <td>22</td>
          <td>Antenna Switching During CTE RX</td>
          <td>支持 CTE 接收期间天线切换</td>
      </tr>
      <tr>
          <td>23</td>
          <td>Receiving Constant Tone Extension</td>
          <td>支持接收连续音调扩展</td>
      </tr>
      <tr>
          <td>24</td>
          <td>Periodic Advertising Sync Transfer - Sender</td>
          <td>支持周期性广告同步传输发送</td>
      </tr>
      <tr>
          <td>25</td>
          <td>Periodic Advertising Sync Transfer - Recipient</td>
          <td>支持周期性广告同步传输接收</td>
      </tr>
      <tr>
          <td>26</td>
          <td>Sleep Clock Accuracy Updates</td>
          <td>支持睡眠时钟精度更新</td>
      </tr>
      <tr>
          <td>27</td>
          <td>Remote Public Key Validation</td>
          <td>支持远程公钥验证</td>
      </tr>
      <tr>
          <td>28</td>
          <td>Connected Isochronous Stream - Master</td>
          <td>支持主设备同步流</td>
      </tr>
      <tr>
          <td>29</td>
          <td>Connected Isochronous Stream - Slave</td>
          <td>支持从设备同步流</td>
      </tr>
      <tr>
          <td>30</td>
          <td>Isochronous Broadcaster</td>
          <td>支持同步广播</td>
      </tr>
      <tr>
          <td>31</td>
          <td>Synchronized Receiver</td>
          <td>支持同步接收</td>
      </tr>
      <tr>
          <td>32</td>
          <td>LE Secure Connections</td>
          <td>支持低功耗安全连接</td>
      </tr>
      <tr>
          <td>33</td>
          <td>BIS Receiver</td>
          <td>支持广播同步流接收（Broadcast Isochronous Stream Receiver）</td>
      </tr>
      <tr>
          <td>34</td>
          <td>Power Control Request</td>
          <td>支持功率控制请求</td>
      </tr>
      <tr>
          <td>35</td>
          <td>Power Change Indication</td>
          <td>支持功率变化指示</td>
      </tr>
      <tr>
          <td>36</td>
          <td>LE Path Loss Monitoring</td>
          <td>支持路径损耗监控</td>
      </tr>
      <tr>
          <td>37-63</td>
          <td>未来保留</td>
          <td>为未来扩展功能保留</td>
      </tr>
  </tbody>
</table>
<h5 id="phy和数据长度管理">
<a class="header-anchor" href="#phy%e5%92%8c%e6%95%b0%e6%8d%ae%e9%95%bf%e5%ba%a6%e7%ae%a1%e7%90%86"></a>
PHY和数据长度管理
</h5><p><code>LL_LENGTH_REQ</code> 和 <code>LL_LENGTH_RSP</code>:用于协商数据包长度。</p>
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x14</code>（<code>LL_LENGTH_REQ</code>）或 <code>0x15</code>（<code>LL_LENGTH_RSP</code>）</td>
      </tr>
      <tr>
          <td><strong>MaxRxOctets</strong></td>
          <td>2</td>
          <td>最大接收字节数（Max Rx Octets）。</td>
      </tr>
      <tr>
          <td><strong>MaxRxTime</strong></td>
          <td>2</td>
          <td>最大接收时间（Max Rx Time），单位为 1.25 ms。</td>
      </tr>
      <tr>
          <td><strong>MaxTxOctets</strong></td>
          <td>2</td>
          <td>最大发送字节数（Max Tx Octets）。</td>
      </tr>
      <tr>
          <td><strong>MaxTxTime</strong></td>
          <td>2</td>
          <td>最大发送时间（Max Tx Time），单位为 1.25 ms</td>
      </tr>
  </tbody>
</table>
<h5 id="其他功能">
<a class="header-anchor" href="#%e5%85%b6%e4%bb%96%e5%8a%9f%e8%83%bd"></a>
其他功能
</h5><ol>
<li><code>LL_VERSION_IND</code>:用于交换协议版本信息。
<table>
  <thead>
      <tr>
          <th>字段名称</th>
          <th>长度（字节）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Opcode</strong></td>
          <td>1</td>
          <td><code>0x0C</code></td>
      </tr>
      <tr>
          <td><strong>VersNr</strong></td>
          <td>1</td>
          <td>协议版本号（Version Number）。</td>
      </tr>
      <tr>
          <td><strong>CompId</strong></td>
          <td>2</td>
          <td>公司标识（Company ID）。</td>
      </tr>
      <tr>
          <td><strong>SubVersNr</strong></td>
          <td>2</td>
          <td>子版本号（Subversion Number）。</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<h4 id="数据报文">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e6%8a%a5%e6%96%87"></a>
数据报文
</h4><p>可通过不同的协议来进行传输协议，如*==GATT&gt;ATT&gt;L2CAP&gt;LL==<em>或者</em>==GAP&gt;LL==*，走不同的协议，会有不同的协议格式。</p>
<h2 id="gap">
<a class="header-anchor" href="#gap"></a>
GAP
</h2><p>GAP的PDU格式如下图：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/01/6_11_39_5_202501061139546.png" alt="蓝牙广播包格式"></p>
<p>如上图所示，报文采用LTV（LENGTH-TYPE-Value）格式，每个AD Structure包含又包含三部分，分别是：</p>
<ol>
<li>
<p>Length(1字节)</p>
</li>
<li>
<p>AD Type(1字节)</p>
</li>
<li>
<p>AD Data(n字节)</p>
<blockquote>
<p>[!tip]</p>
<p>其中Length = AD Type 长度 + AD Data 长度</p></blockquote>
</li>
</ol>
<p>例如，如下广播数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0x04,0x09,0x41,0x42,0x43,0x03,0x19,0x80,0x01
</span></span></code></pre></div><p>按照蓝牙的广播数据格式可以解析为 2 个AD Structure，如下图：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/01/6_11_47_18_202501061147593.png" alt="蓝牙广播数据分解"></p>
<p>上述数据的第一个字节 0x04 是第一个AD Structure的长度，表示后面有4个字节的数据属于该AD Structure，分别是 0x09, 0x41, 0x42, 0x43， 后面的数据 0x03 是第二个 AD Structure 的长度，表示后面有3个字节的数据属于该AD Structure，分别是 0x19, 0x80, 0x01 。</p>
<p>通过上述方法，我们可以将蓝牙广播数据格式分割成若干个 AD Structure ，但是想要知道每一个 AD Structure 的含义，还必须知道广播结构体中 AD Type 的含义。AD Type 由蓝牙组织联盟指定并发布，可以在蓝牙官方网站上下载相关文档， AD Type 及其含义如下(请参阅<a href="http://rfc.nop.hu/bluetooth/AssignedNumbersGenericAccessProfile.pdf">Bluetooth.org - Generic Access Profile (nop.hu)</a>)：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">值</th>
          <th style="text-align: center">类型</th>
          <th style="text-align: center">描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">0x01</td>
          <td style="text-align: center">EIR 数据类型定义</td>
          <td style="text-align: center">设备标识（flag）</td>
      </tr>
      <tr>
          <td style="text-align: center">0x02</td>
          <td style="text-align: center">UUIDs服务类</td>
          <td style="text-align: center">16 位 UUID 可用</td>
      </tr>
      <tr>
          <td style="text-align: center">0x03</td>
          <td style="text-align: center">:</td>
          <td style="text-align: center">16位UUID完整列表</td>
      </tr>
      <tr>
          <td style="text-align: center">0x04</td>
          <td style="text-align: center">:</td>
          <td style="text-align: center">32 位UUID可用</td>
      </tr>
      <tr>
          <td style="text-align: center">0x05</td>
          <td style="text-align: center">:</td>
          <td style="text-align: center">32位UUID完整列表</td>
      </tr>
      <tr>
          <td style="text-align: center">0x06</td>
          <td style="text-align: center">:</td>
          <td style="text-align: center">128位UUID可用</td>
      </tr>
      <tr>
          <td style="text-align: center">0x07</td>
          <td style="text-align: center">:</td>
          <td style="text-align: center">128位UUID完整列表</td>
      </tr>
      <tr>
          <td style="text-align: center">0x08</td>
          <td style="text-align: center">设备名</td>
          <td style="text-align: center">设备简称</td>
      </tr>
      <tr>
          <td style="text-align: center">0x09</td>
          <td style="text-align: center">:</td>
          <td style="text-align: center">设备全称</td>
      </tr>
      <tr>
          <td style="text-align: center">0x0A</td>
          <td style="text-align: center">发射功耗</td>
          <td style="text-align: center">0xXX:-127 至 +127dBm</td>
      </tr>
      <tr>
          <td style="text-align: center">0x0D</td>
          <td style="text-align: center">OOB安全配对</td>
          <td style="text-align: center">设备类别（3 个字节）</td>
      </tr>
      <tr>
          <td style="text-align: center">0x0E</td>
          <td style="text-align: center">:</td>
          <td style="text-align: center">简单配对哈希 C（16 字节）</td>
      </tr>
      <tr>
          <td style="text-align: center">0x0F</td>
          <td style="text-align: center">:</td>
          <td style="text-align: center">简单配对随机器 R（16 字节）</td>
      </tr>
      <tr>
          <td style="text-align: center">0x10</td>
          <td style="text-align: center">设备ID</td>
          <td style="text-align: center">设备 ID 扩展查询响应记录</td>
      </tr>
      <tr>
          <td style="text-align: center">0xFF</td>
          <td style="text-align: center">厂商自定义</td>
          <td style="text-align: center">厂商自定义数据</td>
      </tr>
  </tbody>
</table>
<p>设备标识有以下的格式</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">数据位</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">Bit0</td>
          <td style="text-align: center">LE有限可发现模式</td>
      </tr>
      <tr>
          <td style="text-align: center">Bit1</td>
          <td style="text-align: center">LE普通可发现模式</td>
      </tr>
      <tr>
          <td style="text-align: center">Bit2</td>
          <td style="text-align: center">不支持BR/EDR(经典蓝牙)</td>
      </tr>
      <tr>
          <td style="text-align: center">Blt3</td>
          <td style="text-align: center">控制器端同时支持BR/EDR和LE</td>
      </tr>
      <tr>
          <td style="text-align: center">Bit4</td>
          <td style="text-align: center">主机端同时自持BR/EDR和LE</td>
      </tr>
      <tr>
          <td style="text-align: center">Bit5-7</td>
          <td style="text-align: center">保留</td>
      </tr>
  </tbody>
</table>
<h2 id="l2cap">
<a class="header-anchor" href="#l2cap"></a>
L2CAP
</h2><p>L2CAP PDU用于在蓝牙设备之间传输数据和控制信息。其基本格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Length</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Channel</span> <span class="n">ID</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Payload</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div><ul>
<li><strong>Length (2字节)</strong>：指示有效载荷的长度（不包括Length字段本身）。</li>
<li><strong>Channel ID (2字节)</strong>：标识逻辑通道。</li>
<li><strong>Payload (可变长度)</strong>：实际传输的数据或控制信息。</li>
</ul>
<p>==Channel ID==</p>
<p><strong>CID（Channel Identifier）</strong> 是用来标识逻辑通道的一个关键字段。每个L2CAP通道都有一个唯一的CID，用于区分不同的逻辑连接。CID 用于标识 L2CAP 层上的逻辑通道，使得多个应用程序或服务可以共享同一个蓝牙链路。每个 CID 对应一个独立的逻辑通道，用于传输特定类型的数据。</p>
<h3 id="cid-的取值范围">
<a class="header-anchor" href="#cid-%e7%9a%84%e5%8f%96%e5%80%bc%e8%8c%83%e5%9b%b4"></a>
CID 的取值范围
</h3><p>CID 是一个 16 位的字段，经典蓝牙和低功耗蓝牙选取不同的取值范围：</p>
<p>==经典蓝牙==</p>
<table>
  <thead>
      <tr>
          <th>CID</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>0x0000</code></td>
          <td>空标识，无效 CID。</td>
      </tr>
      <tr>
          <td><code>0x0001</code></td>
          <td>信令通道（Signaling Channel），用于 L2CAP 控制命令（如连接请求、配置请求等）。</td>
      </tr>
      <tr>
          <td><code>0x0002</code></td>
          <td>无连接通道（Connectionless Channel），用于无连接数据传输。</td>
      </tr>
      <tr>
          <td><code>0x0003</code></td>
          <td>AMP管理协议</td>
      </tr>
      <tr>
          <td><code> 0x0004-0x0006</code></td>
          <td>保留用于未来扩展。</td>
      </tr>
      <tr>
          <td><code> 0x0007</code></td>
          <td>BR/EDR安全管理</td>
      </tr>
      <tr>
          <td><code>0x0008-0x003E</code></td>
          <td>保留用于未来扩展。</td>
      </tr>
      <tr>
          <td><code>0x0040</code> - <code>0xFFFF</code></td>
          <td>动态分配给具体的逻辑通道，用于传输应用程序或服务的数据。</td>
      </tr>
  </tbody>
</table>
<p>==低功耗蓝牙==</p>
<table>
  <thead>
      <tr>
          <th>CID</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>0x0000</code></td>
          <td>空标识，无效 CID。</td>
      </tr>
      <tr>
          <td><code>0x0001</code>-<code>0x0003</code></td>
          <td>保留用于未来扩展。</td>
      </tr>
      <tr>
          <td><code>0x0004</code></td>
          <td>ATT协议</td>
      </tr>
      <tr>
          <td><code>0x0005</code></td>
          <td>LE的L2CAP信号通道</td>
      </tr>
      <tr>
          <td><code>0x0006</code></td>
          <td>安全管理协议</td>
      </tr>
      <tr>
          <td><code> 0x0007-0x001F</code></td>
          <td>保留用于未来扩展。</td>
      </tr>
      <tr>
          <td><code> 0x0020-0x003E</code></td>
          <td>对齐数字</td>
      </tr>
      <tr>
          <td><code> 0x0040-0x007F</code></td>
          <td>动态分配给具体的逻辑通道，用于传输应用程序或服务的数据。</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>[!note]</p>
<p>CID的选取请参见<a href="https://www.mouser.com/pdfdocs/bluetooth-Core-v50.pdf">Specification of the Bluetooth System, v5.0</a>的第1728页</p></blockquote>
<h3 id="cid-的使用场景">
<a class="header-anchor" href="#cid-%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af"></a>
CID 的使用场景
</h3><ol>
<li>
<p><strong>信令通道（CID = 0x0001）</strong>：</p>
<ul>
<li>用于 L2CAP 控制命令，例如：
<ul>
<li>建立逻辑通道（<code>L2CAP_ConnectionRequest</code>）。</li>
<li>配置逻辑通道参数（<code>L2CAP_ConfigurationRequest</code>）。</li>
<li>断开逻辑通道（<code>L2CAP_DisconnectionRequest</code>）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>动态分配的 CID</strong>：</p>
<ul>
<li>用于具体的应用程序或服务，例如：
<ul>
<li>RFCOMM（串口仿真协议）会分配一个 CID 用于传输串口数据。</li>
<li>ATT（Attribute Protocol）会分配一个 CID 用于传输 GATT 数据。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="cid-的分配过程">
<a class="header-anchor" href="#cid-%e7%9a%84%e5%88%86%e9%85%8d%e8%bf%87%e7%a8%8b"></a>
<strong>CID 的分配过程</strong>
</h3><ol>
<li>当两个设备需要建立 L2CAP 连接时，发起方会通过信令通道（CID = 0x0001）发送 <code>L2CAP_ConnectionRequest</code>。</li>
<li>接收方同意连接后，会分配一个动态 CID（例如 0x0040）并返回 <code>L2CAP_ConnectionResponse</code>。</li>
<li>双方使用该 CID 进行数据传输。</li>
</ol>
<h2 id="attgatt">
<a class="header-anchor" href="#attgatt"></a>
ATT/GATT
</h2><p>ATT PDU用于在蓝牙低功耗（BLE）设备之间传输属性数据。其基本格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Opcode</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">Parameters</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div><ul>
<li><strong>Opcode (1字节)</strong>：指示操作类型（请求、响应、命令、通知、指示）。</li>
<li><strong>Parameters (可变长度)</strong>：与操作相关的参数。</li>
</ul>
<p>==Opcode==</p>
<p>以下是常见的 <strong>ATT PDU 操作码（Opcode）</strong> 及其对应的功能和方向（客户端到服务器或服务器到客户端）。这些操作码用于定义 ATT 层的通信行为。</p>
<table>
  <thead>
      <tr>
          <th><strong>Opcode 值（十六进制）</strong></th>
          <th><strong>PDU 类型</strong></th>
          <th><strong>方向</strong></th>
          <th><strong>描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>0x01</strong></td>
          <td>Error Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对错误请求的响应。</td>
      </tr>
      <tr>
          <td><strong>0x02</strong></td>
          <td>Exchange MTU Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求交换最大传输单元（MTU）。</td>
      </tr>
      <tr>
          <td><strong>0x03</strong></td>
          <td>Exchange MTU Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Exchange MTU Request 的响应。</td>
      </tr>
      <tr>
          <td><strong>0x04</strong></td>
          <td>Find Information Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求查找属性句柄和类型信息。</td>
      </tr>
      <tr>
          <td><strong>0x05</strong></td>
          <td>Find Information Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Find Information Request 的响应。</td>
      </tr>
      <tr>
          <td><strong>0x06</strong></td>
          <td>Find By Type Value Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求根据类型和值查找属性句柄。</td>
      </tr>
      <tr>
          <td><strong>0x07</strong></td>
          <td>Find By Type Value Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Find By Type Value Request 的响应。</td>
      </tr>
      <tr>
          <td><strong>0x08</strong></td>
          <td>Read By Type Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求读取特定类型的所有属性值。</td>
      </tr>
      <tr>
          <td><strong>0x09</strong></td>
          <td>Read By Type Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Read By Type Request 的响应。</td>
      </tr>
      <tr>
          <td><strong>0x0A</strong></td>
          <td>Read Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求读取特定属性句柄的值。</td>
      </tr>
      <tr>
          <td><strong>0x0B</strong></td>
          <td>Read Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Read Request 的响应，返回属性值。</td>
      </tr>
      <tr>
          <td><strong>0x0C</strong></td>
          <td>Read Blob Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求读取长属性值的部分数据（偏移量指定）。</td>
      </tr>
      <tr>
          <td><strong>0x0D</strong></td>
          <td>Read Blob Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Read Blob Request 的响应，返回部分属性值。</td>
      </tr>
      <tr>
          <td><strong>0x0E</strong></td>
          <td>Read Multiple Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求读取多个属性句柄的值。</td>
      </tr>
      <tr>
          <td><strong>0x0F</strong></td>
          <td>Read Multiple Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Read Multiple Request 的响应，返回多个属性值。</td>
      </tr>
      <tr>
          <td><strong>0x10</strong></td>
          <td>Read By Group Type Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求读取特定组类型的所有属性值。</td>
      </tr>
      <tr>
          <td><strong>0x11</strong></td>
          <td>Read By Group Type Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Read By Group Type Request 的响应。</td>
      </tr>
      <tr>
          <td><strong>0x12</strong></td>
          <td>Write Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求写入属性值。</td>
      </tr>
      <tr>
          <td><strong>0x13</strong></td>
          <td>Write Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Write Request 的响应。</td>
      </tr>
      <tr>
          <td><strong>0x14</strong></td>
          <td>Write Command</td>
          <td>客户端 → 服务器</td>
          <td>客户端发送写入命令，无需服务器响应。</td>
      </tr>
      <tr>
          <td><strong>0x15</strong></td>
          <td>Signed Write Command</td>
          <td>客户端 → 服务器</td>
          <td>客户端发送带签名的写入命令，无需服务器响应。</td>
      </tr>
      <tr>
          <td><strong>0x16</strong></td>
          <td>Prepare Write Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端准备写入长属性值的部分数据。</td>
      </tr>
      <tr>
          <td><strong>0x17</strong></td>
          <td>Prepare Write Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Prepare Write Request 的响应。</td>
      </tr>
      <tr>
          <td><strong>0x18</strong></td>
          <td>Execute Write Request</td>
          <td>客户端 → 服务器</td>
          <td>客户端请求执行之前准备的写入操作。</td>
      </tr>
      <tr>
          <td><strong>0x19</strong></td>
          <td>Execute Write Response</td>
          <td>服务器 → 客户端</td>
          <td>服务器对 Execute Write Request 的响应。</td>
      </tr>
      <tr>
          <td><strong>0x1A</strong></td>
          <td>Handle Value Notification</td>
          <td>服务器 → 客户端</td>
          <td>服务器通知客户端某个属性值的变化，无需客户端确认。</td>
      </tr>
      <tr>
          <td><strong>0x1B</strong></td>
          <td>Handle Value Indication</td>
          <td>服务器 → 客户端</td>
          <td>服务器指示客户端某个属性值的变化，需要客户端确认。</td>
      </tr>
      <tr>
          <td><strong>0x1C</strong></td>
          <td>Handle Value Confirmation</td>
          <td>客户端 → 服务器</td>
          <td>客户端对 Handle Value Indication 的确认。</td>
      </tr>
  </tbody>
</table>
<p>在ATT协议中有两个两个重要的概念：</p>
<ol>
<li>UUID</li>
<li>Handle</li>
</ol>
<blockquote>
<p>[!important]</p>
<p>UUID是固定的，UUID代表了一个设备的有哪些ATT服务，而Handle是主机询问从机有哪些服务，之后将这些服务逐个分配Handle，之后要操作服务就可以通过操作Handle来进行。</p></blockquote>
<h3 id="uuid">
<a class="header-anchor" href="#uuid"></a>
UUID
</h3><p>UUID是Universally Unique IDentifier的缩写，翻译成中文为通用唯一标识符。是蓝牙组织联盟定义的用于区分蓝牙服务和特性的的标识符，总长度为128Bit。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">03B80E5A-EDE8-4B33-A751-6CE34EC4C700
</span></span><span class="line"><span class="cl">7772E5DB-3868-4112-A1A9-F2669D106BF3
</span></span></code></pre></div><p>128Bit的UUID占用16个字节，在传输的时候都很不方便，所以蓝牙联盟定义了一个UUID的基地址，允许在此基础上使用16Bit的UUID。</p>
<p>UUID基地址为：<code>0x0000xxxx-0000-1000-8000-00805F9B34FB</code>，其中的<code>xxxx</code>可以替换为16Bit的UUID，<code>0x2A37</code> 转换成128Bit的UUID为：</p>
<p><code>0x00002A37-0000-1000-8000-00805F9B34FB</code></p>
<p>对于16位的UUID，可参考<a href="https://www.bluetooth.com/specifications/assigned-numbers/">Assigned Numbers | Bluetooth® Technology Website</a>文件中的16位UUID部分。</p>
<h4 id="服务和特性">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%92%8c%e7%89%b9%e6%80%a7"></a>
服务和特性
</h4><p>低功耗蓝牙设备之间通信，都是基于服务和特性。一个蓝牙设备中可以包含若干个服务，一个服务中可以包含若干个特性，每一个服务或者特性都要有一个UUID。蓝牙的数据交互都是基于一个个特性进行的。数据交互的方式有五种，分别是</p>
<ol>
<li>Read</li>
<li>Write</li>
<li>Write Without Response（和Write一样，但是不需要主机回信）</li>
<li>Notify</li>
<li>Indication(和Notify一样，但是需要主机回信)</li>
</ol>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/01/6_15_23_25_202501061523073.png" alt="蓝牙服务和特性"></p>
<p>==每个服务和特性都有自己独有的UUID‼‼‼==，当我们需要使用服务的时候，步骤如下</p>
<ol>
<li>创建要使用的UUID；</li>
<li>使用UUID创建特性并设置特性的读写权限；</li>
<li>将创建好的特性添加到服务集合中；</li>
<li>将服务集合注册到协议栈中。</li>
</ol>
<p>比如我们要创建一个UUID为9011的服务，该服务里面包含两个特性：</p>
<p>这两个特性的UUID分别是9012和9013，9012的特性拥有Read和Write的权限，9013的特性拥有Read和Notify的权限。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/01/6_15_26_29_202501061526125.png" alt="创建一个特性的例子"></p>
<h3 id="handle">
<a class="header-anchor" href="#handle"></a>
Handle
</h3><p>参数的格式和操作码有关，参数中包含多个句柄：</p>
<ol>
<li>属性句柄</li>
<li>起始句柄</li>
<li>结束句柄</li>
</ol>
<blockquote>
<p>[!note]</p>
<p>句柄是用于==唯一==标识和操作属性数据库（Attribute Database）中属性的关键参数。</p></blockquote>
<h4 id="属性句柄attribute-handle">
<a class="header-anchor" href="#%e5%b1%9e%e6%80%a7%e5%8f%a5%e6%9f%84attribute-handle"></a>
属性句柄（Attribute Handle）
</h4><ul>
<li><strong>定义</strong>：每个属性（如特征值、服务声明等）在属性数据库中被分配的唯一16位标识符（0x0001~0xFFFF）。</li>
<li>作用：
<ul>
<li>用于精确访问或操作某个特定属性。</li>
<li>在ATT操作（如读、写、通知）中，通过属性句柄指定目标属性。</li>
</ul>
</li>
<li>示例：
<ul>
<li>读请求（Read Request）中会包含一个属性句柄，指明要读取哪个属性。</li>
</ul>
</li>
</ul>
<h4 id="起始句柄starting-handle">
<a class="header-anchor" href="#%e8%b5%b7%e5%a7%8b%e5%8f%a5%e6%9f%84starting-handle"></a>
起始句柄（Starting Handle）
</h4><ul>
<li><strong>定义</strong>：在范围操作（如发现服务、发现特征）中，表示搜索的起始属性句柄。</li>
<li>作用：
<ul>
<li>与<strong>结束句柄</strong>配合，定义一个属性句柄范围（区间）。</li>
<li>用于批量操作或遍历属性数据库。</li>
</ul>
</li>
<li>示例：
<ul>
<li>发现服务（Discover Services）时，客户端可能指定起始句柄为<code>0x0001</code>，结束句柄为<code>0xFFFF</code>，表示搜索整个数据库。</li>
</ul>
</li>
</ul>
<h4 id="结束句柄ending-handle">
<a class="header-anchor" href="#%e7%bb%93%e6%9d%9f%e5%8f%a5%e6%9f%84ending-handle"></a>
结束句柄（Ending Handle）
</h4><ul>
<li><strong>定义</strong>：在范围操作中，表示搜索的结束属性句柄。</li>
<li>作用：
<ul>
<li>与<strong>起始句柄</strong>共同限定一个属性句柄区间。</li>
<li>服务器返回该区间内符合条件的属性信息。</li>
</ul>
</li>
<li>示例：
<ul>
<li>若起始句柄为<code>0x0010</code>，结束句柄为<code>0x0020</code>，服务器会返回句柄在<code>0x0010</code>到<code>0x0020</code>之间的属性。</li>
</ul>
</li>
</ul>
<h4 id="示例">
<a class="header-anchor" href="#%e7%a4%ba%e4%be%8b"></a>
示例
</h4><p>==发现服务（Discover Services）==</p>
<p>客户端发送一个**“Read By Group Type Request”**，指定：</p>
<ul>
<li>起始句柄：<code>0x0001</code></li>
<li>结束句柄：<code>0xFFFF</code></li>
<li>类型：<code>Primary Service</code>（0x2800）</li>
</ul>
<p>服务器返回句柄范围内所有主服务的声明。</p>
<p>==发现特征（Discover Characteristics）==</p>
<p>客户端发送**“Read By Type Request”**，指定：</p>
<ul>
<li>起始句柄：<code>0x0010</code></li>
<li>结束句柄：<code>0x0020</code></li>
<li>类型：<code>Characteristic Declaration</code>（0x2803）</li>
</ul>
<p>服务器返回该范围内所有特征声明。</p>
<p>==读请求（Read Request）==</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Opcode: 0x0A (Read Request)
</span></span><span class="line"><span class="cl">参数: 属性句柄 = 0x0003
</span></span></code></pre></div><p>==发现服务请求（Read By Group Type Request）==</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Opcode: 0x10 (Read By Group Type Request)
</span></span><span class="line"><span class="cl">参数: 
</span></span><span class="line"><span class="cl">  起始句柄 = 0x0001
</span></span><span class="line"><span class="cl">  结束句柄 = 0xFFFF
</span></span><span class="line"><span class="cl">  类型 = 0x2800 (Primary Service)
</span></span></code></pre></div><h2 id="hci">
<a class="header-anchor" href="#hci"></a>
HCI
</h2><p>HCI PDU用于在蓝牙主机和控制器之间传输命令、事件和数据。其格式取决于数据包类型：</p>
<ul>
<li><strong>HCI Command Packet</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Packet</span> <span class="n">Type</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">Opcode</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Parameter</span> <span class="n">Length</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">Parameters</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div></li>
<li><strong>HCI ACL Data Packet</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Packet</span> <span class="n">Type</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">Handle</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Data</span> <span class="n">Length</span> <span class="p">(</span><span class="mi">2</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Data</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div></li>
<li><strong>HCI Event Packet</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Packet</span> <span class="n">Type</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">Event</span> <span class="n">Code</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">Parameter</span> <span class="n">Length</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">Parameters</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div></li>
</ul>
<h2 id="smp">
<a class="header-anchor" href="#smp"></a>
SMP
</h2><p>SMP PDU用于蓝牙设备之间的安全配对和加密。其格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">|</span> <span class="n">Code</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span> <span class="o">|</span> <span class="n">Data</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">|</span>
</span></span></code></pre></div><ul>
<li><strong>Code (1字节)</strong>：指示SMP操作类型（如配对请求、配对响应等）。</li>
<li><strong>Data (可变长度)</strong>：与操作相关的数据。</li>
</ul>
<h3 id="常见的code">
<a class="header-anchor" href="#%e5%b8%b8%e8%a7%81%e7%9a%84code"></a>
常见的code
</h3><table>
  <thead>
      <tr>
          <th>Code (Hex)</th>
          <th>PDU Type</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x01</td>
          <td>Pairing Request</td>
          <td>发起配对请求，包含主设备的配对参数（如IO能力、认证要求等）。</td>
      </tr>
      <tr>
          <td>0x02</td>
          <td>Pairing Response</td>
          <td>对配对请求的响应，包含从设备的配对参数。</td>
      </tr>
      <tr>
          <td>0x03</td>
          <td>Pairing Confirm</td>
          <td>在配对过程中确认生成的确认值。</td>
      </tr>
      <tr>
          <td>0x04</td>
          <td>Pairing Random</td>
          <td>在配对过程中传递随机数，用于生成确认值和短期密钥（STK）。</td>
      </tr>
      <tr>
          <td>0x05</td>
          <td>Pairing Failed</td>
          <td>配对失败时发送，包含失败原因代码。</td>
      </tr>
      <tr>
          <td>0x06</td>
          <td>Encryption Information</td>
          <td>传递长期密钥（LTK）信息。</td>
      </tr>
      <tr>
          <td>0x07</td>
          <td>Master Identification</td>
          <td>传递主设备的身份信息（如EDIV和随机数）。</td>
      </tr>
      <tr>
          <td>0x08</td>
          <td>Identity Information</td>
          <td>传递身份解析密钥（IRK）。</td>
      </tr>
      <tr>
          <td>0x09</td>
          <td>Identity Address Information</td>
          <td>传递设备的公共或静态地址。</td>
      </tr>
      <tr>
          <td>0x0A</td>
          <td>Signing Information</td>
          <td>传递签名密钥（CSRK）。</td>
      </tr>
      <tr>
          <td>0x0B</td>
          <td>Security Request</td>
          <td>从设备请求主设备启动配对或加密过程。</td>
      </tr>
      <tr>
          <td>0x0C</td>
          <td>Public Key</td>
          <td>在LE Secure Connections配对过程中传递公钥。</td>
      </tr>
      <tr>
          <td>0x0D</td>
          <td>DHKey Check</td>
          <td>在LE Secure Connections配对过程中传递DHKey检查值。</td>
      </tr>
      <tr>
          <td>0x0E</td>
          <td>Keypress Notification</td>
          <td>在配对过程中传递按键通知，用于带外（OOB）认证。</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>[!note]</p>
<ul>
<li><strong>Pairing Request/Response</strong>：用于交换配对参数，启动配对过程。</li>
<li><strong>Pairing Confirm/Random</strong>：用于生成确认值和短期密钥（STK）。</li>
<li><strong>Encryption Information/Master Identification</strong>：用于分发长期密钥（LTK）。</li>
<li><strong>Identity Information/Identity Address Information</strong>：用于身份解析和隐私保护。</li>
<li><strong>Security Request</strong>：从设备请求主设备启动安全过程。</li>
<li><strong>Public Key/DHKey Check</strong>：用于LE Secure Connections配对过程中的公钥交换和验证。</li>
<li><strong>Keypress Notification</strong>：用于带外（OOB）认证中的按键通知。</li>
</ul></blockquote>
<h3 id="不同的data格式">
<a class="header-anchor" href="#%e4%b8%8d%e5%90%8c%e7%9a%84data%e6%a0%bc%e5%bc%8f"></a>
不同的data格式
</h3><p>==Pairing Request (0x01) 和 Pairing Response (0x02)==</p>
<ul>
<li>
<p>IO Capability (1字节)：设备的输入输出能力（如显示、键盘等）。</p>
</li>
<li>
<p>OOB Data Flag (1字节)：指示是否使用带外（OOB）数据。</p>
</li>
<li>
<p>AuthReq (1字节)：认证要求（如MITM保护、绑定等）。</p>
<p>每位代表不同的含义：</p>
<table>
  <thead>
      <tr>
          <th>位（Bit）</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>Bonding Flag</td>
          <td>指示是否要求绑定（Bonding）。1 表示需要绑定，0 表示不需要。</td>
      </tr>
      <tr>
          <td>1</td>
          <td>MITM (Man-in-the-Middle) Flag</td>
          <td>指示是否需要 MITM 保护。1 表示需要，0 表示不需要。</td>
      </tr>
      <tr>
          <td>2</td>
          <td>SC (Secure Connections) Flag</td>
          <td>指示是否使用安全连接（LE Secure Connections）。1 表示使用，0 表示不使用。</td>
      </tr>
      <tr>
          <td>3</td>
          <td>Keypress Flag</td>
          <td>指示是否支持按键通知（Keypress Notification）。1 表示支持，0 表示不支持。</td>
      </tr>
      <tr>
          <td>4-7</td>
          <td>Reserved</td>
          <td>保留位，必须设置为 0。</td>
      </tr>
  </tbody>
</table>
<ol>
<li>
<p><strong>Bonding Flag（绑定标志）</strong>：</p>
<ul>
<li>如果设置为 1，表示设备在配对完成后需要保存配对信息（如长期密钥 LTK），以便后续重新连接时使用。</li>
<li>如果设置为 0，表示设备在配对完成后不会保存配对信息，连接断开后需要重新配对。</li>
</ul>
</li>
<li>
<p><strong>MITM Flag（中间人保护标志）</strong>：</p>
<ul>
<li>如果设置为 1，表示需要 MITM 保护，配对过程中会使用更强的认证方法（如 Passkey Entry 或 OOB）。</li>
<li>如果设置为 0，表示不需要 MITM 保护，配对过程可能使用 Just Works 方法。</li>
</ul>
</li>
<li>
<p><strong>SC Flag（安全连接标志）</strong>：</p>
<ul>
<li>如果设置为 1，表示使用 LE Secure Connections（蓝牙 4.2 及以上版本支持），配对过程会使用更强的加密算法（如 ECDH）。</li>
<li>如果设置为 0，表示使用传统配对方法（Legacy Pairing）。</li>
</ul>
</li>
<li>
<p><strong>Keypress Flag（按键通知标志）</strong>：</p>
<ul>
<li>如果设置为 1，表示设备支持在配对过程中发送按键通知（Keypress Notification），用于 Passkey Entry 方法。</li>
<li>如果设置为 0，表示不支持按键通知。</li>
</ul>
</li>
<li>
<p><strong>Reserved（保留位）</strong>：</p>
<ul>
<li>这些位必须设置为 0，供未来扩展使用。</li>
</ul>
</li>
</ol>
<p>典型值示例：</p>
<ol>
<li>
<p><strong>仅绑定，无 MITM 保护，传统配对</strong>：</p>
<ul>
<li>Bonding Flag = 1</li>
<li>MITM Flag = 0</li>
<li>SC Flag = 0</li>
<li>Keypress Flag = 0</li>
<li>值：<code>0x01</code></li>
</ul>
</li>
<li>
<p><strong>绑定 + MITM 保护，传统配对</strong>：</p>
<ul>
<li>Bonding Flag = 1</li>
<li>MITM Flag = 1</li>
<li>SC Flag = 0</li>
<li>Keypress Flag = 0</li>
<li>值：<code>0x03</code></li>
</ul>
</li>
<li>
<p><strong>绑定 + MITM 保护 + 安全连接</strong>：</p>
<ul>
<li>Bonding Flag = 1</li>
<li>MITM Flag = 1</li>
<li>SC Flag = 1</li>
<li>Keypress Flag = 0</li>
<li>值：<code>0x07</code></li>
</ul>
</li>
<li>
<p><strong>绑定 + MITM 保护 + 安全连接 + 按键通知</strong>：</p>
<ul>
<li>Bonding Flag = 1</li>
<li>MITM Flag = 1</li>
<li>SC Flag = 1</li>
<li>Keypress Flag = 1</li>
<li>值：<code>0x0F</code></li>
</ul>
</li>
</ol>
</li>
<li>
<p>Max Encryption Key Size (1字节)：最大加密密钥长度。</p>
</li>
<li>
<p>Initiator Key Distribution (1字节)：发起方的密钥分发信息。</p>
</li>
<li>
<p>Responder Key Distribution (1字节)：响应方的密钥分发信息。</p>
</li>
</ul>
<p>==Pairing Confirm (0x03)==</p>
<ul>
<li><strong>Confirm Value (16字节)</strong>：确认值，用于验证配对过程。</li>
</ul>
<p>==Pairing Random (0x04)==</p>
<ul>
<li><strong>Random Value (16字节)</strong>：随机数，用于生成确认值和短期密钥（STK）。</li>
</ul>
<p>==Pairing Failed (0x05)==</p>
<ul>
<li><strong>Reason (1字节)</strong>：配对失败的原因代码（如Passkey Entry Failed、OOB Not Available等）。</li>
</ul>
<p>==Encryption Information (0x06)==</p>
<ul>
<li><strong>Long Term Key (16字节)</strong>：长期密钥（LTK）。</li>
</ul>
<p>==Master Identification (0x07)==</p>
<ul>
<li><strong>EDIV (2字节)</strong>：加密分频器。</li>
<li><strong>Random (8字节)</strong>：随机数。</li>
</ul>
<p>==Identity Information (0x08)==</p>
<ul>
<li><strong>Identity Resolving Key (IRK) (16字节)</strong>：身份解析密钥。</li>
</ul>
<p>==Identity Address Information (0x09)==</p>
<ul>
<li><strong>Address Type (1字节)</strong>：地址类型（如公共地址或静态地址）。</li>
<li><strong>Address (6字节)</strong>：设备的公共或静态地址。</li>
</ul>
<p>==Signing Information (0x0A)==</p>
<ul>
<li><strong>Connection Signature Resolving Key (CSRK) (16字节)</strong>：连接签名解析密钥。</li>
</ul>
<p>==Security Request (0x0B)==</p>
<ul>
<li><strong>AuthReq (1字节)</strong>：认证要求（如MITM保护、绑定等）。</li>
</ul>
<ol start="11">
<li>Public Key (0x0C)</li>
</ol>
<ul>
<li><strong>Public Key (64字节)</strong>：设备的公钥。</li>
</ul>
<p>==DHKey Check (0x0D)==</p>
<ul>
<li><strong>DHKey Check Value (16字节)</strong>：DHKey检查值。</li>
</ul>
<p>==Keypress Notification (0x0E)==</p>
<ul>
<li><strong>Notification Type (1字节)</strong>：按键通知类型（如Passkey Entry Started、Passkey Digit Entered等）。</li>
</ul>
<h1 id="通信过程">
<a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e8%bf%87%e7%a8%8b"></a>
通信过程
</h1><blockquote>
<p>假设现在有一个手机A和一个蓝牙设备B（单片机型号为Nordic_HRM），现在将要建立两者的连接。</p></blockquote>
<p>蓝牙的链路层的状态机有五种状态：</p>
<ol>
<li>就绪态</li>
<li>广播态</li>
<li>链接态</li>
<li>扫描态</li>
<li>发起链接态</li>
</ol>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/01/6_13_59_0_202501061359145.png" alt="状态转换"></p>
<p>以手机连接某个蓝牙模块为例，手机作为主机设备，蓝牙模块作为从机设备。上电之后二者都将处于==就绪态==，蓝牙模块设置广播数据并开始广播后将转换到==广播态==；手机扫描附近范围内的蓝牙设备时，手机将处于==扫描态==，手机尝试连接某个设备时，手机的蓝牙处于==发起连接态==，连接成功后，二者将都处于==链接态==。</p>
<p>断开连接之后，二者将都再回到==就绪态==！</p>
<h2 id="广播">
<a class="header-anchor" href="#%e5%b9%bf%e6%92%ad"></a>
广播
</h2><p>在手机A(Observer)跟设备B建立连接之前，设备B需要先进行广播，即设备B（Advertiser）不断发送如下广播信号，t为广播间隔。每发送一次广播包，我们称其为一次广播事件（advertising event），因此t称为广播事件间隔。虽然图中广播事件是用一根线来表示的，但实际上广播事件是有一个持续时间的，蓝牙芯片只有在广播事件期间才打开射频模块，这个时候功耗比较高，其余时间蓝牙芯片都处于idle状态，因此平均功耗非常低，以Nordic nRF52810为例，每1秒钟发一次广播，平均功耗不到11uA。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/16_17_2_2_202412161702884.png" alt="广播案例"></p>
<p>上面只是一个概略图，按照蓝牙spec，实际上每一个广播事件包含三个广播包，即分别在37/38/39三个射频通道上同时广播相同的信息，即真正的广播事件是下面这个样子的。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/16_17_4_8_202412161704241.png" alt="真实的广播事件"></p>
<p>设备B不断发送广播信号给手机（Observer），如果手机不开启扫描窗口，手机是收不到设备B的广播的，如下图所示，不仅手机要开启射频接收窗口，只有手机的射频接收窗口跟广播发送的发射窗口匹配成功，且广播射频通道和手机扫描射频通道是同一个通道，手机才能收到设备B的广播信号。也就是说，如果设备B在37通道发送广播包，而手机在扫描38通道，那么即使他们俩的射频窗口匹配，两者也是无法进行通信的。由于这种匹配成功是一个概率事件，因此手机扫到设备B也是一个概率事件。也就是说，手机有时会很快扫到设备B，比如只需要一个广播事件，手机有时又会很慢才能扫到设备B，比如需要10个广播事件甚至更多。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/17_13_9_27_202412171309770.png" alt="匹配成功案例"></p>
<blockquote>
<p>[!tip]</p>
<p>在蓝牙通信中，射频通道37、38和39被称为主要广播信道（Primary Advertising Channels），它们在低功耗蓝牙（Bluetooth Low Energy, BLE）技术中具有特定的作用和意义。</p>
<ol>
<li>
<p><strong>定义与用途</strong>：</p>
<ul>
<li>这三个信道主要用于设备的发现、连接建立以及广播数据等过程。具体来说，它们用于传输广播包、扫描请求、扫描响应和连接请求。</li>
<li>广播信道的设计目的是为了确保广播的可靠性，并尽量避开Wi-Fi使用的信道，从而减少干扰。</li>
</ul>
</li>
<li>
<p><strong>频率分布</strong>：</p>
<ul>
<li>通道37的中心频率为2402 MHz，通道38的中心频率为2426 MHz，通道39的中心频率为2480 MHz。</li>
<li>这些信道分布在不同的频率范围内，以避免相邻信道之间的干扰。</li>
</ul>
</li>
<li>
<p><strong>技术细节</strong>：</p>
<ul>
<li>在广播过程中，设备会在这三个信道上循环发送广播包，每次只在一个信道上传送一个广播包的副本。</li>
<li>广播信道的选择是随机的，以进一步降低冲突的可能性。</li>
<li>广播包可以包含设备地址、设备名称等信息，并且可以指定是否允许连接。</li>
</ul>
</li>
<li>
<p><strong>与其他信道的关系</strong>：</p>
<ul>
<li>除了这三个广播信道外，剩余的37个信道被称为通用信道（General Purpose Channels），用于已连接设备之间的双向通信。</li>
<li>在BLE协议中，这些通用信道也可以用于辅助广播，特别是在扩展广播模式下。</li>
</ul>
</li>
</ol></blockquote>
<h2 id="扫描请求和扫描响应">
<a class="header-anchor" href="#%e6%89%ab%e6%8f%8f%e8%af%b7%e6%b1%82%e5%92%8c%e6%89%ab%e6%8f%8f%e5%93%8d%e5%ba%94"></a>
扫描请求和扫描响应
</h2><p>蓝牙设备除了可以通过上述方式，主动的发射广播数据外，还可以接受其他设备的扫描请求，从而响应额外的数据，二者的区别如下:</p>
<ul>
<li>广播是蓝牙从机设备主动发出的数据。</li>
<li>而扫描响应是， 当蓝牙主机收到从机的广播数据后，如果想要进一步了解该从机设备的信息，可以向从机设备发送扫描请求，从机收到扫描请求后，向对应的主机回复扫描响应。</li>
</ul>
<pre class="mermaid">sequenceDiagram

蓝牙从机 ->> 蓝牙主机:广播（advertises）
蓝牙主机 ->> 蓝牙从机:扫描请求（scan request）
蓝牙从机 ->> 蓝牙主机:扫描响应（scan response）
</pre>
<p>扫描响应的数据格式和蓝牙广播的数据格式完全一样，其作用也基本一样，那为什么还要设置这么一个扫描响应数据呢？</p>
<p>我们前文中讲到，蓝牙的广播数据最多是31个字节，如果广播数据太多，这31个字节装不下时，我们就可以将一部分不太重要的数据放到扫描响应数据里面，来分担广播数据的工作。</p>
<p>一 次广播的过程如下：</p>
<pre class="mermaid">sequenceDiagram
蓝牙从机 ->> 蓝牙主机:广播
note right of 蓝牙从机:数据为：d6be898e 200d 2b33363432c1 02010600200302fffe 64e3f4 
note right of 蓝牙从机:0xd6be898e：广播ID（access address）
note right of 蓝牙从机:0x200d：packet Header，其中，20：低四位（0）是PDU类型（ADV_IND）。0d：表示长度为13（地址+数据）
note right of 蓝牙从机:0x2b33363432c1：自身地址
note right of 蓝牙从机:02010600200302fffe：使用TVL格式数据
note right of 蓝牙从机:0x64e3f4：校验码

蓝牙主机 ->> 蓝牙从机:扫描请求
note left of 蓝牙主机:数据为：d6be898e 430c ad856cc81e74 2b33363432c1 50fe84
note left of 蓝牙主机:0xd6be898e：广播ID（access address）
note left of 蓝牙主机:0x430c：packet Header
note left of 蓝牙主机:0xad856cc81e74：扫描地址（scanning address）
note left of 蓝牙主机:2b33363432c1：自身地址
note left of 蓝牙主机:0x50fe84：校验码

蓝牙从机 ->> 蓝牙主机:扫描响应
note right of 蓝牙从机:数据为：d6be898e 041c 2b33363432c1 120953696d706c655f5065726970686572616c020a00 d73e88
note right of 蓝牙从机:0xd6be898e：广播ID（access address）
note right of 蓝牙从机:0x041c：packet Header
note right of 蓝牙从机:0x2b33363432c1：自身地址
note right of 蓝牙从机:120953696d706c655f5065726970686572616c020a00：使用TVL格式数据（Simple_Peripher）
note right of 蓝牙从机:0xd73e88：校验码
</pre>
<blockquote>
<p>[!tip]</p>
<p>上图中的一些参数没有进行解释，只展示了较为重要部分的解析，具体每个数据位的含义可见<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/bluetooth/##PDU%e6%a0%bc%e5%bc%8f">PDU格式</a></p>
<p>建议将该过程使用wireShark进行解析。</p>
<p>上述按照小端数据放置</p></blockquote>
<h2 id="建立连接">
<a class="header-anchor" href="#%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5"></a>
建立连接
</h2><p>应付比广播更为复杂的数据传输，或者要在设备之间实现可靠的数据交付，这些都要依赖于连接。连接使用数据信道在两个设备之间可靠地发送信息。它采取了自适应跳频增强鲁棒性，同时使用了非常低的占空比，尽可能地降低功率消耗。</p>
<p>设备创建连接的过程如下图所示。简言之，设备首先广播可连接广播事件，其他设备收到之后即可发起连接。在此过程中，广播者发送的事件类型要么是通用广播事件，要么是直接广播事件。发起者收到正确的广播报文时，将向广播者发送一个连接请求，其中包括了连接开始时需要的所有信息。</p>
<pre class="mermaid">sequenceDiagram
广播者->> 发起者:广播指示
发起者->> 广播者:连接请求
</pre>
<pre class="mermaid">sequenceDiagram
从设备->> 主设备:数据报文
主设备->> 从设备:数据报文
</pre>
<p>更为详细如下：</p>
<pre class="mermaid">flowchart TB
	创建连接 --> step2{{特征交换-可选}} --> 连接请求 --> step4{{角色转换-可选}} --> step5{{AFH-可选}} --> step6{{安全加密-可选}}
	step6 --> step7a{{配对-可选}}
	step6 --> step7b{{认证-可选}}
	step7a --> step8{{加密-可选}}
	step7b --> step8
	step8 --> 设置完成 --> step10{{传输数据}} --> 断开连接
	
</pre>
<p>连接过程中涉及以下名词：</p>
<ol>
<li>连接中使用的接入地址</li>
<li>CRC初始值</li>
<li>发送窗口</li>
<li>连接事件和连接参数</li>
<li>自适应跳频信道图</li>
<li>睡眠时钟精度</li>
</ol>
<p>==接入地址==</p>
<p>连接使用的接入地址总是由主设备来提供。地址通过随机生成，但是需要遵循一些规则。如果主设备有多个从设备，它会为每个从设备选择不同的随机接入地址。地址的随机性确保了在不同的主从设备之间发生的碰撞概率会很低。随机性也增强了隐私，扫描者无法得知是哪两个设备正在通信。</p>
<blockquote>
<p>[!important]</p>
<p>注意：这里的接入地址相当于两台蓝牙设备之间的连接通道，主设备和从设备都使用该地址就可以看成是点对点的通信。</p></blockquote>
<p>==CRC初始值==</p>
<p>CRC初始值是另一个由主设备提供的随机数。随机的意义在于，如果在同一个区域有两个主设备正在和不同从设备通信，那么使用相同的接入地址的概率将会很低。如果确实发生了这种情况，从设备会从错误的主设备收到干扰数据包。因此，为每个从设备设置随机的CRC初始值，主从设备既有相同的接入地址又有相同的CRC初始值的概率就会变得微乎其微。</p>
<p>==发送窗口==</p>
<p>从设备可以自行决定广播的时间，它们是最需要保存电量的设备，这样的设计并无不妥。但是，如果主设备已经在做其他事情，也许是一些更重要的事情，那么它必须让低功耗蓝牙错开当前的活动。在连接建立期间，有两个参数用来传递上述信息：</p>
<ol>
<li>窗口大小</li>
<li>窗口间隔。</li>
</ol>
<p>当连接请求数据包发送完毕，存在一个1.25ms的强制时延，紧接着是发送窗口偏移和发送窗口。发送窗口偏移可以是0到连接间隔之间的任意值，但必须为1.25ms的整数倍。从发送窗口开始，从设备打开其接收器，并等待来自主设备的数据包。如果到发送窗口结束时仍未收到数据包，从设备终止侦听，并会在一个连接的间隔后再次尝试。</p>
<blockquote>
<p>[!note]</p>
<p>关于连接过程，最有趣的一个地方是，一旦发送了连接请求，主设备便认为自身有了连接；该连接已经创建（created），但还不能算是完全确立（established）。当从设备收到连接请求时，它也认为自己已经处在连接之中；连接已经创建，但不能证明完全确立。</p></blockquote>
<p>出于效率的考虑，连接已经创建，主机就会立即收到通知。连接可能不会成功，从设备也许收不到连接请求，或者两个设备的距离很远。这些情况如果发生，连接失败的概率将变得很高。然而，由于主机收到了连接已创建的通知，它可以开始将数据发给控制器从而为首个无线数据包的传输做好准备，并且节约时间和能量。因为第一个数据包的发送至少会在1.25ms延迟之后，主机堆栈应该有足够的时间向控制器提供数据，以便在第一时间发送出去。这种强制性的延迟为设备提供了喘息的机会：在繁重的广播规程与连接正式确立之间，电池获得了宝贵的恢复时间。</p>
<p>只有收到了数据包确认，连接才能视为正式确立。确立不改变连接的工作方式，但它改变了链路监控超时的时间从之前的6个连接间隔，变为了在连接请求中设定的值。这样一来，如果连接不能迅速确立的话将会立即终止。</p>
<p>根据蓝牙spec规定，advertiser发送完一个广播包之后150us（T_IFS），advertiser必须开启一段时间的射频Rx窗口，以接收来自observer的数据包。Observer就可以在这段时间里给advertiser发送连接请求。</p>
<p>如下图所示，手机在第三个广播事件的时候扫到了设备B，并发出了连接请求CONN_REQ(CONN_REQ又称为CONNECT_IND)。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/17_13_24_26_202412171324934.png" alt="建立连接过程"></p>
<p>上图的交互流程比较粗略，为此我们引入下图，以详细描述连接建立过程。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/17_13_28_13_202412171328413.png" alt="连接建立过程"></p>
<blockquote>
<p>[!note]</p>
<p>图中M<strong>代表手机，S</strong>代表设备B**，M-&gt;S<strong>表示手机将数据包发给设备B</strong>，即手机开启Tx<strong>窗口，设备B</strong>开启Rx<strong>窗口；S-&gt;M</strong>正好相反，表示设备B<strong>将数据包发给手机，即设备B</strong>开启Tx**窗口，手机开启Rx窗口。</p></blockquote>
<p>如图所示，手机在收到A1广播包ADV_IND后，以此为初始锚点（这个锚点不是连接的锚点），T_IFS时间后给Advertiser发送一个connection request命令，即A2数据包，告诉advertiser我将要过来连你，请做好准备。Advertiser根据connect_req命令信息做好接收准备。</p>
<ol>
<li>connect_req其实是在告诉advertiser，手机将在Transmit Window期间发送第一个同步包（P1）给你，请在这段时间里把你的射频接收窗口打开。</li>
<li>设备B收到P1后，==T_IFS==时间后将给手机回复数据包P2（ACK包）。</li>
<li>一旦手机收到数据包P2，连接即可认为建立成功。</li>
<li>当然，实际情况会比较复杂，手机有可能收不到P2，这个时候手机将持续发送同步包直到超时时间（supervision timeout）到，在此期间只要设备B回过一次ACK包，连接即算成功。所以一旦P1包发出，主机（手机）即认为连接成功，而不管有没有收到设备的ACK包。这也是为什么在Android或者iOS系统中，应用经常收到连接成功的回调事件（该回调事件就是基于P1包有没有发出，只要P1包发出，手机即认为连接成功，而不管有没有收到设备的ACK包），但实际上手机和设备并没有成功建立连接。后续手机将以P1为锚点（原点），Connection Interval为周期，周期性地给设备B发送数据包（Packet），Packet除了充当数据传送功能，它还有如下两个非常重要的功能：
<ol>
<li>同步手机和设备的时钟，也就是说，设备每收到手机发来的一个包，都会把自己的时序原点重新设置，以跟手机同步。</li>
<li>告诉设备你现在可以传数据给我了。连接成功后，BLE通信将变成主从模式，因此把连接发起者（手机）称为Master或者Central，把被连接者（之前的Advertiser）称为Slave或者Peripheral。BLE通信之所以为主从模式，是因为Slave不能“随性”给Master发信息，它只有等到Master给它发了一个packet后，然后才能在规定的时间把自己的数据回传给Master。</li>
</ol>
</li>
</ol>
<p>连接过程如下：</p>
<pre class="mermaid">sequenceDiagram
蓝牙从机 ->> 蓝牙主机:广播
note right of 蓝牙从机:数据为：d6be898e 200d 2b33363432c1 02010600200302fffe 64e3f4 
note right of 蓝牙从机:0xd6be898e：广播ID（access address）
note right of 蓝牙从机:0x200d：packet Header，其中，20：低四位（0）是PDU类型（ADV_IND）。0d：表示长度为13（地址+数据）
note right of 蓝牙从机:0x2b33363432c1：自身地址
note right of 蓝牙从机:02010600200302fffe：使用TVL格式数据
note right of 蓝牙从机:0x64e3f4：校验码

蓝牙主机 ->> 蓝牙从机:连接请求
note left of 蓝牙主机:数据为：d6be898e 6522 ad856cc81e74 2b33363432c1 9ee8d2e5d085c102120018000000f40180ff03001ea6 8b3eaf
note left of 蓝牙主机:0xd6be898e：广播ID（access address）
note left of 蓝牙主机:0x6522：packet Header
note left of 蓝牙主机:0xad856cc81e74：发起者地址（Initiator address）
note left of 蓝牙主机:0x2b33363432c1：自身地址(advertising address)
note left of 蓝牙主机:9ee8d2e5d085c102120018000000f40180ff03001ea6:LL Data，格式解析请见表格
note left of 蓝牙主机:0x50fe84：校验码
</pre>
<blockquote>
<p>[!important]</p>
<p>注意：前两帧报文还在进行广播，通信通道还在37，38，39</p>
<p>==当两个设备连接成功之后，两设备就会使用同一个Access address（访问地址）==</p></blockquote>
<p>==自适应跳频信道==</p>
<p>自适应跳频信道图是数据信道的位掩码，用来标记信道的好坏。由于共有37个数据信道，信道图的长度于是设为37位。如果某一位被设置为1，表明该信道良好，可用于数据通信；如果该位为0，表明该信道很糟，不可用于数据通信。</p>
<p>跳频算法的跳数值是在5 ~ 16之间的一个随机数。跳数值被用在自适应重映射之前的跳频算法中。显然，跳数值不能为0，否则频率永远不会改变。</p>
<p>非常低的跳数也是不可取的，因为大多数的干扰一般会占据好几兆带宽，使用非常小的跳数值将不会快速地将传输带离干扰源，可能造成持续干扰。同样的逻辑也适用于17或更高的值。试想，如果增量为17，由于跳频算法中要对37个信道取模，每两个频率之间的差距将紧紧只有3个信道。</p>
<p>==睡眠时钟精度==</p>
<p>主设备发往从设备的信息中还包括睡眠时间精度值。该值定义了时钟能够保证的精度范围。如果时钟由晶振提供，晶振有一个根据温度变化的精度范围，比如在室温下为 20ppm，在 0℃ 或 85℃ 时为 50ppm 。如此一来，设备可以声明其时钟精度达到 50ppm 。</p>
<p>时钟精度可以帮助从设备消除连接事件的不稳定性。如果从设备与主设备的不同步时间达到 1s，而这两个设备的定时精度均为 500ppm，那么，将合并的不确定性 1000ppm 乘以上述时间，就得到一个 1ms 的不确定窗口。也就是说，从设备必须提早 1ms醒来，并在这额外的 1ms 内保持侦听，以防主设备和从设备的时钟在不同的方向发生了最大漂移。</p>
<p>更精确的时钟可以降低功耗。还是以使用晶振的设备为例，如果两个设备的时钟精度分别为 50ppm 和 150ppm ，二者合并后的精度只有 200ppm 。一秒钟之后，从设备只需要提前 200μs 醒来并保持侦听。如果设备被唤醒的频率不高，他们的可用工作时间将 5 倍于两个使用 500ppm 晶振的设备。因此，如果对降低功耗有特别的要求，建议在设备中使用高精度的晶振。</p>
<h2 id="连接事件">
<a class="header-anchor" href="#%e8%bf%9e%e6%8e%a5%e4%ba%8b%e4%bb%b6"></a>
连接事件
</h2><p>连接成功后，master和slave在每一个connection interval开始的时候，都必须交互一次（等待150us后再次发送），即master给slave发一个包，slave再给master发一个包，整个交互过程称为一个connection event或者gap event。蓝牙芯片只有在connection event期间才把射频模块打开，此时功耗比较高，其余时间蓝牙芯片都是处于idle状态的，因此蓝牙芯片平均功耗就非常低，以Nordic nRF52810为例，每1秒钟Master和Slave通信1次，平均功耗约为6微安左右。Master不可能时时刻刻都有数据发给slave，所以master大部分时候都是发的==空包==（empty packet）给slave。同样slave也不是时时刻刻都有数据给master，因此slave回复给master的包大部分时候也是空包。另外在一个connection event期间，master也可以发多个包给slave，以提高吞吐率。综上所述，连接成功后的通信时序图应该如下所示：</p>
<p>下图中每个连接事件都只发了一个包：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/17_15_0_56_202412171500648.png" alt="单包通信时序图"></p>
<blockquote>
<p>[!tip]</p>
<p>举个例子，如果连接间隔为 100ms，从设备延迟是 9，那么从设备可以忽略 9 个链接事件，但不得不侦听第 10 个连接事件。换言之，从设备必须每秒侦听一次，而此时监控超时的最小值应为 1010ms。反过来，另一个极端的例子是，如果监控超时使用了 32s 的最大值，对于间隔为 100ms 的链路，从设备延时必须小于等于 319。</p>
<p>虽然如此，如果将从设备延迟设为可行的最大值，在监控超时发生前从设备只能获得唯一一次侦听主设备的机会，这可不是一个好主意。因此，建议至少给从设备留出 6 次侦听的机会。在前面的例子中，如果连接间隔为 100ms ，从设备延迟为 9，那么监控超时应该至少为 6s，这样一来，链路在最终断开前从设备至少会有 6 次侦听的机会。</p></blockquote>
<p>主设备和从设备建立连接之后，所有的数据通信都是在连接事件中进行的。下图中每个连接事件可能发多个包（其中绿色部分就是发送事件）：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/17_15_2_51_202412171502602.png" alt="多包通信时序图"></p>
<p>连接事件细节图：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/17_15_4_8_202412171504421.png" alt="连接事件细节图"></p>
<p>在一个事件间隔内，可以进行一个或多个事件发送，剩下的时间都是睡眠时间。每个连接事件中，都需要由Master发起包，再由Slave回复。</p>
<blockquote>
<p>[!note]</p>
<p>上图中出现了slave latency（slave latency = 1），那么什么叫slave latency？</p>
<p>如前所述，在每一个connection interval开始的时候，Master和Slave必须交互一次，哪怕两者之间交互的是empty packet（空包），但如果slave定义了slave latency，比如slave latency = 9，此时slave可以每9个connection interval才回复一次master，也就是说slave可以在前面8个connection interval期间一直睡眠，直到第9个connection interval到来之后，才回复一个packet给master，这样将大大节省slave的功耗，提高电池续航时间。当然如果slave有数据需要上报给master，它也可以不等到第9个connection interval才上报，直接像正常情况进行传输即可，这样既节省了功耗，又提高了数据传输的实时性。</p></blockquote>
<p>可以通过以下四个参数修改BLE连接过程中的传输速度和功耗：</p>
<table>
  <thead>
      <tr>
          <th>参数名称</th>
          <th>取值范围</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>IntervalMin</td>
          <td>6-3200</td>
          <td>连接事件的间隔最小值</td>
      </tr>
      <tr>
          <td>IntervalMax</td>
          <td>6-3200</td>
          <td>连接事件的间隔最大值</td>
      </tr>
      <tr>
          <td>connectLatency</td>
          <td>0-499</td>
          <td>允许Slave（从设备）在没有数据要发的情况下，跳过一定数目的连接事件（Connection events），在这些连接事件（Connection events）中不必回复Master（主设备）的包。</td>
      </tr>
      <tr>
          <td>supervision Timeout</td>
          <td>10-3200</td>
          <td>这个参数设定了一个超时时间，如果BLE在这个时间内没有发生通信的话，就会自动断开。单位是 10ms，该变量的范围是10 ~ 3200，折算成时间范围是100ms ~ 32s 。</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>[!tip]</p>
<p>这个连接间隔就是指在一个连接事件（Connection events）的开始到下一个连接事件（Connection events）的开始的时间间隔。连接间隔以1.25ms为单元，连接间隔的范围是6 ~ 3200既7.5ms ~ 4s之间。</p>
$$
> Supervision Timeout  > （1 +slaveLatency）* （connectionInterval）
> $$<p>
上述公式必须满足，否则连接就会不正常断开。</p></blockquote>
<h2 id="配对和绑定">
<a class="header-anchor" href="#%e9%85%8d%e5%af%b9%e5%92%8c%e7%bb%91%e5%ae%9a"></a>
配对和绑定
</h2><p>低功耗蓝牙的安全机制建立在三个主要支柱之上：</p>
<ol>
<li>加密</li>
<li>数据签名</li>
<li>设备隐私</li>
</ol>
<p>==加密==</p>
<p>加密是任何安全通信的核心，蓝牙 LE 也不例外。它采用对称密钥分组密码系统，即高级加密标准 (AES)，密钥长度为 128 位。如果使用得当，它的抵抗所有已知实际攻击的能力是得到普遍认可的。</p>
<p>在蓝牙 LE 中，加密过程涉及长期密钥 (LTK)，它是两个连接设备共享和存储的秘密密钥。该密钥在配对过程中生成，并在 AES-CCM 加密算法中用于加密和解密数据。</p>
<p>具体来说，在加密过程中，使用 AES-CCM 算法将明文数据与 LTK 相结合，生成密文——加扰的、不可读的数据。只有拥有相应LTK的设备才能解密并访问原始信息。</p>
<p>LTK 是一个 128 位密钥，与 AES-CCM（下图）加密方法一起使用，用于执行三项主要任务：</p>
<ul>
<li>创建唯一的密钥流：这是使用 LTK 制作特殊的一次性密钥流的第一步。该密钥流有时称为随机数，是随机数或近随机数。与 LTK 结合使用时，它有助于确保加密过程安全且难以破解。</li>
<li>加密数据：创建密钥流后，使用 AES-CCM 加密方法来保护数据。 AES-CCM 读取位于设备 RAM 中的未加密数据包，对数据包进行加密，并向数据包附加一个四字节长的消息完整性检查 (MIC) 字段。该 MIC 字段通过检查消息的完整性和真实性来增强安全性。 AES-CCM 还会调整数据包的长度以考虑额外的 MIC 字段。然后，加密的数据包将存储回设备的内存中。</li>
<li>解密数据：在最后一步中，AES-CCM 查看设备内存中的加密数据包，对其进行解密，并验证数据包的 MIC 字段，从而生成正确的 MIC 状态。数据包的长度针对 MIC 字段进行了调整，将其减少了四个字节。然后，解密的数据包被存储回设备的存储器中。</li>
</ul>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2025/02/28_8_8_48_202502280808121.png" alt="AES-CCM身份验证机制"></p>
<p>==数据签名==</p>
<p>蓝牙 LE 还通过数据签名确保数据完整性和真实性。这种安全措施保证数据在传输过程中不被篡改并且来自合法来源。</p>
<p>连接签名解析密钥（CSRK）在这方面至关重要。当设备有数据要发送时，它会使用 CSRK 生成签名并将其附加到数据中。然后，接收设备使用相同的 CSRK 为接收到的数据生成自己的签名。如果生成的签名与附加到数据的签名相匹配，则确认数据的完整性和真实性。</p>
<p>==设备隐私==</p>
<p>蓝牙 LE 引入了通过可解析私有地址 (RPA) 来保护设备隐私的措施。这些临时且可变的蓝牙设备地址使得恶意观察者很难根据设备的地址长期跟踪设备。</p>
<p>此过程利用身份解析密钥 (IRK)，这是另一个 128 位安全密钥。 IRK 用于生成 RPA 并根据给定的 RPA 解析设备的身份。它确保只有受信任的设备才能从其 RPA 解析设备的真实身份，从而防止未经授权的跟踪。</p>
<hr>
<p>这些过程利用不同的安全密钥来确保数据保护和设备隐私,Paring/bonding是蓝牙security manager（SM）的一部分，SM定义了蓝牙通信的安全框架，里面涉及安全架构，密码工具箱，paring协议等，其中paring协议是关键，所以我们经常把paring和SM二者等价。</p>
<p>Paring（配对）和bonding（绑定）是实现蓝牙射频通信安全的一种机制，有两点需要注意：</p>
<ol>
<li>一是paring/bonding实现的是蓝牙链路层的安全，对应用来说完全透明，也就是说，不管有没有paring/bonding，你发送或接收应用数据的方式是一样的，不会因为加了paring/bonding应用数据传输需要做某些特殊处理；</li>
<li>二安全有两种选项：加密或者签名，目前绝大多数应用都是选择加密。实现蓝牙通信安全，除了paring/bonding这种底层方式，用户也可以在应用层去实现相同功能，两者从功能上和安全性上没有本质区别，只不过应用层自己实现的话，需要自己选择密码算法，密钥生成，密钥交换等，如果你不是这方面的专家，你的应用就有可能会存在安全漏洞。Paring/bonding则把上述过程标准化，放在了蓝牙协议栈中，并且其安全性得到了充分评估，用户可以 “无感的” 用上安全的蓝牙通信。</li>
</ol>
<blockquote>
<p>[!tip]</p>
<p><strong>Bonding（绑定）</strong>:配对过程中会生成一个长期密钥（LTK，long-term Key），如果配对双方把这个LTK存储起来放在Flash中，那么这两个设备<strong>再次重连</strong>的时候，就可以跳过配对流程，而直接使用LTK对蓝牙连接进行加密，设备的这种状态称为bonding。如果paring过程中不存储LTK（不分发LTK）也是可以的，paring完成后连接也是加密的，但是如果两个设备再次重连，那么就需要重走一次paring流程，否则两者还是明文通信。在不引起误解的情况下，我们经常把paring当成paring和bonding两者的组合，因为只paring不bonding的应用情况非常少见。<strong>在不引起混淆的情况下，下文就不区分paring和bonding的区别，换句话说，我们会把paring和bonding两个概念等同起来进行混用。</strong></p></blockquote>
<p>执行配对以建立密钥，再使用密钥加密链接。然后执行特定于传输的密钥分发来共享密钥。而低功耗蓝牙的安全机制密钥可用于在将来重新连接时加密链接、验证签名数据或执行随机地址解析。一般来说，配对有三个阶段。</p>
<ol>
<li>阶段1： 配对特性交换，即交换各自都支持哪些配对特性，比如支不支持SC，支不支持MITM，支不支持OOB，以及它的输入输出能力等</li>
<li>阶段2：密钥生成</li>
</ol>
<ul>
<li>(LE legacy pairing):短期密钥(STK)生成</li>
<li>(LE Secure Connections):长期密钥(LTK)生成</li>
</ul>
<ol start="3">
<li>阶段3：传输指定密钥分发,Legacy paring需要分发LTK，IRK等，而SC paring只需分发IRK。秘密信息分发之前，必须保证连接已加密</li>
</ol>
<pre class="mermaid">sequenceDiagram
	note over 发起者,响应者:建立连接
	note over 发起者,响应者:第一阶段
	响应者 ->> 发起者:（可选）加密请求
	发起者 ->> 响应者:配对请求
	响应者 ->> 发起者:配对响应
	note over 发起者,响应者:第二阶段
	响应者 ->> 发起者:使用SMP协议进行配对（使用传统配对或SC）
	发起者 ->> 响应者:使用SMP协议进行配对（使用传统配对或SC）
	note over 发起者,响应者:第三阶段
	note over 发起者,响应者:建立加密连接
	响应者 ->> 发起者:分发密钥
	发起者 ->> 响应者:分发密钥
	
</pre>
<blockquote>
<p>[!tip]</p>
<p>在这里我们需要搞清楚两个概念：</p>
<ul>
<li>LE legacy pairing</li>
<li>LE Secure Connections</li>
</ul>
<p>在蓝牙4.2规范中，添加了LE物理传输的安全连接特性，升级了对蓝牙LE物理传输的配对，使用了FIPS-approved的算法(AES-CMAC和P-256椭圆曲线)。为了区分蓝牙4.0和4.1规范中定义的安全连接和配对，将其称为LE legacy pairing，而到蓝牙4.2版本后增加了LE Secure Connections的模式。</p></blockquote>
<blockquote>
<p>[!note]</p>
<p><strong>IRK（Identity Resolving Key</strong>，蓝牙设备地址解析密钥），有些蓝牙设备的地址为可解析的随机地址，比如iPhone手机，由于他们的地址随着时间会变化，那如何确定这些变化的地址都来自同一个设备呢？</p>
<p>答案就是IRK，IRK通过解析变化的地址的规律，从而确定这些地址是否来自同一个设备，换句话说，IRK可以用来识别蓝牙设备身份，因此其也称为Identity information。IRK一般由设备出厂的时候按照一定要求自动生成。</p></blockquote>
<h3 id="配对特征交换">
<a class="header-anchor" href="#%e9%85%8d%e5%af%b9%e7%89%b9%e5%be%81%e4%ba%a4%e6%8d%a2"></a>
配对特征交换
</h3><p>当配对特性交换开始时，发起者和响应者将通过配对请求和响应相互交换配对特性信息。有了这些信息，发起者和响应者可以相互确定I/O能力，应该使用哪种配对机制(legacy pairing或LE Secure Connections)，并选择配对方法(just work、Passkey Entry、Numeric Comparison or Out of Band)，以便在phase 2中使用。</p>
<p>可以通过<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/bluetooth/##SMP">PDU格式中的SMP协议</a>中的请求配对和请求响应指令来了解配对有哪些特征。</p>
<h3 id="密钥生成">
<a class="header-anchor" href="#%e5%af%86%e9%92%a5%e7%94%9f%e6%88%90"></a>
密钥生成
</h3><p>可以在<a href="https://www.bluetooth.com/specifications/specs/core-specification-6-0/">Core Specification | Bluetooth® Technology Website</a>的core文件的Vol 3,Part H找到相关描述。</p>
<p>为了支持随机寻址、配对和其他作用，SM提供了一个加密函数工具箱。定义了以下加密函数：</p>
<ul>
<li>ah用于创建用于随机地址创建和解析的24位哈希。</li>
</ul>
<p>以下加密函数以支持Legacy Pairing配对过程：</p>
<ul>
<li>c1用于生成配对过程中使用的确认值。</li>
<li>s1用于在配对过程中生成STK。</li>
</ul>
<p>以下加密函数以支持LE Secure Connections配对过程：</p>
<ul>
<li>f4用于在配对过程中生成确认值。</li>
<li>f5用于在配对过程中生成LTK和MacKey</li>
<li>f6用于在配对过程中的身份验证阶段2期间生成检查值。</li>
<li>g2用于在配对过程中的身份验证阶段1期间生成6位数字比较值。</li>
<li>h6用于从安全连接派生的BR/EDR链路密钥生成LE LTK,并用于从安全连接派生的LE LTK生成BR/EDR链路密钥。</li>
<li>h7用于生成中间密钥，同时从从安全连接派生的BR/EDR链接密钥和从安全连接派生的LE LTK生成BR/EDR链接密钥。</li>
</ul>
<blockquote>
<p>[!tip]</p>
<p>加密函数ah、c1和s1的构建块是安全功能e。</p>
<p>加密函数f4、f5、f6、g2、h6和h7的构建块是安全功能AES-CMAC。</p></blockquote>
<h4 id="传统配对">
<a class="header-anchor" href="#%e4%bc%a0%e7%bb%9f%e9%85%8d%e5%af%b9"></a>
传统配对
</h4><p>传统配对（Legacy Pairing）的密钥生成（STK）步骤：</p>
<ol>
<li>
<p>生成TK（<strong>Temporary Key</strong>），TK的值是取决于配对方法，见<a href="/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/bluetooth/###%e9%85%8d%e5%af%b9%e6%96%b9%e6%b3%95">配对方法</a></p>
</li>
<li>
<p>生成随机数：主（Master）设备和从（Slave）设备分别生成一个随机数（<code>Mrand</code> 和 <code>Srand</code>）。</p>
</li>
<li>
$$
   Mconfirm=c1(TK,Mrand,配对请求命令,配对响应命令,发起设备地址类型,发起设备地址,响应设备地址类型,响应设备地址)\\
   Sconfirm=c1(TK,Srand,配对请求命令,配对响应命令,发起设备地址类型,发起设备地址,响应设备地址类型,响应设备地址)
   $$<blockquote>
<p>[!important]</p>
<p>C1函数的具体实现基于AES-128加密算法，AES算法将输入的参数按照特定的顺序拼接成一个128位的数据块</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[Mrand/Srand (64位)] [配对请求命令 (16位)] [配对响应命令 (16位)] [发起设备地址类型 (8位)] [发起设备地址 (48位)] [响应设备地址类型 (8位)] [响应设备地址 (48位)]
</span></span></code></pre></div><p>不足128的使用0填充，然后使用AES-128算法进行加密，从而申城确认值。</p></blockquote>
</li>
<li>
<p>交换随机数并验证确认值：主设备将<code>Mrand</code>发送给从设备，从设备通过$c1$函数将<code>Mrand</code>对应的<code>confirm</code>计算出来，再和上一步得来的<code>Mconfirm</code>进行比较，相等则算是验证通过，否则算是验证失败。计算从设备将<code>Srand</code>发送给主设备，验证方法和上述方法相同，不再赘述。这里如果确认值是验证通过的，那么就会生成STK，否则就不会进行下一步。</p>
</li>
<li>
$$
   STK=s1(TK,Mrand,Srand)
   $$<blockquote>
<p>[!important]</p>
<p>s1函数也是基于AES-128加密算法（当然也可以使用其余的加密算法），s1函数直接将<code>Mrand</code>和<code>Srand</code>拼合在一起</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[Mrand (64位)] [Srand (64位)]
</span></span></code></pre></div></blockquote>
</li>
</ol>
<h4 id="安全连接">
<a class="header-anchor" href="#%e5%ae%89%e5%85%a8%e8%bf%9e%e6%8e%a5"></a>
安全连接
</h4><p>安全连接（LE Secure Connections）的操作步骤大致如下：</p>
<ol>
<li>交换公钥</li>
<li>身份认证，不同的配对方法使用不同的身份认证方法。</li>
<li>生成TLK</li>
</ol>
<blockquote>
<p>[!important]</p>
<p>SC生成LTK使用椭圆曲线Diffie-Hellman（ECDH）算法</p></blockquote>
<h5 id="交换公钥">
<a class="header-anchor" href="#%e4%ba%a4%e6%8d%a2%e5%85%ac%e9%92%a5"></a>
交换公钥
</h5><ol>
<li>
$$
   PK=SK \times G 
   $$<p>
其中，$PK$是公钥，$SK$是私钥,$G$是基点（是椭圆曲线上选定的一点，用于通过标量乘法生成其他的点）</p>
<ul>
<li>主设备的私钥：$SK\_M$</li>
<li>主设备的公钥：$PK\_M = SK\_M \times G$</li>
<li>从设备的私钥：$SK\_S$</li>
<li>从设备的公钥：$PK\_S = SK\_S \times G$</li>
</ul>
</li>
<li>
<p><strong>交换公钥</strong>：主设备和从设备通过蓝牙通信交换各自的公钥（<code>PK_M</code> 和 <code>PK_S</code>）。</p>
</li>
<li>
<p><strong>计算共享密钥（DHKey）</strong>：主设备和从设备分别使用自己的私钥和对方的公钥，通过椭圆曲线Diffie-Hellman（ECDH）算法计算共享密钥<code>DHKey</code>。</p>
<ul>
<li>
<p>主设备计算：$DHKey = ECDH(SK\_M, PK\_S)=SK\_M \times (SK\_S \times G)=SK\_M \times SK\_S \times G$</p>
</li>
<li>
<p>从设备计算：$DHKey = ECDH(SK\_S, PK\_M)=SK\_S \times (SK\_M \times G)=SK\_M \times SK\_S \times G$</p>
</li>
<li>
<p>由上面的推导可以看出，双方计算出的<code>DHKey</code>是相同的。</p>
</li>
</ul>
</li>
</ol>
<h5 id="身份认证阶段">
<a class="header-anchor" href="#%e8%ba%ab%e4%bb%bd%e8%ae%a4%e8%af%81%e9%98%b6%e6%ae%b5"></a>
身份认证阶段
</h5><p>开始身份认证之后，不同的配对方法采用不同的身份认证流程。</p>
<p>==Just work和Numeric Comparison==</p>
<ol>
<li>
<p>首先发起者和响应者会各自生成一个128位的随机数<code>Na</code>和<code>Nb</code></p>
</li>
<li>
<p>两端将<code>ra</code>和<code>rb</code>设置为0</p>
</li>
<li>
$$
   Cb=f4(PK\_S,PK\_M,Nb,0)
   $$</li>
<li>
<p>双方开始交换随机数<code>Na</code>和<code>Nb</code></p>
</li>
<li>
<p>发起者开始通过拿到的<code>Na</code>来计算确认值，并对比确认值</p>
</li>
<li>
$$
   Va=g2(PK\_S,PK\_M,Na,Nb)\\
   Vb=g2(PK\_S,PK\_M,Na,Nb)
   $$<blockquote>
<p>[!tip]</p>
<p>注意：这里的<code>Va</code>和<code>Vb</code>算出来是6位数字，也就是我们日常生活中屏幕上展示的码。</p></blockquote>
</li>
<li>
<p>设备双方来对比得到的值是否相同，相同则确认成功，否则则失败。</p>
</li>
</ol>
<pre class="mermaid">sequenceDiagram
	note over 发起者:设置一个随机数Na
	note over 响应者:设置一个随机数Nb
	note over 发起者,响应者:将ra和rb设置为0
	note over 响应者:计算Cb
	响应者 ->> 发起者:Cb
	发起者 ->> 响应者:Na
	响应者 ->> 发起者:Nb
	note over 发起者:校验Cb值是否相同，相同就继续，不相同就退出认证
	note over 发起者,响应者:同时计算Va和Vb，如果Va和Vb相同就证明确认成功。
</pre>
<p>==Passkey Entry==</p>
<ol>
<li>
<p>发起者和响应者两台设备中的其中一台显示密码（6位）<code>ra</code>，另一台设备进行输入<code>rb</code>，这里的密码都是随机生成的，<code>Ra</code>、<code>Rb</code>称为PassKey。</p>
<blockquote>
<p>[!important]</p>
<p>6位数字的PassKey使用二进制表示需要20位，如最大的999999=0xF423F</p>
<p>而PassKey的认证原理就是逐位处理，所以一共需要20次循环才可以处理完6位的PassKey，每次循环取一位</p></blockquote>
</li>
<li>
<p>开始对随机生成的<code>Ra</code>、<code>Rb</code>逐位生成确认值，需要循环20次，单次执行步骤如下：</p>
<ol>
<li>
<p>各方生成各自的128位的随机数<code>Na</code>和<code>Nb</code>(每次循环都生成不同的随机数)</p>
</li>
<li>
$$
      Ca=f4(PK\_M,PK\_S,Na,Ra_i)\\
      Cb=f4(PK\_M,PK\_S,Nb,Rb_i)
      $$<blockquote>
<p>[!important]</p>
<p>注意，这里的每次的$Ra_i$和$Rb_i$是取的PassKey的逐个位，如$Ra_1$就是取的PassKey的第一位</p></blockquote>
</li>
<li>
<p>交换<code>Ca</code>和<code>Cb</code></p>
</li>
<li>
$$
      Ca=f4(PK\_M,PK\_S,Na,Ra_i)
      $$</li>
<li>
$$
      Cb=f4(PK\_M,PK\_S,Nb,Rb_i)
      $$</li>
</ol>
</li>
</ol>
<pre class="mermaid">sequenceDiagram
	note over 发起者,响应者:注入密钥，ra和rb，且ra=rb
	loop 执行20次
		note over 发起者:生成一个随机数Na，计算Ca=f4(PK_M,PK_S,Na,Ra_i)
		note over 响应者:生成一个随机数Nb,计算Ca=f4(PK_M,PK_S,Nb,Rb_i)
		发起者 ->> 响应者:Ca
		响应者 ->> 发起者:Cb
		发起者 ->> 响应者:Na
		note over 响应者:计算Ca=f4(PK_M,PK_S,Na,Rb_i),并比较和上一步拿来的Ca是否一致
		响应者 ->> 发起者:Nb
		note over 发起者:计算Cb=f4(PK_M,PK_S,Nb,Ra_i),并比较和上一步拿来的Ca是否一致
		note over 发起者,响应者:注意，这里的Ra_i等于Rb_i,所以计算是相等的
	end
</pre>
<h5 id="生成密钥">
<a class="header-anchor" href="#%e7%94%9f%e6%88%90%e5%af%86%e9%92%a5"></a>
生成密钥
</h5><ol>
<li>
$$
   MacKey ||LTK=f5(DHKey,Na,Nb,发起者地址,响应者地址)
   $$<blockquote>
<p>[!tip]</p>
<p>这里的<code>||</code>符号的意思是将f5函数的返回值拆成两部分，高64位是MacKey，低64位是LTK</p></blockquote>
</li>
<li>
$$
   EB=f6(MacKey,Nb,Na,ra,,IOcap响应者,发起者地址,响应者地址)\\
   EA=f6(MacKey,Nb,Na,ra,IOcap发起者,发起者地址,响应者地址)
   $$</li>
<li>
<p>之后交换确认值，从而通过配对</p>
</li>
</ol>
<p>当计算MacKey之后，又要再一次进行确认值生成</p>
<pre class="mermaid">sequenceDiagram
	note over 发起者,响应者:MacKey ||LTK=f5(DHKey,Na,Nb,发起者地址,响应者地址)
	note over 发起者:EA=f6(MacKey,Nb,Na,ra,IOcap发起者,发起者地址,响应者地址)
	note over 响应者:EB=f6(MacKey,Nb,Na,ra,,IOcap响应者,发起者地址,响应者地址)
	发起者 ->> 响应者:EA
	note over 响应者:计算EA=f6(MacKey,Nb,Na,ra,,IOcap发起者,发起者地址,响应者地址)，并且对比值，如果不相同就不通过
	响应者 ->> 发起者:EB
	note over 发起者:计算EB=f6(MacKey,Nb,Na,ra,,IOcap响应者,发起者地址,响应者地址)，并且对比值，如果不相同则不通过
</pre>
<h3 id="配对方法">
<a class="header-anchor" href="#%e9%85%8d%e5%af%b9%e6%96%b9%e6%b3%95"></a>
配对方法
</h3><p>安全简易配对SSP（Secure simple pairing）是蓝牙2.0之后的配对方式，SSP一共有四种，其中Out of Band很少使用到，具体如下：</p>
<ol>
<li><strong>Just Works</strong>：
<ul>
<li>无需用户交互，安全性较低。</li>
<li>适用于不需要 MITM（Man-in-the-Middle）保护的场景。</li>
<li>TK是一个固定的值，通常为0。</li>
</ul>
</li>
<li><strong>Numeric Comparison（数值比较）</strong>：
<ul>
<li>双方设备显示一个 6 位数字，用户确认两者是否一致。</li>
<li>适用于双方设备都有显示和确认能力（如手机和笔记本电脑）。</li>
<li>双方设备显示一个6位数字，用户确认两者是否一致，TK由这个比较结果生成。</li>
</ul>
</li>
<li><strong>Passkey Entry（密码输入）</strong>：
<ul>
<li>一方设备显示 6 位数字，用户在另一方设备上输入。</li>
<li>适用于一方有显示能力，另一方有输入能力（如手机和键盘）。</li>
<li>用户需要在两个设备上输入相同的6位数字（Passkey），TK由这个Passkey生成。</li>
</ul>
</li>
<li><strong>Out of Band (OOB，带外)</strong>：
<ul>
<li>通过非蓝牙信道（如 NFC、二维码）交换配对信息。</li>
<li>安全性最高，适用于支持 OOB 技术的设备。</li>
<li>通过外部通信方式（如NFC或Wi-Fi）交换配对信息，TK由外部交换的数据生成。</li>
</ul>
</li>
</ol>
<blockquote>
<p>[!note]</p>
<p>LE Secure Connection在Legacy pairing的基础上增加了Numeric Comparison，也就是说Legacy pairing只支持后三种。</p></blockquote>
<p>选择 SSP 方法的主要依据是设备的 <strong>IO 能力</strong> 和 <strong>认证要求</strong>。以下是选择方法的流程：</p>
<ol>
<li>
<p><strong>检查 OOB 支持</strong>：</p>
<ul>
<li>如果双方设备都支持 OOB，则选择 OOB 方法。</li>
<li>如果不支持 OOB，则进入下一步。</li>
</ul>
</li>
<li>
<p><strong>检查 MITM 要求</strong>：</p>
<ul>
<li>如果要求 MITM 保护，则根据设备的 IO 能力选择 Numeric Comparison 或 Passkey Entry。</li>
<li>如果不需要 MITM 保护，则选择 Just Works。</li>
</ul>
</li>
<li>
<p><strong>根据 IO 能力选择方法</strong>：</p>
<ul>
<li><strong>Numeric Comparison</strong>：
<ul>
<li>双方设备都支持 <code>DisplayYesNo</code> 或 <code>KeyboardDisplay</code>。</li>
</ul>
</li>
<li><strong>Passkey Entry</strong>：
<ul>
<li>一方设备支持 <code>KeyboardOnly</code> 或 <code>KeyboardDisplay</code>，另一方设备支持 <code>DisplayOnly</code> 或 <code>DisplayYesNo</code>。</li>
</ul>
</li>
<li><strong>Just Works</strong>：
<ul>
<li>其他情况（如至少一方设备是 <code>NoInputNoOutput</code>）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>[!important]</p>
<p>中间人（MITM）攻击发生在当用户想要连接两台设备时，使得他们并没有直接连接对方，而是在不知情的情况下连接到了第三台（攻击）设备，该设备扮演了他们试图配对的设备的角色。第三台设备随后会在两台设备之间转发信息，造成它们已直接连接的假象。攻击设备甚至可以窃听两台设备之间的通信（称为主动窃听），并能插入和修改连接上的信息。在这种攻击中，两台设备之间交换的所有信息都会被泄露，攻击者可能会向每台设备注入命令和信息，从而可能破坏设备的功能。遭受攻击的设备只有在攻击者在场时才能进行通信。如果攻击者不在或不在攻击范围内，两台受害设备将无法直接通信，用户也会注意到这一点。</p>
<p>为防止 MITM 攻击，安全简单配对提供了两种用户辅助数字方法：数字比较或密码输入。如果安全简单配对使用 16 位的十进制数字，那么其可用性将与使用 16 位的十进制数字 PIN 码的传统配对相同。在这种情况下，MITM 成功插入自己的链接密钥的几率是 10^16=2^53 次配对实例中的 1 次，这是一个几乎不可能的低概率。</p>
<p>安全简单配对功能可保护用户免受 MITM 攻击，目标是提供 1 in 1,000,000 的机会让 MITM 成功发起攻击。选择 MITM 保护的强度是为了通过使用六位数字进行数字比较和密码输入，最大限度地减少对用户的影响。之所以选择这种程度的 MITM 防范措施，是因为在大多数情况下，当 MITM 攻击失败导致连接过程失败时，用户就会警觉到可能存在 MITM 攻击者。虽然大多数用户认为，只要他们没有泄露密码，4 位数的密钥就足以进行身份验证（如银行卡 PIN 码），但使用 6 位数的密钥可以使安全简单配对符合 FIPS 标准，而且这被认为对可用性的影响很小。</p></blockquote>
<h3 id="分发密钥">
<a class="header-anchor" href="#%e5%88%86%e5%8f%91%e5%af%86%e9%92%a5"></a>
分发密钥
</h3><p>在描述密钥的分发需要先了解以下名词：</p>
<ol>
<li>身份解析密钥(IRK):128位密钥，用于生成和解析随机地址。</li>
<li>连接签名解析密钥 （CSRK）:128 位密钥，用于在接收设备上对数据进行签名和验证签名。</li>
<li>长期密钥 （LTK）:128 位密钥，用于为加密连接生成贡献会话密钥。
<ol>
<li>加密多元化器 （EDIV） : 16 位存储值，用于识别在 LE 传统配对期间分发的 LTK。每次分发唯一的 LTK 时，都会生成一个新的 EDIV。</li>
<li>随机数 （Rand） : 64 位存储值，用于标识 LE 传统配对期间分配的 LTK。每次分发唯一的 LTK 时，都会生成一个新的 Rand。</li>
</ol>
</li>
</ol>
<p>我们可以将以上三种密钥分为总结为以下功能：</p>
<table>
  <thead>
      <tr>
          <th>密钥</th>
          <th>核心功能</th>
          <th>应用场景</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>LTK</strong></td>
          <td><strong>加密通信数据</strong></td>
          <td>确保传输内容的机密性</td>
      </tr>
      <tr>
          <td><strong>IRK</strong></td>
          <td><strong>保护设备身份隐私</strong></td>
          <td>防止设备被长期追踪</td>
      </tr>
      <tr>
          <td><strong>CSRK</strong></td>
          <td><strong>验证数据完整性和来源</strong></td>
          <td>防止数据篡改或伪造</td>
      </tr>
  </tbody>
</table>
<p><strong>示例</strong>：</p>
<p>一个医疗设备（如血糖仪）与手机配对时：</p>
<ul>
<li>使用 <strong>LTK</strong> 加密血糖数据；</li>
<li>使用 <strong>IRK</strong> 生成私有地址，避免被未配对设备追踪；</li>
<li>使用 <strong>CSRK</strong> 对数据签名，确保数据未被篡改。</li>
</ul>
<h4 id="传统配对的密钥分发">
<a class="header-anchor" href="#%e4%bc%a0%e7%bb%9f%e9%85%8d%e5%af%b9%e7%9a%84%e5%af%86%e9%92%a5%e5%88%86%e5%8f%91"></a>
传统配对的密钥分发
</h4><p>从机可向主机分发以下密钥：</p>
<ol>
<li>LTK, EDIV, and Rand</li>
<li>IRK</li>
<li>CSRK</li>
</ol>
<p>主机可向从机分发以下密钥：</p>
<ol>
<li>LTK, EDIV, and Rand</li>
<li>IRK</li>
<li>CSRK</li>
</ol>
<h4 id="安全连接的密钥分发">
<a class="header-anchor" href="#%e5%ae%89%e5%85%a8%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%af%86%e9%92%a5%e5%88%86%e5%8f%91"></a>
安全连接的密钥分发
</h4><p>主机和从机可以分发以下密钥：</p>
<ol>
<li>IRK</li>
<li>CSRK</li>
</ol>
<h2 id="数据传输">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93"></a>
数据传输
</h2><p>沟通过程如下：</p>
<pre class="mermaid">sequenceDiagram
蓝牙主机 ->> 蓝牙从机:交换支持特性请求
note right of 蓝牙主机:数据为：9ee8d2e5 0309 08 fff901f7ff000000 9d5ff4
note right of 蓝牙主机:0x9ee8d2e5：广播ID（access address），该ID是上述连接过程中的Access address，不要和公共广播地址搞混
note right of 蓝牙主机:0x0309：packet Header，LLID为0x3（控制PDU），长度为9
note right of 蓝牙主机:0x08：Opcode为0x08（LL_FEATURE_REQ）
note right of 蓝牙主机:0xfff901f7ff000000：特征集合，具体解析见上面特征信息位的代表信息。
note right of 蓝牙主机:0x9d5ff4：校验码

蓝牙从机 ->> 蓝牙主机:交换支持特性回复
note left of 蓝牙从机:数据为：9ee8d2e5 1709 09 fdf8010000000000 0a137c
note left of 蓝牙从机:0x9ee8d2e5：广播ID（access address）
note left of 蓝牙从机:0x1709：packet Header
note left of 蓝牙从机:0x09：Opcode为0x09（LL_FEATURE_RSP）
note left of 蓝牙从机:0xfdf8010000000000：特征集合，具体解析见上面特征信息位的代表信息。
note left of 蓝牙从机:0x0a137c：校验码

蓝牙主机 ->> 蓝牙从机:协商数据包长度请求
note right of 蓝牙主机:数据为：9ee8d2e5 1709 14 fb004808fb004808 2b1f8b
note right of 蓝牙主机:0x9ee8d2e5：广播ID（access address），该ID是上述连接过程中的Access address，不要和公共广播地址搞混
note right of 蓝牙主机:0x1709：packet Header，LLID为0x3（控制PDU），长度为0x17
note right of 蓝牙主机:0x14：Opcode为0x14（LL_LENGTH_REQ）
note right of 蓝牙主机:0xfb004808fb004808：具体解析见上面长度的代表信息。
note right of 蓝牙主机:0x9d5ff4：校验码

蓝牙从机 ->> 蓝牙主机:协商数据包长度回复
note left of 蓝牙从机:数据为：9ee8d2e5 0309 15 1b0048011b004801 31d707
note left of 蓝牙从机:0x9ee8d2e5：广播ID（access address）
note left of 蓝牙从机:0x0309：packet Header
note left of 蓝牙从机:0x15：Opcode为0x15（LL_LENGTH_RSP）
note left of 蓝牙从机:0x1b0048011b004801：具体解析见上面长度的代表信息。
note left of 蓝牙从机:0x31d707：校验码
</pre>
<blockquote>
<p>[!tip]</p>
<p>注意：在packet header中有SN和NESN，这两位用于控制报文重传和流控制功能。</p>
<p>当发送方的的NESN为1，而接收方下一帧报文的SN应该为1</p>
<p>例如：</p>
<table>
  <thead>
      <tr>
          <th>角色</th>
          <th>SN</th>
          <th>NESN</th>
          <th>备注</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>发送方</td>
          <td>0</td>
          <td>0</td>
          <td>初始化时SN和NESN都为0</td>
      </tr>
      <tr>
          <td>接受方</td>
          <td>0</td>
          <td>1</td>
          <td></td>
      </tr>
      <tr>
          <td>发送方</td>
          <td>1</td>
          <td>0</td>
          <td></td>
      </tr>
      <tr>
          <td>接收方</td>
          <td>0</td>
          <td>1</td>
          <td></td>
      </tr>
  </tbody>
</table></blockquote>
<h2 id="连接失败">
<a class="header-anchor" href="#%e8%bf%9e%e6%8e%a5%e5%a4%b1%e8%b4%a5"></a>
连接失败
</h2><p>有如下几种典型的连接失败情况：</p>
<ol>
<li>如果slave在transmit window期间没有收到master发过来的P1，那么连接将会失败。此时应该排查master那边的问题，看看master为什么没有在约定的时间把P1发出来。</li>
<li>如果master在transmit window期间把P1发出来了，也就是说master按照connect_req约定的时序把P1发出来了，但slave没有把P2回过去或者没有在超时时间内把P2回过去，那么连接也会失败。此时应该排查slave这边的问题，看一看slave为什么没有把P2回过去</li>
<li>如果master把P1发出来了，slave也把P2回过去了，此时主机或者从机还是报连接失败，这种情况有可能是软件有问题，需要仔细排查master或者slave的软件。</li>
<li>还有一种比较常见的连接失败情况：空中射频干扰太大。此时应该找一个干净的环境，比如屏蔽室，排除干扰后再去测试连接是否正常。</li>
</ol>
<h2 id="gap角色">
<a class="header-anchor" href="#gap%e8%a7%92%e8%89%b2"></a>
GAP角色
</h2><p>对上面提到的手机和设备B，在BLE通信过程中，随着时间的推移，他们的状态在发生变化，两者的关系也在发生变化，为此蓝牙spec根据不同的时间段或者状态给手机和设备B取不同的名字，即GAP层定义了如下角色：</p>
<ul>
<li>advertiser：发出广播的设备</li>
<li>observer或者scanner：可以扫描广播的设备</li>
<li>initiator：能发起连接的设备</li>
<li>master或者central：连接成功后的主设备，即主动发起packet的设备</li>
<li>slave或者peripheral：连接成功后的从设备，即被动回传packet的设备</li>
</ul>
<p>下图通过时间把observer，initiator和central串起来了，其实这三个角色是相互独立的，也就是说一个设备可以只支持observer角色，而不支持initiator和central角色。同样，下图也把advertiser和peripheral串起来了，其实advertiser和peripheral也是相互独立的，即一个设备可以只作为advertiser角色，而不支持peripheral角色。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/17_15_14_6_202412171514369.png" alt="GAP层角色"></p>
<h1 id="协议规范">
<a class="header-anchor" href="#%e5%8d%8f%e8%ae%ae%e8%a7%84%e8%8c%83"></a>
协议规范
</h1><h2 id="传输协议">
<a class="header-anchor" href="#%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae"></a>
传输协议
</h2><p>蓝牙协议是蓝牙设备间交换信息所应该遵守的规则。与开放系统互联（OSI）模型一样，蓝牙技术的协议体系也采用了分层结构，从底层到高层形成了蓝牙协议栈，各层协议定义了所完成的功能和使用数据分组格式，以保证蓝牙产品间的互操作性。</p>
<h3 id="射频协议">
<a class="header-anchor" href="#%e5%b0%84%e9%a2%91%e5%8d%8f%e8%ae%ae"></a>
射频协议
</h3><h4 id="工作频率">
<a class="header-anchor" href="#%e5%b7%a5%e4%bd%9c%e9%a2%91%e7%8e%87"></a>
工作频率
</h4><p>蓝牙工作在2.4GHz ISM频段上，蓝牙采用跳频扩谱技术主动的避免工作频段受干扰（微波炉的工作频率也是2.4GHz）。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_14_49_41_202412111449431.png" alt="工作频率"></p>
<table>
  <thead>
      <tr>
          <th>地理位置</th>
          <th>ISM频段范围</th>
          <th>射频信道频率</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>中国、美国、欧洲</td>
          <td>2400.0~2483.5MHz</td>
          <td>F=(2402+k)MHz,k在0、1、 .78中随机取值</td>
      </tr>
      <tr>
          <td>法国</td>
          <td>2446.5~2483.5MHz</td>
          <td>F=(2454+k)MHz,k在0、1、 22中随机取值</td>
      </tr>
      <tr>
          <td>日本</td>
          <td>2471.0~ 2497.0MHz</td>
          <td>F=(2473+k)MHz,k在0、1、 22中随机取值</td>
      </tr>
      <tr>
          <td>西班牙</td>
          <td>2445.0 ~ 2475.0MHz</td>
          <td>F=(2449+k)MHz,k在0、1、 22中随机取值</td>
      </tr>
  </tbody>
</table>
<p>我国的蓝牙频率在2.402GHz～2.483GHz,蓝牙每个频道的宽度为1MHz，为了减少带外辐射的干扰，保留上、下保护为3.5MHz和2MHz，79个跳频点中至少75个伪随机码跳动，30S内任何一个频点使用时长不能超过0.4S。</p>
<h4 id="跳频技术发射功率时隙">
<a class="header-anchor" href="#%e8%b7%b3%e9%a2%91%e6%8a%80%e6%9c%af%e5%8f%91%e5%b0%84%e5%8a%9f%e7%8e%87%e6%97%b6%e9%9a%99"></a>
跳频技术、发射功率、时隙
</h4><ol>
<li>
<p>**发射功率：**蓝牙发射功率分三级：一级功率100mW(20dBm)；二级功率2.5mW(4dBm)；三级功率1mW(0dBm)；</p>
</li>
<li>
<p>**物理信道：**蓝牙物理信道有伪随机序列控制的79个跳频点构成，不同跳频序列代表不同的信道。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_14_53_53_202412111453741.png" alt="跳频"></p>
</li>
<li>
<p>**时隙：**蓝牙跳频速率为1600次/s,每个时间为625uS(1S/1600)称为一个时隙；</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_15_0_22_202412111500504.png" alt="时隙"></p>
</li>
</ol>
<blockquote>
<p>[!tip]</p>
<p>跳频（Frequency Hopping）是指在数据传输过程中，设备会快速在多个预设的信道之间切换。这种技术的主要目的是提高抗干扰能力，通过频繁改变传输频率来避免其他设备或环境因素对信号的干扰。蓝牙通常采用每秒1600次的跳频速率，每个时隙（625微秒）内完成一次跳频。跳频序列由设备标志决定，每个时隙的载频由时隙号决定，这样可以确保即使在复杂的环境中，数据包也能被正确接收。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_15_21_8_202412111521248.png" alt="跳频通讯原理"></p>
<p>时隙（Slot）是蓝牙信道划分的基本时间单位，每个时隙长度为625微秒。在蓝牙系统中，信道被划分为多个时隙，每个时隙可以传送一个数据包。主设备和从设备通过时分双工（TDD）机制交替使用这些时隙进行数据传输。==主设备在偶数时隙开始发送数据，而从设备在奇数时隙开始发送数据。这种机制有助于减少碰撞和提高数据传输的效率和可靠性。==</p></blockquote>
<h3 id="基带与链路控制协议">
<a class="header-anchor" href="#%e5%9f%ba%e5%b8%a6%e4%b8%8e%e9%93%be%e8%b7%af%e6%8e%a7%e5%88%b6%e5%8d%8f%e8%ae%ae"></a>
基带与链路控制协议
</h3><blockquote>
<p>[!important]</p>
<ol>
<li>蓝牙发送数据时，基带部分将来自高层的数据进行信道编码，向下发给射频进行发送；</li>
<li>蓝牙接收数据时，将解调恢复空中数据并上传给基带，基带进行信道编码传送给上层。</li>
</ol>
<p>作用：跳频选择、蓝牙编址、链路类型、信道编码、收发规则、信道控制、音频规范、安全设置。</p></blockquote>
<ol>
<li>
<p>蓝牙分组编码为小端模式</p>
</li>
<li>
<p>蓝牙地址</p>
<p>BD_ADDR： Bluetooth Device Address；</p>
<p>LAP: Lower Address Part 低地址部分；</p>
<p>UAP: Upper Address Part 高地址部分；</p>
<p>NAP: Non-significant Address Part 无效地址部分。</p>
<p>地址组成如下：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/12_10_50_43_202412121050981.png" alt="蓝牙地址组成"></p>
</li>
<li>
<p>蓝牙时钟</p>
<p>每个蓝牙设备都有一个独立运行的内部系统时钟，称为本地时钟（Local Clock），决定定时器的收发跳频。为了与其他设备同步，本地时钟要加一个偏移量（offset），提供给其他设备同步。
蓝牙基带四个关键周期：<strong>312.5uS、625uS、1.25mS、1.28S</strong>。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_15_58_43_202412111558062.png" alt="蓝牙时钟"></p>
<p>**CLKN：**本地时钟：
**CLKE:**预计时钟，扫描寻呼过程中用到；
**CLK：**设备实际运行的时钟频率。
CLKE、CLK由CLKN加上一个偏移量得到的。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_16_3_13_202412111603958.png" alt="时钟示例"></p>
</li>
<li>
<p>物理链路层</p>
<p>通信设备间物理层的数据连接通道就是物理链路。
ACL（Asynchronous Connectionless）异步无连接链路；对时间要求不敏感的数据通信，如文件数据、控制信令等。
SCO（Synchronous Connection Oriented）同步面向连接链路；对时间比较敏感的通信，如：语音；最多只支持3条SCO链路，不支持重传。</p>
<blockquote>
<p>[!tip]</p>
<p>ACL用于数据传输；</p></blockquote>
</li>
<li>
<p>蓝牙基带分组</p>
<p>基带分组至少包括：接入码、分组头、有效载荷；</p>
<pre class="mermaid">block-beta
	columns 3
	LSB space MSB
	接入码（72或68bit） 分组头（54bit） 有效载荷（0~2745bit）
</pre>
<blockquote>
<p>[!tip]</p>
<ol>
<li><strong>基带（Baseband）</strong> ：基带是蓝牙协议栈中的一个关键层，负责处理数字信号的编码和解码。它位于射频层之上，主要功能包括链路控制、物理链路管理、分组格式定义以及纠错机制等。</li>
<li><strong>接入码（Access Code）</strong> ：接入码是每个基带数据包的起始部分，用于同步和标识。接入码可以分为三类：信道接入码、设备接入码和请求接入码。接入码包括引导码、同步字和尾码。</li>
<li><strong>分组头（Packet Header）</strong> ：分组头通常包含激活设备地址（AM_ADDR）和分组类型（TYPE），用于识别数据包的来源和用途。</li>
<li><strong>有效载荷（Payload）</strong> ：有效载荷是数据包中实际传输的数据部分，其长度可以变化，范围从0到2745位。</li>
<li><strong>SCO（Synchronous Connection-Oriented）链路</strong>：SCO链路是一种同步连接导向的链路，用于时间受限的信息传输，如压缩音频。</li>
<li><strong>ACL（Asynchronous Connection-Less）链路</strong>：ACL链路是一种异步无连接的链路，用于非时间受限的信息传输。</li>
<li><strong>FEC（Forward Error Correction）编码</strong>：FEC编码是一种前向纠错技术，用于提高数据传输的可靠性。</li>
<li><strong>ARQ（Automatic Repeat Request）机制</strong>：ARQ是一种自动重传请求机制，用于在数据传输过程中检测并纠正错误。</li>
<li><strong>比特误码率（Bit Error Rate, BER）</strong> ：BER是衡量数据传输质量的一个重要指标，表示在传输过程中错误比特的比例。</li>
</ol></blockquote>
<ol>
<li>
<p><strong>接入码</strong>用于同步、直流、载频泄漏偏置补偿标识；</p>
</li>
<li>
<p><strong>分组头</strong>包含链路信息，确保纠正较多的错误。</p>
<table>
  <thead>
      <tr>
          <th>分组类别</th>
          <th>Type(b3b2b1b0)</th>
          <th>时隙</th>
          <th>SCO</th>
          <th>ACL</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>链路控制分组</td>
          <td>0000</td>
          <td>1</td>
          <td>NULL</td>
          <td>NULL</td>
      </tr>
      <tr>
          <td>:</td>
          <td>0001</td>
          <td>:</td>
          <td>POLL</td>
          <td>POLL</td>
      </tr>
      <tr>
          <td>:</td>
          <td>0010</td>
          <td>:</td>
          <td>FHS</td>
          <td>FHS</td>
      </tr>
      <tr>
          <td>:</td>
          <td>0011</td>
          <td>:</td>
          <td>DM1</td>
          <td>DM1</td>
      </tr>
      <tr>
          <td>单时隙分组</td>
          <td>0100</td>
          <td>1</td>
          <td>未定义</td>
          <td>NULL</td>
      </tr>
      <tr>
          <td>:</td>
          <td>0101</td>
          <td>：</td>
          <td>HV1</td>
          <td>:</td>
      </tr>
      <tr>
          <td>:</td>
          <td>0110</td>
          <td>：</td>
          <td>HV2</td>
          <td>:</td>
      </tr>
      <tr>
          <td>:</td>
          <td>0111</td>
          <td>：</td>
          <td>HV3</td>
          <td>:</td>
      </tr>
      <tr>
          <td>:</td>
          <td>1000</td>
          <td>：</td>
          <td>DV</td>
          <td>:</td>
      </tr>
      <tr>
          <td>:</td>
          <td>1001</td>
          <td>：</td>
          <td>NULL</td>
          <td>AUX1</td>
      </tr>
      <tr>
          <td>3时隙分组</td>
          <td>1010</td>
          <td>3</td>
          <td>未定义</td>
          <td>DM3</td>
      </tr>
      <tr>
          <td>:</td>
          <td>1011</td>
          <td>：</td>
          <td>:</td>
          <td>DH3</td>
      </tr>
      <tr>
          <td>:</td>
          <td>1100</td>
          <td>：</td>
          <td>:</td>
          <td>未定义</td>
      </tr>
      <tr>
          <td>:</td>
          <td>1101</td>
          <td>：</td>
          <td>:</td>
          <td>:</td>
      </tr>
      <tr>
          <td>5时隙分组</td>
          <td>1110</td>
          <td>5</td>
          <td>未定义</td>
          <td>DM5</td>
      </tr>
      <tr>
          <td>:</td>
          <td>1111</td>
          <td>：</td>
          <td>:</td>
          <td>:</td>
      </tr>
  </tbody>
</table>
<p>ACL分组形式为：D(M|H)（1|3|5）:</p>
<ol>
<li>
<p>D代表数据分组</p>
</li>
<li>
<p>M代表用2/3比例的FEC的中等速率分组</p>
</li>
<li>
<p>H代表不使用纠错码的高速率分组</p>
</li>
<li>
<p>1、3、5分别代表分组所占用的时隙数目</p>
</li>
<li>
<p>DM1、DM3、DM5、DH1、DH3、DH5</p>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>有效载荷头/字节</th>
          <th>用户有效载荷/字节</th>
          <th>FEC</th>
          <th>CRC</th>
          <th>对称最大速率/kbps</th>
          <th>非对称速率/kbps</th>
          <th>=</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>:</td>
          <td>:</td>
          <td>:</td>
          <td>:</td>
          <td>:</td>
          <td>:</td>
          <td>前向</td>
          <td>后向</td>
      </tr>
      <tr>
          <td>DM1</td>
          <td>1</td>
          <td>0~17</td>
          <td>2/3</td>
          <td>有</td>
          <td>108.8</td>
          <td>108.8</td>
          <td>108.8</td>
      </tr>
      <tr>
          <td>DH1</td>
          <td>1</td>
          <td>0~27</td>
          <td>无</td>
          <td>有</td>
          <td>172.8</td>
          <td>172.8</td>
          <td>172.8</td>
      </tr>
      <tr>
          <td>DM3</td>
          <td>2</td>
          <td>0 ~121</td>
          <td>2/3</td>
          <td>有</td>
          <td>258.1</td>
          <td>387.2</td>
          <td>54.4</td>
      </tr>
      <tr>
          <td>DH3</td>
          <td>2</td>
          <td>0~183</td>
          <td>无</td>
          <td>有</td>
          <td>390.4</td>
          <td>585.6</td>
          <td>86.4</td>
      </tr>
      <tr>
          <td>DM5</td>
          <td>2</td>
          <td>0~ 224</td>
          <td>2/3</td>
          <td>有</td>
          <td>286.7</td>
          <td>477.8</td>
          <td>36.3</td>
      </tr>
      <tr>
          <td>MH5</td>
          <td>2</td>
          <td>0~339</td>
          <td>无</td>
          <td>有</td>
          <td>433.9</td>
          <td>723.2</td>
          <td>57.6</td>
      </tr>
      <tr>
          <td>AUX1</td>
          <td>1</td>
          <td>0~29</td>
          <td>无</td>
          <td>无</td>
          <td>185.6</td>
          <td>185.6</td>
          <td>185.6</td>
      </tr>
  </tbody>
</table>
<p>SCO分组形式为：HV(1|2|3)。</p>
<ol>
<li>
<p>HV代表高质量语言分组</p>
</li>
<li>
<p>1、2、3有效载荷所采用的纠错码方法。1为1/3比例FEC，设备2个时隙发送一个单时隙分组；2为2/3比例FEC，设备4个时隙发送一个单时隙分组；3为不使用纠错码，设备6个时隙发送一个单时隙分组</p>
</li>
<li>
<p>HV1、HV2、HV3</p>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>有效载荷头/字节</th>
          <th>用户有效载荷/字节</th>
          <th>FEC</th>
          <th>CRC</th>
          <th>有效载荷长度</th>
          <th>同步速率/kbps</th>
          <th>占用Tsco数目/语言长度</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>HV1</td>
          <td>无</td>
          <td>10</td>
          <td>1/3</td>
          <td>:</td>
          <td>240位</td>
          <td>64</td>
          <td>2/1.25ms</td>
      </tr>
      <tr>
          <td>HV2</td>
          <td>:</td>
          <td>20</td>
          <td>2/3</td>
          <td>:</td>
          <td>:</td>
          <td>:</td>
          <td>4/2.5ms</td>
      </tr>
      <tr>
          <td>HV3</td>
          <td>:</td>
          <td>30</td>
          <td>无</td>
          <td>:</td>
          <td>:</td>
          <td>:</td>
          <td>6/3.75ms</td>
      </tr>
      <tr>
          <td>DV</td>
          <td>1D</td>
          <td>10+(0-9)D</td>
          <td>2/3D</td>
          <td>有D</td>
          <td></td>
          <td>64+57.6D</td>
          <td></td>
      </tr>
  </tbody>
</table>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>逻辑信道</p>
<ol>
<li>
<p>链路控制信道：Link Control  <code>LC</code></p>
</li>
<li>
<p>链路管理信道：Link Manage <code>LM</code></p>
</li>
<li>
<p>用户异步数据信道：User Asynchronization <code>UA</code></p>
</li>
<li>
<p>用户同步数据信道：User Synchronization <code>US</code></p>
</li>
<li>
<p>用户等时数据信道：User Isochronous UI  <code>UI</code></p>
</li>
</ol>
</li>
<li>
<p>收发规则</p>
<p><strong>时分双工（TDD）技术</strong>：蓝牙收发器采用时分复用TDD方案，这意味着它可以在同一信道上交替进行发送和接收操作。在常规连接状态下，主设备在偶数时隙开始传送，而从设备在奇数时隙开始传送</p>
<p>接收规则：</p>
<ol>
<li><strong>主设备和从设备的RX缓冲器</strong>：主设备对所有从设备共用一个ACL链路的RX缓冲器，SCO缓冲器的数量取决于实际SCO链路的数量。接收过程是发送过程的逆向过程，接收到的数据包需要进行拆包处理，然后进入缓冲区暂存，并根据需要进入异步单元或同步单元接收处理。</li>
<li><strong>流量控制</strong>：在接收端，流量控制同样用于管理数据流。当RX FIFO队列全满时，流量控制避免丢弃数据包和防止阻塞。如果数据没有收到，STOP表示符会被插入到返回数据包的报头中被传送。当发送方收到STOP表示符，它会冻结其FIFO队列，直到接收方准备完毕并发送GO数据包以恢复数据流传输。</li>
<li><strong>比特流处理</strong>：在空中接口发送用户数据前，需要在发送端对比特流作适当的处理。在接收端，应当执行相反的过程，以恢复数据处理前的真实面目。</li>
</ol>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/12_11_8_7_202412121108499.png" alt="RX缓存"></p>
<blockquote>
<p>[!note]</p>
<p>上图SCO发送缓存左边是异步IO端口</p></blockquote>
<p>发送规则：</p>
<ol>
<li><strong>主设备和从设备的准备</strong>：主设备为每个从设备准备了一个独立的ACL链路的TX缓冲器，以及一个或多个SCO链路的TX缓冲器。每个TX缓冲器包括两个先入先出（FIFO）寄存器，这些寄存器交替使用以实现数据的异步和同步发送。</li>
<li><strong>数据包的处理</strong>：在ACL链路上发送业务流时，蓝牙链路管理器将新数据装入由S1接通的缓冲寄存器。然后，分组打包器读取当前缓冲器中的数据，并根据分组类型信息构造分组的净荷。接着，将构造好的净荷加上分组信道接入码和分组头，最后发送分组。</li>
<li><strong>流量控制</strong>：在ACL链路上，流量控制用于解决新的净荷如何装满ACL接收缓冲区的问题。如果ACL缓冲区已经饱和，流量控制通过返回分组头中的FLOW位来使用STOP和GO控制新数据的传输。</li>
</ol>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/12_11_8_50_202412121108136.png" alt="TX缓存"></p>
<blockquote>
<p>[!tip]</p>
<p>蓝牙收发器中的次态现态FIFO寄存器是指在蓝牙通信中用于管理数据包传输的两个关键寄存器。这些寄存器用于区分当前正在处理的数据包（现态）和即将处理的数据包（次态）。</p>
<p>具体来说，蓝牙收发器的FIFO寄存器分为现态寄存器和次态寄存器。现态寄存器由蓝牙控制器识别和读出，用于处理当前正在传输或接收的数据包。而次态寄存器则由蓝牙链接管理器识别和装入新信息，用于准备后续的数据包传输。</p>
<p>在蓝牙的ACL（异步连接通道）和SCO（同步连接通道）链路中，这两个寄存器分别用于管理数据包的收发。例如，在RX ACL缓冲区中，一个寄存器用于识别和装入最近的RX分组的有效信息，另一个寄存器则用于读出先前的有效信息。类似地，在TX SCO缓冲区中，一个寄存器用于填充新到的话音信息，而另一个寄存器则由处理单元读出。</p>
<p>这种设计确保了蓝牙收发器能够有效地管理数据流，避免数据包丢失或阻塞。通过使用FIFO寄存器，蓝牙设备可以实现先入先出（FIFO）队列处理数据包的收发，从而提高数据传输的效率和可靠性。</p>
<p>==并且新分组到达时，ACL链路的RX缓存器要流量控制，SCO数据不需要流量控制；==</p></blockquote>
</li>
<li>
<p><strong>基带信道和网络控制</strong></p>
<ol>
<li>
<p>链路控制器状态：待机、连接、寻呼page、寻呼扫描page scan、查询inquiry、查询扫描inquiry scan、主设备响应Master Response、从设备响应Slave Response、查询响应inquiry response</p>
</li>
<li>
<p>连接状态： 激活模式active、呼吸模式sniff、保持模式hold、休眠模式park。</p>
</li>
<li>
<p>待机状态：待机状态是蓝牙设备缺省低功耗状态，此状态下本地时钟以低精度运行。蓝牙从待机转入寻呼扫描状态，对其他寻呼进行响应成为从设备；也可以从待机状态进入查询扫描状态，完成一个完整的寻呼，成为主设备。</p>
</li>
</ol>
</li>
<li>
<p>接入过程</p>
<blockquote>
<p>[!tip]</p>
<p>IAC （Inquiry Access Code）：查询接入码</p>
<ol>
<li>GIAC（General Inquiry Access Code）:通用查询接入码，适用于任何设备的查询，可以发现所有在查询范围内的设备。</li>
<li>DIAC（Dedicated Inquiry Access Code）：专用查询接入码，仅用于特定类型的设备查询，以过滤出特定类型的设备。</li>
</ol>
<p>DAC（DeviceAccess Code）： 设备接入码，用于建立蓝牙设备间的连接。在连接过程中，DAC帮助设备识别和接入特定的蓝牙设备。</p>
<p>LAP（Link Access Procedure）：建立连接的过程，包括查询和寻呼两个步骤。查询过程使用IAC以发现覆盖区域内的设备及其地址和时钟信息。寻呼过程使用DAC，以建立设备间的蓝牙连接，并确定哪个设备将作为主设备。</p></blockquote>
<blockquote>
<p>[!important]</p>
<p>蓝牙协议中的接入过程是指设备之间建立通信连接的过程。蓝牙协议规范定义了设备接入的不同阶段，主要包括以下几个步骤：</p>
<ol>
<li><strong>设备发现 (Inquiry)</strong></li>
</ol>
<ul>
<li><strong>目的</strong>：蓝牙设备扫描并发现周围的其他蓝牙设备。</li>
<li>过程：
<ul>
<li>主设备（Master）发送<strong>Inquiry</strong>信号，广播自身寻找其他设备。</li>
<li>附近处于可被发现状态的从设备（Slave）会响应并发送自身的设备地址和设备信息。</li>
<li>主设备记录响应的设备信息以便后续连接。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>连接建立 (Paging)</strong></li>
</ol>
<ul>
<li><strong>目的</strong>：主设备与目标从设备建立初始物理连接。</li>
<li>过程：
<ul>
<li>主设备发送<strong>Page</strong>信号，包含目标从设备的蓝牙地址。</li>
<li>从设备识别该信号后，回复响应，双方同步连接参数（时钟偏移和跳频序列）。</li>
<li>此时，设备之间的物理连接完成，但尚未进入逻辑通信阶段。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>连接配置 (Link Setup)</strong></li>
</ol>
<ul>
<li>
<p><strong>目的</strong>：配置逻辑链路以支持具体的蓝牙通信。</p>
</li>
<li>
<p>过程：</p>
<ul>
<li>
<p>设备协商</p>
<p>链路类型</p>
<p>，如：</p>
<ul>
<li>SCO（同步连接导向链路）用于语音通信。</li>
<li>ACL（异步连接逻辑链路）用于数据通信。</li>
</ul>
</li>
<li>
<p>确定认证、加密和蓝牙版本支持等参数。</p>
</li>
<li>
<p>若需要加密通信，设备会交换密钥并启动加密过程。</p>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>配对与认证 (Pairing &amp; Authentication)</strong></li>
</ol>
<ul>
<li><strong>目的</strong>：验证设备身份并建立安全通信。</li>
<li>过程：
<ul>
<li>使用配对码（PIN码或其他方法）完成身份认证。</li>
<li>生成共享密钥以保护通信数据。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>数据传输 (Data Communication)</strong></li>
</ol>
<ul>
<li><strong>目的</strong>：通过建立的逻辑链路进行数据交换。</li>
<li>过程：
<ul>
<li>根据应用需求，设备可进行数据传输、音频流传输等任务。</li>
<li>支持单点或多点连接（如支持多个从设备）。</li>
</ul>
</li>
</ul></blockquote>
<ol>
<li>
<p>查询过程：蓝牙设备通过查询来发现通信范围内的其他蓝牙设备。查询信息分为GIAC、DIAC两种。查询发起设备收集所有相应设备的地址、时钟信息。</p>
<ol>
<li>设备进入查询状态去发现其他设备，查询状态下连续不断的在不同频点发送查询消息。查询的跳频序列有GIAC的LAP导出。</li>
<li>设备想被其他设备发现，就要周期性进入 查询扫描状态，以便相应查询消息。如：我们选择设备多长时间可见，其实就是进入查询扫描状态。</li>
<li>查询扫描：查询扫描状态下，接收设备扫描接入码的时间长度，足以完成对16个频率的扫描。扫描在同一个频率上进行，查询过程用32跳专用查询跳频序列，此序列有通用查询的地址决定，相位有本地时钟决定，每隔1.28S变化一次。</li>
<li>查询：与寻呼类似，TX用查询跳频序列、RX用查询相应跳频序列。</li>
<li>查询响应：从设备响应查询操作。每个设备都有自己的时钟，使用查询序列相位相同的几率比较小。为了避免多个设备在同一查询跳频信道同时激活，从设备查询响应规定：从设备收到查询消息，产生0-1023的一个随机数，锁定当时相位输入值进行跳频选择，从设备此后的RAND时隙中返回到连接或者待机状态。</li>
</ol>
</li>
<li>
<p>寻呼扫描：寻呼扫描状态下的设备扫描窗口内监听自己的DAC。监听只在一个跳频点进行。Twindow page scan足够覆盖16个寻呼扫描频点。 寻呼扫描状态，扫描在同一个频率上进行，持续1.28S，再选择另一个不同频率。</p>
<table>
  <thead>
      <tr>
          <th>SR模式</th>
          <th>Tpage scan</th>
          <th>寻呼次数Npage</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>R0</td>
          <td>连续</td>
          <td>&gt;=1</td>
      </tr>
      <tr>
          <td>R1</td>
          <td>&lt;=1.28S</td>
          <td>&gt;=128</td>
      </tr>
      <tr>
          <td>R2</td>
          <td>&lt;=2.56S</td>
          <td>&gt;=256</td>
      </tr>
      <tr>
          <td>预留</td>
          <td>-</td>
          <td>-</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
</li>
</ol>
<h3 id="链路管理器">
<a class="header-anchor" href="#%e9%93%be%e8%b7%af%e7%ae%a1%e7%90%86%e5%99%a8"></a>
链路管理器
</h3><p>链路管理器负责完成设备的功率管理、链路质量管理、链路控制管理、数据分组管理、链路安全管理。</p>
<ol>
<li>链路管理协议数据单元：蓝牙链路管理器接收到高层的控制信息后，不是向自身的基带部分分发控制信息，就是与另一台设备的链路管理器进行协商管理。这些控制信息封装在链路管理协议数据单元LMP_PDU中，由ACL分组的有效载荷携带。</li>
<li>链路管理器协议规范
<ol>
<li>设备功率管理：RSSI保持模式、呼吸模式、休眠模式。</li>
<li>链路质量管理 QoSQuality of Service
<ol>
<li>ACL链路</li>
<li>SCO链路。</li>
</ol>
</li>
<li>链路控制管理：设备寻呼模式、设备角色转换、时钟计时设置、信息交换:版本信息、支持特性、设备名称；建立连接、链路释放。</li>
<li>数据分组管理</li>
</ol>
</li>
</ol>
<h2 id="中介协议">
<a class="header-anchor" href="#%e4%b8%ad%e4%bb%8b%e5%8d%8f%e8%ae%ae"></a>
中介协议
</h2><h3 id="主机控制接口协议hci">
<a class="header-anchor" href="#%e4%b8%bb%e6%9c%ba%e6%8e%a7%e5%88%b6%e6%8e%a5%e5%8f%a3%e5%8d%8f%e8%ae%aehci"></a>
主机控制接口协议（HCI）
</h3><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/12_15_35_12_202412121535390.png" alt="蓝牙主机-主机控模型"></p>
<p>软件协议栈的数据传输过程：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/12_15_38_14_202412121538146.png" alt="数据传输过程"></p>
<p>蓝牙控制器接口数据分组：</p>
<ol>
<li>
<p>指令分组</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/12_15_41_50_202412121541815.png" alt="指令分组"></p>
<p>现在有一个Accept Connection Request，使用大端数据模式，指令为：09 04 07 9f 16 5f fd 0d 00 01，则</p>
<ol>
<li>Opcode为：0x0409</li>
<li>参数长度为: 07</li>
<li>参数中蓝牙地址为：00:0d:fd:5f:16:9f</li>
<li>角色为：从设备 0x01</li>
</ol>
</li>
<li>
<p>事件分组</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/12_15_48_15_202412121548580.png" alt="事件分组"></p>
<p>现在有一个HCI event，使用大端数据模式，指令为：0f 04 00 01 09 04</p>
<ol>
<li>Opcode :0x0409</li>
<li>状态： 0x00</li>
<li>总长度： 4字节</li>
<li>命令状态：0x0f</li>
</ol>
</li>
<li>
<p>数据分组</p>
<p>ACL数据分组：</p>
<table>
  <thead>
      <tr>
          <th>连接句柄 (12bit)</th>
          <th>PB(2bit)</th>
          <th>BC(2bit)</th>
          <th>数据长度 (16bit)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>数据&hellip;&hellip;.</td>
          <td>==</td>
          <td>==</td>
          <td>==</td>
      </tr>
  </tbody>
</table>
<p>SCO数据分组：</p>
<table>
  <thead>
      <tr>
          <th>连接句柄 (12bit)</th>
          <th>保留 (4bit)</th>
          <th>数据长度 (16bit)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>数据&hellip;&hellip;.</td>
          <td>==</td>
          <td>==</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>RS232分组指示器</p>
<table>
  <thead>
      <tr>
          <th>HCI分组类型</th>
          <th>RS232分组指示器</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>HCI指令分组</td>
          <td>0x01</td>
      </tr>
      <tr>
          <td>HCI ACL数据分组</td>
          <td>0x02</td>
      </tr>
      <tr>
          <td>HCI SCO数据分组</td>
          <td>0x03</td>
      </tr>
      <tr>
          <td>HCI事件分组</td>
          <td>0x04</td>
      </tr>
      <tr>
          <td>HCI错误消息分组</td>
          <td>0x05</td>
      </tr>
      <tr>
          <td>HCI协商分组</td>
          <td>0x06</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<p>HCI控制命令：</p>
<ol>
<li>
<p>链路控制指令</p>
<table>
  <thead>
      <tr>
          <th>命令</th>
          <th>OCF</th>
          <th>概述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Inquiry</td>
          <td>0x0001</td>
          <td>蓝牙设备进入查询模式，搜索临近设备</td>
      </tr>
      <tr>
          <td>Inquiry Cancel</td>
          <td>0x0002</td>
          <td>退出查询模式</td>
      </tr>
      <tr>
          <td>Periodic Inquiry Mode</td>
          <td>0x0003</td>
          <td>蓝牙设备在指定周期内自动查询</td>
      </tr>
      <tr>
          <td>Exit Periodic Inquiry Mode</td>
          <td>0x0004</td>
          <td>退出自动查询模式</td>
      </tr>
      <tr>
          <td>Create Connection</td>
          <td>0x0005</td>
          <td>按指定蓝牙设备的BD_ADDR创建ACL链路</td>
      </tr>
      <tr>
          <td>Disconnect</td>
          <td>0x0006</td>
          <td>终止现有连接</td>
      </tr>
      <tr>
          <td>Add SCO Connection</td>
          <td>0x0007</td>
          <td>利用连接句柄参数指定的ACL连接创建SCO</td>
      </tr>
      <tr>
          <td>Cancel Create Connection</td>
          <td>0x0008</td>
          <td></td>
      </tr>
      <tr>
          <td>Accept Connection Request</td>
          <td>0x0009</td>
          <td>接收新的呼入连接请求</td>
      </tr>
      <tr>
          <td>Reject Connection Request</td>
          <td>0x000A</td>
          <td>拒绝新的呼入连接请求</td>
      </tr>
      <tr>
          <td>Link Key Request Reply</td>
          <td>0x000B</td>
          <td>应答从主机控制器发出的链路密钥请求事件，并指定存储在主机上的链路密钥做为与 BD_ADDR指定的蓝牙设备进行连接使用的链路密钥请求事件</td>
      </tr>
      <tr>
          <td>Link Key Request Negative Reply</td>
          <td>0x000C</td>
          <td>如果主机上没有存储链路密钥，作为与BD_ADDR指定的蓝牙设备进行连接使用的链路密钥， 就应答从主机控制器发出的链路密钥请求事件</td>
      </tr>
      <tr>
          <td>PIN Code Request Reply</td>
          <td>0x000D</td>
          <td>应答从主机控制器发出的PIN请求事件，并指定用于连接的PIN</td>
      </tr>
      <tr>
          <td>PIN Code Request Negative Reply</td>
          <td>0x000E</td>
          <td>当主机不能指定连接的PIN时，应回答从机控制器发出的PIN请求事件</td>
      </tr>
      <tr>
          <td>Change Connection Packet  Type</td>
          <td>0x000F</td>
          <td>改变正在建立连接的分组类型</td>
      </tr>
      <tr>
          <td>Authentication Request</td>
          <td>0x0011</td>
          <td>指定连接句柄关联的两个蓝牙设备之间建立身份鉴权</td>
      </tr>
      <tr>
          <td>Set Connection Encryption</td>
          <td>0x0013</td>
          <td>建立取消连接加密</td>
      </tr>
      <tr>
          <td>Change Connection Link Key</td>
          <td>0x0015</td>
          <td>强制关联了连接句柄的两个设备建立连接，并生成一个新的链路密钥</td>
      </tr>
      <tr>
          <td>Master Link Key</td>
          <td>0x0017</td>
          <td>强制关联了连接句柄的两个设备利用主设备时链路密钥或常规密钥</td>
      </tr>
      <tr>
          <td>Remote Name Request</td>
          <td>0x0019</td>
          <td>获取远端设备的名称</td>
      </tr>
      <tr>
          <td>Cancel Remote Name Request</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>Read Remote Supported Features</td>
          <td>0x001B</td>
          <td>请求远端设备所支持的特性列表</td>
      </tr>
      <tr>
          <td>Read Remote Extended Features</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>Read Remote Version Information</td>
          <td>0x001D</td>
          <td>从远端设备读取版本信息</td>
      </tr>
      <tr>
          <td>Read Clock Offset</td>
          <td>0x001F</td>
          <td>读取远端的时钟信息</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>链路策略指令</p>
<table>
  <thead>
      <tr>
          <th>命令</th>
          <th>OCF</th>
          <th>简介</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Hold Mode</td>
          <td>0x0001</td>
          <td>改变LM状态和本地及远程设备为主模式的LM位置</td>
      </tr>
      <tr>
          <td>Sniff Mode</td>
          <td>0x0003</td>
          <td>改变LM状态和本地及远程设备为呼吸模式的LM位置</td>
      </tr>
      <tr>
          <td>Exit Sniff Mode</td>
          <td>0x0004</td>
          <td>结束连接句柄在当前呼吸模式里的呼吸模式</td>
      </tr>
      <tr>
          <td>Park State</td>
          <td>0x0005</td>
          <td>改变LM状态和本地及远程设备为休眠模式的LM位置</td>
      </tr>
      <tr>
          <td>Exit Park State</td>
          <td>0x0006</td>
          <td>切换从休眠模式返回到激活模式的蓝牙设备</td>
      </tr>
      <tr>
          <td>QoS Setup</td>
          <td>0x0007</td>
          <td>指出连接句柄的服务质量参数</td>
      </tr>
      <tr>
          <td>Role Discovery</td>
          <td>0x0009</td>
          <td>蓝牙设备连接后确定自己的主从角色</td>
      </tr>
      <tr>
          <td>Switch Role</td>
          <td>0x000B</td>
          <td>角色互换</td>
      </tr>
      <tr>
          <td>Read Link Policy Settings</td>
          <td>0x000C</td>
          <td>为指定连接句柄读链路策略设置。链路策略设置允许主机控制器指定用于连接句柄的LM 连接模式</td>
      </tr>
      <tr>
          <td>Write Link Policy Setings</td>
          <td>0x000D</td>
          <td>为指定连接句柄写链路策略设置。链路策略设置允许主机控制器指定用于连接句柄的LM 连接模式</td>
      </tr>
      <tr>
          <td>Read Default Link Policy Settings</td>
          <td>0x000E</td>
          <td></td>
      </tr>
      <tr>
          <td>Write Default Link Policy Settings</td>
          <td>0x000F</td>
          <td></td>
      </tr>
      <tr>
          <td>Flow Specification</td>
          <td>0X0010</td>
          <td></td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>主机控制器与基带指令</p>
<table>
  <thead>
      <tr>
          <th>命令</th>
          <th>OCF</th>
          <th>简介</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Set Event Mark</td>
          <td>0x0001</td>
          <td>使能主机过滤HCI产生的事件</td>
      </tr>
      <tr>
          <td>Reset</td>
          <td>0x0003</td>
          <td>复位蓝牙控制器、链路管理器、基带链路管理器</td>
      </tr>
      <tr>
          <td>Set Event Filter</td>
          <td>0x0005</td>
          <td>使能主机指定不同事件过滤</td>
      </tr>
      <tr>
          <td>Flush</td>
          <td>0x0008</td>
          <td>针对指定的蓝牙句柄，放弃所有作为当前待传输数据，甚至当前是属于多个在主机控制 器里的L2CAP指令的数据块</td>
      </tr>
      <tr>
          <td>Read PIN Type</td>
          <td>0x0009</td>
          <td>主机读取指定主机的PIN类型是可变的还是固定的</td>
      </tr>
      <tr>
          <td>Write PIN Type</td>
          <td>0x000A</td>
          <td>主机写入指定主机的PIN类型是可变的还是固定的</td>
      </tr>
      <tr>
          <td>Create New Unit Key</td>
          <td>0x000B</td>
          <td>创建新的单一密钥</td>
      </tr>
      <tr>
          <td>Read Stored Link Key</td>
          <td>0x000D</td>
          <td>读取存放在蓝牙控制器中的单个或者多个密钥</td>
      </tr>
      <tr>
          <td>Write Stored Link Key</td>
          <td>0x0011</td>
          <td>写入存放在蓝牙控制器中的单个或者多个密钥</td>
      </tr>
      <tr>
          <td>Delete Stored Link Key</td>
          <td>0x0012</td>
          <td>删除存放在蓝牙控制器中的单个或者多个密钥</td>
      </tr>
      <tr>
          <td>Write Local Name</td>
          <td>0x0013</td>
          <td>修改蓝牙设备名称</td>
      </tr>
      <tr>
          <td>Read Local Name</td>
          <td>0x0014</td>
          <td>读取蓝牙设备名称</td>
      </tr>
      <tr>
          <td>Read Connection Accept Timeout</td>
          <td>0x0015</td>
          <td>读连接识别超时参数值，定时器终止后蓝牙硬件Q自动拒绝连接</td>
      </tr>
      <tr>
          <td>Write Connection Accept Timeout</td>
          <td>0x0016</td>
          <td>写连接识别超时参数值，定时器终止后蓝牙硬件自动拒绝连接</td>
      </tr>
      <tr>
          <td>Read Page Timeout</td>
          <td>0x0017</td>
          <td>读寻呼超时参数值，本地设备返回连接失败前，该值是允许蓝牙硬件定义等待远程设备 连接申请时间</td>
      </tr>
      <tr>
          <td>Write Page Timeout</td>
          <td>0x0018</td>
          <td>写寻呼超时参数值，本地设备返回连接失败前，该值是允许蓝牙硬件定义等待远程设备 连接申请时间</td>
      </tr>
      <tr>
          <td>Read Scan Enable</td>
          <td>0x0019</td>
          <td>写出扫描允许参数值&mdash;用来控制蓝牙设备周期性查询</td>
      </tr>
      <tr>
          <td>WriteScanEnable</td>
          <td>0x001A</td>
          <td>读出扫描允许参数值&mdash;用来控制蓝牙设备周期性查询</td>
      </tr>
      <tr>
          <td>Read Page Scan Activity</td>
          <td>0x001B</td>
          <td>读寻呼扫描间隔、寻呼扫描区间参数</td>
      </tr>
      <tr>
          <td>Write Page Scan Activity</td>
          <td>0x001C</td>
          <td>写寻呼扫描间隔、寻呼扫描区间参数</td>
      </tr>
      <tr>
          <td>Read Inquiry Scan Activity</td>
          <td>0x001D</td>
          <td>读查询扫描间隔、查询扫描区间参数</td>
      </tr>
      <tr>
          <td>Write Inquiry Scan Activity</td>
          <td>0x001E</td>
          <td>写查询扫描间隔、查询扫描区间参数</td>
      </tr>
      <tr>
          <td>Read Authentication Enable</td>
          <td>0x001F</td>
          <td>读取鉴权允许参数&ndash;控制蓝牙设备是否对每个连接进行鉴权</td>
      </tr>
      <tr>
          <td>Write Authentication Enable</td>
          <td>0x0020</td>
          <td>写取鉴权允许参数&mdash;控制蓝牙设备是否对每个连接进行鉴权</td>
      </tr>
      <tr>
          <td>Read Encryption Mode</td>
          <td>0x0021</td>
          <td>读加密模式数值&mdash;控制蓝牙设备是否对每个连接进行加密</td>
      </tr>
      <tr>
          <td>Write Encryption Mode</td>
          <td>0x0022</td>
          <td>写加密模式数值-控制蓝牙设备是否对每个连接进行加密</td>
      </tr>
      <tr>
          <td>Read Class Of Device</td>
          <td>0x0023</td>
          <td>读取设备类型参数值，用于区别设备能力</td>
      </tr>
      <tr>
          <td>Write Class Of Device</td>
          <td>0x0024</td>
          <td>写设备类型参数值，用于区别设备能力</td>
      </tr>
      <tr>
          <td>Read Voice Setting</td>
          <td>0x0025</td>
          <td>读取语音设置参数值，控制语音连接的各种设置</td>
      </tr>
      <tr>
          <td>Write Voice Setting</td>
          <td>0x0026</td>
          <td>写语音设置参数值，控制语音连接的各种设置</td>
      </tr>
      <tr>
          <td>Read AutomaticFlush Timeout</td>
          <td>0x0027</td>
          <td>对指定句柄，读取刷新超时值</td>
      </tr>
      <tr>
          <td>Write Automatic Flush Timeout</td>
          <td>0x0028</td>
          <td>对指定句柄，写入刷新超时值</td>
      </tr>
      <tr>
          <td>Read Num Broadcast Retransmissions</td>
          <td>0x0029</td>
          <td>读取设备的广播重复发送次数，重复发送提高广播消息的可靠性</td>
      </tr>
      <tr>
          <td>Write NumBroadcast Retransmissions</td>
          <td>0x002A</td>
          <td>写入设备的广播重复发送次数，重复发送提高广播消息的可靠性</td>
      </tr>
      <tr>
          <td>Read Hold Mode Activity</td>
          <td>0x002B</td>
          <td>读取Hold Mode Activity的参数值，用来确定Hold挂起的时间</td>
      </tr>
      <tr>
          <td>Write Hold Mode Activity</td>
          <td>0x002C</td>
          <td>写入Hold Mode Activity的参数值，用来确定Hold挂起的时间</td>
      </tr>
      <tr>
          <td>Read Transmit Power Level</td>
          <td>0x002D</td>
          <td>对指定句柄，读取传输功率的参数值</td>
      </tr>
      <tr>
          <td>Read Synchronous Flow Control Enable</td>
          <td>0x002E</td>
          <td>读取SCO流量控制设置。通过使用该设置，主机控制器决定是否主机控制器发送与SCO 连接句柄相关的完成分组事件的数量</td>
      </tr>
      <tr>
          <td>Write Synchronous Flow Control Enable</td>
          <td>0x002F</td>
          <td>读写入SCO流量控制设置。通过使用该设置，主机控制器决定是否主机控制器发送与 SCO连接句柄相关的完成分组事件的数量</td>
      </tr>
      <tr>
          <td>Set Host Controller To Host Flow Control</td>
          <td>0x0031</td>
          <td>主机控制器的打开、关闭，主机控制器到主机的流量控制</td>
      </tr>
      <tr>
          <td>Host Buffer Size</td>
          <td>0x0033</td>
          <td>主机通知主机控制器自己的ACL、SCO数据缓冲区大小。主机控制器分段传输数据，而 数据不会超出这个范围</td>
      </tr>
      <tr>
          <td>Host Number Of Completed Packets</td>
          <td>0x0035 制器</td>
          <td>当主机对于任何连接的句柄准备接受较多的HCI指令时，该指令用于通过主机指出主机控</td>
      </tr>
      <tr>
          <td>Read Link Supervision Timeout</td>
          <td>0x0036</td>
          <td>读取连接管理超时参数。主从蓝牙设备用该参数监视链路丢失情况</td>
      </tr>
      <tr>
          <td>Write Link Supervision Timeout</td>
          <td>0x0037</td>
          <td>写入连接管理超时参数。主从蓝牙设备用该参数监视链路丢失情况</td>
      </tr>
      <tr>
          <td>Read Number of Supported IAC</td>
          <td>0x0038</td>
          <td>读取查询扫描期间本地蓝牙扫描的查询识别码（ICA）的数值</td>
      </tr>
      <tr>
          <td>Read Current IAC LAP</td>
          <td>0x0039</td>
          <td>读取创建在查询扫描期间本地蓝牙设备正同时扫描的蓝牙识别码的LAP</td>
      </tr>
      <tr>
          <td>Write Current IAC LAP</td>
          <td>0x003A</td>
          <td>写入创建在查询扫描期间本地蓝牙设备正同时扫描的蓝牙识别码的LAP</td>
      </tr>
      <tr>
          <td>Read Page Scan Period Mode</td>
          <td>0x003B</td>
          <td>读取本地蓝牙设备的强制寻呼扫描区间模式</td>
      </tr>
      <tr>
          <td>Write Page Scan Period Mode</td>
          <td>0x003C C</td>
          <td>写入本地蓝牙设备的强制寻呼扫描区间模式</td>
      </tr>
      <tr>
          <td>Read Page Scan Mode</td>
          <td>0x003D</td>
          <td>读取本地蓝牙设备的默认寻呼扫描区间模式</td>
      </tr>
      <tr>
          <td>Write Page Scan Mode</td>
          <td>0x003E</td>
          <td>写入本地蓝牙设备的默认寻呼扫描区间模式</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>信息指令参数</p>
<table>
  <thead>
      <tr>
          <th>命令</th>
          <th>OCF</th>
          <th>简介</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Read Local Version Information</td>
          <td>0x0001</td>
          <td>读取本地蓝牙版本信息</td>
      </tr>
      <tr>
          <td>Read Local Supported Features</td>
          <td>0x0003</td>
          <td>读取本地蓝牙设备特征表</td>
      </tr>
      <tr>
          <td>Read Local Extended Features</td>
          <td>0x0004</td>
          <td></td>
      </tr>
      <tr>
          <td>Read Buffer Size</td>
          <td>0x0005</td>
          <td>返回HCI缓冲容量。缓冲容量用于传输缓冲数据</td>
      </tr>
      <tr>
          <td>Read Country Code [Deprecated]</td>
          <td>0x0007</td>
          <td>读取国家代码状态参数值</td>
      </tr>
      <tr>
          <td>Read BD ADDR</td>
          <td>0x0009</td>
          <td>读取BD_ADDR的参数值</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>状态指令参数</p>
<table>
  <thead>
      <tr>
          <th>命令</th>
          <th>OCF</th>
          <th>简介</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Read Failed Contact Count</td>
          <td>0x0001</td>
          <td>读取对于其他设备特殊连接的Failed Contact Count参数值。Failed Contact Count记录在刷新时终止及 当前正在传输的L2CAP数据指令被自动刷新后，主单元或从单元不能连续响应事件次数</td>
      </tr>
      <tr>
          <td>Reset Failed</td>
          <td>0x0002</td>
          <td>复位时对于其他设备的连接的Failed Contact Count的参数值。Failed Contact Count记录在刷新时终止 及当前正在传输的L2CAP数据指令被自动刷新后，主单元或从单元不能连续响应事件次数</td>
      </tr>
      <tr>
          <td>Contact Count Get LinkQuality</td>
          <td>0x0003</td>
          <td>读取指定连接句柄的LinkQuality的值</td>
      </tr>
      <tr>
          <td>Read RSSI</td>
          <td>0x0005</td>
          <td>读取对于其他蓝牙设备连接句柄的接收信号强度指示</td>
      </tr>
      <tr>
          <td>Read AFH Channel Map</td>
          <td>0x0007</td>
          <td></td>
      </tr>
      <tr>
          <td>Read BD Clock</td>
          <td>0x0009</td>
          <td></td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>测试指令</p>
<table>
  <thead>
      <tr>
          <th>命令</th>
          <th>OCF</th>
          <th>简介</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Read Loopback Mode</td>
          <td>0x0001</td>
          <td>读取主机端控制器会送模式的设置值。回送模式设置可以确定信息发送路径</td>
      </tr>
      <tr>
          <td>Write Loopback Mode</td>
          <td>0x0002</td>
          <td>写入主机控制器会送模式的设置值。回送模式设置可以确定信息发送路径</td>
      </tr>
      <tr>
          <td>Enable Device Under Test Mode</td>
          <td>0x0003</td>
          <td>允许本地蓝牙设备模块通过LMP测试指令接入测试模式。当主机要求本地设备作为待测试设备， 实现蓝牙测试模式文件中规定测试场景，则发送该指令</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>错误代码</p>
<table>
  <thead>
      <tr>
          <th>错误代码</th>
          <th>错误含义</th>
          <th>错误代码</th>
          <th>错误含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x01</td>
          <td>位置HCI指令</td>
          <td>0x14</td>
          <td>由于另一端引起连接中断：资源限制</td>
      </tr>
      <tr>
          <td>0x02</td>
          <td>不能连接</td>
          <td>0x15</td>
          <td>由于另一端引起连接中断：关机</td>
      </tr>
      <tr>
          <td>0x03</td>
          <td>硬件故障</td>
          <td>0x16</td>
          <td>本机中断连接</td>
      </tr>
      <tr>
          <td>0x04</td>
          <td>寻呼超时</td>
          <td>0x17</td>
          <td>重复尝试</td>
      </tr>
      <tr>
          <td>0x05</td>
          <td>身份验证失败</td>
          <td>0x18</td>
          <td>不允许匹配</td>
      </tr>
      <tr>
          <td>0x06</td>
          <td>键丢失</td>
          <td>0x19</td>
          <td>未知LMP PDU</td>
      </tr>
      <tr>
          <td>0x07</td>
          <td>存储器已满</td>
          <td>0x1A</td>
          <td>不支持远端特性</td>
      </tr>
      <tr>
          <td>0x08</td>
          <td>连接超时</td>
          <td>0x1B</td>
          <td>拒绝SCO补偿</td>
      </tr>
      <tr>
          <td>0x09</td>
          <td>最大连接数</td>
          <td>0x1C</td>
          <td>拒绝SCO间歇模式</td>
      </tr>
      <tr>
          <td>0x0A</td>
          <td>连接到设备A的最大SCO连接数</td>
          <td>0x1D</td>
          <td>拒绝SCO无线模式</td>
      </tr>
      <tr>
          <td>0x0B</td>
          <td>ACL连接已存在</td>
          <td>0x1E</td>
          <td>非法链路管理参数</td>
      </tr>
      <tr>
          <td>0x0C</td>
          <td>指令非法</td>
          <td>0x1F</td>
          <td>未特别指明错误</td>
      </tr>
      <tr>
          <td>0x0D</td>
          <td>由于资源有限，主机被拒绝</td>
          <td>0x20</td>
          <td>不支持链路管理器协议参数</td>
      </tr>
      <tr>
          <td>0x0E</td>
          <td>由于安全原因，主机被拒绝</td>
          <td>0x21</td>
          <td>不允许角色改变</td>
      </tr>
      <tr>
          <td>0x0F</td>
          <td>由于远端设备单连接设备，主机拒绝</td>
          <td>0x22</td>
          <td>链路管理响应超时</td>
      </tr>
      <tr>
          <td>0x10</td>
          <td>主机超时</td>
          <td>0x23</td>
          <td>链路管理错误处理Q事务冲突</td>
      </tr>
      <tr>
          <td>0x11</td>
          <td>不支持特性或参数值</td>
          <td>0x24</td>
          <td>不允许LMPPDU</td>
      </tr>
      <tr>
          <td>0x12</td>
          <td>非法主机控制接口指令</td>
          <td>0x25~0xFF</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>0x13</td>
          <td>由于另一端引起连接中断：用户中断连接</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<h3 id="逻辑链路控制与适配协议l2cap">
<a class="header-anchor" href="#%e9%80%bb%e8%be%91%e9%93%be%e8%b7%af%e6%8e%a7%e5%88%b6%e4%b8%8e%e9%80%82%e9%85%8d%e5%8d%8f%e8%ae%ael2cap"></a>
逻辑链路控制与适配协议（L2CAP）
</h3><p>L2CAP位于基带之上，将基带的数据分组转换为便于高层应用的数据分组格式，并提供协议复用和服务质量交换等功能。L2CAP只支持ACL数据传输，不支持SCO数据。</p>
<p>L2CAP本身不提供加强信道可靠性和保证数据完整性的机制，其信道的可靠性依靠基带提供。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_13_2_34_202412131302654.png" alt="L2CAP协议栈"></p>
<ol>
<li>协议复用：底层传输协议没有提供对高层协议的复用机制，因而L2CAP支持高层协议复用，L2CAP层可以区分其上的SDP、RFCOMM、TCS等。</li>
<li>分段重组：L2CAP层帮助实现基带的短PDU和高层的长PDU相互传输，L2CAP本身不完成任何PDU的分段重组，具体的分段重组有低层和高层来完成。</li>
<li>服务质量 Quality of Service 信息的交换：蓝牙建立连接的过程中，L2CAP允许交互蓝牙所期望的服务质量，建立完成后，通过监视资源的使用情况，来保证服务质量。</li>
<li>组抽象：L2CAP忽略地址组概念，他只关心数据。</li>
</ol>
<p>L2CAP信道有三种类型：</p>
<ol>
<li>
<p>面向连接信道：Connection-Oriented CO，用于两个设备之间的数据通信。</p>
</li>
<li>
<p>无连接信道：Connection-Less CL，用来向一组设备广播方式传输数据。CID为固定值：0x0002。</p>
</li>
<li>
<p>信令信道：Signaling，用于创建CO通道，可以通过协商改变CO信道的特性</p>
</li>
</ol>
<p>CL信道的L2CAP_PDU:</p>
<table>
  <thead>
      <tr>
          <th>长度 (2bytes)</th>
          <th>信道ID (0x0002)</th>
          <th>PSM(最小为2bytes)</th>
          <th>有效载荷</th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>
<p>PSM为 协议/服务复用器Protocol/Service Multiplexer，一般为SDP、RFCOMM、TCS等中介协议复用,是小于0x1000的值，0x0001对应SDP，0x0003对应RFCOMM、0x0005对应TCS。</p>
<h4 id="蓝牙逻辑链路控制与适配协议信令">
<a class="header-anchor" href="#%e8%93%9d%e7%89%99%e9%80%bb%e8%be%91%e9%93%be%e8%b7%af%e6%8e%a7%e5%88%b6%e4%b8%8e%e9%80%82%e9%85%8d%e5%8d%8f%e8%ae%ae%e4%bf%a1%e4%bb%a4"></a>
蓝牙逻辑链路控制与适配协议信令
</h4><p>L2CAP的信令通道的CID为0x0001， <strong>信令指令分组：</strong></p>
<table>
  <thead>
      <tr>
          <th>长度 (2byte)</th>
          <th>CID(0x0001)</th>
          <th>指令1</th>
          <th>指令2</th>
          <th>&hellip;</th>
          <th>指令n</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>L2CAP分组头部分</td>
          <td>==</td>
          <td>==</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p><strong>信令指令格式：</strong></p>
<table>
  <thead>
      <tr>
          <th>代码 (1byte)</th>
          <th>标识符 (1byte)</th>
          <th>长度(2byte)</th>
          <th>数据</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>信令指令头</td>
          <td>==</td>
          <td>==</td>
          <td>==</td>
      </tr>
  </tbody>
</table>
<p>L2CAP信令的格式为：</p>
<pre><code>Role:Master
Address:11
PDULength: 6  //指令的长度，值为06 00
ChannelID: 0x0001  (Signaling)//L2CAP的信令通道，值为01 00
Code:Information request//信息请求，值为0a
Identifier:1//标识符，值为01
CommandLength: 2//命令长度，值为02 00
InfoType:Extended features supported//02 00
</code></pre>
<p>所以这条指令的完整形式为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">06 00 01 00 0a 01 02 00 02 00
</span></span></code></pre></div><p><strong>L2CAP信令指令码：</strong></p>
<table>
  <thead>
      <tr>
          <th>信令指令码</th>
          <th>描述</th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00</td>
          <td>RESERVED</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>0x01</td>
          <td>Command reject</td>
          <td>拒绝命令</td>
      </tr>
      <tr>
          <td>0x02</td>
          <td>Connection request</td>
          <td>连接请求</td>
      </tr>
      <tr>
          <td>0x03</td>
          <td>Connection response</td>
          <td>连接响应</td>
      </tr>
      <tr>
          <td>0x04</td>
          <td>Configure request</td>
          <td>配置请求</td>
      </tr>
      <tr>
          <td>0x05</td>
          <td>Configure response</td>
          <td>配置响应</td>
      </tr>
      <tr>
          <td>0x06</td>
          <td>Disconnection request</td>
          <td>断开请求</td>
      </tr>
      <tr>
          <td>0x07</td>
          <td>Disconnection response</td>
          <td>断开响应</td>
      </tr>
      <tr>
          <td>0x08</td>
          <td>Echo request</td>
          <td></td>
      </tr>
      <tr>
          <td>0x09</td>
          <td>Echo response</td>
          <td></td>
      </tr>
      <tr>
          <td>0x0A</td>
          <td>Information request</td>
          <td>信息请求</td>
      </tr>
      <tr>
          <td>0x0B</td>
          <td>Information response</td>
          <td>信息响应</td>
      </tr>
  </tbody>
</table>
<ol>
<li>
<p>连接请求</p>
<table>
  <thead>
      <tr>
          <th>代码 (0x02)</th>
          <th>标识符 (1字节)</th>
          <th>长度 (2字节)</th>
          <th>PSM (2字节)</th>
          <th>源CID (2字节)</th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>
<p>假设一条SDP的连接请求为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Role:Master
</span></span><span class="line"><span class="cl">Address:50
</span></span><span class="line"><span class="cl">PDU Length:8
</span></span><span class="line"><span class="cl">Channel ID:0x0001 [Signaling]
</span></span><span class="line"><span class="cl">Code:Connection Request
</span></span><span class="line"><span class="cl">Identifier:3
</span></span><span class="line"><span class="cl">Command Length:4
</span></span><span class="line"><span class="cl">Protocol/Service Multiplexer:SDP
</span></span><span class="line"><span class="cl">Source Channel ID:0x0040
</span></span></code></pre></div><p>所以上述的报文为</p>
<table>
  <thead>
      <tr>
          <th>代码(0x02)</th>
          <th>标识符 (1字节)</th>
          <th>长度 (2字节)</th>
          <th>PSM (2字节)</th>
          <th>源CID (2字节)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x02</td>
          <td>3</td>
          <td>4</td>
          <td>SDP</td>
          <td>0x0040</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>连接响应</p>
<table>
  <thead>
      <tr>
          <th>代码 (0x03)</th>
          <th>标识符</th>
          <th>长度</th>
          <th>目标CID</th>
          <th>源CID</th>
          <th>结果</th>
          <th>状态</th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>
<p>假设一条SDP请求响应为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Role:Slave
</span></span><span class="line"><span class="cl">Address:50
</span></span><span class="line"><span class="cl">PDU Length:12
</span></span><span class="line"><span class="cl">Channel ID:0x0001 [Signaling)
</span></span><span class="line"><span class="cl">Code:Connection Response
</span></span><span class="line"><span class="cl">Identifier:3
</span></span><span class="line"><span class="cl">Command Length:8
</span></span><span class="line"><span class="cl">Destination Channel ID:0x0040
</span></span><span class="line"><span class="cl">Source Channel ID:0x0040
</span></span><span class="line"><span class="cl">Result:Connection successful
</span></span></code></pre></div><p>所以上述的报文为：</p>
<table>
  <thead>
      <tr>
          <th>代码(0x03)</th>
          <th>标识符</th>
          <th>长度</th>
          <th>目标CID</th>
          <th>源CID</th>
          <th>结果</th>
          <th>状态</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x03</td>
          <td>3</td>
          <td>8</td>
          <td>0x0040</td>
          <td>0x0040</td>
          <td>0x0000</td>
          <td></td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>MTU MAXIMUMTRANSMISSION UNIT最大传输单元</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Role:Master
</span></span><span class="line"><span class="cl">Address:11
</span></span><span class="line"><span class="cl">PDU Length:14
</span></span><span class="line"><span class="cl">Channel ID:0x0001 [Signaling]
</span></span><span class="line"><span class="cl">Code:Configure Response
</span></span><span class="line"><span class="cl">Identifier:2
</span></span><span class="line"><span class="cl">Command Length:10
</span></span><span class="line"><span class="cl">Source Channel ID:0x0049
</span></span><span class="line"><span class="cl">C Flag:Last Configuration Request
</span></span><span class="line"><span class="cl">Results:Success
</span></span><span class="line"><span class="cl">Option:MAXIMUM TRANSMISSION UNIT (MTU)
</span></span><span class="line"><span class="cl">	Length:2
</span></span><span class="line"><span class="cl">	value:48
</span></span></code></pre></div><p>MTU最大传输单元，L2CAP应用必须支持最小为48字节的MTU，默认值为672</p>
</li>
</ol>
<h3 id="服务发现协议sdp">
<a class="header-anchor" href="#%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0%e5%8d%8f%e8%ae%aesdp"></a>
服务发现协议（SDP）
</h3><p>SDP两种服务发现模式：</p>
<ol>
<li>服务搜索：查询具有特定服务属性的服务；</li>
<li>服务浏览：简单的浏览全部可用服务。</li>
</ol>
<p>PDU 格式：（协议数据单元）</p>
<table>
  <thead>
      <tr>
          <th>PDU ID (1byte)</th>
          <th>Transaction ID (2byte)</th>
          <th>参数长度 (2byte)</th>
          <th>参数1</th>
          <th>&hellip;</th>
          <th>参数N</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Header</td>
          <td>==</td>
          <td>==</td>
          <td></td>
          <td>==</td>
          <td>==</td>
      </tr>
  </tbody>
</table>
<p>不同PDU ID实现SDP的不同功能，概述如下表格：</p>
<table>
  <thead>
      <tr>
          <th>ID</th>
          <th>参数描述</th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x00</td>
          <td>Reserved</td>
          <td>保留</td>
      </tr>
      <tr>
          <td>0x01</td>
          <td>SDP_ErrorResponse</td>
          <td>错误响应</td>
      </tr>
      <tr>
          <td>0x02</td>
          <td>SDP_ServiceSearchRequest</td>
          <td>服务搜索请求</td>
      </tr>
      <tr>
          <td>0x03</td>
          <td>SDP_ServiceSearchResponse</td>
          <td>服务搜索响应</td>
      </tr>
      <tr>
          <td>0x04</td>
          <td>SDP_ServiceAttributeRequest</td>
          <td>服务属性请求</td>
      </tr>
      <tr>
          <td>0x05</td>
          <td>SDP_ServiceAttributeResponse</td>
          <td>服务属性响应</td>
      </tr>
      <tr>
          <td>0x06</td>
          <td>SDP_ServiceSearchAttributeRequest</td>
          <td>服务搜索属性请求</td>
      </tr>
      <tr>
          <td>0x07</td>
          <td>SDP_ServiceSearchAttributeResponse</td>
          <td>服务搜索属性响应</td>
      </tr>
      <tr>
          <td>0x08-0xff</td>
          <td>Reserved</td>
          <td>保留</td>
      </tr>
  </tbody>
</table>
<p>服务记录表：</p>
<p>SDP的服务记录表对每一个服务进行描述，每条记录包含服务句柄、一组服务属性：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_13_45_58_202412131345470.png" alt="SDP服务记录表"></p>
<p>Service Record Attributes：服务记录；</p>
<p>Service Record Handle 服务句柄；</p>
<p>Attribute 服务属性；</p>
<h3 id="串口仿真协议rfcomm">
<a class="header-anchor" href="#%e4%b8%b2%e5%8f%a3%e4%bb%bf%e7%9c%9f%e5%8d%8f%e8%ae%aerfcomm"></a>
串口仿真协议（RFCOMM）
</h3><p>为建立在串口之上的传统应用提供环境接口，使他们可以做比较少协议改动就可以在蓝牙无线通信无线链路上工作。多路串口仿真是RFCOMM的重要功能，通过多路复用器(multiplexer)，一条L2CAP链路可以同时多个串行应用。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_13_47_46_202412131347355.png" alt="两台设备间的串口仿真"></p>
<p>RFCOMM 两个蓝牙设备之间可以支持多达60多路仿真串口。</p>
<p>RFCOMM帧类型如下：</p>
<table>
  <thead>
      <tr>
          <th>帧类型</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>SABM</td>
          <td>异步平衡模式设置指令</td>
      </tr>
      <tr>
          <td>UA</td>
          <td>未加编号的确认响应</td>
      </tr>
      <tr>
          <td>DM</td>
          <td>断开连接模式响应</td>
      </tr>
      <tr>
          <td>DISC</td>
          <td>断开连接指令</td>
      </tr>
      <tr>
          <td>UIH</td>
          <td>带头校验的未编号信息命令和响应</td>
      </tr>
  </tbody>
</table>
<h2 id="应用协议">
<a class="header-anchor" href="#%e5%ba%94%e7%94%a8%e5%8d%8f%e8%ae%ae"></a>
应用协议
</h2><h3 id="irda互操作协议">
<a class="header-anchor" href="#irda%e4%ba%92%e6%93%8d%e4%bd%9c%e5%8d%8f%e8%ae%ae"></a>
IrDA互操作协议
</h3><p>IrOBEX 红外对象交互协议，简称OBEX，使高层协议同时运作在蓝牙和红外的无线链路之上。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_13_54_58_202412131354134.png" alt="IrDA互操协议"></p>
<p>主要操作指令有：连接操作、断开操作、Put操作、Get操作。</p>
<ol>
<li>
<p>连接操作</p>
<p>操作码为0x80</p>
<table>
  <thead>
      <tr>
          <th>字节0</th>
          <th>字节1、2</th>
          <th>字节3</th>
          <th>字节4</th>
          <th>字节5、6</th>
          <th>字节7~n</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x80</td>
          <td>连接请求分组长度</td>
          <td>OBEX版本号</td>
          <td>标志</td>
          <td>客户端可接收最大的OBEX分组长度</td>
          <td>可选头</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>断开操作：操作码为0x81</p>
</li>
<li>
<p>PUT操作：操作码为0x02，连接成功后，客户端通过Put请求向服务器“推送”对象，如果对象较大，Put请求可以用多个Put请求分组。</p>
</li>
<li>
<p>Get操作：操作码为0x30</p>
</li>
</ol>
<h3 id="音频与电话控制协议">
<a class="header-anchor" href="#%e9%9f%b3%e9%a2%91%e4%b8%8e%e7%94%b5%e8%af%9d%e6%8e%a7%e5%88%b6%e5%8d%8f%e8%ae%ae"></a>
音频与电话控制协议
</h3><ol>
<li>
<p>框架部分</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_14_0_8_202412131400395.png" alt="音频与电话协议框架"></p>
<p>蓝牙音频如上图协议栈所示：音频通过基带传输同步面向连接分组实现，没有以规范的形式给出，不是协议栈的一部分。
TCS_Binary是一种基于分组电话控制二进制编码指令集，位于L2CAP之上。实现蓝牙无绳电话、对讲机功能。
RFCOMM用于AT指令，拨号上网、蓝牙耳机、耳麦、传真通过AT发送指令控制。</p>
</li>
<li>
<p>音频部分</p>
<p>64kbps电信级语言质量音频流
CVSD  continuous variable slope delta 连续可变斜率增量。
PCM  pulse code modulation 。
PCM存在斜率效应。CVSD使用音节压缩算法，编码步长根据信号斜率变化自动调整，是现在比较好的编码方案，提高语言的抗干扰能力。</p>
</li>
<li>
<p>电话控制部分</p>
<p>TCS-Binary电话控制部分。</p>
<ol>
<li>电话呼叫： 呼叫控制、呼叫建立、呼叫拆除；</li>
<li>组管理： 访问权限请求、分布式配置、快速内部成员访问。</li>
</ol>
</li>
</ol>
<h3 id="网络封装协议bnep">
<a class="header-anchor" href="#%e7%bd%91%e7%bb%9c%e5%b0%81%e8%a3%85%e5%8d%8f%e8%ae%aebnep"></a>
网络封装协议（BNEP）
</h3><p>BNEP BluetoothNetworkEncapsulation Protocol 网络封装协议。</p>
<p>为了使集成蓝牙技术的电脑、电话、PDA、家用电器等网络设备交换信息，需要在网络层统一数据分组。网络封装协议将来自不同网络的数据分组重新封装，通过L2CAP进行传输。这部分协议感觉在现实中用处不大，有更多简单便捷的方法去实现网络功能。 BNEP支持Ipv4、Ipv6、IPX</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_14_21_26_202412131421825.png" alt="网络封装协议"></p>
<h3 id="音频分发协议avdtp">
<a class="header-anchor" href="#%e9%9f%b3%e9%a2%91%e5%88%86%e5%8f%91%e5%8d%8f%e8%ae%aeavdtp"></a>
音频分发协议（AVDTP）
</h3><p>AVDTPAudio/Video Distribution Transport Protocol音视频分发传输协议</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_14_22_25_202412131422861.png" alt="音频分发协议"></p>
<p>有关A/V的协议有 AVDTP音视频分发传输协议、AVCTP音视频控制传输协议、GAVDP通用音视频分发框架、A2DP高级音频分发框架、AVCRP音视频遥控框架</p>
<h4 id="基本概念术语">
<a class="header-anchor" href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5%e6%9c%af%e8%af%ad"></a>
基本概念术语
</h4><p>**流stream:**流是音视频传输的数据形式，单向传输，在AVDTP中被分为媒介分组。流有句柄HS统一标识。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_14_23_55_202412131423751.png" alt="流"></p>
<h4 id="信令">
<a class="header-anchor" href="#%e4%bf%a1%e4%bb%a4"></a>
信令
</h4><p>AVDTP信令列表</p>
<table>
  <thead>
      <tr>
          <th>命令</th>
          <th>信令标识符</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>AVDTP_DISCOVER</td>
          <td>0x01</td>
          <td>发现设备中的流端点</td>
      </tr>
      <tr>
          <td>AVDTP_GET_CAPABILITIES</td>
          <td>0x02</td>
          <td>获得流端点的信息能力</td>
      </tr>
      <tr>
          <td>AVDTP SET CONFIGURATION</td>
          <td>0x03</td>
          <td>对SEP进行配置</td>
      </tr>
      <tr>
          <td>AVDTP GET CONFIGURATION</td>
          <td>0x04</td>
          <td>获取SEP当前配置</td>
      </tr>
      <tr>
          <td>AVDTP_RECONFIGURE</td>
          <td>0x05</td>
          <td>对SEP重新配置</td>
      </tr>
      <tr>
          <td>AVDTP_OPEN</td>
          <td>0x06</td>
          <td>成功的配置SEP后，打开流</td>
      </tr>
      <tr>
          <td>AVDTP_START</td>
          <td>0x07</td>
          <td>流被打开：用于开始形成流；流暂停时：用于重新形成流。</td>
      </tr>
      <tr>
          <td>AVDTP_CLOSE</td>
          <td>0x08</td>
          <td>对SEP关闭</td>
      </tr>
      <tr>
          <td>AVDTP_SUSPEND</td>
          <td>0x09</td>
          <td>请求SEP暂停</td>
      </tr>
      <tr>
          <td>AVDTP_SECURITY_CONTROL</td>
          <td>0xOA</td>
          <td>设置设备内容保护、或者请求设备状况信息</td>
      </tr>
      <tr>
          <td>AVDTP_ABORT</td>
          <td>0xOB</td>
          <td>中断正在建立或者传输的过程</td>
      </tr>
      <tr>
          <td>AVDTP_GET_ALL_CAPABILITIES</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>AVDTP_DELAYREPORT</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>这部分信令，实现了蓝牙的A2DP 数据流的控制；</p>
<p>流的信令管理流程</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_14_25_56_202412131425891.png" alt="image-20241213142556572"></p>
<h3 id="音视频控制传输协议avctp">
<a class="header-anchor" href="#%e9%9f%b3%e8%a7%86%e9%a2%91%e6%8e%a7%e5%88%b6%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%aeavctp"></a>
音视频控制传输协议（AVCTP）
</h3><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/13_14_27_38_202412131427909.png" alt="AVCTP"></p>
<p>AVCTP可以使音视频设备同时支持多个应用框架，每个应用框架定义了各自相应的消息格式与应用规则。
这部分操作，在现实的应用中也有不足的地方，蓝牙传输的数据量有限，实现这些功能有一定的不足。随着科学技术的发展，蓝牙在无线通信方面的优点、缺点都凸显出来，找的合适的方向，合理的发展方向是硬道理。</p>

      
    </div>
    <footer class="article-footer">
      

      

      

      

      

      

      

      
      <ul class="article-tag-list" itemprop="keywords">
  
    <li class="article-tag-list-item" data-aos="zoom-in">
      <a
        class="article-tag-list-link"
        href="/tags/%e9%80%9a%e4%bf%a1%e5%8d%8f%e8%ae%ae"
        rel="tag"
        >通信协议</a
      >
    </li>
  
</ul>

    </footer>
  </div>
  
    
  <nav
    id="article-nav"
    data-aos="fade-up"
  >
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          <img
            data-src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/11_8_56_5_202410110856024.png"
            data-sizes="auto"
            alt="BootLoader"
            class="lazyload"
          />
        
        <a href="http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/bootloader/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            BootLoader
          
        </h3>
      </div>
    

    
      <div class="article-nav-link-wrap article-nav-link-right">
        
          
          
            <img
              data-src="https://wallpaperm.cmcm.com/0feb1a932efcb5aa8c20423e777c277d.jpg"
              data-sizes="auto"
              alt="Batch"
              class="lazyload"
            />
          
        
        <a href="http://localhost:1313/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/batch/"></a>
        <div class="article-nav-caption">后一篇</div>
        <h3 class="article-nav-title">
          
            Batch
          
        </h3>
      </div>
    
  </nav>


  
</article>










</section>
        </div>
        
        
        



  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



<footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
      2020 -
      2025
      <span class="footer-info-sep rotate"></span>
      TrustMe
    </div>
    
      <div>
        基于&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div>
    
    
      <div>
        <span class="icon-brush"
          >&nbsp;
            58.9k
          </span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;
          
          

          05:07
        </span>
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >总访问量&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >总访客量&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar">
        <div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#名称由来">名称由来</a></li>
    <li><a href="#发展历史">发展历史</a></li>
    <li><a href="#技术特点">技术特点</a></li>
    <li><a href="#系统组成">系统组成</a></li>
    <li><a href="#蓝牙协议规范">蓝牙协议规范</a></li>
    <li><a href="#硬件接口">硬件接口</a></li>
    <li><a href="#协议栈">协议栈</a></li>
  </ul>

  <ul>
    <li><a href="#广播方式">广播方式</a></li>
    <li><a href="#连接方式">连接方式</a></li>
    <li><a href="#封包过程">封包过程</a>
      <ul>
        <li><a href="#广播方式-1">广播方式</a></li>
        <li><a href="#连接方式-1">连接方式</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#ll">LL</a>
      <ul>
        <li><a href="#广播信道">广播信道</a></li>
        <li><a href="#数据信道">数据信道</a></li>
      </ul>
    </li>
    <li><a href="#gap">GAP</a></li>
    <li><a href="#l2cap">L2CAP</a>
      <ul>
        <li><a href="#cid-的取值范围">CID 的取值范围</a></li>
        <li><a href="#cid-的使用场景">CID 的使用场景</a></li>
        <li><a href="#cid-的分配过程"><strong>CID 的分配过程</strong></a></li>
      </ul>
    </li>
    <li><a href="#attgatt">ATT/GATT</a>
      <ul>
        <li><a href="#uuid">UUID</a></li>
        <li><a href="#handle">Handle</a></li>
      </ul>
    </li>
    <li><a href="#hci">HCI</a></li>
    <li><a href="#smp">SMP</a>
      <ul>
        <li><a href="#常见的code">常见的code</a></li>
        <li><a href="#不同的data格式">不同的data格式</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#广播">广播</a></li>
    <li><a href="#扫描请求和扫描响应">扫描请求和扫描响应</a></li>
    <li><a href="#建立连接">建立连接</a></li>
    <li><a href="#连接事件">连接事件</a></li>
    <li><a href="#配对和绑定">配对和绑定</a>
      <ul>
        <li><a href="#配对特征交换">配对特征交换</a></li>
        <li><a href="#密钥生成">密钥生成</a></li>
        <li><a href="#配对方法">配对方法</a></li>
        <li><a href="#分发密钥">分发密钥</a></li>
      </ul>
    </li>
    <li><a href="#数据传输">数据传输</a></li>
    <li><a href="#连接失败">连接失败</a></li>
    <li><a href="#gap角色">GAP角色</a></li>
  </ul>

  <ul>
    <li><a href="#传输协议">传输协议</a>
      <ul>
        <li><a href="#射频协议">射频协议</a></li>
        <li><a href="#基带与链路控制协议">基带与链路控制协议</a></li>
        <li><a href="#链路管理器">链路管理器</a></li>
      </ul>
    </li>
    <li><a href="#中介协议">中介协议</a>
      <ul>
        <li><a href="#主机控制接口协议hci">主机控制接口协议（HCI）</a></li>
        <li><a href="#逻辑链路控制与适配协议l2cap">逻辑链路控制与适配协议（L2CAP）</a></li>
        <li><a href="#服务发现协议sdp">服务发现协议（SDP）</a></li>
        <li><a href="#串口仿真协议rfcomm">串口仿真协议（RFCOMM）</a></li>
      </ul>
    </li>
    <li><a href="#应用协议">应用协议</a>
      <ul>
        <li><a href="#irda互操作协议">IrDA互操作协议</a></li>
        <li><a href="#音频与电话控制协议">音频与电话控制协议</a></li>
        <li><a href="#网络封装协议bnep">网络封装协议（BNEP）</a></li>
        <li><a href="#音频分发协议avdtp">音频分发协议（AVDTP）</a></li>
        <li><a href="#音视频控制传输协议avctp">音视频控制传输协议（AVCTP）</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
      </div>
      <div class="sidebar-common-sidebar hidden">
        
<div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="TrustMe"
    class="lazyload"
  />
  <div class="sidebar-author-name">TrustMe</div>
  <div class="sidebar-description">你要信我啊</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    
    <div class="sidebar-state-number">59</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">7</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="首页"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="归档"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="关于"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="友链"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>

      </div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
      <div class="site-search">
        <div class="reimu-popup popup">
          <div class="reimu-search">
            <div class="reimu-search-input-icon"></div>
            <div class="reimu-search-input" id="reimu-search-input"></div>
            <div class="popup-btn-close"></div>
          </div>
          <div class="reimu-results">
            <div id="reimu-stats"></div>
            <div id="reimu-hits"></div>
            <div id="reimu-pagination" class="reimu-pagination"></div>
          </div>
          <img class="reimu-bg" src="/images/reimu.png" />
        </div>
      </div>
    
    






  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"
  ></script>




  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"
  ></script>









  
      
      <script src="/js/main.js" ></script>
      



  





  
      
      <script src="/js/aos.js" ></script>
      

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script>








  
      
      <script src="/js/pjax_main.js" data-pjax></script>
      



  <script>
    var ALGOLIA_CONFIG = {
      logo: '\/images\/algolia_logo.svg',
      algolia: {
        applicationID: "",
        apiKey: "",
        indexName: "",
        hits: {
          "per_page": parseInt("10")
        },
        labels: {
          "input_placeholder": "搜索.....",
          "hits_empty": "未发现与 「${query}」相关内容",
          "hits_stats": "找到${hits}条结果（用时 ${time} ms）"
        }
      }
    };
  </script>
  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/algoliasearch@4.17.1/dist/algoliasearch-lite.umd.js"
    defer
    
    
    
    integrity="sha384-xvLS0jfKuoREs7pqkRI/OI8GcqohO5S&#43;jQz7ZBtQXnsXmD&#43;9jDOOY4cL6dCPzlrk" crossorigin="anonymous"
  ></script>


  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/instantsearch.js@4.56.1/dist/instantsearch.production.min.js"
    defer
    
    
    
    integrity="sha384-hHJCflT4KBLQyHfKO9vpstIcFKn/Y&#43;KHTORelMMEn7mOp2AVPp&#43;7fr03dLgZiV3J" crossorigin="anonymous"
  ></script>


  





  
      
      <script src="/js/algolia_search.js" ></script>
      




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/mouse-firework@0.1.0/dist/index.umd.js"
    
    
    
    
    integrity="sha384-KM6i7tu43nYd6e0beIljxHMC5tZc58XBDu7pPA58w50h18Jsx7gLdimfS09RXlKv" crossorigin="anonymous"
  ></script>


<script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"#ff5252\",\"#ff7c7c\",\"#ffafaf\",\"#ffd0d0\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"#ff0000\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>








<div id="lazy-script">
  <div>
    
      
      
        
      
      <script data-pjax>
        window.REIMU_POST = {
          author: "TrustMe",
          title: "Bluetooth",
          url: "http:\/\/localhost:1313\/post\/%E5%B5%8C%E5%85%A5%E5%BC%8F\/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\/bluetooth\/",
          description: " 参考链接 深入浅出低功耗蓝牙(BLE)协议栈及蓝牙连接过程_蓝牙芯片的寄存器组为什么需要分为两块-CSDN博客\n蓝牙核心技术概述（一）:蓝牙概述_蓝牙技术-CSDN博客\n蓝牙核心技术概述（三）： 蓝牙协议规范（射频、基带链路控制、链路管理）_蓝牙3.0技术规范-CSDN博客\n蓝牙核心技术概述（四）：蓝牙协议规范（HCI、L2CAP、SDP、RFOCMM）_蓝牙通信帧分类-CSDN博客\n蓝牙核心技术概述（五）：蓝牙协议规范（irOBEX、BNEP、AVDTP、AVCTP）_蓝牙核心bnep-CSDN博客\nBLE协议学习 – 学习笔记 (giraffexiu.love)\nESP32 …",
          cover: "https:\/\/gitlab.com\/18355291538\/picture\/-\/raw\/main\/pictures\/2024\/12\/9_14_8_59_202412091408388.png",
        };
      </script>
    
    
    
      





  
      
      <script src="/js/insert_highlight.js" data-pjax></script>
      

      
      
      
      
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      












      
    
    
  </div>
</div>




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"
  ></script>





  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>


<script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script>




  </body>
</html>
