<!doctype html>
<html
  lang="zh-cn" 
  
    data-theme-mode="auto"
  
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>







  

<title>
  C | TrustMe
</title>
<meta
  name="description"
  content="你要信我啊"
/>










<script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"clipboard\":{\"copyright\":{\"content\":\"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\",\"count\":50,\"enable\":false},\"fail\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"success\":\"复制成功(*^▽^*)\"},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_0khxww3tj3q9\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":\"本文最后更新于 {time}，请注意文中内容可能已经发生变化。\"}}");
</script>











  
  
  
    
  

  
  
  
    
  

  
    

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>






  <link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_0khxww3tj3q9.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  />



  






 <link rel="stylesheet" href="/css/loader.css" />




  <meta property="og:type" content="website" />
  <meta property="og:title" content="C | TrustMe" />
  <meta
    property="og:description"
    content="你要信我啊"
  />
  <meta property="og:url" content="http://localhost:1313/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/" />
  <meta
    property="og:site_name"
    content="TruestMe&#39;s Blog"
  />
  <meta
    property="og:image"
    content="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/30_10_53_6_202411301053994.png"
  />
  <meta property="article:author" content="TrustMe" />
  <meta property="article:published_time" content="2025-03-01T00:00:00&#43;00:00" />
  <meta property="article:modified_time" content="2025-03-01T00:00:00&#43;00:00" />
  
    <meta property="article:tag" content="编程语言" />
  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/30_10_53_6_202411301053994.png" />
  
  
  
  
  




<link rel="shortcut icon" href="/favicon.ico">







 <link rel="stylesheet" href="/css/main.css" />





  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />






  <link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"
    onload="this.onload=null;this.rel='stylesheet'"
  />








  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"
  ></script>





  


  <link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" />





  </head>
  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff5252" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="#ff5252" />
          </svg>
        
      </div>
      <div class="loading-word">你要信我啊...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        
<div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="/">首页</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="/archives">归档</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="/about">关于</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>
          
            
              &#xe62b;
            
          
        </div>
        <a class="main-nav-link" href="/friend">友链</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
      <a id="nav-search-btn" class="nav-icon popup-trigger" title="搜索"></a>
    
  </nav>
</div>
<header id="header">
  
    
    <picture></picture>
      <img fetchpriority="high" src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/30_10_53_6_202411301053994.png" alt="C">
    
  

  <div id="header-outer">
    <div id="header-title">
      
        
        
          
        
  
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">C</h1>
          </a>
        
      
  
      
        
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>
        <div id="content"
          
          class="sidebar-right"  >
          <aside id="sidebar">
  
  
  <div class="sidebar-wrapper wrap-sticky">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    >
      
        <div class="sidebar-toc-sidebar">
          <div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#宏-1">宏</a></li>
    <li><a href="#条件编译">条件编译</a></li>
    <li><a href="#宏函数">宏函数</a></li>
    <li><a href="#调试宏">调试宏</a></li>
  </ul>

  <ul>
    <li><a href="#sizeof">sizeof</a></li>
    <li><a href="#数据类型关键字">数据类型关键字</a>
      <ul>
        <li><a href="#标准类型">标准类型</a></li>
        <li><a href="#自定义类型">自定义类型</a></li>
        <li><a href="#地址指针类型">地址（指针）类型</a></li>
        <li><a href="#typedef">typedef</a></li>
      </ul>
    </li>
    <li><a href="#修饰关键字">修饰关键字</a>
      <ul>
        <li><a href="#auto">auto</a></li>
        <li><a href="#register">register</a></li>
        <li><a href="#static">static</a></li>
        <li><a href="#extern">extern</a></li>
        <li><a href="#const">const</a></li>
        <li><a href="#volatile">volatile</a></li>
      </ul>
    </li>
    <li><a href="#逻辑关键字">逻辑关键字</a></li>
  </ul>

  <ul>
    <li><a href="#算术运算">算术运算</a></li>
    <li><a href="#位运算">位运算</a></li>
    <li><a href="#逻辑运算">逻辑运算</a></li>
    <li><a href="#内存操作">内存操作</a></li>
  </ul>

  <ul>
    <li><a href="#函数的世界">函数的世界</a>
      <ul>
        <li><a href="#函数的三大属性">函数的三大属性</a></li>
        <li><a href="#函数的参数传递">函数的参数传递</a></li>
      </ul>
    </li>
    <li><a href="#c与面向对象">C与面向对象</a>
      <ul>
        <li><a href="#c与继承">C与继承</a></li>
        <li><a href="#c与封装">C与封装</a></li>
        <li><a href="#c与多态">C与多态</a></li>
        <li><a href="#c与重载">C与重载</a></li>
      </ul>
    </li>
    <li><a href="#solid设计原则">Solid设计原则</a></li>
  </ul>

  <ul>
    <li><a href="#内存分布">内存分布</a>
      <ul>
        <li><a href="#代码段">代码段</a></li>
        <li><a href="#只读数据段">只读数据段</a></li>
        <li><a href="#全局数据段">全局数据段</a></li>
        <li><a href="#堆空间">堆空间</a></li>
        <li><a href="#栈空间">栈空间</a></li>
      </ul>
    </li>
    <li><a href="#内存溢出">内存溢出</a>
      <ul>
        <li><a href="#栈溢出">栈溢出</a></li>
        <li><a href="#堆溢出">堆溢出</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#指针访问内存">指针访问内存</a>
      <ul>
        <li><a href="#指针变量初始化">指针变量初始化</a></li>
        <li><a href="#空指针和野指针">空指针和野指针</a></li>
        <li><a href="#指针访问内存规则">指针访问内存规则</a></li>
      </ul>
    </li>
    <li><a href="#指针运算">指针运算</a>
      <ul>
        <li><a href="#算术运算-1">算术运算</a></li>
        <li><a href="#逻辑运算-1">逻辑运算</a></li>
      </ul>
    </li>
    <li><a href="#多级指针">多级指针</a>
      <ul>
        <li><a href="#指针的地址传值">指针的地址传值</a></li>
        <li><a href="#无序变有序">无序变有序</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#pragma">pragma</a>
      <ul>
        <li><a href="#基本语法">基本语法</a></li>
        <li><a href="#常见使用场景">常见使用场景</a></li>
      </ul>
    </li>
    <li><a href="#attribute">attribute</a>
      <ul>
        <li><a href="#函数属性">函数属性</a></li>
        <li><a href="#变量属性">变量属性</a></li>
        <li><a href="#参数属性">参数属性</a></li>
        <li><a href="#unused"><code>unused</code></a></li>
        <li><a href="#对齐属性">对齐属性</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
        </div>
        <div class="sidebar-common-sidebar hidden">
          
<div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="TrustMe"
    class="lazyload"
  />
  <div class="sidebar-author-name">TrustMe</div>
  <div class="sidebar-description">你要信我啊</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    
    <div class="sidebar-state-number">59</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">7</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="首页"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="归档"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="关于"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="友链"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>

        </div>
      

      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  <div class="sidebar-widget">
    
  </div>
</aside>

          <section id="main">
  <article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta">
      <div class="article-date">
  <span
    class="article-date-link"
    data-aos="zoom-in"
  >
    <time datetime="2025-03-01 00:00:00 &#43;0000 UTC" itemprop="datePublished"
      >2025-03-01</time
    >
    <time style="display: none;" id="post-update-time"
      >2025-03-01</time
    >
  </span>
</div>

      <div class="article-category">
  
</div>

    </div>
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="宏">
<a class="header-anchor" href="#%e5%ae%8f"></a>
宏
</h1><h2 id="宏-1">
<a class="header-anchor" href="#%e5%ae%8f-1"></a>
宏
</h2><blockquote>
<p>[!important]</p>
<p>宏是一个纯粹的文本替换</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define 宏名 宏体
</span></span></span></code></pre></div><p>当宏体包含运算符时，需要增加括号来==限制==宏体和外部的计算优先级</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define 宏名 (带有运算的的宏体)
</span></span></span></code></pre></div><h2 id="条件编译">
<a class="header-anchor" href="#%e6%9d%a1%e4%bb%b6%e7%bc%96%e8%af%91"></a>
条件编译
</h2><p>条件编译语句：编译中的分支语句</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifdef your_macro	</span><span class="c1">//条件编译语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#else	</span><span class="c1">//条件编译语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif	</span><span class="c1">//条件编译语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#if your_macro == constant	</span><span class="c1">//条件编译语句 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif	</span><span class="c1">//条件编译语句
</span></span></span></code></pre></div><p>提示编译语句</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifdef your_macro	
</span></span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#error &#34;error information durnning in the compile&#34;	</span><span class="c1">//在编译过程中会显示的错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#warning &#34;warning information durnning in the compile&#34;	</span><span class="c1">//在编译过程中会显示的警告信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span></code></pre></div><h2 id="宏函数">
<a class="header-anchor" href="#%e5%ae%8f%e5%87%bd%e6%95%b0"></a>
宏函数
</h2><blockquote>
<p>[!important]</p>
<p>宏函数可以减少内存开销</p></blockquote>
<p>简单使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define FUNC(a,b) a*b
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//上面说了，带有运算的宏体需要添加括号，所以想要实现功能需要修改为如下代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define FUNC(a,b) ((a)*(b))
</span></span></span></code></pre></div><p>使用<code>\</code>可以实现宏函数的多行显示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define FUNC(a,b) ((a) = (a) * (b));
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>						<span class="err">\</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">)</span>                           
</span></span></code></pre></div><blockquote>
<p>[!note]</p>
<p>在多行显示的代码中，可以看到(a++)后没有==冒号==</p>
<p>实际上由于宏是纯粹的文本替代，所以在调用FUNC函数时会加上冒号，所以在宏体中不需要加冒号</p></blockquote>
<p>宏函数与分支语句的联动，如果不适用花括号来控制分支语句的作用域，可能会出现不符合预期的结果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">FUNC</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//此时可以通过在if语句中加花括号，亦可以在宏体中使用花括号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define FUNC(a,b) {((a) = (a) * (b));
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>						<span class="err">\</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">)</span><span class="err">；</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//此时只能使用一条if语句，而不能使用else语句，否则会报错，因为我们在宏体中加了分号，展开为
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">((</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">)</span><span class="err">；</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//如果此时增加else语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">FUNC</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">	<span class="nf">FUNC</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//那么展开为
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">((</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">)</span><span class="err">；</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>	<span class="c1">//这里会多出一个冒号，会截断if语句，导致下面的else语句成为独立的else，编译器会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">((</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">)</span><span class="err">；</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>要保证多分支语句的正确运行，我们可以使用do-while语句来控制</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define FUNC(a,b) do{((a) = (a) * (b));
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>						<span class="err">\</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">)</span><span class="err">；</span><span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="c1">//注意，此时的while(0)后面不能加分号，不然使用分支语句时依然会报错                     
</span></span></span></code></pre></div><h2 id="调试宏">
<a class="header-anchor" href="#%e8%b0%83%e8%af%95%e5%ae%8f"></a>
调试宏
</h2><p>使用<code>#</code>来实现字符化</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define LOG_INFO(x) printf(&#34;x is %d\n&#34;,(x))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//此时当我使用该宏时，printf函数中的x并不会被替换，如
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">LOG_INFO</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>	<span class="c1">//打印为x is 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//如果使用#来进行字符化，可以将宏修改为
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define LOG_INFO(x) printf(&#34;%s is %d\n&#34;,#(x),(x))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="nf">LOG_INFO</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>	<span class="c1">//打印为a is 10
</span></span></span></code></pre></div><p>使用<code>##</code>进行连接，一般用于有规律的变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define LOG_INFO(x) printf(&#34;x is %d\n&#34;,(x))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define DAY_DECLARE(x) int day##x
</span></span></span><span class="line"><span class="cl"><span class="cp">#define DAY(x) day##x
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">DAY_DECLARE</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">DAY_DECLARE</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">LOG_INFO</span><span class="p">(</span><span class="nf">DAY</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>	<span class="c1">//打印为DAY（1） is 100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">LOF_INFO</span><span class="p">(</span><span class="nf">DAY</span><span class="p">(</span><span class="mi">21</span><span class="p">));</span>	<span class="c1">//打印为DAY（21） is 200
</span></span></span></code></pre></div><p>使用系统自定义的宏来打印相关信息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">__FUNCTION__</span>	<span class="c1">//用于打印函数名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__LINE__</span>		<span class="c1">//用于打印行号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__FILE__</span>		<span class="c1">//用于打印文件名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__VA_ARGS__</span>		<span class="c1">//在使用可变长变量时用于解析变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl"><span class="c1">//知道这些之后，可以在打印日志的地方来显示调用的函数、行号和文件名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define LOG_INFO(x) printf(&#34;%s:%s:%d %s is %d \n&#34;,__FILE__,__FUNCTION__,__LINE__,#x,(x));
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//上面会打印信息文件名，调用函数名，调用的行号等等相关信息，所以打印结果为1.c:main:23:DAY(21)is 200
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl"><span class="c1">//但是上面的函数的使用限制会很大，不能实际实现printf函数的使用手法，所以可以使用...来控制可变长变量，改造代码如下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define LOG_INFO(x,...) printf(&#34;%s:%s:%d:&#34;x&#34;&#34;,__FILE__,__FUNCTION__,__LINE__,##__VA_ARGS__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//使用方法如下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">LOG_INFO</span><span class="p">(</span><span class="s">&#34;DAY1 = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="nf">DAY</span><span class="p">(</span><span class="mi">21</span><span class="p">));</span>	<span class="c1">//此处会打印1.c:main:23:DAY21=200
</span></span></span></code></pre></div><h1 id="关键字">
<a class="header-anchor" href="#%e5%85%b3%e9%94%ae%e5%ad%97"></a>
关键字
</h1><p>关键字可以被分为3大类：</p>
<ol>
<li>数据类型关键字</li>
<li>修饰关键字</li>
<li>逻辑关键字</li>
</ol>
<h2 id="sizeof">
<a class="header-anchor" href="#sizeof"></a>
sizeof
</h2><blockquote>
<p>[!important]</p>
<p>在编译过程中就已经能算出大小，并不是在运行过程中计算的</p>
<p><code>sizeof</code>并不是函数，而是关键字，所以我们也可以使用<code>sizeof a</code>，来定义一个常量，但是这里需要注意的是<code>a</code>需要在之前已经定义了，且不可以使用<code>sizeof(int)</code>这样的表示</p></blockquote>
<h2 id="数据类型关键字">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%85%b3%e9%94%ae%e5%ad%97"></a>
数据类型关键字
</h2><h3 id="标准类型">
<a class="header-anchor" href="#%e6%a0%87%e5%87%86%e7%b1%bb%e5%9e%8b"></a>
标准类型
</h3><h4 id="char">
<a class="header-anchor" href="#char"></a>
char
</h4><p><code>char</code>类型的关键字是最小内存空间的数据类型，也是最适合操作硬件的数据类型。</p>
<blockquote>
<p>[!tip]</p>
<p>我们知道硬件上最小的状态是高低电平，对于软件来讲就是0和1状态，那C语言中为什么没有byte这个数据类型关键字呢？</p>
<p>因为0-1只有这两个状态，对于内存来讲当然是充分利用，但对于CPU来讲处理效率非常低。比如要把32(0b100000)这个数据从内存读到CPU内部寄存器，至少需要执行6个指令周期(1个指令周期：寻址-&gt;发读的控制信息-&gt;数据通过数据总线送到寄存器)才能读到0b100000。所以兼顾CPU性能和内存管理，计算机科学家把操作内存最小单位为8bit,也称1byte,也就是char类型，可以表示256种状态。当编译器看到<code>chār</code>关键字的时候，就知道圈定的内存大小是1byte:</p></blockquote>
<blockquote>
<p>[!NOTE]</p>
<p>这里的<code>char a=10;</code>相当于在内存中圈出一块1byte的内存，内存的标签叫a(也可以理解成这块内存属于a),内存里面的值是10</p>
<p>Q:想一想，声明和定义的区别？extern char a和char a;</p>
<p>A:声明没有分配内存，定义会分配内存。(声明实际上是引用，并不会分配空间)</p></blockquote>
<h4 id="int">
<a class="header-anchor" href="#int"></a>
int
</h4><p><code>int</code>类型是最适合CPU的数据类型，大小和编译器有关</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/30_10_53_6_202411301053994.png" alt="CPU处理数据过程"></p>
<p>为了充分发挥CPU的数据处理能力，数据总线尽量要充分利用，在系统一个周期内所能接受的最大处理单位就是<code>int</code>。所以对于32位的CPU,<code>int</code>就是32bit(4byte)，16位的CPU,int就是16bit(2byte)。对于一个数字常量默认就是int的，体会以下代码：</p>
<h4 id="void">
<a class="header-anchor" href="#void"></a>
void
</h4><p><code>void</code>一般用于占位符</p>
<blockquote>
<p>[!tip]</p>
<p>为了减少编译器报未使用参数的警告，我们可以使用void来规避</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>	<span class="c1">//此时可以规避编译器出现警告的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></blockquote>
<blockquote>
<p>[!tip]</p>
<p>void*是一个通用类型指针，可以将这个指针转化为任意类型的指针</p></blockquote>
<h3 id="自定义类型">
<a class="header-anchor" href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b"></a>
自定义类型
</h3><h4 id="struct">
<a class="header-anchor" href="#struct"></a>
struct
</h4><p>C语言通过struct关键字表示新的组合类型，内存表现为累加且对齐，我们叫这种数据类型为结构体。声明规则如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="err">结构体类型名</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>		<span class="c1">//结构体成员变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">short</span> <span class="n">b</span><span class="p">;</span>	<span class="c1">//结构体成员变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="err">；</span>
</span></span></code></pre></div><blockquote>
<p>[!note]</p>
<p>当我们申明了一个结构体时会分配内存吗？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">abc</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>答案是否定的，注意，申明不会申请内存</p></blockquote>
<blockquote>
<p>[!tip]</p>
<p>数据对齐和CPU总线有关，如果CPU总线为4字节，那么地址4字节对齐会对CPU的读写有利</p></blockquote>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/30_11_57_7_202411301157415.png" alt="字节对齐"></p>
<h4 id="union">
<a class="header-anchor" href="#union"></a>
union
</h4><p>union关键字表示新的类型叫联合体，内存表现为：==共享一份内存==（以最大数据类型作为分配空间）和内存的首地址，申明规则如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">union</span> <span class="err">名字</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/2_20_34_10_202412022034339.png" alt="大小端示例"></p>
<h4 id="structunion">
<a class="header-anchor" href="#structunion"></a>
struct+union
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">abc</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">short</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>	<span class="c1">//用于防止编译器进行字节对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">efg</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">short</span> <span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="nf">__atttribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>	<span class="c1">//用于防止编译器进行字节对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#pragma anon_unions	</span><span class="c1">//用于匿名union编译不报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">package</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">payload</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>	<span class="c1">//payload占用空间和a、b一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">struct</span> <span class="n">abc</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">efg</span> <span class="n">b</span><span class="p">;</span>      
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><blockquote>
<p>[!tip]</p>
<p>注意，编译器实际上是会对数据体进行对齐的，所以使用编译器选项<code>__attribute__((packed))</code>可以防止编译器进行字节对齐，也就是不会自动的填充0。</p>
<p>同时，上述的代码中的union并没有命名，这样不报错的原因是在结构体的开头增加了<code>#pragma anon_unions</code></p></blockquote>
<h4 id="enum">
<a class="header-anchor" href="#enum"></a>
enum
</h4><p>enum关键字表示的类型叫枚举类型，内存表现为：内存根据定义值的大小默认选择整数常量大小(int),如果超出int大小，编译器会选择更大的整型类型，比如Iong,所以内存大小不是固定的。声明的规则如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">enum</span> <span class="err">名字</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="o">=</span> <span class="mi">200</span><span class="err">，</span>
</span></span><span class="line"><span class="cl">   	<span class="n">B</span> <span class="o">=</span> <span class="mi">300</span><span class="err">，</span>
</span></span><span class="line"><span class="cl">    <span class="n">C</span> <span class="o">=</span> <span class="mi">400</span><span class="err">，</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="err">；</span>
</span></span></code></pre></div><blockquote>
<p>[!note]</p>
<p>实际上，枚举类型是建议型类型，如下列代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">abc</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">C</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">abc</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">abc</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">func</span><span class="p">();</span>	<span class="c1">//此时打印a的值可以是10，所以说是一个建议类型
</span></span></span></code></pre></div></blockquote>
<h3 id="地址指针类型">
<a class="header-anchor" href="#%e5%9c%b0%e5%9d%80%e6%8c%87%e9%92%88%e7%b1%bb%e5%9e%8b"></a>
地址（指针）类型
</h3><p>C语言中，地址类型也称指针类型，圈定的内存用来存放地址编号的值。==指针类型的内存表现限编译器有关或者说跟CPU的地址总线有关==。在32位的系统中，指针类型占用4byte,在64位的系统中，指针类型占用8byte。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/3_19_22_58_202412031922432.png" alt="地址映射"></p>
<blockquote>
<p>[!TIP]</p>
<p>指针所占用的内存空间和申明的类型没有关系，只和编译器和CPU的地址总线宽度有关</p>
<p>申明类型只和访问的数据的范围有关，如int类型的指针就要访问4个字节的数据，char类型的指针只能访问1个字节的数据</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;symbol visit:a %d,addr visit:a =%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>	<span class="c1">//打印出symbol visit:a 10,addr visit:a 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>[!tip]</p>
<ol>
<li>首先，p也是一个变量（没啥神秘的），这本质上也是圈定一块内存，内存的大小跟编译器有关，p是这块内存的标签。到这里和的在变量的视角中一摸一样</li>
<li>然后，p的特殊性在于，它圈定的那块内存，存放的不是一般的值而是一个地址编号。所以除了通过标签读出这个地址编号外，C语言还提供一种直接访问这个地址编号的方法，那就是在p前面加一个<code>*</code>号。</li>
</ol>
<p>举一个形象的例子：</p>
<p>你要去访问A朋友家，第一种是直接让A带你去，第二种是P知道A家的地址，通过P带你去。a和*p就是这种感觉</p></blockquote>
<h3 id="typedef">
<a class="header-anchor" href="#typedef"></a>
typedef
</h3><p>typedef:关键字是给数据类型起一个别名，让程序的可读性更高，特别是复杂的类型（如函数指针类型），做到见字知意。使用的规则如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">abc</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="kt">abc_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="kt">len_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="kt">uint8_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="n">func</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="err">）</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">len_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">abc_t</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="修饰关键字">
<a class="header-anchor" href="#%e4%bf%ae%e9%a5%b0%e5%85%b3%e9%94%ae%e5%ad%97"></a>
修饰关键字
</h2><h3 id="auto">
<a class="header-anchor" href="#auto"></a>
auto
</h3><p>auto关键字是最无感的存在。编译器在默认缺省的情况下，所有变量都是uto的。你就当做它不存在，不曾来过。</p>
<h3 id="register">
<a class="header-anchor" href="#register"></a>
register
</h3><p>register关键字是一个建议性关键字。设计的初衷是想要定义的变量放到cpu的寄存器中，但是往往编译器看到这个关键字的时候，发出一句呐喊：臣妾做不到啊。寄存器相对于内存，cpu在访问速度上更快，但也很稀缺，不是说想放就放的。所以编译器只能尽量的去做，它不保证一定能做得到，大家也就不要奢望了。</p>
<blockquote>
<p>[!tip]</p>
<p>但值得注意的是加上registerf修饰后的变量，无法通过&amp;来取地址。即使大概率放进寄存器会失败，但编译器就不给你寻址，万一成功了呢？编译器还是有梦想的。</p></blockquote>
<h3 id="static">
<a class="header-anchor" href="#static"></a>
static
</h3><p>在C语言中static关键字有两个作用：</p>
<ol>
<li>规定变量的内存从静态全局数据区分配；</li>
<li>限定变量或函数的作用域</li>
</ol>
<p><strong>生命周期</strong>：不管是修饰局部变量还是全局变量，最后都在静态全局数据区分配。这意味着变量在整个程序的生命周期内都是有效合法的。</p>
<p><strong>限定范围</strong>：限定全局变量只在当前定义的文件可见，其他文件即使加上exterr修饰，也无法引用。会编译报错</p>
<h3 id="extern">
<a class="header-anchor" href="#extern"></a>
extern
</h3><p>extern用来声明一个没有被static修饰的变量或者函数。</p>
<p>在架构设计中尽量不要用extern,会导致代码耦合度非常高而且不太可控。建议使用<code>get</code>、<code>set</code>方法来获取成员变量的值，从而避免出现文件的互相调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get_a</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">set_a</span><span class="p">(</span><span class="kt">int</span> <span class="n">para</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="n">para</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>extern&quot;C&quot;,用C++的编译器(g++)按照C的规则进行编译。C++和C语言在编译规则上有很多不同，所以在C++中想完全复用C写的代码，就可以用extern&quot;C&quot;来修饰。这种在C++使用C的Iib库的时候比较常见。</p>
<blockquote>
<p>[!tip]</p>
<p>实际上，extern c就是在c++代码中使用c的编译规则去编译代码</p></blockquote>
<h3 id="const">
<a class="header-anchor" href="#const"></a>
const
</h3><p>const是constant的缩写，是恒定不变的意思，被修饰的变量经常被人误解成常数或者常量。这个理解不太准确，准确的理解应该是read only。.本质上还是变量，编译器只能尽量的不让你去修改，但是实际上总有一些方法可以做到修改c0st修饰变量的值，往往都是一些异常的操作导致（比如数组越界、指针越界访问、栈溢出等等）。我们要建立一个正确的编程理念：const修饰的变量技术上能改，但是不要去改。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//const 数据类型 变量名 or 数据类型 const 变量名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="k">const</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//a=20;//编译错误，编译不给修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;a =%d,b =%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>[!tip]</p>
<p>实际上这里的变量a和b也是可以修改的，之前说过，访问一个变量有两种方法：</p>
<ol>
<li>通过标签去访问值，如访问a和b</li>
<li>通过地址去访问值，如访问&amp;a和&amp;b</li>
</ol>
<p>上面的代码如果使用地址来修改就可以修改值，在c++中编译器会自动拦截修改const类型的值，但是c中不会</p></blockquote>
<p>==const修饰指针==</p>
<p>很多同学对const修饰指针变量，有时候分不清楚是修饰指针变量还是限定指针指向的内容。今天教大家一个方法，叫&quot;近水楼台先得月&quot;：</p>
<ol>
<li>忽略数据类型</li>
<li>观察const向右靠近什么
<ol>
<li>靠近 *：表示指针指向的内容不能变</li>
<li>靠近变量：表示指针的指向（指针中存的内容）不能变</li>
<li>既靠近*又靠近变量：表示指针内容和指针指向的内容都不能变</li>
</ol>
</li>
</ol>
<blockquote>
<p>[!tip]</p>
<p>在定义指针的时候，编译器会先向右遍历，再向左遍历，然后才会确定一个变量的具体限制</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>		<span class="c1">//-&gt; const *a -&gt; 靠近*，所以地址指向的内容（*a)不能变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>		<span class="c1">//-&gt; const *b -&gt; 靠近*，所以地址指向的内容(*b)不能变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">c</span><span class="p">;</span>		<span class="c1">//-&gt; * const c-&gt; 靠近c,所以c指针变量不能变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">d</span><span class="p">;</span>	<span class="c1">//-&gt; const * const d-&gt;靠近*又靠近c,所以d和*d都不能变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//下面5个语句编译器会报错烂截
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>使用const可以提高运行效率：如果用const修饰，编译器会直接把立即数200赋值给变量a,而没有const修饰的则每次都需要读取内存中ABC值。这样用const修饰时，执行效率就比较高（我们知道读取内存是相对慢的操作)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">ABC</span> <span class="mi">200</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="n">ABC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span><span class="ne">int</span> <span class="n">a</span> <span class="n">ABC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">movl</span> <span class="n">ABC</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>	<span class="o">//</span><span class="err">把内存中</span><span class="n">ABC的值读到寄存器中去</span>
</span></span><span class="line"><span class="cl"><span class="n">movl</span> <span class="n">eax</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span><span class="k">const</span> <span class="ne">int</span> <span class="n">a</span> <span class="n">ABC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">movl</span> <span class="o">$</span><span class="mi">200</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span><span class="err">】</span>
</span></span></code></pre></div><blockquote>
<p>[!tip]</p>
<p>Cost设计的初衷就是为了代蒂宏，消除它的缺点，继承它的优点。</p>
<ul>
<li>编译器处理方式：define宏是在预处理阶段展开；const变量是编译运行阶段使用</li>
<li>安全检查：define宏不做任何类型检查，仅仅是展开；const变量编译阶段会执行类型检查</li>
<li>内存位置：define宏在代码段；const常量可以在静态全局数据段、栈中</li>
</ul></blockquote>
<h3 id="volatile">
<a class="header-anchor" href="#volatile"></a>
volatile
</h3><p>volatile关键字用于告诉编译器，被声明为volatile的变量的值可能在程序的控制之外发生变化，因此编译器不应该对其进行某些优化。主要用于处理硬件寄存器、中断服务程序和多线程等情况：</p>
<p>下面的代码中，如果buff变量是uart的DR寄存器映射，即使代码中设有地方更新buff的值，也应该告诉编译器不要优化，如果有地方读取buff的值的时候，都需要从内存中读取，因为外部uart会触发更新。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">whi1e</span><span class="p">(</span><span class="n">buff</span><span class="p">){</span><span class="c1">//等待buff不为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/4_20_4_25_202412042004317.png" alt="存储结构"></p>
<h2 id="逻辑关键字">
<a class="header-anchor" href="#%e9%80%bb%e8%be%91%e5%85%b3%e9%94%ae%e5%ad%97"></a>
逻辑关键字
</h2><p>在Cpu的眼里很单纯，程序指针(PC)指到哪里就执行哪里，默认情况下顺序往下执行，而逻辑关键字作用就是改变PC指针的指向，这个最基本的思想就构成了程序里各种逻辑设计（条件、选择、跳转、循环)。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/4_20_17_41_202412042017864.png" alt="CPU执行过程"></p>
<ol>
<li>条件关键字：if-else</li>
<li>选择关键字：switch-case-default</li>
<li>循环关键字：for、while、do-while</li>
<li>跳转关键字：continue、break、return、goto</li>
</ol>
<h1 id="运算符">
<a class="header-anchor" href="#%e8%bf%90%e7%ae%97%e7%ac%a6"></a>
运算符
</h1><p>程序的本质是逻辑和数据。狭义上运算是指是数学运算，广义的运算是数据处理。在C语言中运算符分为：算数运算、逻辑运算、位运算、赋值更新、内存访问。这里提一个理念：对于运算符的优先级问题，不建议死记硬背，用()万能钥匙来人为定义优先级。不要吝啬用()，()会让你的程序变得清晰可读。</p>
<h2 id="算术运算">
<a class="header-anchor" href="#%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97"></a>
算术运算
</h2><p>加减乘除大家从小学就开始学了，所以非常容易理解。这里提一个观念就是：对于CPU来讲，加减法的运行速率比乘除要快。这是因为CPU进行运算主要依赖于算术逻辑单元(ALU)和浮点运算单元(FPU),而ALU的本质是累加器，所以加减法在硬件处理就很快，乘除法有时候编译器会转换成动加减法或者移位操作。随着计算机的发展，现在已经有了&quot;乘法器&quot;的硬件支持，速度上也已经很快。</p>
<p>我们感受一下编译器对乘除法的优化：</p>
<ul>
<li>
<p>直接调用&quot;乘法器&quot;进行运算</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">34</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;b =%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movl $16,-8(%rbp）
</span></span><span class="line"><span class="cl">movl -8(%rbp),%eax
</span></span><span class="line"><span class="cl">imull $34,%eax,%eax	//这里调用乘法器
</span></span><span class="line"><span class="cl">movl  %eax,-4(%rbp)
</span></span></code></pre></div></li>
<li>
<p>将乘法转换为左移位和加法操作</p>
</li>
</ul>
<p>==mod运算==：表示取余数</p>
<p>一般可用于</p>
<ol>
<li>
<p>循环队列的索引更新</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define LEN 10
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">data_process</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">%</span> <span class="n">LEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">buff</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">index</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>生成[L,R]区间内的随机数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;malloc.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span><span class="o">*</span> <span class="nf">generate_array</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">R</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">srand</span><span class="p">(</span><span class="nf">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">rand</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_array</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="nf">generate_array</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">print_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//运行结果
</span></span></span><span class="line"><span class="cl"><span class="c1">//04708611035
</span></span></span></code></pre></div></li>
<li>
<p>%还可以做占位符，在格式转换时用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;a %d %x %o </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ol>
<h2 id="位运算">
<a class="header-anchor" href="#%e4%bd%8d%e8%bf%90%e7%ae%97"></a>
位运算
</h2><ul>
<li>
<p>左移<code>&lt;&lt;</code>:在没有溢出之前，每移动一位等价于乘于2，且移位后右边补0</p>
</li>
<li>
<p>右移<code>&gt;&gt;</code>：每移动一位等价于除以2，signed类型和unsigned在右移的时候有差别：</p>
<ul>
<li>如果是负数，移位后补1，所以负数通过右移永远不会等于0</li>
<li>正数补0</li>
</ul>
</li>
<li>
<p>与或非</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">|:</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">|</span><span class="mi">0</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="o">|</span><span class="mi">1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">=</span><span class="mi">0</span> <span class="o">-&gt;</span><span class="err">俗称置位器</span><span class="p">(</span><span class="n">set</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&amp;:</span><span class="mi">1</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">&amp;</span><span class="mi">0</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="o">&amp;</span><span class="mi">0</span><span class="o">=</span><span class="mi">0</span> <span class="o">-&gt;</span><span class="err">俗称清零器</span><span class="p">(</span><span class="n">c1r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">~:~</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x7F</span> <span class="o">-&gt;</span> <span class="err">按位取反</span>
</span></span></code></pre></div></li>
<li>
<p>位异或<code>^</code></p>
</li>
</ul>
<h2 id="逻辑运算">
<a class="header-anchor" href="#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97"></a>
逻辑运算
</h2><ul>
<li>
<p>条件运算：&amp;&amp;（与）||（或）</p>
<blockquote>
<p>A &amp;&amp; B //只要A为假，B就不会被执行</p>
<p>A || B //只要B为真，B就不会被执行</p></blockquote>
</li>
<li>
<p>大小判断：==、&lt;、&gt;、&gt;=、&lt;=、？：</p>
<blockquote>
<p>[!tip]</p>
<p>建议在使用<code>==</code>的时候，可以将数字放在<code>==</code>的左边，变量写在右边，这样如果写成<code>=</code>编译器就会报错拦截出来</p></blockquote>
</li>
<li>
<p>条件取反：！</p>
<blockquote>
<p>使用取反可以实现二值化处理</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">xx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="o">!!</span><span class="n">a</span><span class="p">;</span>	<span class="c1">//将非零的值a归零化到1
</span></span></span></code></pre></div></blockquote>
</li>
<li>
<p>赋值更新：=、+=、-=、&amp;=、|=、++、&ndash;</p>
<blockquote>
<p>赋值更新的本质是：通过标签（变量名）改变内存中的值</p></blockquote>
</li>
</ul>
<h2 id="内存操作">
<a class="header-anchor" href="#%e5%86%85%e5%ad%98%e6%93%8d%e4%bd%9c"></a>
内存操作
</h2><ul>
<li>函数访问<code>()</code>：用于访问函数名圈定的地址</li>
<li>取值操作:
<ul>
<li><code>[]</code></li>
<li><code>*</code></li>
<li><code>-&gt;</code></li>
<li><code>.</code></li>
</ul>
</li>
<li>取址操作<code>&amp;</code></li>
<li>内存打包<code>{}</code>:结构体、联合体、枚举、函数就是典型的通过<code>{}</code>进行打包</li>
</ul>
<h1 id="函数视角">
<a class="header-anchor" href="#%e5%87%bd%e6%95%b0%e8%a7%86%e8%a7%92"></a>
函数视角
</h1><p>希望大家养成一个好的编程&quot;洁癖&quot;：Don&rsquo;t Repeat Yourself.,不要写重复的代码。所以当别人问你函数有什么用时，你就可以这么回答他。C语言是一个面向过程的语言，即面向方法（函数）编程(C++/门ava是面向对象编程)，所以理解和应用函数的重要性不言而喻。</p>
<h2 id="函数的世界">
<a class="header-anchor" href="#%e5%87%bd%e6%95%b0%e7%9a%84%e4%b8%96%e7%95%8c"></a>
函数的世界
</h2><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/5_19_54_32_202412051954990.png" alt="形象比喻"></p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/5_19_54_59_202412051954179.png" alt="数学表示"></p>
<h3 id="函数的三大属性">
<a class="header-anchor" href="#%e5%87%bd%e6%95%b0%e7%9a%84%e4%b8%89%e5%a4%a7%e5%b1%9e%e6%80%a7"></a>
函数的三大属性
</h3><p>将上面的栗子进行抽象，就可以得到函数的三大属性：输入参数、返回值、函数名</p>
<ol>
<li>函数名（地址）</li>
<li>输入参数（可多个）</li>
<li>返回值（至多一个）</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//输出：函数名：输入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">char</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//XXX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>[!tip]</p>
<p>编译器只要看到有这三大属性，就判定为函数（即使函数体是空的）</p></blockquote>
<p>函数名本质上是一个==地址标签==，如果知道函数的地址，就可以直接用<code>()</code>调过去</p>
<h3 id="函数的参数传递">
<a class="header-anchor" href="#%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92"></a>
函数的参数传递
</h3><h4 id="参数传递的本质">
<a class="header-anchor" href="#%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92%e7%9a%84%e6%9c%ac%e8%b4%a8"></a>
参数传递的本质
</h4><p>调用函数时，需要传入和返回参数。传入和返回的参数过程本质上是：==内存拷贝==。既然是拷贝，那一定存在两个对象：目的地(dst)，源(src)。在C语言中，传入参数时，目的地叫==形参==、源叫==实参==：返回参数时，目的地和源都叫返回值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">show</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>	<span class="c1">//a是形参，传递过程，就把num的值拷贝给了a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>	<span class="c1">//a此时是返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10086</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//num是实参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="nf">show</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="c1">//show函数返回a的值会拷贝给ret
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>[!note]</p>
<p>在执行函数的时候实际上是一个内存拷贝的过程，我们知道每次调用一个函数，在内存中都会为这个函数分配一部分内存空间作为函数栈</p>
<ol>
<li>当main调用show的时候，内存中会申请一个栈，用于存函数中的变量，比如这里的num中的10086就会拷贝到show函数的形参a中</li>
<li>当对a进行自增完之后，返回的值同样会返回到main函数的栈中</li>
<li>对show函数的空间进行销毁</li>
</ol>
<pre class="mermaid">block-beta
	columns 5
	space 	main 	space 	show 	space
	num	  	data1["10086"]	space	data2["10086"]	a
    data1 --> data2
    ret		data3["10087"]	space data4["10087"]	return
    data4 --> data3
    
</pre></blockquote>
<h4 id="值传递">
<a class="header-anchor" href="#%e5%80%bc%e4%bc%a0%e9%80%92"></a>
值传递
</h4><p>==对数据进行隔离和保护==</p>
<p>因为存在拷贝的机制，值传递的时，不会对调用者的源数据进行破坏，所以值传递对数据起到保护和隔离的作用。体会一下下面的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">show</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;a in show %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10086</span><span class="p">;</span>	<span class="c1">//源数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">//返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="nf">show</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;a in main %d,ret %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">num</span><span class="p">,</span><span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//程序运行结果：
</span></span></span><span class="line"><span class="cl"><span class="c1">//a in show 10087
</span></span></span><span class="line"><span class="cl"><span class="c1">//a in main 10086,ret 10087
</span></span></span></code></pre></div><p>另外，大家要养成一个思维习惯：当函数结束时，函数里的局部变量（形参也是局部变量）都会被”销毁&quot;，即使内存中原来的值还存在，但已经不受到系统保护，数据随时可能被覆盖、改写等等。所以当我们要返回一个局部变量的指针时，需要考虑指针指向的内存的生命周期。</p>
<blockquote>
<p>[!tip]</p>
<p>恢复栈中的局部变量：在分析crash问题的时候，通常需要分析调用栈，可以通过保存之前的栈针地址，查看原来内存的值。可参考：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">show</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10086</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10010</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;movq %rbp,addr(%rip)&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">show</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;show bp 0x%1x,a =%d,b =%d In&#34;</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//程序运行结果：
</span></span></span><span class="line"><span class="cl"><span class="c1">//show bp 0x7fffff2cacbe,a 10010,b 10086
</span></span></span></code></pre></div></blockquote>
<h4 id="地址传递">
<a class="header-anchor" href="#%e5%9c%b0%e5%9d%80%e4%bc%a0%e9%80%92"></a>
地址传递
</h4><p>地址传递本质上跟值传递一样，只不过这个值有特殊的含义：代表了一个地址编号。地址传递一般用于返回结果和连续空间传递。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;ret %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//#程序运行结果：
</span></span></span><span class="line"><span class="cl"><span class="c1">//ret 200
</span></span></span></code></pre></div><h2 id="c与面向对象">
<a class="header-anchor" href="#c%e4%b8%8e%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1"></a>
C与面向对象
</h2><p>C语言是面向过程的语言，但我们可以借助C++/JAVA面向对象思想，实现类似&quot;继承&quot;、&ldquo;多态&rdquo;、&ldquo;封装&rdquo;、&ldquo;重载”的功能。从而服务于架构设计。</p>
<h3 id="c与继承">
<a class="header-anchor" href="#c%e4%b8%8e%e7%bb%a7%e6%89%bf"></a>
C与继承
</h3><p>继承是使用已存在的类作为基础建立新的类的技术。新的类可以增加新的数据类型或者方法，也可以使用父类的功能，但不能选择性的继承父类。通过继承可以很好的复用以前的代码，提高开发效率。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">parent_class</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setWidth</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parent_class</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span><span class="kt">int</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">child_class</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">parent_calss</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getArea</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parent_class</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="c与封装">
<a class="header-anchor" href="#c%e4%b8%8e%e5%b0%81%e8%a3%85"></a>
C与封装
</h3><p>封装的概念是指：将抽象的数据和行为（成者方法）相结合，形成一个有机的整体。是面向对象思想的核心，目的是增强安全性和简化编程，使用者不必理解具体的实现细节，通过调用接口使用数据成员。</p>
<p>上节代码中的函数指针就是就做到了封装的概念，通过函数来改变一个对象的值</p>
<h3 id="c与多态">
<a class="header-anchor" href="#c%e4%b8%8e%e5%a4%9a%e6%80%81"></a>
C与多态
</h3><p>多态的概念是指：通过父类的指针来调用子类中的方法。作用是把不同的子类对象当做父类来看，屏蔽不同子类之间的差异，用于适应需求的不断变化，本质上是面向抽象编程，在C++中，多态的实现是通过虚函数来实现。体会一下以下这个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">person</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">person</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">usa_person</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">person</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">person</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">get_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">person</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">usa_person</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span><span class="p">(</span><span class="k">struct</span> <span class="n">usa_person</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="o">-&gt;</span><span class="nf">get_name</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">get_usa_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">person</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;%s&#34;</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sprintf</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="nf">strlen</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span><span class="s">&#34;%s&#34;</span><span class="p">,</span><span class="s">&#34;-usa&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="c与重载">
<a class="header-anchor" href="#c%e4%b8%8e%e9%87%8d%e8%bd%bd"></a>
C与重载
</h3><p>重载的概念是指：在同一个范围中声明几个同名函数，但同名函数的形参不同（个数、类型、顺序），一般是用来处理功能类似但是数据类型不同的问题。严格意义上C的编译器不支持重载，但我们有一些方法达到相同的目的。</p>
<blockquote>
<p>[!tip]</p>
<p><code>printf</code>函数就是典型的具有重载效果的函数</p></blockquote>
<h4 id="可变参数函数">
<a class="header-anchor" href="#%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0%e5%87%bd%e6%95%b0"></a>
可变参数函数
</h4><p>可变参数函数的格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">va_func</span><span class="p">(</span><span class="err">强制参数，可变参数</span><span class="p">)</span>
</span></span></code></pre></div><ol>
<li>强制参数有至少有一个，代表以一种规则，由函数定义者自行定义和解析。</li>
<li>可变参数可以有多个，函数定义者和调用者自行决定，实际上可变参数</li>
</ol>
<p>实际上，可变参数函数的实现依赖的是四个主键：</p>
<ol>
<li>
<p>va_list:实际上是一个结构体数组，但是结构体中只有一个元素</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">va_list</span> <span class="o">=</span> <span class="k">struct</span> <span class="n">_va_list_tag</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gp_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fp_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">overflow_arg_area</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">reg_save_area</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}[</span><span class="mi">1</span><span class="p">]</span>
</span></span></code></pre></div></li>
<li>
<p>va_start：定位到可变参数的地址</p>
</li>
<li>
<p>va_arg：遍历可变参数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type va_arg(va_list ap, type);
</span></span></code></pre></div></li>
<li>
<p>va_end：终止va_list遍历</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//这里约定n为后面参数的个数（一种规则)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="n">va</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,...)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">va_list</span> <span class="n">ptr</span><span class="p">;</span>	<span class="c1">//定义一个可变参数列表，也就是形参中的...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">va_start</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>	<span class="c1">//传n进去，来计算可变参数的起始位置，n后面的第一位就是可变参数的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">va</span> <span class="nf">arg</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">va_end</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">va_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">va_func</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">300</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>[!important]</p>
<p>注意：这里使用可变函数列表的时候，需要引入<code>#include &lt;stdarg.h&gt;</code>的头文件</p></blockquote>
<h4 id="回调函数">
<a class="header-anchor" href="#%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0"></a>
回调函数
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">exchange_int</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">_a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">_b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">_a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">_a</span> <span class="o">=</span> <span class="o">*</span><span class="n">_b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">exchange_double</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="o">*</span><span class="n">_a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="o">*</span><span class="n">_b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">tmp</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=*</span><span class="n">_a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">_b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">_b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">func</span> <span class="n">exchange</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exchange</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">func</span> <span class="n">exchange</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exchange</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">1.23</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">4.56</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">swap</span><span class="p">(</span><span class="n">exchange_int</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">swap</span><span class="p">(</span><span class="n">exchange_double</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;a = %d,b = %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;c = %f,d = %f </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="弱连接函数">
<a class="header-anchor" href="#%e5%bc%b1%e8%bf%9e%e6%8e%a5%e5%87%bd%e6%95%b0"></a>
弱连接函数
</h4><p>在驱动设计时经常用到。weak修饰的函数属于弱连接函数，==当前工程中如果有定义跟其相同的函数时，weak修饰的函数会被编译覆盖==，达到overridel的效果。</p>
<p><em>==1.c==</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//1.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">extern</span> <span class="kt">void</span> <span class="nf">config</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__attribute_</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="nf">config</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;config default</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nf">config</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><em>==2.c==</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">config</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;config one </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最终执行的效果为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">config one
</span></span></code></pre></div><h2 id="solid设计原则">
<a class="header-anchor" href="#solid%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99"></a>
Solid设计原则
</h2><p>solid设计是面向对象的原则，是由Gang of Four(四人帮)，即Erich Gamma,Richard Helm,Ralph Johnson&amp;John Vlissides四人的《设计模式》
(1995年出版)是第一次将设计模式提升到理论高度，并将之规范化。</p>
<p>solid有五个设计原则：</p>
<ol>
<li>
<p>单一职责原则：一个类只负责一件事情。在C语言中，就是一个结构体在设计和封装的时候只负责一个事情。</p>
</li>
<li>
<p>开闭原则：软件中的对象（类、模块、函数等）应该满足对于拓展是开放的，对修改是封闭的。</p>
</li>
<li>
<p>里氏替换原则：简单来讲就是子类可以去拓展父类的功能，但不能改变父类原有的功能。技术上，所有引用基
类的地方必须能够透明的使用其子类的对象。价值：继承一定程度上破坏了封装，此原则侧用来包含封装性。</p>
</li>
<li>
<p>接口隔离原则</p>
<p>定义：不应该强迫用户端实现一个它用不上的接口。具体两个的例子：</p>
<ol>
<li>
<p>抽象了面积和体积的两个接口，客户瑞在使用的这个接口的时候会发现，对于正方形来说设有体积，所以实现体积的函数对它来说就是冗余的。</p>
</li>
<li>
<p>抽象了器件初始化和读取数据的接口。对于LED灯来说，一般都是控制型，没有必要实现一个虬ED数据的接口，所以对LED来说，读取数据就是冗余的。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_19_56_35_202412091956560.png" alt="接口隔离原则"></p>
<p>上图中的红色部分就是冗余设计</p>
</li>
</ol>
</li>
<li>
<p>依赖倒置原则</p>
<p>高层次模块不应该依赖低层次的模块，实际上是面向抽象编程思想，这样可以降低代码间的耦合度，使其看扩展、易维护。举一个驱动的
列子：荏这个架构设计中，IMU有很多公共的业务逻辑：初始化、读取数据、数据校准等等，这些业务逻辑不应该耦合具体驱动的接口，而是
依赖于抽象接口：同时驱动与驱动之间也不能互相调用，而是调用抽象接口。后续的器件增加拓展，只需要修改驱动部分，抽象层都不会改
动。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/9_19_59_5_202412091959280.png" alt="依赖倒置原则"></p>
</li>
</ol>
<h1 id="内存视角">
<a class="header-anchor" href="#%e5%86%85%e5%ad%98%e8%a7%86%e8%a7%92"></a>
内存视角
</h1><p>前面在学习数据类型关键字的时候我们了解到，定义一个变量的本质是在内存中圈定一块特定大小的内存。本章将会对内存的位置、生命
周期、操作权限等做更多的深讨。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/10_19_21_41_202412101921288.png" alt="内存视角"></p>
<h2 id="内存分布">
<a class="header-anchor" href="#%e5%86%85%e5%ad%98%e5%88%86%e5%b8%83"></a>
内存分布
</h2><p>内存分布分成静态区和动态区，静态区在编译时已经决定了内存分配大小，动态区是运行时分配。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/10_19_23_9_202412101923962.png" alt="内存分布"></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">global_inited</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>	<span class="c1">//全局初始化变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">global_uninited</span><span class="p">;</span>	<span class="c1">//全局未初始化变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">local_var</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>	<span class="c1">//局部变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="p">;</span>	<span class="c1">//字符串常量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="kt">int</span> <span class="n">static_var</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span>	<span class="c1">//静态变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">heap_var</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>	<span class="c1">//动态分配的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;address of code:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">main</span><span class="p">);</span>	<span class="c1">//将会打印main函数的地址，也就是代码段的首地址，0x55f7c567f1a9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;address of str:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>	<span class="c1">//打印出来的地址实际上是只读数据段，因为是一个常量的地址，0x55f7c5680008
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;address of global inited %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">global_inited</span> <span class="p">);</span>	<span class="c1">//全局数据初始化段，0x55f7c5682010
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;address of static var:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">static_var</span><span class="p">);</span>	<span class="c1">//	全局数据未初始化段，0x55f7c5682014
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;address of global uninited:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">global_uninited</span><span class="p">);</span>	<span class="c1">//全局数据未初始化段，0x55f7c568201c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;address of heap var %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">heap_var</span><span class="p">);</span>	<span class="c1">//该指针位于堆空间，0x55f7c71392a0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;address of local var %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">local_var</span><span class="p">);</span>	<span class="c1">//该便变量位于栈空间，0x7ffc5ef3b5f4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">//释放动态分配的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">free</span><span class="p">(</span><span class="n">heap_var</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>[!tip]</p>
<p>函数名实际上是一个指针常量，所以可以通过函数名来打印地址</p>
<p>堆和栈的生长空间是相反的</p></blockquote>
<h3 id="代码段">
<a class="header-anchor" href="#%e4%bb%a3%e7%a0%81%e6%ae%b5"></a>
代码段
</h3><p>代码段只能读不可以写，写会触发Segmentation fault(core dumped),俗称&quot;段错误&rdquo;。在整个程序生命周期内合法有效。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;hello func </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;func addr %p </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//try to access
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">p</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">func</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//try to read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;func addr %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">p1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//try to write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="只读数据段">
<a class="header-anchor" href="#%e5%8f%aa%e8%af%bb%e6%95%b0%e6%8d%ae%e6%ae%b5"></a>
只读数据段
</h3><p>只读数据段存放字符传常量，地址比代码段更高。权限是：只能读不可以写，写会触发Segmentation fault(core dumped),在整个程序生
命周期内合法有效。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s read only data addr:%p </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="s">&#34;hello world&#34;</span><span class="p">,</span><span class="s">&#34;hello world&#34;</span><span class="p">);</span>	<span class="c1">//hello world read only data addr:0x56014766f008
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">&#34;hallo world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;e&#39;</span><span class="p">;</span><span class="c1">//try to write rodata Segmentation，Segmentation fault (core dumped)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="全局数据段">
<a class="header-anchor" href="#%e5%85%a8%e5%b1%80%e6%95%b0%e6%8d%ae%e6%ae%b5"></a>
全局数据段
</h3><p>全局变量和局部static修饰的变量会放在全局数据段(data/bbs),允许读写，在整个程序生命周期内合法有效。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">d</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">b</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">++</span><span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%p %p,%p </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//try to write data Segmentation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">a</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">b</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">=</span><span class="mi">40</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;a =%d b =%d,c %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;b %dd =%d,d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="nf">func</span><span class="p">(),</span><span class="nf">func</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//运行结果：
</span></span></span><span class="line"><span class="cl"><span class="c1">//0x5556e9e9b010,0x5556e9e9b020,0x5556e9e9b81c
</span></span></span><span class="line"><span class="cl"><span class="c1">//a=20,b=30,c=40
</span></span></span><span class="line"><span class="cl"><span class="c1">//b=32,d=12,d=11
</span></span></span></code></pre></div><h3 id="堆空间">
<a class="header-anchor" href="#%e5%a0%86%e7%a9%ba%e9%97%b4"></a>
堆空间
</h3><p>堆空间在运行时由程序员来分配(malloc)和释放(free)，可读可写，生命周期是程序员来决定。值得注意的是，如果在一个函数中分配
堆内存，函数执行结束后māoc空间不会被释放，如果不手动进行释放的话，会造成内存泄漏。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">heap_var</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="c1">//动态分配的内存，单位是B,默认反馈的类型是void*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">heap_var</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//try to write heap segmentation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">heap_var</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;heap addr =%p heap_var %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">heap_var</span><span class="p">,</span><span class="o">*</span><span class="n">heap_var</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">heap_var</span><span class="p">);</span><span class="c1">//如果没有free动作，heap_var指向的内存就存在泄漏：不会再使用但又不能分配给别人
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//运行结果：
</span></span></span><span class="line"><span class="cl"><span class="c1">// heap addr 0x55bf2b8db2a0,heap_var 10
</span></span></span></code></pre></div><h3 id="栈空间">
<a class="header-anchor" href="#%e6%a0%88%e7%a9%ba%e9%97%b4"></a>
栈空间
</h3><p>栈空间指的是在函数运行时的上下文分配的空间，可读可写，生命周期在函数执行结束后结束。看下面的一个例子：buff和s都是局部变量，系统会给buff分配sizeof(&ldquo;hello world&rdquo;)栈空间，而s的栈空间是4byte,它指向只读数据段中的字符串&quot;hello world&quot;的地址编号。所以这里返回buff就会有问题，返回指针没有问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">char</span><span class="o">*</span><span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">&#34;hello world&#34;</span><span class="p">;</span>	<span class="c1">//字符串会放在只读数据区，所以该函数返回指针是没问题的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">buff</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;hello world&#34;</span><span class="p">;</span>	<span class="c1">//但是使用数组，将会从只读数据区中拷贝字符串到栈中，此时返回这个数组就会有问题了，因为函数运行结束就要释放栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;func:%s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">buff</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;main:%s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/10_20_27_31_202412102027864.png" alt="内存分布图"></p>
<h2 id="内存溢出">
<a class="header-anchor" href="#%e5%86%85%e5%ad%98%e6%ba%a2%e5%87%ba"></a>
内存溢出
</h2><p>内存溢出指的程序运行过程中，访问超过其分配空间范围的内存区域。</p>
<h3 id="栈溢出">
<a class="header-anchor" href="#%e6%a0%88%e6%ba%a2%e5%87%ba"></a>
栈溢出
</h3><ul>
<li>
<p>递归函数：递归函数如果没有正常的退出条件，最后会把整个栈空间消耗殆尽，最后出现段错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">try_overflow</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">try_overflow</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">try_overflow</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#运行结果：
</span></span><span class="line"><span class="cl">Segmentation fault (core dumped)
</span></span><span class="line"><span class="cl">#汇编
</span></span><span class="line"><span class="cl">try_overflow:
</span></span><span class="line"><span class="cl">.LFBO:
</span></span><span class="line"><span class="cl">	endbr64
</span></span><span class="line"><span class="cl">	pushq	%rbp
</span></span><span class="line"><span class="cl">	movq	%rsp,%rbp
</span></span><span class="line"><span class="cl">	subq	$16,%rsp	#分配栈空间的内存
</span></span><span class="line"><span class="cl">	movl	$10,-4(%rbp)
</span></span><span class="line"><span class="cl">	call	try_overf1ow	#反复调用
</span></span><span class="line"><span class="cl">	nop
</span></span><span class="line"><span class="cl">	leave
</span></span><span class="line"><span class="cl">	ret
</span></span></code></pre></div></li>
<li>
<p>栈缓冲区溢出</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define N 10
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">arr</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;hello world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">strcpy</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">arr1</span><span class="p">);</span>	<span class="c1">//工程上建议不要用strcpy,用strncpy,因为原理上是使用\0作为结束符的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//strncpy(arr,arr1,N);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;arr:%s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;arr1:%s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arr1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//strcpy.运行结果
</span></span></span><span class="line"><span class="cl"><span class="c1">//arr:hello world
</span></span></span><span class="line"><span class="cl"><span class="c1">//arr1:d
</span></span></span><span class="line"><span class="cl"><span class="c1">//strncpy.运行结果
</span></span></span><span class="line"><span class="cl"><span class="c1">//arr:he1 1o wor1hel1 o world/原因是arr长度不够，copy N个字符中缺少结束符&#39;\0&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1">//arr1:hello world
</span></span></span></code></pre></div><h3 id="堆溢出">
<a class="header-anchor" href="#%e5%a0%86%e6%ba%a2%e5%87%ba"></a>
堆溢出
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define N 5
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span><span class="o">*</span> <span class="n">strl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">strcpy</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span><span class="s">&#34;hello world&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">strcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="s">&#34;hello world&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;str:%s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;str1:%s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">strl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<h1 id="指针">
<a class="header-anchor" href="#%e6%8c%87%e9%92%88"></a>
指针
</h1><p>前面在介绍指针类型时，已经知道指针变量圈定的内存大小跟编译器有关或者说跟CPU的地址总线有关。在32位的系统中，指针类型占用4byte,在64位的系统中，指针类型占用8byte。指针变量的值有特殊意义，代表了一个地址编号，本章讲重点讲指针访问内存的规则和技巧。另外，希望大家对这两个概念：指针和指针变量，有清晰的区分。我们一般说指针，代表就是这个指针变量的值，即内存地址；指针变量就是一个变量，用于存放内存地址。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/10_20_52_43_202412102052192.png" alt="指针访问"></p>
<h2 id="指针访问内存">
<a class="header-anchor" href="#%e6%8c%87%e9%92%88%e8%ae%bf%e9%97%ae%e5%86%85%e5%ad%98"></a>
指针访问内存
</h2><blockquote>
<p>[!note]</p>
<p>要访问指针指向的地址，那就必然需要回答两个问题：</p>
<ol>
<li>内存的可读可写性是什么？</li>
<li>内存的访问规则是什么？</li>
</ol></blockquote>
<h3 id="指针变量初始化">
<a class="header-anchor" href="#%e6%8c%87%e9%92%88%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96"></a>
指针变量初始化
</h3><p>大家要养成思维习惯：每当看到一个指针变量，要对其值的合法性保持敬畏。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">b</span><span class="o">=</span>  <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p3</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="mi">100</span><span class="p">;</span>	<span class="c1">//从复制语法上可行，但内存不可读，不可写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;*p1=%d,*p2=%d,*p3=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="n">p3</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;p %p </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;*p %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">p3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//运行结果：
</span></span></span><span class="line"><span class="cl"><span class="c1">//*p1=10,*p2=20,*p3=30
</span></span></span><span class="line"><span class="cl"><span class="c1">//p=0x64
</span></span></span><span class="line"><span class="cl"><span class="c1">//Segmentation fault (core dumped)
</span></span></span></code></pre></div><h3 id="空指针和野指针">
<a class="header-anchor" href="#%e7%a9%ba%e6%8c%87%e9%92%88%e5%92%8c%e9%87%8e%e6%8c%87%e9%92%88"></a>
空指针和野指针
</h3><p>空指针很好理解，就是值为0(NULL)的指针变量，如果访问了0地址就会出现非法访问的错误。野指针是指值为非法地址的指针变量。野
指针在实际工程中有很大的危害，会造成代码的稳定问题（不可预知的bug)。要形成free后，把指针变量置空(NULL)的习惯。</p>
<p>空指针的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;*p = %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>	<span class="c1">//访问空地址将会触发segmentation fault
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">ptn</span> <span class="o">=</span> <span class="mi">102</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;*p %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>野指针的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>	<span class="c1">//当使用free之后，仅仅只是把标志位置为未使用，并不会将ptr的内容改为NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//ptr = NULL,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">ptr</span><span class="o">=</span><span class="mi">102</span><span class="p">;</span>	<span class="c1">//将会进入这行代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;*p %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;ptr %p </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">ptr</span><span class="p">);</span>	<span class="c1">//和下面的p将会打印同样的地址，因为在堆里进行申请内存，刚刚又释放了一个int类型的指针，所以现在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;p %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>			<span class="c1">//申请的地址就是一致的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//*ptr=101;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="指针访问内存规则">
<a class="header-anchor" href="#%e6%8c%87%e9%92%88%e8%ae%bf%e9%97%ae%e5%86%85%e5%ad%98%e8%a7%84%e5%88%99"></a>
指针访问内存规则
</h3><h4 id="标准数据类型指针">
<a class="header-anchor" href="#%e6%a0%87%e5%87%86%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%8c%87%e9%92%88"></a>
标准数据类型指针
</h4><p>我们前面学过几种指针访问内存的方式：* p、p[x]、p-&gt;X。那每次访问的大小是多少呢？我们知道指针变量的定义的形式是：数据类型*p;所以每次访问的大小由前面修饰的数据类型决定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;*p = 0x%x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;*p1 = 0x%x In&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">p1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;p1[0] = 0x%x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;p1[1] = 0x%x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;p1[2] = 0x%x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p1</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;p1[3] = 0x%x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p1</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span></span></code></pre></div><p>运行结果为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">*p=0x12345678
</span></span><span class="line"><span class="cl">*p1=0x78
</span></span><span class="line"><span class="cl">p1[9]=0x78
</span></span><span class="line"><span class="cl">p1[1]=0x56
</span></span><span class="line"><span class="cl">p1[2]=0x34
</span></span><span class="line"><span class="cl">p1[3]=0x12
</span></span></code></pre></div><blockquote>
<p>[!tip]</p>
<p>不管大端还是小端，指针p和p1都是指向低地址。</p></blockquote>
<h4 id="连续空间类型指针">
<a class="header-anchor" href="#%e8%bf%9e%e7%bb%ad%e7%a9%ba%e9%97%b4%e7%b1%bb%e5%9e%8b%e6%8c%87%e9%92%88"></a>
连续空间类型指针
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//会进行4字节对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">abc</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">abc</span> <span class="n">data</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">C</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;size of struct abc %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">abc</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">abc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;a =%d,b %d,c =%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;struct p1[0]%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;struct p1[1]%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;struct p1[2]%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p1</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>	<span class="c1">//将不会展示正确的数值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;arr p2[0]=%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;arr p2[1]=%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;arr p2[2]%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p2</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以通过结构体成员的地址从而获取结构体的地址，如下代码，假设现在有一个结构体abc，先已经知道c的地址，求这个结构体的地址？</p>
<p>首先先设这个结构体的体的偏移地址是<code>x</code>，那么则有：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">&amp;</span><span class="p">(</span><span class="k">struct</span> <span class="n">abc</span><span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">-</span> <span class="n">x</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">abc</span><span class="p">)</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//Linux container_of宏的思想
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define container_of(ptr,type,member) ({	\
</span></span></span><span class="line"><span class="cl"><span class="cp">	const typeof(((type *)0)-&gt;member)*__mptr = (ptr);	\
</span></span></span><span class="line"><span class="cl"><span class="cp">	(type *)(char *)__mptr - offsetof(type,member));})
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">abc</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">find_struct</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">member</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">abc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">offset</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">abc</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span>	<span class="c1">//这里使用0地址就是为了方便计算b相对于a的offset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;member offset:%ld </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">abc</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">member</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>	<span class="c1">//这里使用char*是为了取最低位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;a:%d,b:%d c:%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">abc</span> <span class="n">data</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;size of struct abc =%ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">abc</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">abc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;a %d,b %d,c=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">find</span> <span class="nf">struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="函数类型的指针">
<a class="header-anchor" href="#%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%8c%87%e9%92%88"></a>
函数类型的指针
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>	<span class="c1">//编译器会先向右看再向左看
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;func call </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">show</span> <span class="o">-</span> <span class="n">func</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>[!note]</p>
<p>建议使用<code>typedef</code>来重命名函数，使代码通俗易懂</p></blockquote>
<h2 id="指针运算">
<a class="header-anchor" href="#%e6%8c%87%e9%92%88%e8%bf%90%e7%ae%97"></a>
指针运算
</h2><h3 id="算术运算-1">
<a class="header-anchor" href="#%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97-1"></a>
算术运算
</h3><p>指针变量本质也是一个变量，所以进行算数运算语法上是可以的。但是实际的工程应用中，指针变量的乘除法没有意义，更多的是加减法。总的来说，+运算符用于指针的算术运算，允许将指针移动到任意偏移位置，而++运算符是+运算符的特例，它递增指针指向的位置，移动一个对象的大小。看一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span><span class="c1">//p[2]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;*p %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">++</span><span class="p">;</span><span class="c1">//p[3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;*p = %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//运行结果
</span></span></span><span class="line"><span class="cl"><span class="c1">//*p=3
</span></span></span><span class="line"><span class="cl"><span class="c1">//*p=4
</span></span></span></code></pre></div><h3 id="逻辑运算-1">
<a class="header-anchor" href="#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97-1"></a>
逻辑运算
</h3><p>逻辑运算中，判断两个指针是否相等比较常用，其他的不常用。另外，只有两个相同类型的指针比较才有意义，一般编译也会包警告，如果类型不同。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">p1</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">p</span><span class="p">){</span>	<span class="c1">//这里将会报警告，因为不同类型的指针不能比较
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="多级指针">
<a class="header-anchor" href="#%e5%a4%9a%e7%ba%a7%e6%8c%87%e9%92%88"></a>
多级指针
</h2><p>多级指针本质上也是一个指针，也需要一个指针变量来存放。这个指针变量的内存大小跟一级指针一样，跟系统有关。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">**</span><span class="n">p</span>
</span></span></code></pre></div><ol>
<li><code>*p</code>第一<code>*</code>决定变量p是一个指针变量</li>
<li><code>**p</code>第二<code>*</code>决定指针p访问内存规则是以==指针类型==进行访问，所以<code>*p</code>的值还是一个指针（地址）</li>
<li>int决定指针(<code>*p</code>)访问内存规则是以int类型进行访问，所以<code>*(*p)</code>是int类型</li>
</ol>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_20_53_43_202412112053165.png" alt="32位系统下多级指针访问"></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;**pp %d,*pp[0]=%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">**</span><span class="n">pp</span><span class="p">,</span><span class="o">*</span><span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;size of pp %ld </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pp</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="指针的地址传值">
<a class="header-anchor" href="#%e6%8c%87%e9%92%88%e7%9a%84%e5%9c%b0%e5%9d%80%e4%bc%a0%e5%80%bc"></a>
指针的地址传值
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">funcl</span><span class="p">(</span><span class="kt">char</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;funcl:%s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="s">&#34;hello linux&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">ss</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;func2:%s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">ss</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">ǐ</span><span class="n">ss</span><span class="o">=</span><span class="s">&#34;hello linux&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">&#34;hello world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">func1</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//func2(&amp;s);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;s %s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="无序变有序">
<a class="header-anchor" href="#%e6%97%a0%e5%ba%8f%e5%8f%98%e6%9c%89%e5%ba%8f"></a>
无序变有序
</h3><p>多级指针用于物理无序映射到逻辑有序的数据结构设计：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span><span class="s">&#34;to&#34;</span><span class="p">,</span><span class="s">&#34;linux&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">**</span><span class="n">s</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">s</span><span class="p">[</span><span class="n">e</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="n">e</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;&amp;s[0]:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;&amp;s[1]:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;&amp;s[2]:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/12/11_21_5_22_202412112105963.png" alt="多级指针访问"></p>
<h1 id="编译器指令">
<a class="header-anchor" href="#%e7%bc%96%e8%af%91%e5%99%a8%e6%8c%87%e4%bb%a4"></a>
编译器指令
</h1><h2 id="pragma">
<a class="header-anchor" href="#pragma"></a>
pragma
</h2><p>在 <strong>C语言</strong> 中，<code>#pragma</code> 是用于为编译器提供特定指令的预处理指令。具体的使用和支持的 <code>#pragma</code> 类型取决于 <strong>编译器</strong>（如 GCC、IAR、Keil、MSVC 等）。</p>
<h3 id="基本语法">
<a class="header-anchor" href="#%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95"></a>
基本语法
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#pragma &lt;指令&gt;  </span><span class="c1">// 根据指令内容执行不同的编译行为
</span></span></span></code></pre></div><p>如果编译器遇到它不支持的 <code>#pragma</code> 指令，通常会<strong>忽略</strong>它，而不会产生错误。这使得 <code>#pragma</code> 在处理平台相关编译选项时非常灵活。</p>
<h3 id="常见使用场景">
<a class="header-anchor" href="#%e5%b8%b8%e8%a7%81%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af"></a>
常见使用场景
</h3><h4 id="once">
<a class="header-anchor" href="#once"></a>
<code>once</code>
</h4><p>防止头文件重复包含，是一种常见的替代 <strong>include guards</strong> 的方式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#pragma once
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 头文件内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">myFunction</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li><strong>作用</strong>：确保头文件在一次编译过程中只会被包含一次。</li>
<li><strong>支持</strong>：大部分现代编译器（如 GCC、Clang、MSVC、IAR）。</li>
</ul>
<h4 id="pack">
<a class="header-anchor" href="#pack"></a>
<code>pack</code>
</h4><p>用于<strong>结构体对齐</strong>控制。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#pragma pack(4)  </span><span class="c1">// 设置为1字节对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">PackedStruct</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#pragma pack()  </span><span class="c1">// 恢复原始对齐
</span></span></span></code></pre></div><ul>
<li><strong>作用</strong>：确保结构体字段按照指定的字节数对齐。<code>push</code> 和 <code>pop</code> 用于保存和恢复对齐状态。</li>
<li><strong>应用</strong>：减少内存浪费，或在与硬件设备通信时保持字节一致性。</li>
<li><strong>支持</strong>：GCC、MSVC、IAR 等大部分编译器。</li>
</ul>
<h4 id="location-iar-特有">
<a class="header-anchor" href="#location-iar-%e7%89%b9%e6%9c%89"></a>
<code>location</code> （IAR 特有）
</h4><p>用于<strong>指定变量或函数的内存地址</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#pragma location=0x20001000  </span><span class="c1">// 指定变量存放位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">volatile</span> <span class="kt">int</span> <span class="n">myVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li><strong>作用</strong>：将变量或函数放置在特定的内存地址中。这在嵌入式开发中很常见，比如初始化存储在特定 RAM/ROM 地址的配置数据。</li>
<li><strong>支持</strong>：IAR 编译器。</li>
</ul>
<h4 id="warning">
<a class="header-anchor" href="#warning"></a>
<code>warning</code>
</h4><p>控制<strong>编译器警告</strong>的显示和抑制。适用于 MSVC 或 GCC。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#pragma warning(push)       </span><span class="c1">// 保存当前警告状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#pragma warning(disable: 4996)  </span><span class="c1">// 禁用警告 4996（示例）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">deprecatedFunction</span><span class="p">();</span>  <span class="c1">// 调用旧函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#pragma warning(pop)        </span><span class="c1">// 恢复警告状态
</span></span></span></code></pre></div><ul>
<li><strong>作用</strong>：用于临时禁用某些特定的警告。</li>
<li><strong>支持</strong>：MSVC，GCC 使用 <code>#pragma GCC diagnostic</code>。</li>
</ul>
<h4 id="diag_suppress--diag_default--diag_erroriar">
<a class="header-anchor" href="#diag_suppress--diag_default--diag_erroriar"></a>
<code>diag_suppress</code> / <code>diag_default</code> / <code>diag_error</code>（IAR）
</h4><p>用于控制 IAR 编译器的警告或错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#pragma diag_suppress=Pe940  </span><span class="c1">// 禁用警告 Pe940
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">someFunction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 代码内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#pragma diag_default=Pe940  </span><span class="c1">// 恢复默认警告设置
</span></span></span></code></pre></div><h4 id="optimizegccmsvc">
<a class="header-anchor" href="#optimizegccmsvc"></a>
<code>optimize</code>（GCC/MSVC）
</h4><p>用于控制<strong>代码优化</strong>级别。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#pragma optimize(&#34;&#34;, off)  </span><span class="c1">// 禁用优化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">criticalFunction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 关键代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#pragma optimize(&#34;&#34;, on)   </span><span class="c1">// 启用优化
</span></span></span></code></pre></div><ul>
<li><strong>作用</strong>：临时启用或禁用特定区域的优化。</li>
<li><strong>支持</strong>：GCC、MSVC。</li>
</ul>
<h4 id="sectioniar">
<a class="header-anchor" href="#sectioniar"></a>
<code>section</code>（IAR）
</h4><p>用于将代码或数据放入指定的段中，常用于嵌入式系统的内存管理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#pragma section = &#34;MY_SECTION&#34;  </span><span class="c1">// 声明段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">myArray</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="err">@</span> <span class="s">&#34;MY_SECTION&#34;</span><span class="p">;</span>  <span class="c1">// 将数组放入指定段
</span></span></span></code></pre></div><ul>
<li><strong>作用</strong>：将数据或代码放入特定段，方便嵌入式开发中的内存分区。</li>
<li><strong>支持</strong>：IAR 等嵌入式编译器。</li>
</ul>
<h2 id="attribute">
<a class="header-anchor" href="#attribute"></a>
attribute
</h2><p>在 C 语言中，<code>__attribute__</code> 是 GCC 编译器提供的一种扩展，用于指定函数或变量的特性。它可以帮助编译器优化代码或改变函数的行为。</p>
<h3 id="函数属性">
<a class="header-anchor" href="#%e5%87%bd%e6%95%b0%e5%b1%9e%e6%80%a7"></a>
函数属性
</h3><h4 id="noreturn">
<a class="header-anchor" href="#noreturn"></a>
<code>noreturn</code>
</h4><ul>
<li><strong>作用</strong>：告知编译器该函数不会返回，通常用于 <code>exit()</code>、<code>abort()</code> 等函数。</li>
<li><strong>用法</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_exit</span><span class="p">()</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_exit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 终止程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="pure">
<a class="header-anchor" href="#pure"></a>
<code>pure</code>
</h4><ul>
<li><strong>作用</strong>：表示函数是纯函数，不会产生副作用，返回值只依赖于输入参数。</li>
<li><strong>用法</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">pure</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="malloc">
<a class="header-anchor" href="#malloc"></a>
<code>malloc</code>
</h4><ul>
<li><strong>作用</strong>：指示返回的指针指向未初始化的内存，告诉编译器该函数会分配内存。</li>
<li><strong>用法</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="nf">my_malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">malloc</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="nf">my_malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="变量属性">
<a class="header-anchor" href="#%e5%8f%98%e9%87%8f%e5%b1%9e%e6%80%a7"></a>
变量属性
</h3><h4 id="section">
<a class="header-anchor" href="#section"></a>
<code>section</code>
</h4><ul>
<li><strong>作用</strong>：将变量放置在特定的内存段中，常用于嵌入式开发。</li>
<li><strong>用法</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">my_var</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="nf">section</span><span class="p">(</span><span class="s">&#34;.my_section&#34;</span><span class="p">)));</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="aligned">
<a class="header-anchor" href="#aligned"></a>
<code>aligned</code>
</h4><ul>
<li><strong>作用</strong>：设置变量的对齐方式，确保变量在特定的内存边界上。</li>
<li><strong>用法</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="nf">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="参数属性">
<a class="header-anchor" href="#%e5%8f%82%e6%95%b0%e5%b1%9e%e6%80%a7"></a>
参数属性
</h3><h3 id="unused">
<a class="header-anchor" href="#unused"></a>
<code>unused</code>
</h3><ul>
<li><strong>作用</strong>：防止编译器对未使用的参数发出警告。</li>
<li><strong>用法</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">unused_param</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 该参数可以不使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="对齐属性">
<a class="header-anchor" href="#%e5%af%b9%e9%bd%90%e5%b1%9e%e6%80%a7"></a>
对齐属性
</h3><h4 id="结构体对齐">
<a class="header-anchor" href="#%e7%bb%93%e6%9e%84%e4%bd%93%e5%af%b9%e9%bd%90"></a>
结构体对齐
</h4><ul>
<li><strong>作用</strong>：确保结构体的某些成员或整个结构体的对齐方式。</li>
<li><strong>用法</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">my_struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="nf">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span> <span class="c1">// 确保 i 在 4 字节边界上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="性能优化">
<a class="header-anchor" href="#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"></a>
性能优化
</h4><h5 id="hot-和-cold">
<a class="header-anchor" href="#hot-%e5%92%8c-cold"></a>
<code>hot</code> 和 <code>cold</code>
</h5><ul>
<li><strong>作用</strong>：用于提示编译器对频繁执行的代码进行优化（<code>hot</code>）或对不常执行的代码进行优化（<code>cold</code>）。</li>
<li><strong>用法</strong>：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_hot_function</span><span class="p">()</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">hot</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_cold_function</span><span class="p">()</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">cold</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_hot_function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 频繁调用的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_cold_function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 不常调用的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>

      
    </div>
    <footer class="article-footer">
      

      

      

      

      

      

      

      
      <ul class="article-tag-list" itemprop="keywords">
  
    <li class="article-tag-list-item" data-aos="zoom-in">
      <a
        class="article-tag-list-link"
        href="/tags/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80"
        rel="tag"
        >编程语言</a
      >
    </li>
  
</ul>

    </footer>
  </div>
  
    
  <nav
    id="article-nav"
    data-aos="fade-up"
  >
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img
              data-src="https://s.ipyimatong.com/yuancangip/ips/20230926155265128a333caea.jpeg"
              data-sizes="auto"
              alt="C&#43;&#43;"
              class="lazyload"
            />
          
        
        <a href="http://localhost:1313/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c&#43;&#43;/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            C&#43;&#43;
          
        </h3>
      </div>
    

    
      <div class="article-nav-link-wrap article-nav-link-right">
        
          <img
            data-src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/11_8_56_5_202410110856024.png"
            data-sizes="auto"
            alt="BootLoader"
            class="lazyload"
          />
        
        <a href="http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/bootloader/"></a>
        <div class="article-nav-caption">后一篇</div>
        <h3 class="article-nav-title">
          
            BootLoader
          
        </h3>
      </div>
    
  </nav>


  
</article>










</section>
        </div>
        
        
        



  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



<footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
      2020 -
      2025
      <span class="footer-info-sep rotate"></span>
      TrustMe
    </div>
    
      <div>
        基于&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div>
    
    
      <div>
        <span class="icon-brush"
          >&nbsp;
            58.9k
          </span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;
          
          

          05:07
        </span>
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >总访问量&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >总访客量&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar">
        <div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#宏-1">宏</a></li>
    <li><a href="#条件编译">条件编译</a></li>
    <li><a href="#宏函数">宏函数</a></li>
    <li><a href="#调试宏">调试宏</a></li>
  </ul>

  <ul>
    <li><a href="#sizeof">sizeof</a></li>
    <li><a href="#数据类型关键字">数据类型关键字</a>
      <ul>
        <li><a href="#标准类型">标准类型</a></li>
        <li><a href="#自定义类型">自定义类型</a></li>
        <li><a href="#地址指针类型">地址（指针）类型</a></li>
        <li><a href="#typedef">typedef</a></li>
      </ul>
    </li>
    <li><a href="#修饰关键字">修饰关键字</a>
      <ul>
        <li><a href="#auto">auto</a></li>
        <li><a href="#register">register</a></li>
        <li><a href="#static">static</a></li>
        <li><a href="#extern">extern</a></li>
        <li><a href="#const">const</a></li>
        <li><a href="#volatile">volatile</a></li>
      </ul>
    </li>
    <li><a href="#逻辑关键字">逻辑关键字</a></li>
  </ul>

  <ul>
    <li><a href="#算术运算">算术运算</a></li>
    <li><a href="#位运算">位运算</a></li>
    <li><a href="#逻辑运算">逻辑运算</a></li>
    <li><a href="#内存操作">内存操作</a></li>
  </ul>

  <ul>
    <li><a href="#函数的世界">函数的世界</a>
      <ul>
        <li><a href="#函数的三大属性">函数的三大属性</a></li>
        <li><a href="#函数的参数传递">函数的参数传递</a></li>
      </ul>
    </li>
    <li><a href="#c与面向对象">C与面向对象</a>
      <ul>
        <li><a href="#c与继承">C与继承</a></li>
        <li><a href="#c与封装">C与封装</a></li>
        <li><a href="#c与多态">C与多态</a></li>
        <li><a href="#c与重载">C与重载</a></li>
      </ul>
    </li>
    <li><a href="#solid设计原则">Solid设计原则</a></li>
  </ul>

  <ul>
    <li><a href="#内存分布">内存分布</a>
      <ul>
        <li><a href="#代码段">代码段</a></li>
        <li><a href="#只读数据段">只读数据段</a></li>
        <li><a href="#全局数据段">全局数据段</a></li>
        <li><a href="#堆空间">堆空间</a></li>
        <li><a href="#栈空间">栈空间</a></li>
      </ul>
    </li>
    <li><a href="#内存溢出">内存溢出</a>
      <ul>
        <li><a href="#栈溢出">栈溢出</a></li>
        <li><a href="#堆溢出">堆溢出</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#指针访问内存">指针访问内存</a>
      <ul>
        <li><a href="#指针变量初始化">指针变量初始化</a></li>
        <li><a href="#空指针和野指针">空指针和野指针</a></li>
        <li><a href="#指针访问内存规则">指针访问内存规则</a></li>
      </ul>
    </li>
    <li><a href="#指针运算">指针运算</a>
      <ul>
        <li><a href="#算术运算-1">算术运算</a></li>
        <li><a href="#逻辑运算-1">逻辑运算</a></li>
      </ul>
    </li>
    <li><a href="#多级指针">多级指针</a>
      <ul>
        <li><a href="#指针的地址传值">指针的地址传值</a></li>
        <li><a href="#无序变有序">无序变有序</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#pragma">pragma</a>
      <ul>
        <li><a href="#基本语法">基本语法</a></li>
        <li><a href="#常见使用场景">常见使用场景</a></li>
      </ul>
    </li>
    <li><a href="#attribute">attribute</a>
      <ul>
        <li><a href="#函数属性">函数属性</a></li>
        <li><a href="#变量属性">变量属性</a></li>
        <li><a href="#参数属性">参数属性</a></li>
        <li><a href="#unused"><code>unused</code></a></li>
        <li><a href="#对齐属性">对齐属性</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
      </div>
      <div class="sidebar-common-sidebar hidden">
        
<div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="TrustMe"
    class="lazyload"
  />
  <div class="sidebar-author-name">TrustMe</div>
  <div class="sidebar-description">你要信我啊</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    
    <div class="sidebar-state-number">59</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">
      0
    </div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">7</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="首页"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="归档"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="关于"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="友链"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>
        
          
            &#xe62b;
          
        
      </div>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>

      </div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
      <div class="site-search">
        <div class="reimu-popup popup">
          <div class="reimu-search">
            <div class="reimu-search-input-icon"></div>
            <div class="reimu-search-input" id="reimu-search-input"></div>
            <div class="popup-btn-close"></div>
          </div>
          <div class="reimu-results">
            <div id="reimu-stats"></div>
            <div id="reimu-hits"></div>
            <div id="reimu-pagination" class="reimu-pagination"></div>
          </div>
          <img class="reimu-bg" src="/images/reimu.png" />
        </div>
      </div>
    
    






  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"
  ></script>




  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"
  ></script>









  
      
      <script src="/js/main.js" ></script>
      



  





  
      
      <script src="/js/aos.js" ></script>
      

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script>








  
      
      <script src="/js/pjax_main.js" data-pjax></script>
      



  <script>
    var ALGOLIA_CONFIG = {
      logo: '\/images\/algolia_logo.svg',
      algolia: {
        applicationID: "",
        apiKey: "",
        indexName: "",
        hits: {
          "per_page": parseInt("10")
        },
        labels: {
          "input_placeholder": "搜索.....",
          "hits_empty": "未发现与 「${query}」相关内容",
          "hits_stats": "找到${hits}条结果（用时 ${time} ms）"
        }
      }
    };
  </script>
  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/algoliasearch@4.17.1/dist/algoliasearch-lite.umd.js"
    defer
    
    
    
    integrity="sha384-xvLS0jfKuoREs7pqkRI/OI8GcqohO5S&#43;jQz7ZBtQXnsXmD&#43;9jDOOY4cL6dCPzlrk" crossorigin="anonymous"
  ></script>


  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/instantsearch.js@4.56.1/dist/instantsearch.production.min.js"
    defer
    
    
    
    integrity="sha384-hHJCflT4KBLQyHfKO9vpstIcFKn/Y&#43;KHTORelMMEn7mOp2AVPp&#43;7fr03dLgZiV3J" crossorigin="anonymous"
  ></script>


  





  
      
      <script src="/js/algolia_search.js" ></script>
      




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/mouse-firework@0.1.0/dist/index.umd.js"
    
    
    
    
    integrity="sha384-KM6i7tu43nYd6e0beIljxHMC5tZc58XBDu7pPA58w50h18Jsx7gLdimfS09RXlKv" crossorigin="anonymous"
  ></script>


<script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"#ff5252\",\"#ff7c7c\",\"#ffafaf\",\"#ffd0d0\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"#ff0000\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>








<div id="lazy-script">
  <div>
    
      
      
        
      
      <script data-pjax>
        window.REIMU_POST = {
          author: "TrustMe",
          title: "C",
          url: "http:\/\/localhost:1313\/post\/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80\/c\/",
          description: " 宏 宏 [!important]\n宏是一个纯粹的文本替换\n#define 宏名 宏体 当宏体包含运算符时，需要增加括号来==限制==宏体和外部的计算优先级\n#define 宏名 (带有运算的的宏体) 条件编译 条件编译语句：编译中的分支语句\n#ifdef your_macro\t\/\/条件编译语句 #else\t\/\/条件编译语句 #endif\t\/\/条件编译语句 #if your_macro == constant\t\/\/条件编译语句 #endif\t\/\/条件编译语句 提示编译语句\n#ifdef your_macro\t#else #error \u0026#34;error information …",
          cover: "https:\/\/gitlab.com\/18355291538\/picture\/-\/raw\/main\/pictures\/2024\/11\/30_10_53_6_202411301053994.png",
        };
      </script>
    
    
    
      





  
      
      <script src="/js/insert_highlight.js" data-pjax></script>
      

      
      
      
      
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;

        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      












      
    
    
  </div>
</div>




  

  
  
  
  
  
  
  <script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"
  ></script>





  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>


<script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script>




  </body>
</html>
