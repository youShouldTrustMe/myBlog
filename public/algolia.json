
[
  
  
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/readme/",
    "title": "",
    
    "content": " 该仓库为笔记文件，相关的参考链接已在文章中注明，如出现侵权行为，请及时联系删除相关文件 如果想要有完美的阅读体验，请使用typora+vlook进行查阅，具体使用可以参见\\编程语言\\MarkDown.md 由于该仓库作为笔记，其中大部分内容是笔者自己的理解，所有请谨慎参考，如有理解有误的地方，请提出，我会修正。 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/arm%E6%9E%B6%E6%9E%84/",
    "title": "",
    
    "content": "在ARM Cortex-M架构中，向量表是一个关键的数据结构，用于存储中断和异常处理程序的入口地址。向量表通常位于Flash存储的起始位置，并且其内容和排列位置是固定的。以下是向量表中存放的内容及其排列位置：\n向量表内容 初始堆栈指针 (SP):\n位置: 向量表的第一个条目（偏移量0）。 内容: 初始化堆栈指针的地址。系统复位时，处理器会将这个值加载到主堆栈指针（MSP）寄存器中。 复位处理程序地址 (PC):\n位置: 向量表的第二个条目（偏移量4）。 内容: 复位处理程序的入口地址。系统复位时，处理器会跳转到这个地址开始执行。 异常和中断处理程序地址:\n位置: 从向量表的第三个条目开始（偏移量8），依次存放各个异常和中断的处理程序地址。 内容: 包括各种异常（如NMI、硬故障）和外部中断的处理程序地址。每个处理程序地址占用4个字节。 向量表排列示例 假设向量表的起始地址为 0x08000000，以下是一个示例排列：\n偏移量 内容 描述 0x00 初始SP地址 初始堆栈指针 0x04 复位处理程序地址 复位处理程序（入口点） 0x08 NMI处理程序地址 非屏蔽中断处理程序 0x0C 硬故障处理程序地址 硬故障处理程序 0x10 内存管理故障处理程序地址 内存管理故障处理程序 0x14 总线故障处理程序地址 总线故障处理程序 0x18 用法故障处理程序地址 用法故障处理程序 \u0026hellip; \u0026hellip; \u0026hellip; 0xXX 外部中断处理程序地址 外部中断处理程序（如EXTI） 注意事项 对齐要求: 向量表的起始地址通常需要对齐到特定的边界（如128字节或256字节），具体取决于处理器的实现。 可重定位: 在某些情况下，向量表可以被重定位到RAM中，以支持动态修改中断向量。 安全性: 确保向量表的内容在系统运行期间不会被意外修改，以防止中断处理程序被篡改。 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/bootloader/",
    "title": "",
    
    "content": " 参考链接 基于UDS的BootLoader设计——架构设计及规范_nxp s32k144 bootloader 基于uds-CSDN博客\nBootloader升级方式一————擦、写flash在RAM中运行 - isAndyWu - 博客园 (cnblogs.com)\n基础介绍 BootLoader的作用 Boot Loader又称为引导加载程序，引导加载程序是系统上电后运行的第一段软件代码，常被用来加载系统或者更新系统等。因此，大部分的Boot Loader存在两种不同的操作模式：\n==启动模式==：启动加载（BootLoading）模式也称为自主模（Autonmous）式，即BootLoader从目标机上某个固态存储设备上将操作系统加载至RAM中运行，整个过程中并没有用户的介入。 ==下载模式==：在下载（DownLoading）模式下，目标机上的Boot Loader将通过串口连接或者网络连接等通信手段下载文件，如下载内核映像和根文件系统映像等。通常文件会保存在RAM中，然后将其写入目标地址完后系统的更新等。 ==Bootloader=Boot + loader==\nBoot的目的： 最终目的：跳到C语言中；为了C语言运行程序会进行一系列的初始化，系统一上电后如何通过一系列的设置让软件程序员进入C语言/更高级语言环境的开发，这个过程就是boot的主要目的。\nLoader的目的： 主要目的是开始执行应用逻辑，比如点灯：需要灯的接口开发；串口输入输出：需要串口编程；加载linux的内核：flash的编程、网卡的编程、内核启动前的初始化部分。根据不同的应用会有不同的变化。\n==一个开发板要想执行loader，要先看boot做了什么事。==\nBootLoader的基本需求 两个SWC（Software Component）：\n启动管理——控制器的启动管理等 应用程序——ECU软件下载升级及标定数据再编程等 四个服务模块：\n内存管理——软件更新主要是将Flash中的Application及标定数据重编程，内存擦除与重写驱动必不可少的模块； CAN协议栈——软件更新媒介 看门狗模块——软件运行保护 安全模块——软件数据保护，下载数据校验等 BOOT设计流程 流程：\n关闭看门狗、中断、MMU、CACHE，通过汇编语言对相应的寄存器进行置位即可实现。 配置系统工作时钟，通过 …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/map%E6%96%87%E4%BB%B6/",
    "title": "",
    
    "content": " 参考链接 KEIL MDK .map文件分析(必学知识点) - 正点原子倾力打造！-OpenEdv-开源电子网\n充分理解Linux GCC 链接生成的Map文件 - 知乎 (zhihu.com)\n[!important]\n可以使用AMAP可视化map文件\nGCC平台 Archives linked 一般位于map文件的第一行\nArchive member included to satisfy reference by file (symbol) /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc_nano.a(lib_a-exit.o) /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/crt0.o (exit) 上面的文件信息格式如下：\nThe archive file location (compilation unit) The compilation unit referencing the archive (symbol called) 上面内容的意思是crt0这个文件中会调用exit函数，exit函数在exit.o这个目标文件中，exit.o目标文件是被链接在libc_nano.a这个库文件里的。\nMemory configuration Map文件中最直接的信息是实际的内存区域，这些区域具有位置、大小和访问权限:\nMemory Configuration Name Origin Length Attributes FLASH 0x0000000000001000 0x00000000000ff000 xr RAM 0x0000000020000008 0x000000000003fff8 xrw *default* 0x0000000000000000 …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/",
    "title": "",
    
    "content": " Bin BIN文件是纯二进制文件，没有固定的结构或元数据。==当想要将二进制文件烧录进单片机时，不需要再对数据进行处理==，也就是说，我们使用ImHex打开的原始数据是什么样的，那么我们查看Flash中的内容就是什么样的。\nHex Hex 全称 (Intel HEX)文件是由一行行符合Intel HEX文件格式的文本所构成的ASCII文本文件。\n在Intel HEX文件中，每一行包含一个HEX记录。\n[!note]\n注意：我们使用txt文件打开的时候显示的是ASCII表示，也就是一个字符串。实际上一行数据的原始数据如下图左侧所示，使用txt打开的如右图所示。\n下面会用源数据表示左侧的数据，用ASCII表示右侧数据。\n参考链接 单片机烧录用的hex文件，文件格式解析（转载）_.hex用什么软件打开-CSDN博客\nIntel Hex Format\n行结构 一行Hex数据由以下结构组成：\n[Start code][Byte count][Address][Record type][Data][Checksum] 参数 长度 说明 Start code - 每行都由冒号开头，这是固定的 Byte count 1 字节 本行数据的长度,最大值是255 (0xFF). 16 (0x10) 和32 (0x20)是最常用的 Address 2字节 Memory数据开始16-bit地址偏移。物理地址通常是有这个偏移加上基地址 Record type 1 字节 表示不同数据段的含义 Data 可变长度 具体数据 N Byte ，表示本行中数据字节的数量 Checksum 1 字节 校验值 [!tip]\nChecksum的计算方法为：\n如0300300002337A1E,数据和为：03 + 00 + 30 + 00 + 02 + 33 + 7A = E2 这个E2的补码是 1E ，即这个数据record的补码\n[!note]\n注意：上表的长度是ASCII的长度，也就是假设txt显示:1010，那么10就是一个字节，但是在源数据中，这就是两个字节0x31 0x30\n==Record type的选取==\n数值 数据类型详（Record type） 00 表示后面记录的是数据 01 表示文件结束，放在文件的最后，标识HEX文件的结尾 02 表示扩展段地址 03 表示开始段地址 04 表示扩展线性地址 05 表示开始线性地址 [!important]\n这里需要注意的是Bin文件和Hex文件的区别：\nBin文件中的数据内容可以直接烧录进入Flash中\nHex文件中的数据内容（指的是源数据）是经过改变之后才可以放入Flash中的\n一般我们通过txt文件看到的都是ASCII表示，并不是文件源数据，我们需要将ASCII的数据当成16进制的数据，也就是我们看见的:1010转换为0x10 0x10。此时他们的源数据就改变了。源数据从0x3A 0x31 0x30 0x31 0x30变成0x10 0x10 0x10 0x10\n地址解读 因为HEX的地址段只有两个字节表示，只能寻址到16位,显然是不够的，所以就有了拓展地址，相关解释请参考Intel Hex Format。\n地址分为16位和32位或8位。\n8位和32位：==数据记录中的数据字节在内存中的绝对地址为线性地址==。 16位：==数据字节的绝对地址是分段地址==。 $$\r实际物理地址=基地址+偏移地址\r$$ 地址类型 Record type 地址解读 线性基地址 0x04 得到的数据左移16位 段基地址 0x02 得到的数据左移4位 偏移地址 0x00 得到的数据 [!tip]\n选择不同类型的基地址（0x02和0x04）对应着不同位长的系统。\n==指定程序入口==\n$$\r实际入口地址=（代码段地址\u003c\u003c4）+指令指针地址\r$$ 地址类型 Record type 地址解读 代码段地址（CS） 0x03 得到的数据的高2字节 指令指针地址（IP） 0x03 得到的数据的低2字节 记录：:0400000300003800C1 数据字段：00003800。 CS = 0x0000。 IP = 0x3800。 实际入口地址 = (0x0000 \u0026lt;\u0026lt; 4) + 0x3800 = 0x03800。 开始线性入口：可以直接使用数据字段的值。\n记录：:04000005000000CD2A 数据字段：000000CD。 实际入口地址 = 0x000000CD。 ==示例==\n以下是一个包含扩展地址记录的HEX文件示例：\n复制\n:020000021200EA :10000000AABBCCDDEEFF00112233445566778899F1 :10001000ABCDEF0123456789ABCDEF0123456789B2 :00000001FF 第一行（类型02）： 数据字段：1200（段地址）。 基地址 = 0x1200 \u0026lt;\u0026lt; 4 = 0x12000。 第二行（类型00）： 偏移地址：0000。 实际地址 = 0x12000 + 0x0000 = 0x12000。 数据字段：AABBCCDDEEFF00112233445566778899。 第三行（类型00）： 偏移地址：0010。 实际地址 = 0x12000 + 0x0010 = 0x12010。 数据字段：ABCDEF0123456789ABCDEF0123456789。 第四行（类型01）： 文件结束记录。 实现 以下使用CAPL语言实现：\nvariables { struct Block { dword BlockStartAddr; //数据开始的地址 dword BlockDataLength; //数据的长度 byte dataBuffer[0x020FFFF]; //数据区域(单块数据的Buffer，如果hex文件很大，则需要把次参数调大) }; struct Block hexfile[5]; //创建5个数据块(主要根据HEX文件进行调整，hex有几个数据块就需要设置几个) int HexBlockTotalNumber = 0; //数据块总数 dword t1; //计算解析所用的时间 } /********************************************************************************* *Function: //char2byte * Description： //把单个字符转换为Byte的函数 *Input: //ch：ASCII编码字符，取值为0到F *Return: //val，为byte类型 **********************************************************************************/ byte char2byte(char ch) { byte val; val = 0; if ( ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { val = ch - \u0026#39;0\u0026#39;; } if ( ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;f\u0026#39;) { val = (ch - \u0026#39;a\u0026#39;) + 10; } if ( ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;F\u0026#39;) { val = (ch - \u0026#39;A\u0026#39;) + 10; } return val; } /********************************************************************************* *Function: //Read_hexFile * Description： //解码HEX文件，只支持0x00，0x04，0x01类型 *Input: //Filename：需要解码的文件名 *Output: //hexfile *Return: //void **********************************************************************************/ //读取HEXFILE void Read_hexFile(char Filename[]) { long file_handle; char RowData[128]; //逐行读取,每行数据缓存，当每行数据大于128时，需要将其调整 dword i; dword RowDataByte;\t//单块数据块字节数 qword OffsetAddress;\t//扩展线性地址 qword ReAddr;\t//上一数据行起始地址 dword Len;\t//HEX每行有效数据字节数 dword ReLen;\t//HEX前一次数据长度 dword Addr;\t//HEX每行起始地址 dword Type;\t//HEX每行类型，有00，01，04四种类型 RowDataByte = 0;i = 0;Len = 0;ReLen = 0;Addr=0;Type = 0;ReAddr = 0; file_handle = OpenFileRead(Filename,0); HexBlockTotalNumber = 0; if(file_handle!=0) { // Read all lines while ( fileGetStringSZ(RowData,elcount(RowData),file_handle)!=0 ){ //判断首字符是否为:号 if(RowData[0] == \u0026#39;:\u0026#39;){ Len = (char2byte(RowData[1])*0x10+char2byte(RowData[2])); Addr = char2byte(RowData[3])*0x1000+char2byte(RowData[4])*0x100+char2byte(RowData[5])*0x10+char2byte(RowData[6]); Addr |= (OffsetAddress \u0026lt;\u0026lt; 16); Type = char2byte(RowData[7])*0x10+char2byte(RowData[8]); //以下为打印解析的过程，打印解析时候的变量 //write(\u0026#34;RowData:%s,HexBlockTotalNumber:%d,ReLen:%X,ReAddr:%X,Addr:%X,RowDataByte:%X\u0026#34;,RowData,HexBlockTotalNumber,ReLen,ReAddr,Addr,RowDataByte); switch(Type){ case 0x00:\t//数据 if (Addr \u0026gt; (ReLen + ReAddr)){ //判断为新数据块 if(RowDataByte == 0)\t//是否为首行数据字节数 { hexfile[HexBlockTotalNumber].BlockStartAddr = Addr; //记录新数据块的起始地址 } else\t//不是首行 { hexfile[HexBlockTotalNumber].BlockDataLength = RowDataByte; //数据长度 RowDataByte = 0;\t//重新开始计数 hexfile[HexBlockTotalNumber].BlockStartAddr = Addr;\t//记录新数据块的起始地址 HexBlockTotalNumber++; } } for(i = 0; i\u0026lt; Len ; i++) { //储存buffer，注意没有对crc进行校验。 hexfile[HexBlockTotalNumber].dataBuffer[RowDataByte++]=(char2byte(RowData[2*i+9])*0x10+char2byte(RowData[2*i+10])); } ReAddr = Addr;\t//保存当前地址,下一次使用 ReLen = Len;\t//保存当前长度,下一次使用 break; case 0x04:\t//扩展线性地址记录 OffsetAddress = char2byte(RowData[9])*0x1000+char2byte(RowData[10])*0x100+char2byte(RowData[11])*0x10+char2byte(RowData[12]);\t//偏移地址\tbreak; case 0x01:\t//地址,结束 hexfile[HexBlockTotalNumber].BlockDataLength = RowDataByte; //数据长度 HexBlockTotalNumber++; break; } } } write(\u0026#34;Hex文件读取成功, 数据分块:%d\u0026#34;,HexBlockTotalNumber); for(i = 0; i \u0026lt; HexBlockTotalNumber; i++) { write(\u0026#34;数据块:%d, 起始地址:0x%X, 结束地址:0x%X, 数据长度:%6d字节\\r\\n\u0026#34;, i+1, hexfile[i].BlockStartAddr, hexfile[i].BlockStartAddr + hexfile[i].BlockDataLength - 1, hexfile[i].BlockDataLength); } fileClose(file_handle); } else{ write(\u0026#34;OpenFileRead,error occurs\u0026#34;); } } on key \u0026#39;f\u0026#39; { t1 = timeNow(); Read_hexFile(\u0026#34;test.hex\u0026#34;); write(\u0026#34;%d\u0026#34;,t1-timeNow()); write(hexfile[0].dataBuffer); } write (byte v[]) { int i; for (i=0; i\u0026lt;48; i++) write(\u0026#34;dataBuffer:%x\u0026#34;,hexfile[0].dataBuffer[i]); } Elf ELF（Executable and Linkable Format，可执行与可链接格式）是一种用于可执行文件、目标文件、共享库和核心转储的标准文件格式。它广泛应用于类Unix系统（如Linux、BSD）以及嵌入式系统中。\nELF文件的结构 ELF文件由以下几个主要部分组成：\nELF头 程序头表 节头表 段和节 ELF头（ELF Header） 作用：描述文件的基本信息，如文件类型、目标架构、程序入口地址等。 重要字段： e_ident：魔数（Magic Number），标识文件为ELF格式。 e_type：文件类型（如可执行文件、共享库等）。 e_machine：目标架构（如x86、ARM）。 e_entry：程序入口地址。 e_phoff：程序头表偏移。 e_shoff：节头表偏移。 程序头表（Program Header Table） 作用：描述段（Segment）信息，用于加载可执行文件。 重要字段： p_type：段类型（如可加载段、动态链接信息）。 p_offset：段在文件中的偏移。 p_vaddr：段在内存中的虚拟地址。 p_filesz：段在文件中的大小。 p_memsz：段在内存中的大小。 节头表（Section Header Table） 作用：描述节（Section）信息，用于链接和调试。 重要字段： sh_name：节名称（在字符串表中的索引）。 sh_type：节类型（如代码节、数据节）。 sh_addr：节在内存中的地址。 sh_offset：节在文件中的偏移。 sh_size：节的大小。 段（Segments）和节（Sections） 段：用于加载和执行，通常包含代码、数据等。 节：用于链接和调试，通常包含符号表、字符串表等。 ELF文件的类型 ELF文件可以分为以下几种类型：\n可执行文件（Executable）：可以直接运行的程序。 共享库（Shared Library）：动态链接库（如.so文件）。 目标文件（Relocatable File）：编译生成的中间文件（如.o文件）。 核心转储（Core Dump）：程序崩溃时的内存转储。 ELF文件的工具 以下工具可以用于分析和操作ELF文件：\nreadelf：查看ELF文件的详细信息。 示例：readelf -h \u0026lt;file\u0026gt;（查看ELF头）。 objdump：反汇编和查看ELF文件内容。 示例：objdump -d \u0026lt;file\u0026gt;（反汇编代码段）。 nm：查看ELF文件的符号表。 示例：nm \u0026lt;file\u0026gt;。 strip：删除ELF文件的符号表和调试信息。 示例：strip \u0026lt;file\u0026gt;。 ELF文件的加载和执行 当ELF可执行文件被加载到内存中时，操作系统会执行以下步骤：\n解析ELF头，确定文件类型和入口地址。 根据程序头表，将段加载到内存中。 设置程序的堆栈和环境变量。 跳转到入口地址，开始执行程序。 ELF文件的示例解析 以下是一个简单的ELF文件解析示例：\n查看ELF头 readelf -h hello 输出示例：\nELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2\u0026#39;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x400430 Start of program headers: 64 (bytes into file) Start of section headers: 6936 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 28 查看程序头表 readelf -l hello 输出示例：\nElf file type is EXEC (Executable file) Entry point 0x400430 There are 9 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x00000000000006fc 0x00000000000006fc R E 200000 LOAD 0x0000000000000700 0x0000000000600700 0x0000000000600700 0x0000000000000230 0x0000000000000238 RW 200000 ... 查看节头表 readelf -S hello 输出示例：\nThere are 31 section headers, starting at offset 0x1b18: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000400238 00000238 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 00000254 0000000000000020 0000000000000000 A 0 0 4 ... ELF文件的常见节 .text：代码段，包含程序的指令。 .data：已初始化的全局变量和静态变量。 .bss：未初始化的全局变量和静态变量。 .rodata：只读数据（如字符串常量）。 .symtab：符号表。 .strtab：字符串表。 .dynamic：动态链接信息。 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/",
    "title": "",
    
    "content": " 1 参考链接 操作系统：设计与实现 (2024 春季学期) (jyywiki.cn)\n应用视角下的操作系统 构造一个最小程序 要理解操作系统首先要理解程序,下面是一个最简单的程序：\nint main() { printf(\u0026#34;Hello world!\u0026#34;); } 当生成输出文件之后，可以使用以下的命令来查看生成的可执行文件\nobjdump 工具可以查看对应的汇编代码 gcc --verbose 可以查看所有编译选项 (真不少)printf 变成了 puts@plt gcc -Wl,--verbose 可以查看所有链接选项 (真不少)原来链接了那么多东西还解释了 end 符号的由来 gcc -static 会链接 libc (大量的代码) 当使用以上工具查看生成的main的可执行文件时，发现可执行文件内容较多。编译链接的过程会链接库文件导致可执行文件变大。\n那么我们可以尝试着手动的去链接可定位文件，可以先生成一个main.o文件，然后将这个mian.o试着手动链接编译的文件\n直接用 ld 链接失败：因为ld 不知道怎么链接 printf\n所以只能不调用 printf ，将程序改为以下内容\nint main() { } 运行时出现 Segmentation Fault ，调试时发现在return时出现错误\n如果改成以下代码\nint main() { while(1); } 运行时会卡在死循环中，说明我们的程序时可以运行的\n[!NOTE]\n为什么会出现Segmention falut？\n当函数在renturn时，程序会从内存的rsp寄存器中取出地址给PC，作为下一条执行指令的地址，然后rsp+8,栈（rsp存在栈中）是向下生长的\n当执行完错误的return语句之后，PC的地址变为了1\n这意味着在执行return之前，内存中的rsp指向运行代码的地址，也就是上面的1，所以出现了问题\n程序 程序实际上是一个状态机：\nstruct CPUState { uint32_t regs[32], csrs[CSR_COUNT]; uint8_t *mem; uint32_t mem_offset, mem_size; }; 处理器：无情的、执行指令的状态机\n从 𝑀[𝑃𝐶]中取出一条指令 执行它 循环往复 程度的退出 程序自己是不能 “停下来” 的!\n指令集里==没有一条关闭计算机的指令==，那么操作系统是如何在关闭所有软件后，切断计算机的电源的？ 只能借助操作系统\nmovq $SYS_exit, %rax # exit( movq $1, %rdi # status=1 syscall # ); 把 “系统调用” 的参数放到寄存器中 执行==syscall==，操作系统接管程序 操作系统可以任意改变程序状态 (甚至终止程序) [!TIP]\nsyscall是一条特殊指令，由操作系统提供。\n当main函数退出时，可以使用syscall指令告诉操作系统，程序即将退出，然后等待syscall的回应，此时一个系统调用就完成了。\n[!TIP]\n在操作系统之下是电路，实际上在下面的电路也可以看成有一个小型的操作系统，当上层操作系统向底层的操作系统发送指令之后（通过ACPI（高级配置和电源接口）进行交互），底层的操作系统会向它所管理的元器件发送高低电平，从而达到关机的效果\n此时就可以构造最小的程序\n==mininal.S==\n#include // The x86-64 system call Application Binary Interface (ABI): // System call number: RAX // Arguments: RDI, RSI, RDX, RCX, R8, R9 // Return value: RAX // See also: syscall(2) syscalls(2) #define syscall3(id, a1, a2, a3) \\ movq $SYS_##id, %rax; \\ movq $a1, %rdi; \\ movq $a2, %rsi; \\ movq $a3, %rdx; \\ syscall #define syscall2(id, a1, a2) syscall3(id, a1, a2, 0) #define syscall1(id, a1) syscall2(id, a1, 0) .globl _start _start: syscall3(write, 1, addr1, addr2 - addr1) syscall1(exit, 1) addr1: .ascii \u0026#34;\\033[01;31mHello, OS World\\033[0m\\n\u0026#34; addr2: 使用以下指令运行上面的汇编程序\ngcc -g -S minimal.S minimal.s as minimal.s -o minimal.o ld -o minimal minimal.o ./minimal echo $status #使用该行指令打印出RAX中的值 程序 = 状态机 ==Everything（二进制文件）= 状态机==\n状态\ngdb 内可见的内存和寄存器 初始状态\n由 ABI 规定 (例如有一个合法的 %rsp) 状态迁移\n执行一条指令 gdb 可以单步观察状态机的执行 syscall 指令: 将状态机 “完全交给” 操作系统 [!IMPORTANT]\n状态 = 变量数值 + 栈 初始状态 = main 的第一条语句 状态迁移 = 执行一条语句中的一小步 拆解程序 操作系统上有很多不同种类的程序\nCore Utilities (coreutils)\nStandard programs for text and file manipulation\n系统中默认安装的是 GNU Coreutils\n系统/工具程序\nbash,binutils, apt, ip, ssh, vim, tmux, gcc, python, ffmpeg, \u0026hellip;\n原理不复杂 (例如 apt 是 dpkg 的套壳)，但琐碎 All-in-one 工具合集：busybox, toybox\n其他各种应用程序\nVscode、OBS-Studio、浏览器、音乐播放器：它们在各种工具程序基础上建立起来 (例：ffmpeg) 追踪一个程序\n工具程序代表：编译器 (gcc):\nstrace -f gcc a.c #(gcc 会启动其他进程) 可以管道给编辑器 vim -\n编辑器里还可以\n%!grep 对于开发者来说，工具的组合是非常重要的 图形界面程序代表：编辑器 (xedit):\nstrace xedit 图形界面程序和 X-Window 服务器按照 X11 协议通信 虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host 任何程序 = minimal.S = 状态机\n程序在操作系统上的执行过程：\n总是从被操作系统加载开始 通过另一个进程执行 execve 设置为初始状态 经历状态机执行 (计算 + syscalls) 进程管理：fork, execve, exit, \u0026hellip; 文件/设备管理：open, close, read, write, \u0026hellip; 存储管理：mmap, brk, \u0026hellip; 最终调用 _exit (exit_group) 退出 ==应用程序 = 计算 + 操作系统 API==\n窗口管理器 能直接管理屏幕设备 (read/write/mmap)\n能画一个点，理论上就能画任何东西 能够和其他进程通信 (send, recv)\n任务管理器 能访问操作系统提供的进程对象 (M1 - pstree) 杀毒软件 文件静态扫描 (read)、主动防御 (ptrace) ==操作系统的职责：提供令应用程序舒适的抽象 (对象 + API)==\n编译器 既然说 “任何程序” 都和 minimal.S 是一样的\n为什么我们没有在 C 代码里看到系统调用？ C 代码是如何变成二进制文件的？ 到底编译器什么优化能做、什么优化不能做？ 如果说程序就是一个状态机，那么如何写一个C语言代码的解释器？\n在写C语言的解释器的时候，我们首先需要将C代码简化，将C 代码改写成 SimpleC，将C转化为SimpleC需要遵循以下规则：\n成每条语句至多一次运算 (函数调用也是运算) 条件语句中不包含运算 真的有这种工具 (C Intermediate Language) 和解释器 (暂时假设没有指针和内存分配) Everything (C 程序) = 状态机\n状态 = 变量数值 + 栈 初始状态 = main 的第一条语句 状态迁移 = 执行一条语句中的一小步 状态机\n“状态机” 是拥有严格数学定义的对象。这意味着你可以把定义写出来，并且用数学严格的方法理解它 —— 形式化方法\n状态：\n[StackFrame, StackFrame, \u0026hellip;] + 全局变量\n实际上一个状态就是一个栈帧\n初始状态：\n仅有一个 StackFrame(main, argc, argv, PC=0) 全局变量全部为初始值 每个栈帧中都有一个PC值，用来保存当前的执行指针 状态迁移：\n执行 frames[-1].PC 处的简单语句 什么是编译器\n编译器的输入\n高级语言 (C) 代码 = 状态机 编译器的输出\n汇编代码 (指令序列) = 状态机 编译器 = 状态机之间的翻译器\nSimpleC的直接翻译\n运算：\n把操作数 load 到寄存器、执行运算、store 写回结果 分支/循环：\n使用条件跳转分别执行代码 函数调用：\n专门留一个寄存器给栈 (SP, Stack Pointer) 将 Stack frame 的信息保存在内存里 通过 SP 可以访问当前栈帧的变量、返回地址等 所以，==C 被称为高级汇编语言==\n存在 C 代码到指令集的直接对应关系 状态机和迁移都可以 “直译” 于是计算机系统里多了一个抽象层 (“一生二、二生三、三生万物”) 更 “高级” 的语言就很难了 C++ virtual void foo(); Python [1, 2, 3, *rest] Javascript await fetch(...) 编译优化\nC 语言编译器在进行代码优化时，遵循的基本准则是在不改变程序的==语义== (即程序的行为和输出结果) 的前提下，提高程序的执行效率和/或减少程序的资源消耗\nint foo(int x) { int y = x + 1; return y - 1; } 一些 “不改变语义” 的例子 (编译优化中最重要的 “三板斧”)：\n函数内联：将函数调用替换为函数体本身的内容 常量传播：在编译时计算常量表达式的值并替换 死代码消除：删除永远不会被执行到的代码 例子\n==编译优化前==\nint compute(int x) { int y = x + 1; return y - 1; } ==编译优化前==\nint compute(int x) { if(true) { x = 1; } else { } return x; } ==编译优化后==\nint compute(int x) { return x; } ==编译优化后==\nint compute(int x) { //if(true) 死代码消除 //{ // x = 1; 常量传播 //} //else 死代码消除 //{ //} //return x; return 1; //常量传播 } 编译的正确性\n系统调用是使程序计算结果可见的唯一方法\n不改变语义 = 不改变可见结果 状态机的视角：满足C/汇编状态机生成的所有 syscall 序列完全一致，任何优化都是允许的 C 代码中的不可优化部分\nExternal function calls (链接时才能确定到底是什么代码) 未知的代码可能包含系统调用 因此不可删除、移出循环等，且要保证参数传递完全一致 编译器提供的 “不可优化” 标注 volatile [load | store | inline assembly] 硬件视角下的操作系统 reset之后执行firmware\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%A0%A1%E9%AA%8C/",
    "title": "",
    
    "content": " 校验和 (Checksum) 参考链接 CheckSum算法\u0026amp;ndash;又名累加和校验算法 - 皮卡成球 - 博客园\n原理及步骤 **校验和（Checksum）**是网络协议使用的数据错误检测方法，并且被认为比LRC（纵向冗余校验，Longitudinal Redundancy Check，LRC），VRC和CRC（循环冗余校验（Cyclic Redundancy Codes，CRC））更可靠。此方法在发送方使用校验和生成器，在接收方使用校验和校验器。\n累加和校验算法的实现\n发送方：对要数据累加，得到一个数据和，对和求反，即得到我们的校验值。然后把要发的数据和这个校验值一起发送给接收方。\n接受方：对接收的数据（包括校验和）进行累加，然后加1，如果得到0，那么说明数据没有出现传输错误。\n注意，此处发送方和接收方用于保存累加结果的类型一定要一致，否则加1就无法实现溢出从而无法得到0，校验就会无效。\n步骤：\n校验数据以16bit为单位进行累加求和，校验数据需为偶字节数（不然无法以16bit为累加单位），奇字节数末尾填充0变为偶字节数； 累加和超过16bit，产生进位，将进位当作高16bit，其他数为低16bit，进行相加； 循环步骤2，直到没有进位产生为止，得到sum值 累加和取反得到校验和，即checksum值，存入数据的checksum字段即可。 [!important]\nCheckSum取反主要原理是：\n==原码+反码+1 = 0==\n栗子 八位保存累加和：\n需要发送数据(8bit 2进制)： 10101001 00111001 00001010\n奇字节补0:10101001 00111001 00001010 00000000 10101001 + 00111001 + 00001010 + 00000000 = 11101100(sum值) ~11101100 = 00010011(checksum值) 所以发送的数据就是： 10101001 00111001 00001010 00010011 接收方接收到的数据是： 10101001 00111001 00001010 00010011 10101001 + 00111001 + 00001010 + 00010011 = 11111111(sum值) ~11111111 = 00000000(结果是0， …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/",
    "title": "",
    
    "content": " 测试指标 测试覆盖率 测试覆盖率(（Test Coverage)是测试用例执行时，系统或代码的覆盖程度。它反映了测试是否覆盖了系统的各个方面，包括功能、代码、路径等。\n不同的测试覆盖率指标提供了对测试的不同层面的检查。一般来说：\n语句覆盖率和分支覆盖率是最常用的基础覆盖率，适用于大多数场景。 路径覆盖率和多条件覆盖率适用于复杂的系统，特别是那些有大量分支和复杂条件的系统。 函数覆盖率、调用路径覆盖率等适用于验证系统中的函数调用和路径的完整性。 功能覆盖率 $$\r功能覆盖率 = （已执行的功能点数量 / 总功能点数量）× 100\\%\r$$ 应用场景：\n适用于验证系统是否实现了所有设计或需求文档中的功能。 适合功能测试，确保所有业务流程、用例和需求都已测试。 语句覆盖率 $$\r语句覆盖率 = （已执行的语句数量 / 总语句数量）× 100\\%\r$$ 应用场景：\n适用于测试代码是否执行过每一行，特别是代码逻辑简单且不复杂时。 分支覆盖率 $$\r分支覆盖率 = （已执行的分支数量 / 总分支数量）× 100\\%\r$$ 应用场景：\n适用于检查条件语句（如if、else）的所有可能结果是否都被覆盖。 比语句覆盖率更精细，因为它考虑了条件的所有可能分支。 条件覆盖率 $$\r条件覆盖率 = （已执行的条件数量 / 总条件数量）× 100\\%\r$$ 应用场景：\n适用于对单个条件进行验证，特别是在复合条件语句中，确保每个条件都独立地进行了验证。 路径覆盖率 $$\r路径覆盖率 = （已执行的路径数量 / 总路径数量）× 100\\%\r$$ 应用场景：\n适用于对复杂的程序进行全面的验证，尤其是涉及多分支、循环的代码块。 条件-决策覆盖率 $$\r条件-决策覆盖率 = （已执行的条件-决策点数量 / 总条件-决策点数量）× 100\\%\r$$ 应用场景：\n适用于确保测试用例对条件和决策的覆盖面都全面。 循环覆盖率 循环覆盖率（Loop Coverage）是指测试用例覆盖程序中的循环结构的程度。它确保每个循环的进入、退出及重复执行都被测试过。\n$$\r循环覆盖率 = （已执行的循环次数 / 总循环次数）× 100\\%\r$$ 应用场景：\n适用于存在循环结构的程序（如for、while循环），确保循环条件和边界情况都得到充分验证。 函数覆盖率 $$\r函数覆盖率 = （已执行的函数数量 / 总函数数量）× 100\\%\r$$ 应用场景：\n适用于对软件系统中的函数或方法进行验证，确保每个函数都有被调用到。 调用路径覆盖率 $$\r调用路径覆盖率 = （已调用的函数路径数量 / 总函数路径数量）× 100\\%\r$$ 应用场景：\n适用于复杂系统中函数之间的调用关系验证，确保系统的功能通过各个函数调用得到了执行。 多条件覆盖率 $$\r多条件覆盖率 = （已测试的条件组合数量 / 总条件组合数量）× 100\\%\r$$ 应用场景：\n适用于具有多个条件组合的系统，确保每种组合的可能性都被验证。 缺陷密度 缺陷密度（Defect Density）指的是每千行代码（KLOC）中发现的缺陷数量。它是衡量软件质量的一个重要指标。评估标准为：\n缺陷密度越高，说明软件质量越差，可能存在很多隐藏的缺陷。 一般来说，在不同阶段的缺陷密度有所不同，开发阶段缺陷密度较高，测试阶段和发布前缺陷密度较低。 通过标准：\n一般来说，低于0.5个缺陷/千行代码（KLOC）为良好的质量标准，但具体要求会根据项目的复杂性和行业标准有所不同。 缺陷发现率 缺陷发现率（Defect Discovery Rate）是指每单位时间内（如每日、每周、每月）发现的缺陷数量。它能够帮助评估测试进度和测试的效率。评估标准为：\n高缺陷发现率可能意味着测试阶段的有效性较高。 如果缺陷发现率急剧下降，可能意味着大部分缺陷已经被发现，或者测试没有覆盖到关键的功能区域。 通过标准：\n随着测试进度的推进，缺陷发现率应该逐渐降低，测试结束前如果没有新的严重缺陷被发现，说明测试已经接近完成。 缺陷修复率 缺陷修复率（Defect Fix Rate）是指在发现缺陷后，修复缺陷的速度和效率。它可以反映开发团队对缺陷的响应速度和处理能力。评估标准为：\n高修复率表示开发团队对缺陷的及时响应和高效修复。 修复率过低可能表明问题没有及时得到处理，或者缺陷修复的质量不高。 通过标准：\n理想的缺陷修复率应该接近100%，即所有发现的缺陷都应得到修复，尤其是高优先级缺陷。 测试执行率 测试执行率（Test Execution Rate）是指在给定时间内，实际执行的测试用例数量与计划测试用例总数之间的比例。评估标准为：\n高执行率表示测试团队按照计划执行测试，测试进度顺利。 低执行率可能意味着测试工作滞后，测试覆盖不全面。 通过标准：\n测试执行率通常期望达到100%，即所有计划的测试用例都应在测试阶段执行完毕。 测试缺陷重开率 缺陷重开率（Defect Reopen Rate）是指已经标记为解决的缺陷，在后续的测试中再次被发现或被测试人员重新标记为有效缺陷的比例。评估标准为：\n如果缺陷重开率较高，表明缺陷修复不彻底，或者修复后的回归测试没有有效执行。 较低的重开率通常意味着缺陷修复彻底，解决方案有效。 通过标准：\n理想情况下，缺陷重开率应尽可能低。如果重开率较高，可能需要对缺陷修复过程进行审查，并提高修复质量。 回归测试通过率 回归测试通过率（Regression Test Pass Rate）是指回归测试过程中通过的测试用例占总回归测试用例的比例。评估标准为：\n高回归测试通过率表明系统的修改不会破坏现有的功能，系统在修复或新增功能后仍然稳定。 如果回归测试通过率较低，可能意味着修改引入了新的缺陷或不兼容的改变。 通过标准：\n一般来说，回归测试通过率应接近100%，特别是在关键功能区域。 测试效率 测试效率（Test Efficiency）是指测试用例执行中发现缺陷的比例。它帮助评估测试用例设计和执行的质量。评估标准为：\n高测试效率表示测试用例设计得当，能够有效地找到软件中的缺陷。 低测试效率可能意味着测试用例不够全面，或测试覆盖不到关键路径。 通过标准：\n理想情况下，测试效率应较高，至少达到20%-30%，即每执行3-5个测试用例，能发现1个缺陷。 用户验收测试（UAT）通过率 定义：用户验收测试通过率是指用户验收测试过程中，符合用户需求的测试用例通过的比例。评估标准为：\n高通过率意味着软件满足用户的预期需求和业务需求。 低通过率可能表明软件与用户需求存在较大差距。 通过标准：\n用户验收测试通过率通常期望达到100%，即系统完全符合用户的需求。 测试方法 黑盒测试 定义：不关注内部代码，只测试功能。 方法： 等价类划分：将输入数据分为有效和无效类。 边界值分析：测试输入范围的边界值。 决策表测试：基于条件组合设计测试用例。 状态转换测试：测试系统在不同状态下的行为。 用例测试：根据用户场景设计测试。 白盒测试 定义：基于代码内部结构设计测试。 方法： 语句覆盖：确保每条语句至少执行一次。 分支覆盖：确保每个分支至少执行一次。 路径覆盖：测试所有可能的执行路径。 条件覆盖：确保每个条件的所有可能结果都被测试。 灰盒测试 定义：结合黑盒和白盒测试，部分了解内部结构。 方法： 集成测试：测试模块间的交互。 回归测试：确保新代码不影响现有功能。 手动测试 定义：人工执行测试用例。 方法： 探索性测试：无预设用例，自由探索。 用户验收测试：由最终用户验证系统是否符合需求。 自动化测试 定义：使用工具或脚本自动执行测试。 方法： 单元测试：测试单个代码单元。 集成测试：测试多个模块的交互。 性能测试：评估系统性能。 负载测试：测试系统在高负载下的表现。 压力测试：测试系统在极限条件下的表现。 性能测试 定义：评估系统在不同条件下的性能。 方法： 负载测试：模拟多用户或高数据量。 压力测试：测试系统在极限条件下的表现。 容量测试：确定系统能处理的最大负载。 安全测试 定义：评估系统的安全性。 方法： 漏洞扫描：查找已知漏洞。 渗透测试：模拟攻击测试系统防护。 安全代码审查：检查代码中的安全漏洞。 兼容性测试 定义：测试系统在不同环境下的兼容性。 方法： 跨浏览器测试：测试不同浏览器的兼容性。 跨平台测试：测试不同操作系统或设备的兼容性。 可用性测试 定义：评估系统的用户体验。 方法： 用户测试：让真实用户使用并提供反馈。 A/B测试：比较不同设计或功能的效果。 回归测试 定义：确保新代码不影响现有功能。 方法： 自动化回归测试：使用自动化工具执行回归测试。 手动回归测试：人工执行回归测试。 测试用例的设计方法 等价类划分法 等价类划分是一种通过将输入数据划分为不同的等价类来减少测试用例数量的方法。每个等价类中的数据被认为是等价的，即他们在程序中会被系统地处理为相同的方式。\n主要步骤为：\n输入划分：根据输入数据的特性，划分出有效等价类和无效等价类。 有效等价类：程序应该正常处理的输入范围。 无效等价类：程序应该拒绝或抛出错误的输入范围。 测试用例选择：从每个等价类中选择一个代表性测试用例。 适用场景：\n当输入数据范围很大时，等价类划分帮助测试者选择具有代表性的测试数据，避免不必要的重复测试。 边界值分析法 边界值分析法（Boundary Value Analysis）是等价类划分的一个扩展，着重于测试输入数据的边界条件，因为边界值往往是程序出错的地方。\n主要步骤为：\n对于每个等价类，选取边界值作为测试用例（包括边界值的上限和下限）。 对于无效等价类，也应该测试边界值附近的数据。 适用场景：\n特别适用于存在明显边界的输入数据，例如数组的索引、数字范围、日期等。 决策表测试法 决策表测试法（Decision Table Testing）通过构建决策表来表达输入条件与对应行为之间的关系。它用于描述系统在不同输入条件组合下的行为，帮助识别所有的逻辑路径。\n主要步骤：\n列出所有输入条件，并考虑每种输入条件可能的状态（如\u0026quot;真\u0026quot;或\u0026quot;假\u0026quot;、\u0026ldquo;开\u0026quot;或\u0026quot;关\u0026rdquo;）。 通过决策表排列条件组合，并标明每个组合下的预期输出。 基于决策表设计测试用例。 适用场景：\n适用于复杂的逻辑条件，如多条件决策，尤其当输入条件的组合多且复杂时。 状态转换测试法 状态转换测试法（State Transition Testing）用于测试系统在不同状态下的行为。系统会根据不同的输入从一个状态转移到另一个状态，因此需要根据状态转换图来设计测试用例。\n主要步骤：\n绘制系统的状态转换图，列出所有可能的状态及其之间的转换。 设计测试用例以覆盖状态转换过程，包括合法的状态转换和非法的状态转换。 适用场景：\n适用于具有多种状态（如状态机系统、用户登录状态、订单处理等）的系统。 因果图法 因果图法（Cause-Effect Graphing）是基于逻辑关系的测试用例设计方法。通过因果图表示输入条件与输出结果之间的因果关系，进而构建测试用例。\n主要步骤：\n绘制因果图，列出系统的输入条件及其导致的输出结果。 从因果图中提取最小的有效测试用例集合。 将因果图转换为决策表，进行具体的测试设计。 适用场景：\n适用于复杂的条件与结果之间存在因果关系的系统，尤其是需要通过多个输入条件组合来触发某个输出的场景。 错误推测法 错误推测法（Error Guessing）是基于测试人员的经验，通过预测系统可能出现错误的地方来设计测试用例。这种方法主要依赖于测试人员对系统的理解和直觉。\n主要步骤：\n根据历史缺陷、系统复杂性或对系统的熟悉，推测可能的缺陷区域。 基于推测设计测试用例，重点关注可能的错误点。 适用场景：\n适用于经验丰富的测试人员，能够基于对系统的理解和过往经验，推测出潜在的错误区域。 组合测试法 组合测试法（Combinatorial Testing）通过测试输入条件的不同组合来找出可能的缺陷。这种方法适用于输入条件之间存在复杂的交互关系的系统。\n主要步骤：\n确定测试的输入条件和它们的取值范围。 使用数学模型（如覆盖每对条件组合的二阶组合、三阶组合）来设计最小化的测试用例集，确保覆盖所有可能的条件组合。 适用场景：\n适用于系统中存在多个输入条件且条件之间有复杂交互关系的情况。 随机测试法 随机测试法（Random Testing）通过随机选择输入数据来设计测试用例。这种方法没有固定规则，完全依赖于随机选择的输入。\n主要步骤：\n随机选择输入数据，并使用这些数据作为测试用例。 测试通过随机选择的输入数据来验证系统是否能处理各种未预见的情况。 适用场景：\n适用于快速探索系统，或者没有明确需求和设计文档的系统。 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/",
    "title": "",
    
    "content": " 参考链接 C语言 | 嵌入式C语言编程规范_函数名开头加uc-CSDN博客\n[!tip]\n以下文件排版将会按照自顶向下的方式进行编排，==文件夹 \u0026amp;gt; 文件名 \u0026amp;gt; 排版 \u0026amp;gt; 函数 \u0026amp;gt; 变量==\n文件架构 缩写 该项目文件树参考AUTOSAR结构，为了便于理解，此处展示部分缩写的全称：\n缩写 全称 描述 AUTOSAR AUTomotive Open System ARchitecture 汽车开放系统架构，是汽车软件开发的标准框架。 ASW Application Software 应用软件，主要负责实现特定功能的业务逻辑。 BSW Basic Software 基础软件，负责底层硬件控制和通用服务的实现。 BSP Board Support Package 板级支持包，包含硬件初始化、驱动和相关工具。 HAL Hardware Abstraction Layer 硬件抽象层，提供对硬件的抽象访问接口。 MCAL Microcontroller Abstraction Layer 微控制器抽象层，提供对芯片外设的直接访问接口。 RTE Run-Time Environment 运行时环境，负责 ASW 与 BSW 的通信管理。 UDS Unified Diagnostic Services 统一诊断服务协议（ISO 14229），用于 ECU 的诊断通信。 Dcm Diagnostic Communication Manager 诊断通信管理模块，实现 UDS 服务的解析和处理。 Dem Diagnostic Event Manager 诊断事件管理模块，负责故障码存储和管理。 PduR Protocol Data Unit Router 协议数据单元路由模块，负责数据路由。 CanTp CAN Transport Protocol CAN 传输协议模块，用于实现 UDS 消息的传输。 NvM Non-Volatile Memory Manager 非易失性内存管理模块，负责数据的持久化存储。 SoAd Socket Adapter 套接字适配器，用于实现基于 TCP/IP 的通信协议（如 DoIP）。 ECU Electronic Control Unit 电子控制单元，是汽车的嵌入式控制器。 GPIO General Purpose …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/",
    "title": "",
    
    "content": " 概述 计算机基本工作原理 冯诺依曼结构 硬件模型基本结构\n模型中包含以下四个部分\n用来存放指令和数据的主存储器，简称==主存或内存==； 用来进行算术逻辑运算的部件，即算术逻辑部件(Arithmetic Logic Unit,简称==ALU==),在ALU操作控制 信号ALUop的控制下，ALU可以对输人端A和B进行不同的运算，得到结果F; 用于自动逐条取出指令并进行译码的部件，即控制部件(Control Unit,简称CU),也称==控制器==； 用来和用户交互的==输入设备和输出设备==。 CPU内部不同的组件\n为了临时存放从主存取来的数据或运算的结果，还需要若干通用寄存器(General Purpose Register)组成通用寄存器组(==GPRs==)，ALU两个输入端A和B的数据来自通用寄存器； ALU运算的结果会产生标志信息，例如，结果是否为0（零标志ZF)、是否为负数（符号标志SF)等，这些标志信息需要记录在专门的==标志寄存器==中； 从主存取来的指令需要临时保存在指令寄存器(Instruction Register,简称==IR==)中； CPU为了自动按序读取主存中的指令，还需要有一个程序计数器(Program Counter,简称==PC==),在执行当前指令过程中，自动 计算出下一条指令的地址并送到PC中保存。 通常把控制部件、运算部件和各类寄存器互连组成的电路称为中央处理器(Central Processing Unit,简称CPU),简称处理器。 CPU读取数据过程\nCPU需要从通用寄存器中取数据到ALU运算，或把ALU运算的结果保存到通用寄存器中，因此，需要给每个通用寄存器编号；\n同样，主存中每个单元也需要编号，称为主存单元地址，简称主存地址。\n通用寄存器和主存都属于存储部件，通常，计算机中的存储部件从0开始编号，例如，4个通用寄存器编号分别为0 ~ 3；16个主存单元编号分别为0 ~ 15。\nCPU为了从主存取指令和存取数据，需要通过传输介质与主存相连，通常把连接不同部件进行信息传输的介质称为==总线==，其中，包含了用于传输地址信息、数据信息和控制信息的地址线、数据线和控制线。\nCPU访问主存时，需先将主存地址、读/写命令分别送到总线的地址线、控制线，然后通过数据线发送或接收数据。CPU送到地址线的主存地址应先存放在主存地址寄 …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
    "title": "",
    
    "content": " 参考链接 这些嵌入式知识助 你秋招，也助你进阶 (qq.com)\nAUTOSAR架构 AUTOSAR（Automotive Open System Architecture）是一个用于开发汽车电子系统的软件架构标准。它通过标准化的架构提高了软件的可重用性和可移植性，减少了开发时间和成本。以下是AUTOSAR架构的详细描述：\nAUTOSAR架构概述 AUTOSAR架构由多个层次组成，包括应用软件层（Application Layer）、运行时环境（Runtime Environment, RTE）和基础软件层（Basic Software, BSW）。这些层次共同工作，提供完整的汽车电子系统解决方案。\nAUTOSAR层次结构 Application Layer（应用层，ASW）\n包含所有的应用程序组件，这些组件定义了具体的功能，如传感器数据处理、控制算法等。 应用组件通过接口与RTE进行通信，而不是直接与硬件交互。 Runtime Environment (RTE)（运行时环境）\n作为应用层和基础软件层之间的抽象层，提供标准化的接口。 管理应用组件之间以及应用组件与基础软件之间的通信。 确保组件的独立性，使得应用软件能够在不同的硬件平台上运行。 Basic Software (BSW)（基础软件层）\n包含所有的基础服务和驱动程序，为应用软件提供硬件无关的标准化服务。 BSW进一步划分为四个主要部分： Microcontroller Abstraction Layer (MCAL)（微控制器抽象层）：提供对微控制器和外设的抽象接口。 ECU Abstraction Layer（ECU抽象层）：实现ECU级别的硬件抽象，提供对外围设备的访问。 Service Layer（服务层）：提供系统服务，如操作系统、存储管理、诊断服务等。 Complex Device Drivers（复杂设备驱动）：处理复杂的硬件设备，不适合通过MCAL和ECU抽象层实现。 AUTOSAR架构图示 --------------------------------- | Application Layer | | (ASW) | --------------------------------- | Runtime Environment (RTE) | …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/",
    "title": "",
    
    "content": " LD LD 文件是 GNU 工具链（如 GCC）使用的链接器脚本，用于指定如何将程序的各个部分（如代码段、数据段等）放置到目标设备的内存中。LD 脚本的语法非常灵活，支持详细的内存区域分配、段定义以及符号管理。\n基本结构 LD 链接脚本主要由以下几部分组成：\n全局声明和变量：设置内存区域和段的分配。 段定义（SECTIONS）：定义程序的各个段（如 .text, .data, .bss 等）在内存中的位置。 符号管理：可以设置一些符号（如 __start、__end）的地址。 内存区域定义 使用 MEMORY 关键字来定义目标设备的内存区域。每个内存区域指定起始地址（ORIGIN）和长度（LENGTH）。\nMEMORY { FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 1M RAM (rw) : ORIGIN = 0x20000000, LENGTH = 128K } FLASH 区域指定为可读 (r) 和可执行 (x)。 RAM 区域指定为可读 (r) 和可写 (w)。 段定义 SECTIONS 用来定义程序的各个段及其如何映射到内存中。每个段由其名称（如 .text、.data 等）定义，并可以指定要放置的内存区域。\nSECTIONS { .text : { *(.text) // 所有 .text 段的内容 } \u0026amp;gt; FLASH // 放置到 FLASH 区域 .data : { *(.data) // 所有 .data 段的内容 } \u0026amp;gt; RAM // 放置到 RAM 区域 .bss : { *(.bss) // 所有 .bss 段的内容 } \u0026amp;gt; RAM // 放置到 RAM 区域 .stack : { *(.stack) // 堆栈区域 } \u0026amp;gt; RAM // 放置到 RAM 区域 } *() 用于包含所有具有相应段名的输入部分。例如，*(.text) 包含所有 .text 段的内容。 \u0026amp;gt; MEMORY_REGION 用于将段放置到指定的内存区域。 特殊符号定义 可以在链接器脚本中定义特殊符号，来标记某些特定的位置（如段的开始和结束）。\nSECTIONS { .text : { __text_start = .; // 定义一个符号，表示 .text 段的开始 *(.text) …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E6%A0%91%E7%BB%93%E6%9E%84/",
    "title": "",
    
    "content": " 缩写 该项目文件树参考AUTOSAR结构，所以为了便于理解，此处展示部分缩写的全称：\n缩写 全称 描述 AUTOSAR AUTomotive Open System ARchitecture 汽车开放系统架构，是汽车软件开发的标准框架。 ASW Application Software 应用软件，主要负责实现特定功能的业务逻辑。 BSW Basic Software 基础软件，负责底层硬件控制和通用服务的实现。 BSP Board Support Package 板级支持包，包含硬件初始化、驱动和相关工具。 HAL Hardware Abstraction Layer 硬件抽象层，提供对硬件的抽象访问接口。 MCAL Microcontroller Abstraction Layer 微控制器抽象层，提供对芯片外设的直接访问接口。 RTE Run-Time Environment 运行时环境，负责 ASW 与 BSW 的通信管理。 UDS Unified Diagnostic Services 统一诊断服务协议（ISO 14229），用于 ECU 的诊断通信。 Dcm Diagnostic Communication Manager 诊断通信管理模块，实现 UDS 服务的解析和处理。 Dem Diagnostic Event Manager 诊断事件管理模块，负责故障码存储和管理。 PduR Protocol Data Unit Router 协议数据单元路由模块，负责数据路由。 CanTp CAN Transport Protocol CAN 传输协议模块，用于实现 UDS 消息的传输。 NvM Non-Volatile Memory Manager 非易失性内存管理模块，负责数据的持久化存储。 SoAd Socket Adapter 套接字适配器，用于实现基于 TCP/IP 的通信协议（如 DoIP）。 ECU Electronic Control Unit 电子控制单元，是汽车的嵌入式控制器。 GPIO General Purpose Input/Output 通用输入输出，硬件外设的一种。 UART Universal Asynchronous Receiver-Transmitter 通用异步收发器，用于串行通信。 SPI Serial Peripheral Interface 串行外设接口，用于高性能串行通信。 I2C Inter-Integrated Circuit 一种常用的两线串行通信协议。 CAN Controller Area Network 控制器局域网，是汽车通信总线的一种。 FlexRay Flexible Ray 一种高速汽车通信协议，用于安全关键应用。 LIN Local Interconnect Network 局域互连网络，低成本汽车通信协议。 DoIP Diagnostics over Internet Protocol 基于 IP 协议的诊断通信。 OS Operating System 操作系统，提供任务调度和资源管理功能。 SWC Software Component 软件组件，用于实现应用逻辑，是 ASW 层的核心构成模块。 概览 ├─.vscode ├─ASW\t此处存放与硬件平台无关代码 ├─BSW\t存放与硬件相关代码，所以子文件夹需要区分不同芯片型号 ├─BOOT\t存放BOOT相关代码 ├─Documents\t存放项目相关的文档，为了方便使用，最好将使用的芯片的手册放于此处 ├─OS\t存放和系统相关的，如文件系统、操作系统、调度系统等等 ├─Output\t存放输出文件，请在设置Keil和IAR等软件时，选用输出到此文件夹，方便管理，并且增强Project中的整洁性 └─Project\t存放和工程相关的文件树，如KEIL、IAR、SOURCEINSIGHT、TSMATSER、CANoe、JFLASH，与项目相关的工程请放置此处 [!important]\n不知道要将代码放在哪个文件夹中需要参考以下准则：\n与硬件无关的请存放于ASW，也就是逻辑相关 与硬件有关的请存放于BSW，也就是对接硬件平台 OS中存放系统相关，如文件系统、操作系统、调度系统 BOOT中存放和BOOT相关的文件，采用的协议文件，如UDS、OSI [!note]\n为了保持风格的一致性，高两级的文件夹请使用开头大写（ASW、OS、User、Components等），再低级的文件夹就使用小写（inc、src、cfg等）\nASW ├─.vscode ├─ASW\t此处存放与硬件平台无关代码 │ ├─SWC\t此处存放APP相关组件代码，如门窗控制器组件等等 │ │ └─btdm\t此级文件夹下的文件树可以按照自己的喜好存放，如可以将c和h文件放在一起，也可按照不同的文件后缀对文件树进行构建 │ │ ├─inc\t存放头文件 │ │ ├─lib\t存放lib库文件 │ │ └─src\t存放c文件 │ │ └─cfg\t存放cfg文件 │ ├─Scripts\t存放脚本相关文件，如sct、icf、bat、py，和工程相关的脚本文件请都放至此处。在Keil中如果使用可视化宏文件请放置此处 │ ├─User\t一般用于存放main函数和相关app操作函数，一般来说main函数尽量不要有太多的内容，使用函数调用，方便在此基础上修改 │ └─Utils\t存放工具文件，如delay、RTT、coreMark等工具。 [!note]\n注意，ASW中存放和硬件无关的代码，所以在写其中的代码，我们应该要尽量减少和硬件有关的代码，使用抽象代码，如使用定死的函数名访问，我们并不需要知道它下面是怎么实现的，我们只需要调用。（使用定死的函数名方便进行抽象）\n[!important]\n‼‼‼在ASW中写代码，一定要有抽象的概念‼‼‼\n例如SWC是组件的意思，也就意味着，当你写好一个组件，那么我下次使用别的平台的时候可以直接调用你的组件，而不需要再修改很多东西，如定义一个宏开关来控制。\n对于一个组件来说，我只需要知道你的组件的输入和输出即可，所以其中的代码尽量写的抽象，减少重复造轮子。\nBSW ├─BSW\t存放与硬件相关代码，所以需要区分不同芯片型号 │ ├─Bsp\t存放供应商和用户的接口函数 │ │ └─FR3032D\t注意，这里需要定义到芯片的具体型号 │ │ ├─inc │ │ └─src │ ├─Cmsis\t这里存放和芯片内核文件，如core_cm3.h、cmsis_compile.h等等类似文件 │ │ └─FR3032D │ ├─Diagnostics\t这里存放诊断相关文件，如UDS │ │ └─UDS │ ├─Drivers\t这里存放驱动文件 │ │ └─FR3032D │ └─StartUp\t这里存放启动文件，如startUp.s等文件 │ └─FR3032D [!tip]\n需要考虑的是，是否要增加芯片厂商的文件夹，如ZX/FR3032D，如果要制定芯片厂商，请和plm等保持一致的缩写，如ZX代表智芯\nBOOT ├─BOOT │ └───BootLoader\t存放Boot相关的代码，如控制启动流程等 │ ├─inc │ └─src\tDocuments ├─Documents\t存放和项目相关的手册、点检表、变更履历表，如果要存放过多的文件，请使用文件夹分类，便于查阅 │ └─FR3032D\tOS ├─OS\t│ ├─FlashDB\t文件系统 │ │ ├─inc │ │ └─src │ └─FreeRTOS\t操作系统 │ ├─inc │ └─src Output ├─Output │ ├─Listings\t存放链接文件和映射文件，注意该文件夹是软件生成的，在Keil或IAR中设置即可 │ ├─Objects\t存放中间文件，如o文件、obj文件，该文件夹也是软件自动生成的，需要配置 [!note]\n请务必在工程中设置output和listing以保证项目树的整洁性\nProject └─Project ├─KEIL │ └─RTE │ └─_blueTooth ├─SOURCEINSIGHT │ └─blueTooth.si4project │ ├─Backup │ └─cache │ └─parse └─VSCODE [!important]\n和项目相关的工程请存放至此，我们常用的工程有：\nKeil IAR SourceInsight Vscode TSMaster Canoe ZLG JFLash QAC Tessy [!note]\nQAC和Tessy的测试输出报告请不要放置Document中，需要存放在Project下的相关文件夹中\nReadMe ReadMe文件中用来存放和项目相关教程，如Flash、Ram分布，如何使用函数，当使用的时候需要修改哪些等等。\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/aspice/aspice/",
    "title": "",
    
    "content": " 概述 ASPICE（Automotive SPICE）是一种用于汽车行业中软件开发过程改进和能力评定的框架，其主要目的是通过规范化的流程和评估体系来提升软件质量。根据不同的证据，ASPICE可以分为多个部分或等级，每个部分或等级都有其特定的功能和作用。\nASPICE的组成部分 过程参考模型（PRM）：\n过程参考模型是ASPICE的核心部分，它定义了软件开发过程中需要遵循的标准流程和实践。这些流程包括需求分析、设计、开发、测试等各个阶段，旨在确保软件开发的规范性和有效性。 过程评估模型（PAM）：\n过程评估模型用于评估企业在软件开发过程中的能力水平。它通过一系列的评估指标和量测架构，帮助企业识别改进领域，并提升其软件开发能力。 量测架构：\n量测架构用于量化和监控软件开发过程中的各项活动。通过统计分析和数据收集，企业可以对项目进行实时调整，以确保高质量的交付。 ASPICE的能力等级 ASPICE将软件开发能力分为五个等级，从0级到5级，每个等级代表了企业在软件开发过程中的不同成熟度水平：\n0级（Incomplete）：未完成级，表示企业的软件开发过程不完整，可能无法独立完成产品开发。\n1级（执行级）：已执行级，表示企业能够完成产品开发，但缺乏总结经验、设计规范和管理规范。\n2级（管理级）：已管理级，表示企业能够制定项目计划、监控和调整，确保项目有序进行。\n3级（建立级）：已建立级，表示企业积累了开发与管理经验，能够根据公司过程规范裁剪和执行项目。\n4级（可预测级）：可预测级，表示企业能够通过过程数据的统计分析和预测结果，实时调整项目开发过程，确保高质量的项目交付。\n5级（优化级）：优化级，表示企业能够基于商业目标需求反向调整过程，持续改善和优化过程，实现持续改进。\n功能与作用 过程规范化：ASPICE通过定义标准化的开发流程，帮助企业规范代码开发流程，提高代码质量。 能力评估：通过过程评估模型，企业可以评估自身的软件开发能力，并识别需要改进的领域。 项目管理：ASPICE强调双向追溯性和一致性，确保工作产品之间的引用和链接，支持覆盖率和影响分析。 持续改进：通过量测架构和统计分析，企业可以对项目进行实时调整和优化，确保高质量的交付。 执行流程 系统过程组（SYS） SYS1:需求挖掘\n工作内容：获得利益相关方需求和要求，理解利益相关方期望，达成需求共识，需求变更管理，需求沟通机制\n结果：建立双方持续沟通，定义利益相关方需求，建立变更机制评估需求变更，建立持续监控利益相关方机制，评估能力风险\n交付物：风险管理计划，风险缓解计划，沟通记录，评审记录，变更控制记录，分析报告，利益相关方需求\nSYS2：系统需求分析\n工作内容：定义系统需求，结构化系统需求，分析系统需求，分析需求对运行环境影响，制定验证准则，建立双响可追溯性，保证一致性，沟通\n结果：建立定义的系统需求，分类系统需求，分析系统需求对环境影响，定义实施优先级，根据需要更新系统需求，建立利益相关方需求和系统需求之间的一致性和双向可追溯性，从成本进度和技术影响来评估系统需求，约定系统需求并与所有受影响相关方沟通\n交付物：沟通记录，评审记录，变更控制记录，追溯记录，分析报告，接口需求规范，系统需求规范，验证准则\nSYS3:系统架构设计\n工作内容：开发系统架构设计，分配系统需求，定义系统要素的接口，描述动态行为，评估备选的系统架构，建立双向可追溯性，确保一致性，沟通约定的系统架构设计\n交付物：系统架构设计，沟通记录，评审记录\nSYS4:系统集成与集成测试\n相关内容：制定系统集成策略，制定测试策略，开发测试规范（用例，管理用例），系统集成项，选择测试用例，执行系统集成测试，建立双向可追溯性（测试和需求），总结（测试报告）\n交付物：测试规范，测试计划，系统，沟通记录，评审记录，追溯记录，测试结果\nSYS5:系统合格性测试\n相关内容：制定系统合格性测试策略，开发合格性测试规范，选择测试用例\n结果：制定计划，制定测试规范，选择测试用例，记录结果，\n交付物：测试规范，测试计划，沟通记录，评审记录，追溯记录，测试结果\n软件过程组（SWE） SWE1：软件需求分析（将系统需求转化为软件需求）\n相关内容：定义软件需求（分析哪些参数是标定量，哪些是Signal信号，标定量要写进RAM，随时擦写，不能全局变量），结构化软件需求（软件需求进行分类），分析软件需求（是否能满足需求，有些不能满足的要和客户沟通），对运行环境的影响（与系统的接口，与硬件与底层的接口），制定验证准则，建立双向可追溯性，确保一致性，沟通约定的软件需求\n结果：定义需求和接口，分类底层与应用层需求，软件需求对系统的要求，底层软件需求优先，软件需求变更管理\n输出物：沟通评审记录，变更控制记录，接口需求规范，软件需求规范，验证准则\nSWE2：软件架构设计\n相关内容：开发软件架构，分配软件需求，定义软件要素的接口（硬件要DBC报文），描述动态行为，定义资源消耗目标（RAM,ROM,FLASH,CPU负载等），评估备选架构（建立准则选择，模快化，复用性，可拓展性），建立双向可追溯性，确保一致性，沟通约定软件架构设计\n输出物：软件架构设计，沟通评审记录，追溯记录，接口需求规范（红色字体，蓝色字体，黄色字体，哪些是强制的，哪些是项目定制的）\nSWE3：软件详细设计和单元构建\n相关内容:开发软件详细设计（单元模块），定义软件单元接口（知道输入输出），描述动态行为，评估软件详细设计（设计是否方便，交互是否合理，关键性指标，参数怎么设定，技术是不是复杂，软件是不是有风险），追溯性，一致性，沟通约定的软件详细设计，开发软件单元\n结果:要有软件详细设计，说明书，这个模块干嘛的，输入是什么输出是什么；定义接口，动态行为，生成软件详细设计所定义的软件单元\n输出物:软件详细设计文档，软件单元模块\u0026hellip;..\nSWE4：软件单元验证\n相关内容：制定包括回归策略在内的软件单元验证策略，制定单元验证准则（MAAB,MISRA），执行软件单元静态验证（静态分析，代码评审，写测试用例，编码规范，结构覆盖率等），测试软件单元（根据策略来测试功能），建立一致性，可追溯性，总结沟通结果\n结果：制定包括回归策略在内的单元验证策略，根据策略制定验证准则以适于提供软件单元符合软件详细设计及非功能性软件需求的依据，根据策略和验证准则，验证软件单元并进行结果记录，建立软件单元和验证准则及验证结果之间的一致性和追溯性，总结单元验证结果并与所有受影响相关方沟通\n输出物：测试计划，测试规范，沟通评审记录，追溯记录，测试验证结果，分析报告\nSWE5：软件集成和集成测试（把所有软件模块集成起来再和底层软件集成，底层软件作用就是CAN通信，Signal通信等功能，就是软件和硬件通信）\n相关内容:制定软件集成策略，制定包含回归策略在内的软件集成测试策略，开发软件集成测试规范（单元m/s,km/h接口，资源消耗的问题），集成软件单元和软件项，选择测试用例，执行软件集成测试（测试报告，MIL,SIL），建立一致性可追溯性，总结沟通测试结果\n结果:制定与项目计划，发布计划和软件架构设计相一致的软件集成策略及集成软件项，制定包括软件回归策略在内的软件集成测试策略，以测试软件单元之间和软件项之间的交互，根据软件集成测试策略，开发软件集成测试规范，以适于提供集成的软件项目符合软件架构设计（包括软件单元之间和软件项目之间的接口）的证据，根据集成策略集成软件单元和软件项直至完整的集成软件，根据软件集成测试策略发布计划选择软件集成测试规范中的测试用例，使用选定的测试用例测试集成了的软件项目并记录测试结果，建立软件架构设计要素与软件集成测试规范中的测试用例间的一直性双向可追溯性建立测试用例和测试结果之间的一致性和双向可追溯性，总结软件集成测试结果并与受影响方沟通\n输出物:软件项，集成软件，测试计划，测试规范，沟通评审记录，追溯记录，测试结果，编译清单（测试过程中模型编译成代码，背靠背测试，MathWorks，Target-link dSpace）\nSWE6：软件合格性测试\n相关内容:制定包括回归策略在内的软件合格性测试策略（MIL测试建立各种场景），开发软件合格性测试规范，选择测试用例，测试集成软件，建立双向可追溯性和一致性，总结沟通结果\n结果:制定软件合格性测试策略，根据策略开发软件合格性测试规范，根据测试策略和测试规范选择测试用例，用测试用例进行软件测试记录测试结果，建立软件需求和合格性测试规范中测试用例的一致性和双向可追溯性，测试用例和测试结果之间的双向可追溯和一致性，总结软甲你测试结果\n输出物:测试规范，测试计划，沟通评审记录，追溯记录，测试结果\n相关术语 BP(Basic Practice) 在ASPICE（高级软件过程改进和能力评估）中，BP（Basic Practice，基本实践）是定义了每个过程域所需的具体活动和任务的实践。这些实践旨在确保过程的实施能够达到预期的目标，并提供明确的指导以帮助组织改进其软件开发和管理流程。\n例如，在ASPICE指南中，BP可以包括以下内容：\n问题解决：BP1至BP9涉及制定问题解决策略、识别和记录问题、跟踪问题状态、分析问题趋势等，以确保问题能够被有效管理和解决。\n需求管理：BP用于获取利益相关方的需求和要求，确保需求的一致性和可追溯性。\n设计与验证：BP用于制定详细的设计、定义软件组件的接口、描述动态行为、评估软件设计等，以确保设计的质量和一致性。\n测试与验证：BP用于选择测试用例、执行软件集成测试、确保双向可追溯性等，以保证软件测试的全面性和有效性。\n配置管理：BP用于定义访问权限、识别配置项、创建基线等，以确保配置管理的规范性和一致性。\n项目管理：BP用于定义工作范围、评估项目可行性、确保项目计划的一致性等，以支持项目的顺利实施。\n支持过程组（SUP） SUP.9 SUP.9（问题解决管理）是一个关键的过程，旨在确保项目中出现的问题能够被及时、有效地识别、分析、管理和解决。以下是SUP.9的具体内容和细节：\n问题识别与登记：首先，需要准确记录项目中出现的缺陷、故障、不一致等问题，并为每个问题分配状态以便跟踪。这一步骤确保了问题信息的准确性和完整性。\n问题分析与评估：对问题进行深入分析，确定其成因和影响。这包括调查问题的原因，评估其对其他系统或受影响方的影响，并根据严重性、关键性和紧迫性等因素对问题进行分类。\n授权紧急解决行动：如果问题需要立即解决，则获得授权采取紧急行动。这可能涉及短期的应急措施，以防止问题进一步恶化。\n发出警报通知：当问题可能对其他系统或受影响方产生重大影响时，应发出警报通知相关方。\n启动问题解决：根据问题的分类，采取适当的长期行动来解决问题。这可能包括审查这些行动或发起变更请求，并确保与短期紧急解决行动的一致性和协调性。\n跟踪问题关闭状态：持续跟踪问题的关闭状态，包括所有相关的变更请求，并确保相关利益攸关方接受问题已解决。\n报告问题解决活动的状况：收集和分析问题解决管理数据，识别趋势并启动相关行动。定期向相关利益攸关方报告数据分析结果、识别的趋势和问题解决活动的状况。\n建立问题管理流程和工具：明确定义问题管理流程，包括输入、输出和角色责任，并选择适合的问题管理工具，用于记录、分配、追踪和统计。\n培训相关人员：为项目参与人员提供问题解决管理培训，确保他们了解流程和工具的使用。\nSUP.9.BP的步骤：\nASPICE的SUP.9.BP（基本实践）包括以下内容：\nSUP.9.BP1：制定问题解决管理策略\n制定问题解决管理策略，包括问题解决活动、问题状态模型、警报通知、执行这些活动的责任以及紧急解决策略。定义受影响方的接口并维护该定义。\nSUP.9.BP2：识别和记录问题 每个问题都被唯一识别、描述和记录。为每个问题分配一个状态以方便追踪，并提供支持信息以复现和诊断问题。\nSUP.9.BP3：记录问题状态 根据状态模型，给每个问题分配状态以便于跟踪。\nSUP.9.BP4：诊断问题的原因，确定问题的影响 调查问\n题并确定其原因和影响，以便对问题进行分类并确定适当的行动。如果问题对其他系统或受影响方有较大影响，则需要发出警报通知。\nSUP.9.BP5：授权紧急解决行动\n根据分类采取适当行动来解决问题，包括审查这些行动或发起变更请求。这包括与短期紧急解决方案同步和一致（如果适用）。\nSUP.9.BP6：发出警报通知\n跟踪问题的状态至关闭，包括所有相关的变更请求。相关利益方接受问题的关闭。\nSUP.9.BP7：启动问题的解决 收集和分析问题解决管理数据，识别趋势并采取相关行动。定期向相关利益方报告数据分析结果、识别出的趋势以及问题解决活动的进度。\nSUP.9.BP8：跟踪问题直至关闭\n如果问题需要紧急解决，根据策略获得授权进行立即行动。\nSUP.9.BP9：分析问题趋势\nSUP.10 SUP.10 是 ASPICE 中的一个支持过程，主要用于管理问题的识别、跟踪和解决。其核心目的是在系统和软件开发生命周期中确保所有问题（如缺陷、偏差或风险）被有效管理，并最终得以解决，从而提升产品质量和开发效率。\nSUP.10 的关键任务：\n记录问题：将发现的所有问题（如软件缺陷、需求冲突或集成失败）记录下来，确保没有遗漏。 分类与分配：对问题进行分类（例如严重性、优先级、类型）并分配给合适的团队或责任人。 跟踪状态：持续跟踪问题的生命周期状态，从“新建”到“解决”再到“关闭”。 分析问题：找出问题的根本原因（Root Cause Analysis, RCA），并提出适当的解决方案。 验证解决方案：确保问题的解决方案已经有效实施，并不会引入新的问题。 监控与报告：提供问题状态的监控和统计报告，以便管理层做出决策。 目标：\n确保所有问题都被清晰地记录、妥善解决。 提高开发过程中问题处理的透明度和效率。 通过根本原因分析，减少重复问题发生的可能性。 支持产品质量和项目进度的持续改进。 SUP.10.BP从大方向上分为三步：\nBP1-BP3：问题的发现和初步管理（识别、分类、分配）。 BP4-BP6：问题的深入处理（分析、解决、验证）。 BP7-BP9：问题的闭环管理和改进（关闭、监控、总结）。 SUP.10.BP的详细步骤：\nBP1：问题识别和记录 作用:确保所有在开发过程中发现的问题（如缺陷、偏差）都能被识别并清晰地记录下来。 关键活动： 使用问题管理工具或系统，记录问题的基本信息，包括描述、来源、发生时间等。 确定问题的初始状态，例如“新建”或“待处理”。 输出：已记录的问题列表。 BP2：问题分类和优先级设定 作用：对记录的问题进行分类，并根据其影响程度或紧急性设定优先级，以便合理分配资源。 关键活动： 确定问题的严重性（Critical、Major、Minor 等）。 分类问题类型（需求缺陷、实现问题、性能问题等）。 为问题设定处理优先级（高、中、低）。 输出：具有分类和优先级信息的问题列表。 BP3：问题分配 作用：将每个问题分配给合适的责任人或团队，明确问题的处理者。 关键活动： 确定处理问题所需的技能或权限。 指派责任人，并设定处理时限或预期解决日期。 输出：分配了责任人的问题记录。 BP4：问题分析 作用：深入分析问题的根本原因，评估其对项目的影响，并制定解决方案。 关键活动： 进行根本原因分析（Root Cause Analysis, RCA）。 使用工具和方法（如鱼骨图、5 Whys 等）分析问题。 记录分析结果和建议的解决措施。 输出： 问题分析报告。 提议的解决方案。 BP5：问题解决 作用：根据分析结果实施解决方案，修复问题。 关键活动： 修改设计、代码或文档以解决问题。 确保实施的解决方案符合相关要求。 执行回归测试或验证测试，确认问题已解决。 输出： 修复完成的问题。 更新的文档或交付物。 BP6：问题验证 作用：确认问题的解决方案已经正确实施，并且没有引入新的问题。 关键活动： 针对问题对应的测试用例进行执行。 验证解决方案是否符合问题的初始描述和需求。 记录验证结果。 输出： 验证通过的问题。 验证记录。 BP7：问题关闭 作用：将已验证的问题标记为关闭，结束问题的生命周期。 关键活动： 确保所有相关方（如客户、质量团队）同意问题可以关闭。 在问题管理工具中将状态更新为“关闭”。 归档问题的所有相关记录，作为经验库的一部分。 输出：问题关闭记录。 BP8：问题状态监控 作用：定期监控问题的状态，确保问题的解决过程符合预期。 关键活动： 跟踪问题的生命周期状态（如“新建”、“分析中”、“已解决”、“已关闭”）。 定期生成问题状态的统计报告。 识别未按时解决或处理延迟的问题。 输出： 问题状态报告。 识别到的异常问题。 BP9：问题管理的经验总结 作用：分析已解决的问题，提取经验和教训，用于未来的改进和问题预防。 关键活动： 汇总问题的根本原因和解决方案。 提出改进建议，优化过程。 将经验记录到组织的知识库中。 输出： 改进建议。 更新的知识库。 系统过程组（SYS） SYS.3 输出物：\n系统架构设计方案 系统架构设计计划检查表 系统架构设计 系统架构设计检查表 系统架构设计评估报告 系统架构设计流程检查表 SYS.3的BP过程为：\nSYS.3_BP1: 开发系统架构设计。开发，分析并文档化系统架构设计， 该系统架构设计规范中包括基于系统功能性需求和非功能性需求定义系统架构，系统架构设计的开发通常包括在适当的各层级上分解成元素，并对各元素进行详细说明。\nSYS.3_BP2: 分配系统需求。将SYS.2过程域中定义的系统需求分配给系统架构设计的元素。\nSYS.3_BP3: 描述动态行为，定义系统元素的接口。 识别、分析，开发并文档化每个系统元素之间的接口信息。\n动态行为取决于运动模式，如启动、关机、正常模式、标定和诊断\nSYS.3_BP4: 描述系统元素的静态行为和动态行为。 评估，分析并文档化系统元素之间相互作用的静态行为和动态行为，其中，动态行为取决于运行模式（例如:启动、关机、正常模式、标定和诊断等方面）。\nSYS.3_BP5: 评估，分析备选的系统架构。定义当前系统架构和备选系统架构方案，以及架构设计的评估准则。根据已定义的评估准则，评估备选的系统架构。记录被选定的系统架构的选择理由。其中，评估准则可以包括质量特性（模块性、可维护性、可扩展性、可扩缩性、可靠性、安全（security）可实现性、易用性）和开发-购买-重用分析的结果。\nSYS.3_BP6: 建立双向可追溯性。建立系统需求和系统架构设计的元素之间的双向可追溯性。双向可追溯性覆盖系统需求向系统架构设计的要素的分配。双向可追溯性有助于覆盖率、一致性和影响分析。\nSYS.3_BP7: 确保一致性。确保系统需求和系统架构设计间的一致性。一致性由双向可追溯性支持，并可通过评审记录来证明。\nSYS.3_BP8: 沟通约定的系统架构设计。与所有相关方以及相关的工程师沟通已约定的系统架构设计规范以及对系统架构设计规范针对评审问题进行更新。\n软件过程组（SWE） 软件需求分析（SWE.1） 软件需求分析过程的目的是将系统需求中与软件相关的部分转化为一组软件需求。\n基本实践为：\nSWE.1.BP1：定义软件需求。 使用系统需求和系统架构及其变更来识别软件所需的功能和能力。在软件需求规范中定义功能性和非功能性软件需求。\n输出的成果为：\n定义了系统中分配给软件要素的软件需求及其接口； 根据需要更新了软件需求； 从成本、进度和技术影响来评估软件需求； [!tip]\n影响功能和能力的应用参数是系统需求的一部分。 如果只有软件开发，系统需求和系统架构是指给定的运行环境。在这种情况下，应将利益相关方需求作为识别软件所需功能和能力以及识别影响软件功能和能力的应用参数的基础。 SWE.2.BP2:结构化系统需求。 在软件需求规范中结构化软件需求，例如\n按项目相关集群进行分组； 按项目中逻辑顺序排序； 基于项目相关准则进行分类； 根据利益相关方需要进行优先级排序 输出的成果为：\n对软件需求进行分类，并分析了其正确性和可验证性； 根据需要更新了软件需求； [!tip]\n优先级排序通常包括将软件内容分配给已计划的发布。\nSWE.1.BP3:分析软件需求。 分析已定义的系统需求（包括它们的相互依赖关系），以确保正确性、技术可行性和可验证性，并且支持风险识别。分析对成本、进度和技术的影响。\n输出的成果为：\n对软件需求进行分类，并分析了其正确性和可验证性； 从成本、进度和技术影响来评估软件需求； [!tip]\n对成本和进度的影响分析有助于项目估算的调整。\n针对于软件，还可考虑如下风险：\n不充分的解决方案、测试方案 不完整的开发及测试工具链 非功能需求能否被充分满足 自动生成代码导致测试工作量的负荷影响等 SWE.1.BP4:分析对运行环境的影响。 分析软件需求对系统要素接口及运行环境的影响。 [成果3,7]\n输出的成果为：\n分析了软件需求对运行环境的影响； 从成本、进度和技术影响来评估软件需求； [!tip]\n运行环境是指软件运行所在的系统（例如：硬件、操作系统等）。\nGuideword Deviation Possible Cause Consequences Measures Too often High bus load Non-compliance with the bus spec, calling party sending even if no one listens Communication breakdown, messages get lost 1. Ensure that bus spec is know 2. Ensure that the bus spec is understood 3. Verify through design review Implement specific bus load tests Too rarely Faulty communication Non-compliance with the bus spec, calling party not sending if someone listens Communication breakdown, messages missing 4. See above SWE.1.BP5:制定验证准则。 对每个软件需求指定验证准则，定义定性的和定量的措施用于需求验证。\n输出的成果为：\n对软件需求进行分类，并分析了其正确性和可验证性； 从成本、进度和技术影响来评估软件需求； [!tip]\n验证准则证明了需求可以在约定的约束范围内得到验证，并且通常被用作软件测试用例开发或其他证明符合系统需求的验证措施的输入。 测试不能覆盖的验证由SUP.2覆盖。 SWE.1.BP6:建立双向可追溯性。 系统需求与软件需求之间的双向可追溯性，建立系统架构设计与软件需求之间的双向追溯性。\n输出的成果为：\n在系统需求与软件需求之间、在系统架构设计与软件需求之间建立了一致性和双向可追溯性； [!tip]\n应通过建立同时满足项目和组织要求的方法来避免冗余。 双向可追溯性有助于覆盖率、 一致性和影响分析。 SWE.1.BP7:确保一致性。 确保系统需求与软件需求之间的一致性，确保系统架构与软件需求之间的一致性。\n输出成果为：\n在系统需求与软件需求之间、在系统架构设计与软件需求之间建立了一致性和双向可追溯性； [!tip]\n一致性由双向可追溯性支持，并可通过评审记录来证明。 如果只有软件开发，系统需求和系统架构是指软件的运行环境。在这种情况下，必须确保利益相关方需求与软件需求之间的一致性和双向可追溯性。 SWE.1.BP8:沟通约定的软件需求。 与所有相关方沟通约定的软件需求及软件需求的更新。\n输出成果为：\n约定了软件需求，并与所有受影响方沟通。 SWE.1.BP之间的关系为：\n成功实施这个过程的结果是：\n定义了系统中分配给软件要素的软件需求及其接口； 对软件需求进行分类，并分析了其正确性和可验证性； 分析了软件需求对运行环境的影响； 定义了软件需求实施的优先级； 根据需要更新了软件需求； 在系统需求与软件需求之间、在系统架构设计与软件需求之间建立了一致性和双向可追溯性； 从成本、进度和技术影响来评估软件需求； 约定了软件需求，并与所有受影响方沟通。 软件架构设计（SWE.2） 软件架构设计过程的目的是：建立软件架构设计，识别将哪些软件需求分配给软件的哪些要素，并依照已定义的准则评估软件架构设计。\nSWE.2是软件架构设计，主要内容有：\n静态架构\n这部分需要定义好软件模块（Component/Element）有哪些，模块间的一个交互关系的定义，主要是一些接口函数的定义，需要定义清楚函数类型（返回值，或者无返回），参数及类型。假如要做一个电压检测的功能，需要读取ADC采集到的值然后再做其他逻辑判断，那么可以定义如下的一个接口交互关系：\n由上图可知，对于电压检测这个功能，我们需要一个读取电压ADC值的接口，所以我们可以将接口定义如下：\nuint16 u16GetADCValue(uint8 ch_id); 由上述定义我们就可以明确，需要一个返回值类型为uint16（必要时可以定义返回值范围），参数为uint8（必要时可以定义入参范围，为软件集成测试定义一个明确的测试范围）的一个接口，这样可以指导软件架构的下游活动，例如详细设计（Detailed Design）和软件集成测试（Software Integration and Integration Test）去实施。\n动态架构\n这部分需要定义模块的动态合作关系，例如一些时序等，还是以上面讲到的电压检测功能为例，可以画出动态架构图如下：\n由上图可以看出MCAL_TASK和VOL_TASK的调用先后关系，需要ADC先处理完得到ADC值，电压检测模块才去调用u16GetADCValue这个接口获取电压值，然后再做进一步的逻辑判断。\n如果有一些状态转换的需求，需要定义一些状态及状态跳转的条件等，例如：\n基本实践为：\nSWE.2.BP1:开发软件软件设计。 开发并文档化软件架构设计，该设计基于软件功能性需求和非功能性需求定义软件要素。\n输出的成果为：\n定义了识别软件要素的软件架构设计； [!tip]\n将软件分解为适当的各层级上的要素，直至软件架构设计的最低层级要素，即详细设计中描述的软件组件。\n例：基于AUTOSAR架构进行开发\nSWE.2.BP2:分配软件需求。 将软件需求分配给软件架构设计的要素。\n输出的成果为：\n将软件需求分配给软件的要素； SWE.2.BP3:定义软件要素的接口。 识别、开发并文档化每个软件要素的接口。\n输出的成果为：\n定义了每个软件要素的接口； SWE.2.BP4:描述动态行为。 评估并文档化软件要素之间的时许和动态交互，以满足系统所需的动态行为。\n输出的成果为：\n定义了软件要素的动态行为和资源消耗目标； [!tip]\n动态行为取决于运行模式（例如：启动、关机、正常模式、标定、诊断等）、进程及进程间相互通信、任务、线程、时间片、中断等。 在评估动态行为时，宜考虑目标平台和目标对象的潜在负载。 SWE.2.BP5:定义资源消耗目标。 在适当的层级上确定并文档化软件架构设计的所有相关要素的资源消耗目标。\n输出的成果为：\n定义了软件要素的动态行为和资源消耗目标； [!tip]\n资源消耗通常取决于资源，如：内存（ROM、 RAM、外部/内部EEPROM或数据闪存）、 CPU负载等。\nSWE.2.BP6:评估备选的软件架构。 定义架构的评估准则。根据定义的准则评估备选的软件架构，记录被选定的软件架构的选择理由。\n输出的成果为：\n定义了识别软件要素的软件架构设计； 将软件需求分配给软件的要素； 定义了每个软件要素的接口； 定义了软件要素的动态行为和资源消耗目标； 建立了软件需求和软件架构设计之间的一致性和双向可追溯性； [!tip]\n评估准则可包括质量特性（模块性、可维护性、可扩展性、可扩缩性、可靠性、安全（security）可实现性和易用性）以及开发-购买-重用分析的结果。\nSWE.2.BP7:建立双向可追溯性。 建立软件需求和软件架构设计的要素之间的双向可追溯性。\n输出的成果为：\n建立了软件需求和软件架构设计之间的一致性和双向可追溯性； [!tip]\n双向可追溯性覆盖软件需求向软件架构设计的要素的分配。 双向可追溯性有助于覆盖率、 一致性和影响分析。 SWE.2.BP8:确保一致性。 确保软件需求和软件架构设计之间的一致性。\n输出的成果为：\n定义了识别软件要素的软件架构设计； 将软件需求分配给软件的要素； 建立了软件需求和软件架构设计之间的一致性和双向可追溯性； 约定了软件架构设计，并与所有受影响方沟通 [!tip]\n一致性由双向可追溯性支持，并可通过评审记录来证明。\nSWE.2.BP9:沟通约定的软件架构设计。 与所有相关方沟通已约定的软件架构设计及对软件架构设计的更新。\n输出的成果为：\n约定了软件架构设计，并与所有受影响方沟通 SWE.2.BP之间的关系：\n成功实施这个过程的结果是：\n定义了识别软件要素的软件架构设计； 将软件需求分配给软件的要素； 定义了每个软件要素的接口； 定义了软件要素的动态行为和资源消耗目标； 建立了软件需求和软件架构设计之间的一致性和双向可追溯性； 约定了软件架构设计，并与所有受影响方沟通 软件详细设计与单元构建（SWE.3） 软件详细设计和单元构建过程的目的是：为软件组件提供经过评估的详细设计，并定义和生成软件单元。\n基本实践为：\nSWE.3.BP1:开发软件详细设计。 开发软件架构设计中定义的各软件组件的详细设计，该设计基于软件功能性需求和非功能性需求定义软件单元。\n输出成果为\n开发了描述软件单元的详细设计； SWE.3.BP2:定义软件单元的接口。 识别、定义和文档化各软件单元的接口。\n输出成果为：\n定义了各软件单元的接口； SWE.3.BP3:描述动态行为。 评估并文档化相关软件单元之间的动态行为和交互。\n输出成果\n定义了软件单元的动态行为； [!tip]\n并非所有的软件单元都有动态行为可描述。\n为了描述一个软件组件在运行时的动态行为, 需要进行行为描述, 例如:\n状态机 时序图 用例图 另外，响应时间需要考虑定义如下:\n任务 线程概念 时间片 中断 接口 SWE.3.BP4:评估软件详细设计。 从互操作性、交互、关键性、技术复杂性、风险和可测试性方面对软件详细设计进行评估。\n输出成果为：\n开发了描述软件单元的详细设计； 定义了各软件单元的接口； 定义了软件单元的动态行为； 建立了软件需求与软件单元之间的一致性和双向可追溯性；建立了软件架构设计与软件详细设计之间的一致性和双向可追溯性；建立了软件详细设计与软件单元之间一致性和双向可追溯性； [!tip]\n评估结果能作为软件单元验证的输入。\nSWE.3.BP5:建立双向可追溯性。 建立软件需求与软件单元之间的双向可追溯性。建立软件架构设计与软件详细设计之间的双向可追溯性。建立软件详细设计与软件单元之间的双向可追溯性。\n输出成果为\n建立了软件需求与软件单元之间的一致性和双向可追溯性；建立了软件架构设计与软件详细设计之间的一致性和双向可追溯性；建立了软件详细设计与软件单元之间一致性和双向可追溯性； [!tip]\n对以上方法进行组合，覆盖项目和组织需要， 避免冗余。 双向可追溯性有助于覆盖率、一致性和影响分析。 SWE.3.BP6:确保一致性。 确保软件需求与软件单元之间的一致性。确保软件架构设计、软件详细设计及软件单元之间的一致性。\n输出成果为：\n建立了软件需求与软件单元之间的一致性和双向可追溯性；建立了软件架构设计与软件详细设计之间的一致性和双向可追溯性；建立了软件详细设计与软件单元之间一致性和双向可追溯性； [!tip]\n一致性由双向可追溯性支持，并可通过评审记录来证明。\n模型：详细设计、单元需要符合建模规范（例MAAB）\n代码：详细设计、单元需要符合编码规范（例MISRA C）\nSWE.3.BP7:沟通约定的软件详细设计。 与所有相关方沟通已约定的软件详细设计及对软件详细设计的更新。\n输出成果为：\n约定了软件详细设计及该设计与软件架构设计的关系，并和所有受影响方沟通； SWE.3.BP8:开发软件单元。 根据软件详细设计，开发并文档化各软件单元的可执行形式。\n输出的成果为：\n生成了软件详细设计所定义的软件单元。 [!tip]\n软件单元不得包含详细设计中未说明的内容，因为这支持可维护性或缺陷分析。\n实践的关联为：\n成功实施这个过程的结果是：\n开发了描述软件单元的详细设计； 定义了各软件单元的接口； 定义了软件单元的动态行为； 建立了软件需求与软件单元之间的一致性和双向可追溯性；建立了软件架构设计与软件详细设计之间的一致性和双向可追溯性；建立了软件详细设计与软件单元之间一致性和双向可追溯性； 约定了软件详细设计及该设计与软件架构设计的关系，并和所有受影响方沟通； 生成了软件详细设计所定义的软件单元。 软件单元验证（SWE.4） 软件单元验证过程的目的是：验证软件单元，以提供软件单元符合软件详细设计和非功能性软件需求的证据。\n类别 SWE4 软件单元验证 SWE5 软件集成和集 成测试 SWE6 软件合 格性测 试 SYS4 系统集成和集 成测试 SYS5 系统合格 性测试 制定策略 √(测试) √(集成+测试) √ (测试) √ (集成+测试) √(测试) 开发测试规格书 √(静态+动态) √ √ √ √ 执行集成 √ √ 选择测试用例 √ √ √ √ √ 执行测试 √(静态+动态) √ √ √ √ 建立追溯一致性 √ √ √ √ √ 总结沟通 √ √ √ √ √ 基本实践为：\nSWE.4.BP1:\n制订包括回归策略在内的软件单元验证策略。 制订软件\n单元验证策略（包括软件单元变更时实施再验证的回归策略）。验\n证策略应定义如何提供软件单元符合软件详细设计和非功能性需求\n的证据。\n[成果1]\n成功实施这个过程的结果是：\n制订了包括回归策略在内的软件单元验证策略，以验证软件单元； 根据软件单元验证策略，制订了软件单元验证准则，以适于提供软件单元符合软件详细设计及非功能性软件需求的证据； 根据软件单元验证策略及软件单元验证准则， 验证了软件单元并记录了结果； 建立了软件单元、验证准则及验证结果之间的双向可追溯性和一致性； 总结了单元验证结果，并与所有受影响方沟通。 SWE.5 SWE.5是软件集成与集成测试，SWE.5的主要目标和成果为：\n目标：\n将软件单元集成到更大的软件项目中，形成完整的集成软件解决方案。 确保集成后的软件组件能够满足软件架构设计的要求，包括模块间的接口和数据流。 通过集成测试验证软件组件的正确性和一致性，提供符合性证据。 成果：\n制定软件集成策略，该策略应与项目计划、发布计划和软件架构设计一致。 建立全面的软件集成测试策略，涵盖回归测试，以评估软件单元和组件之间的交互。 创建符合测试策略的软件集成测试规范，以证明集成后的软件组件与架构设计的一致性。 记录集成测试的结果和日志，确保所有测试活动都有充分的覆盖率。 SWE.5的基本实践（BP）\nSWE.5包含多个基本实践（BP），每个BP都有其特定的目标和要求：\nBP1：制定软件集成验证措施：\n针对软件架构中定义的软件组件及其接口的行为和接口进行验证。 包括技术、进入和退出标准以及通过/失败标准。 BP2：选择测试用例：\n根据软件集成测试策略选择测试用例，确保测试用例具有足够的覆盖率。 测试用例的选择需考虑交付物的使用场景（如测试台、测试轨道或公共道路等）。 BP3：开发软件集成测试规范：\n根据软件集成测试策略开发测试规范，包括针对每个集成软件项的测试用例。 测试规范应能够证明集成后的软件项与架构设计的一致性。 BP4：执行软件集成测试：\n使用选定的测试用例执行软件集成测试，并记录测试结果和日志。 确保所有模块间的接口和数据流符合预期。 BP5：总结和沟通结果：\n总结集成测试的结果，并与所有相关方沟通。 提供详细的测试报告和分析，以支持后续的改进活动。 SWE.6 SWE.6是软件合格性测试，SWE.6的具体内容和目标为：\n过程目标：\n确保集成软件经过测试，以提供符合软件需求的证据。 检查软件是否符合要求，并确定它们是否得到充分满足和正确实施。 基础实践（BP）：\nBP1：制定软件资格测试策略，包括与回归测试策略的一致性。 BP2：选择验证措施，根据选择标准记录验证措施的选择。 BP3：使用选定的验证措施对集成软件进行验证，并记录验证结果。 BP4：确保验证措施与软件需求的一致性，并建立验证结果与验证措施之间的双向可追溯性。 BP5：总结和传达软件资格测试结果，向所有受影响方沟通。 BP6：建立软件需求与软件资格测试规范（包括测试案例）以及测试案例与测试结果之间的一致性和双向可追溯性。 BP7：总结和沟通测试结果，提供必要的信息以便其他方判断结果。 输出工作产品：\n测试规范（Test Specification） 测试计划（Test Plan） 测试用例（Test Cases） 测试结果（Test Results） 沟通记录（Communication Records） 审查记录（Review Records） 可追溯记录（Traceability Records）。 示例 问题：\n假设现在车身控制中外灯系统中的近光灯部分需求点为例\nSWE.1：在进行SWE.1之前，开发者应该接收来自SYS.2、SYS.3的输入，即系统需求和系统架构设计。当接收到系统需求和系统架构设计之后，开发者应该（必须）遵循SWE.1.BP来执行过程，执行流程为：\n定义软件需求 结构化软件需求 分析软件需求 分析需求在操作环境中的影响 确保一致性和双向可追溯性 与利益相关者对系统需求及其影响沟通达成一致 在此过程中，应该产生以下需求：\nSW_REQ-10001：若整车电源模式是ON，车辆应在打开近光灯开关被按下时打开近光灯；\nSW_REQ-10002：若整车电源模式是ON，车辆应在关闭所有灯光被按下时关闭近光灯；\nSW_REQ-10003：车辆应为用户提供信息（近光指示灯）以提示近光灯的工作状态。\n架构化需求及环境模块影响分析：\nSWE.2:SWE.1之后开始软件架构设计（SWE.2），所以SWE.2的输入来源于SWE.1；SWE.2目的是建立一个与软件需求一致的且分析过的软件架构，包括静态和动态方面。在此过程中需要使用以下BP来执行：\n定义静态的软件架构\n定义动态的软件架构\n分析软件架构\n确保一致性并建立双向可追溯性\n沟通商定的系统架构\n以上述SW_REQ-10001~ SW_REQ-10003需求为例：\n静态架构设计：定义软件模块的静态信息，如接口名、信号名、模块名等；\n动态架构示意：重点在于模块的动态交互、时序等逻辑体现\nSWE.3:软件详细设计和单元构建；目的是建立与软件体系结构一致的软件详细设计，包括静态和动态方面，并构建与软件详细设计一致的软件单元。它的输入来源为SWE.1和SWE.2。在此过程中，开发工程师应遵循以下BP实现：\n定义软件详细配置 定义软件详细模块交互 开发并配置模块单元 确保一致性并建立双向可追溯性 沟通商定的软件详细设计和开发的软件单元 这一环节是对软件架构设计中的SW Component的进一步设计，同样的也包含了动态详细设计与静态详细设计两个方面；通常需要识别出SWE.2环节中设定的软件模块SWC中包含哪些子模块，不过，在通常的正向开发过程中，SWE.2执行过程已经完成这一步分析。\n如LoBeam SWC中包含了SW unit：电源判断模块与 SW unit：灯光判断模块两个软件子模块；对SW uint进行更详细的设计：定义操作函数、设定或理解交互接口；如果涉及到复杂的数据类型或者算法，也需要在这个环节完成；\nSWE.4:软件单元验证；目的是验证软件单元是否与软件详细设计一致，提供证据证明软件单元符合软件详细设计和非功能软件需求；开发工程师需要遵循以下BP来实现：\n规定软件单元验证措施 选择软件单元验证措施 验证软件单元 确保一致性，建立双向可追溯性 总结并交流结果 所要验证的对象来自于SWE.3的输出；\n根据BP，实际操作流程可以如下：\n收齐输入物（被测模型/代码），即SWE.1需求，与SWE.3代码/模型\n搭建测试环境\n在代码模型里模拟输入，观测输出；如在代码simulink模型中搭建测试module；\n导入测试用例：首先要制定测试用例，以SWE.3中的模块为例，制定测试case；\nSWC Test ID 测试人 前置条件 用户输入 功能预期 实际测 试结果 功能通过 (Y/N) LoBeam Unit-test-01 ** PowerSts =ON LightsWSts =LoBeamON LoBeamReq= Req LoBeam Unit-test-02 ** PowerSts =OFF LightsWSts =LoBeamON LoBeamReq= NoReq 执行测试：按照测试case执行测试代码+功能代码，记录测试结果；\n针对测试结果及覆盖度结果补充测试用例：分析测试结果，同步的检查测试用例制定的完整性\n回归测试：反馈测试NG项，待代码修改后回归测试，完整的流程过程物/输出物应该还包含详细的测试计划、测试报告分析等内容。\nSWE.5：软件组件验证和集成验证；这一环节目的是验证软件组件与软件架构设计一致，并集成软件元素，验证集成的软件元素与软件架构和软件详细设计一致。开发工程师应遵循以下BP进行进行验证：\n指定软件集成验证措施 指定验证软件组件行为的验证措施 选择验证措施 集成软件元素并执行集成验证 执行软件组件验证 确保一致性并建立双向可追溯性 总结和交流结果 SWE.4与SWE.5均是做软件验证，区别就是范围不一样，SWE.4侧重于单个软件单元的验证，确保单元的正确性和质量；而SWE.5则关注于软件组件的集成和整体系统的测试，确保系统能够正确运行并满足需求。\nSWE.5的关键输入即是SWE.2中的输出物\u0026ndash;软件架构；软件集成后，按照SWE.2中SWC模块逐步进行测试即可；测试过程与相关过程物类型与SWE.4接近。\nSWE.6:软件验证；确保集成的软件与软件需求一致，也叫软件合格性测试。开发工程师需要遵循以下的BP来进行实现：\n规定软件验证的验证措施 选择验证措施 验证集成软件 确保一致性并建立双向可追溯性。 总结并沟通结果 该环节的输入主要来源于上级SYS.1中的系统需求与SWE.1中的软件需求；SWE.6与SWE.4、SWE.5同属测试范畴，为了更好的区分，特意做出如下对比：\n区别点 SIWE.5：软件集成与集成测试 SWE.6：软件合格性测试 目的 验证软件组件之间的集成和交互是否满足系统需求 确保集成软件整体符合软件需求 关注点 软件组件之间的接口、集成顺序、集成环境 集成软件的整体功能和性能，以及与软件需求的符合性 测试范围 特定于软件组件之间的集成和交互 覆盖整个集成软件 测试用例 设计 基于集成的功能和需求设计 基于软件需求设计 输出 集成测试结果、双向 可追溯性、集成测试报告 软件合格性测试结果、双向可追溯性、测试报告 以SWE.1中软件需求SW_REQ-10001为例，验证用例和测试结果记录表格可参考如下：\n软件验证规范 = = = = = = = = = = = 软件需求ID 标题 作者 子系统 Subsystem 测试ID 测试人 优先级 前置条件 用户输入 功能预期 实际测试结果 功能通过 (Y/ N) SW_RE Q-10001 LoBeam ** 近光灯 SW_REQ -10001-1 ** 中 车辆上电 打开近光灯开关 近光灯打开 : : : : SW_REQ -10001-2 低 车辆下电 打开近光灯开关 近光灯未打开 : : : : SW_REQ -10001-3 中 ** [!important]\n双向追溯:\nV模型左边的需求、设计和实现之间 V模型左边的需求设计实现与V模型右边的测试规范（或测试用例）之间 测试用例与测试结果之间 变更与变更影响的工作产品之间 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/fs/flashdb/",
    "title": "",
    
    "content": " 参考链接 FlashDB/README_zh.md at master · armink/FlashDB (github.com)\n基本概念 键值数据库（KVDB）：是一种非关系数据库，它将数据存储为键值（Key-Value）对集合，其中键作为唯一标识符。KVDB 操作简洁，可扩展性强。 时序数据（TSDB） ：时间序列数据库 （Time Series Database , 简称 TSDB），它将数据按照 时间顺序存储 。TSDB 数据具有时间戳，数据存储量大，插入及查询性能高。 时序记录（TSL） ：TSL (Time series log)，是 TSDB 中每条记录的简称。 Blob ：在计算机中，blob 常常是数据库中用来存储二进制文件的字段类型。在 FlashDB 中， KV 和 TSL 都使用 blob 类型来存储，该类型可以兼容任意变量类型。 迭代器（iterator）：它可以让用户透过特定的接口巡访容器中的每一个元素，而不用了解底层的实现。 TSDB 和 KVDB 都支持通过迭代器对数据库进行遍历访问。 KVDB 字符串类型 使用一个名为 \u0026amp;quot;temp\u0026amp;quot; 的 KV 来存储温度值，分别演示了字符串 KV 从 创建-\u0026amp;gt;读取-\u0026amp;gt;修改-\u0026amp;gt;删除 的全过程。大致内容如下：\nvoid kvdb_type_string_sample(fdb_kvdb_t kvdb) { FDB_INFO(\u0026amp;#34;==================== kvdb_type_string_sample ====================\\n\u0026amp;#34;); { /* CREATE new Key-Value */ char temp_data[10] = \u0026amp;#34;36C\u0026amp;#34;; /* It will create new KV node when \u0026amp;#34;temp\u0026amp;#34; KV not in database. */ fdb_kv_set(kvdb, \u0026amp;#34;temp\u0026amp;#34;, temp_data); FDB_INFO(\u0026amp;#34;create the \u0026amp;#39;temp\u0026amp;#39; string KV, value is: %s\\n\u0026amp;#34;, temp_data); } { /* GET the KV value */ …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/rtos/freertos/",
    "title": "",
    
    "content": " 入门 裸机与RTOS 裸机和RTOS的特点 基础知识 堆 堆就是一块空闲的内存，我们可以管理内存，我们可以从内存中取出一些数据，用完之后再释放（放回）\nchar heap_buf[1024]; //空闲的内存，只要在上面实现内存的分配和释放，那么他就是一个堆 int pos = 0; //定义一个位置指针 void *my_malloc(int size) //分配内存 { int old_pos = pos; pos += size; return \u0026amp;amp;heap_buf[pos]; } void my_free(void *buf) { //暂时无法实现 } int main(void) { char ch = 65; int i; char *buf = my_malloc(100); for(i = 0; i \u0026amp;lt; 26; i++){ buf[i] = \u0026amp;#39;A\u0026amp;#39; + i; } } 栈 栈是一块空闲的内存\n==一个c函数的开头将会怎么处理栈？==\n划分栈（用来保存LR等寄存器以及局部变量） LR寄存器等存入栈 执行代码 int b_func(void) { } int c_func(void) { } int a_func(int val) { int a = 8; a += val; b_func(); c_func(); } int main(void) { a_func(46); //当该函数执行完，需要返回一个下一个程序的执行地址，也就是下面的return0语句的地址 return 0; } ==一个函数执行完之后返回的地址保存在哪？==\nmain如何调用a_func\n首先将函数地址保存在某个寄存器中（LR link register），main函数在执行到a_func之前会将return 0 这个语句的地址保存在LR中，之后调用函数a_func a_func掉用b_func前也需要将下一条语句的地址保存到LR中，之后调用b_func 此时LR中的值就会被覆盖，解决方案是 在a_func内部，将LR中的值压入栈中 在b_func内部，将LR中的值压入栈中 函数的运行过程：\nMain-\u0026amp;gt;a_func-\u0026amp;gt;b_func-\u0026amp;gt;c_func 执行main，此时main函数自动划分出一个N字节的栈，将main的返回地址（即下 …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/rtos/ucos/",
    "title": "",
    
    "content": "",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/adc/",
    "title": "",
    
    "content": " ADC简介 介绍 •ADC（Analog-Digital Converter）模拟-数字转换器\n•ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁\n•12位逐次逼近型ADC，1us转换时间\n•输入电压范围：03.3V，转换结果范围：04095\n•18个输入通道，可测量16个外部和2个内部信号源\n•规则组和注入组两个转换单元\n•模拟看门狗自动监测输入电压范围\n•STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道\n原理 常见ADC类型 ADC电路类型 优点 缺点 并联比较型 转换速度最快 成本高、功耗高，分辨率低 逐次逼近型 结构简单，功耗低 转换速度较慢 并联比较型 将输入的参考电压和模拟电压输入进行比较，比较器会输出0或1从而获得二进制的数字量\n逐次逼近型 特性 特性参数 各系列主要特性 主要特性 F1 F4 F7 H7 ADC类型 逐次逼近型 分辨率 12位 6/8/10/12位 6/8/10/12位 8/10/12/14/16位 ADC时钟频率 14MHz（max） 36MHz（max） 采样时间 采样时间越长, 转换结果相对越准确, 但是转换速度就越慢 转换时间 与ADC时钟频率、分辨率和采样时间等有关 供电电压 VSSA ：0V，VDDA ：2.4V~3.6V（全速运行） 参考电压 VREF– ：0V，VREF+一般为3.3V 输入电压 VREF–≤VIN≤VREF+ 整体结构 结构框图 参考电压/模拟部分电压 ADC所能测量的电压范围是Vref- \u0026lt; VIN \u0026lt; Vref+,如果把VSSA和VREF-接地，把VREF+和VDDA接3V3，得到ADC的输入范围为0-3.3v\n输入通道 ADC的信号输入通过通道来实现的，信号通过通道输入到单片机中，单片机经过转换后，将模拟信号转换为数字信号。Stm32中的ADC有18个通道，其中外部16个通道已经在图中标出，这16个通道对应着不同的IO口，除此之外ADC1/2/3还有内部通道。\nADC1 IO ADC2 IO ADC3 IO 通道0 PA0 通道0 PA0 通道0 PA0 通道1 PA1 通道1 PA1 通道1 PA1 通道2 PA2 通道2 PA2 通道2 PA2 通道3 PA3 通道3 PA3 通道3 PA3 通道4 PA4 通道4 PA4 通道4 PF6 通道5 PA5 通道5 PA5 通道5 PF7 通道6 PA6 通道6 PA6 通道6 PF8 通道7 PA7 通道7 PA7 通道7 PF9 通道8 PB0 通道8 PB0 通道8 PF10 通道9 PB1 通道9 PB1 通道9 连接内部VSS 通道10 PC0 通道10 PC0 通道10 PC0 通道11 PC1 通道11 PC1 通道11 PC1 通道12 PC2 通道12 PC2 通道12 PC2 通道13 PC3 通道13 PC3 通道13 PC3 通道14 PC4 通道14 PC4 通道14 连接内部VSS 通道15 PC5 通道15 PC5 通道15 连接内部VSS 通道16 连接内部温度传感器 通道16 连接内部VSS 通道16 连接内部VSS 通道17 连接内部Vrefint 通道17 连接内部VSS 通道17 连接内部VSS 外部的16个通道在转换时又分为规则通道和注入通道，其中规则通道最多有16路，注入通道最多有4路\n规则通道 规则通道是用于普通的周期性 ADC 数据采集的通道。它们适用于周期性地采集模拟信号，例如传感器测量、输入信号的连续转换等。在规则通道中，可以设置 ADC 转换的采样时间、分辨率等参数。\n注入通道 注入通道是用于触发式或突发式 ADC 数据采集的通道。它们适用于在特定事件或条件下进行数据采集，例如外部触发或中断事件。注入通道可以用于实现对不同事件的响应并采集模拟信号。在注入通道中，您可以设置触发源、采样时间等参数。\n转换顺序 知道了ADC的转换通道后，如果ADC只使用一个通道来转换，那就很简单，但如果是使用多个通道进行转换就涉及到一个先后顺序了，毕竟规则转换通道只有一个数据寄存器。所以将转换的顺序分组，每组转换的顺序组成一个序列。\n多个通道的使用顺序分为俩种情况：\n规则通道的转换顺序\n注入通道的转换顺序\n这里的规则组只有一个寄存器，所以说当数据转换完成之后就需要尽快转移数据，防止数据覆盖。注入组有四个寄存器，可以将转换的数据存在各自的寄存器中。\n规则通道转换顺序 规则通道中的转换顺序由三个寄存器控制：SQR1、SQR2、SQR3，它们都是32位寄存器。SQR寄存器控制着转换通道的数目和转换顺序，只要在对应的寄存器位SQx中写入相应的通道，这个通道就是第x个转换。具体的对应关系如下\n优先级比较 注入组优先级高于规则组，注入组的转换可以打断规则组。\n规则序列 规则序列寄存器控制关系汇总 寄存器 寄存器位 功能 取值 SQR3 SQ1 [ 4 : 0 ] 设置第1个转换的通道 通道0~17 SQ2 [ 4 : 0 ] 设置第2个转换的通道 通道0~17 SQ3 [ 4 : 0 ] 设置第3个转换的通道 通道0~17 SQ4 [ 4 : 0 ] 设置第4个转换的通道 通道0~17 SQ5 [ 4 : 0 ] 设置第5个转换的通道 通道0~17 SQ6 [ 4 : 0 ] 设置第6个转换的通道 通道0~17 SQR2 SQ7 [ 4 : 0 ] 设置第7个转换的通道 通道0~17 SQ8 [ 4 : 0 ] 设置第8个转换的通道 通道0~17 SQ9 [ 4 : 0 ] 设置第9个转换的通道 通道0~17 SQ10 [ 4 : 0 ] 设置第10个转换的通道 通道0~17 SQ11 [ 4 : 0 ] 设置第11个转换的通道 通道0~17 SQ12 [ 4 : 0 ] 设置第12个转换的通道 通道0~17 SQR1 SQ13 [ 4 : 0 ] 设置第13个转换的通道 通道0~17 SQ14 [ 4 : 0 ] 设置第14个转换的通道 通道0~17 SQ15 [ 4 : 0 ] 设置第15个转换的通道 通道0~17 SQ16 [ 4 : 0 ] 设置第16个转换的通道 通道0~17 SQL [ 3 : 0 ] 设置规则序列要转换的通道数 0~15 注入序列 和规则通道转换顺序的控制一样，注入通道的转换也是通过注入寄存器来控制，只不过只有一个JSQR寄存器来控制，控制关系如下\n需要注意的是，只有当JL=4的时候，注入通道的转换顺序才会按照JSQ1、JSQ2、JSQ3、JSQ4的顺序执行。当JL\u0026lt;4时，注入通道的转换顺序恰恰相反，也就是执行顺序为：JSQ4、JSQ3、JSQ2、JSQ1。\n注入序列寄存器控制关系汇总 寄存器 寄存器位 功能 取值 JSQR JSQ1 [ 4 : 0 ] 设置第1个转换的通道 通道0~17 JSQ2 [ 4 : 0 ] 设置第2个转换的通道 通道0~17 JSQ3 [ 4 : 0 ] 设置第3个转换的通道 通道0~17 JSQ4 [ 4 : 0 ] 设置第4个转换的通道 通道0~17 JL [ 1 : 0 ] 设置注入序列要转换的通道数 0~3 触发源 ADC转换的输入、通道、转换顺序都已经说明了，但ADC转换是怎么触发的呢？就像通信协议一样，都要规定一个起始信号才能传输信息，ADC也需要一个触发信号来实行模/数转换。\n1、通过直接配置寄存器触发，通过配置控制寄存器CR2的ADON位，写1时开始转换，写0时停止转换。在程序运行过程中只要调用库函数，将CR2寄存器的ADON位置1就可以进行转换。\n2、通过内部定时器或者外部IO触发转换，也就是说可以利用内部时钟让ADC进行周期性的转换，也可以利用外部IO使ADC在需要时转换，具体的触发由控制寄存器CR2决定。\n转换时间 ADC的每一次信号转换都要时间，这个时间就是转换时间，转换时间由输入时钟和采样周期来决定。\n输入时钟 由于ADC在STM32中是挂载在APB2总线上的，所以ADC得时钟是由PCLK2（72MHz）经过分频得到的，分频因子由 RCC 时钟配置寄存器RCC_CFGR 的位 15:14 ADCPRE[1:0]设置，可以是 2/4/6/8 分频，一般配置分频因子为8，即8分频得到ADC的输入时钟频率为9MHz。\n采样周期 采样周期是确立在输入时钟上的，配置采样周期可以确定使用多少个ADC时钟周期来对电压进行采样，采样的周期数可通过 ADC采样时间寄存器 ADC_SMPR1 和 ADC_SMPR2 中的 SMP[2:0]位设置，ADC_SMPR2 控制的是通道 09， ADC_SMPR1 控制的是通道 1017。每个通道可以配置不同的采样周期，但最小的采样周期是1.5个周期，也就是说如果想最快时间采样就设置采样周期为1.5.\n转换时间 转换时间=采样时间+12.5个周期\n12.5个周期是固定的，一般我们设置 PCLK2=72M，经过 ADC 预分频器能分频到最大的时钟只能是 12M，采样周期设置为 1.5 个周期，算出最短的转换时间为 1.17us。\n数据寄存器 当使用ADC独立模式（也就是只使用一个ADC，可以使用多个通道）时，数据存放在低16位中，当使用ADC多模式时高16位存放ADC2的数据。需要注意的是ADC转换的精度是12位，而寄存器中有16个位来存放数据，所以要规定数据存放是左对齐还是右对齐。\n当使用多个通道转换数据时，会产生多个转换数据，然鹅数据寄存器只有一个，多个数据存放在一个寄存器中会覆盖数据导致ADC转换错误，所以我们经常在一个通道转换完成之后就立刻将数据取出来，方便下一个数据存放。一般开启DMA模式将转换的数据，传输在一个数组中，程序对数组读操作就可以得到转换的结果。\n注入通道转换的数据寄存器有4个，由于注入通道最多有4个，所以注入通道转换的数据都有固定的存放位置，不会跟规则寄存器那样产生数据覆盖的问题。 ADC_JDRx 是 32 位的，低 16 位有效，高 16 位保留，数据同样分为左对齐和右对齐，具体是以哪一种方式存放，由ADC_CR2 的 11 位 ALIGN 设置。\n中断 从框图中可以知道数据转换完成之后可以产生中断，有三种情况：\n规则通道转换完成中断\n规则通道数据转换完成之后，可以产生一个中断，可以在中断函数中读取规则数据寄存器的值。这也是单通道时读取数据的一种方法。\n注入通道转换完成中断\n注入通道数据转换完成之后，可以产生一个中断，并且也可以在中断中读取注入数据寄存器的值，达到读取数据的作用。\n模拟看门狗事件\n当输入的模拟量（电压）不再阈值范围内就会产生看门狗事件，就是用来监视输入的模拟量是否正常。\n以上中断的配置都由ADC_SR寄存器决定：\n电压转换 $$\ry=\\frac{3.3 \\times x}{4096}\r$$ 单次转换和连续转换 一组只转换一个通道\n连续转换，在一轮转换结束后，继续下一轮的转换\n每次转换后都会停下来，但是和非扫描模式不同的是，扫描模式会扫描序列，然后对列表中的序列转换出来\n连续转换，扫描模式\n扫描模式\n不同模式的组合 实验 使用ADC的步骤\n电位器作为ADC输入\n确定ADC挂载在哪个总线上，并开启ADC的时钟 配置与ADC通道相对应的GPIO引脚为模拟输入模式 配置规则组通道，包括通道号、顺序和采样时间 设置ADC的工作模式、数据对齐方式 、外部触发源、通道数量等参数 使能ADC 校准ADC void adc_init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE); RCC_ADCCLKConfig(RCC_PCLK2_Div6); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Pin = ADC_PIN; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(ADC_PORT,\u0026amp;GPIO_InitStruct); ADC_RegularChannelConfig(ADC3,ADC_Channel_4,1,ADC_SampleTime_55Cycles5);\t//配置规则通道组，填充菜单列表 ADC_InitTypeDef ADC_InitStruct; ADC_InitStruct.ADC_ContinuousConvMode = DISABLE; ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;\t//软件触发 ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; ADC_InitStruct.ADC_NbrOfChannel = 1; ADC_InitStruct.ADC_ScanConvMode = DISABLE; ADC_Init(ADC3,\u0026amp;ADC_InitStruct); ADC_Cmd(ADC3,ENABLE); //开始校准 ADC_ResetCalibration(ADC3);\t//复位校准 while(ADC_GetResetCalibrationStatus(ADC3) != RESET);\t//等待复位校准完成 ADC_StartCalibration(ADC3);\t//开始校准 while(ADC_GetCalibrationStatus(ADC3) == SET);//等待校准完成 } u16 ad_getValue(void) { ADC_SoftwareStartConvCmd(ADC3,ENABLE); while(ADC_GetFlagStatus(ADC3,ADC_FLAG_EOC) == RESET);\t//等待转换完成，也就是EOC信号 return ADC_GetConversionValue(ADC3);\t//读取完数据将会自动清除数据位 } int main(void){ char str[50]; serial_init(); adc_init();\twhile(1){ sprintf(str,\u0026#34;read: %u\\n \u0026#34;,ad_getValue()); send_string(str); Delay_ms(1000); } } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/dac/",
    "title": "",
    
    "content": " 参考链接 【STM32】DAC详解_dac12bit-CSDN博客\n简述 DAC,全称：Digital-to-Analog Converter,指数字/模拟转换器\nDAC 模块是 12 位电压输出数模转换器。\nDAC 可以按 8 位或 12 位模式进行配置，并且可与DMA 控制器配合使用。 在 12 位模式下，数据可以采用左对齐或右对齐。 DAC 有两个输出通道，每个通道各有一个转换器。在 DAC 双通道模式下，每个通道可以单独进行转换；当两个通道组合在一起同步执行更新操作时，也可以同时进行转换。可通过一个输入参考电压引脚 V REF+ （与 ADC 共享）来提高分辨率。 [!IMPORTANT]\nADC和DAC是模拟电路和数字电路之间的桥梁\n特性参数 分辨率：表示模拟电压的最小增量，常用二进制位数表示，比如：8、12位等 建立时间：表示将一个数字量转换为稳定模拟信号所需的时间 精度：转换器实际特性曲线与理想特性曲线之间的最大偏差 误差源：比例系统误差、失调误差、非线性误差 原因：元件参数误差、基准电压不稳定、运算放大器零漂等 主要特性 主要特性 F1 F4 F7 H7 DAC输出类型 电压输出型 == == == 分辨率 8/12位 == == == DAC时钟频率 36MHz(APB1) 42MHz(APB1) 45MHz(APB1) 54MHz(APB1) 120MHz(APB1) 建立时间 3us == == 1.7us 供电电压 Vssa : 0V, VpDa : 2.4V~3.6V == == == 参考电压 VReF- : OV, VREE+ 般为3.3V == == == 输出通道 DAC_OUT1(PA4）、DAC_OUT2(PA5) 为了避免寄生电流消耗，PA4和PA5配置为模拟功能 每个通道都有单独的转换器，可同时或单独转换，每个通道都有DMA功能 == == == 两个 DAC 转换器：各对应一个输出通道 12 位模式下数据采用左对齐或右对齐 同步更新功能 生成噪声波 生成三角波 DAC 双通道单独或同时转换 每个通道都具有 DMA 功能 DMA 下溢错误检测 通过外部触发信号进行转换 输入参考电压 V REF+ 工作原理 [!TIP]\n使能 DAC 通道 x 后，相应 GPIO 引脚（ PA4 或 PA5 ）将自动连接到模拟转换器输出(DAC_OUTx) 。为了避免寄生电流消耗，应首先将 PA4 或 PA5 引脚配置为模拟模式 (AIN) 。\n参考电压和模拟电压 名称 信号类型 备注 VREF+ 正模拟参考电压输入 DAC 高/正参考电压，1.8V≤VREF+≤VDDA VDDA 模拟电源输入 模拟电源 VsSA 模拟电源接地输入 模拟电源接地 DAC_OUTx 模拟输出信号 DAC 通道×模拟输出 201040420 数据格式 数据寄存器，是DAC数据转换的来源\n触发源 关闭触发时的转换时序\nDAC_DORx 无法直接写入，任何数据都必须通过加载 DAC_DHRx 寄存器（写入DAC_DHR8Rx、DAC_DHR12Lx、DAC_DHR12Rx、DAC_DHR8RD、DAC_DHR12LD 或DAC_DHR12LD）才能传输到 DAC 通道 x。\n如果未选择硬件触发（DAC_CR 寄存器中的 TENx 位复位），那么经过一个 APB1 时钟周期后，DAC_DHRx 寄存器中存储的数据将自动转移到 DAC_DORx 寄存器。但是，如果选择硬件触发（置位 DAC_CR 寄存器中的 TENx 位）且触发条件到来，将在三个 APB1 时钟周期后进行转移。\n当 DAC_DORx 加载了 DAC_DHRx 内容时，模拟输出电压将在一段时间 t SETTLING 后可用，具体时间取决于电源电压和模拟输出负载。\n源 类型 TSEL[2:0] Timer 6 TRGO event 片上定时器的内部信号 外部引脚 000 Timer 8 TRGO event : 001 Timer 7 TRGO event : 010 Timer 5 TRGO event : 011 Timer 2TRGOevent : 100 Timer 4 TRGO event : 101 EXTI line9 外部引脚 110 SWTRIG 软件控制位 111 DMA请求 每个 DAC 通道都具有 DMA 功能。两个 DMA 通道用于处理 DAC 通道的 DMA 请求。当 DMAENx 位置 1 时，如果发生外部触发（而不是软件触发），则将产生 DAC DMA 请求。DAC_DHRx 寄存器的值随后转移到 DAC_DORx 寄存器。\n在双通道模式下，如果两个 DMAENx 位均置 1，则将产生两个 DMA 请求。如果只需要一个DMA 请求，应仅将相应 DMAENx 位置 1。这样，应用程序可以在双通道模式下通过一个DMA 请求和一个特定 DMA 通道来管理两个 DAC 通道。\n输出电压 经过线性转换后，数字输入会转换为 0 到 V REF+ 之间的输出电压。各DAC通道引脚的模拟输出电压通过以下公式确定：\n这里的4096和256分别是2^12 2^8\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/dma/",
    "title": "",
    
    "content": " 参考链接 【STM32】 DMA原理，步骤超细详解，一文看懂DMA-CSDN博客\n概述 [!IMPORTANT]\nDMA传输无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现过程\n通过硬件为RAM和IO设备开辟一条直接传输数据的通道，使得CPU的效率大大提高\n作用：为CPU减负\n一般而言，DMA控制器将包括一条地址总线、一条数据总线和控制寄存器。高效率的DMA控制器将具有访问其所需要的任意资源的能力，而==无须处理器==本身的介入，它必须能==产生中断==。最后，它必须能在控制器内部计算出地址。\n一个处理器可以包含多个DMA控制器。每个控制器有多个DMA通道，以及多条直接与存储器站(memory bank)和外设连接的总线。在很多高性能处理器中集成了两种类型的DMA控制器：\n第一类通常称为“系统DMA控制器”，可以实现对任何资源(外设和存储器)的访问，对于这种类型的控制器来说，信号周期数是以系统时钟(SCLK)来计数的，以ADI的Blackfin处理器为例，频率最高可达133MHz。 第二类称为内部存储器DMA控制器(IMDMA)，专门用于内部存储器所处位置之间的相互存取操作。因为存取都发生在内部(L1－L1、L1－L2，或者L2－L2)，周期数的计数则以内核时钟(CCLK)为基准来进行，该时钟的速度可以超过600MHz。 graph LR subgraph a[处理器] L1存储器 \u003c--DMA内核总线--\u003e DMA控制器 L2存储器 \u003c--DMA系统总线--\u003e DMA控制器 \u003c--DMA存取总线--\u003e 外设 end DMA控制器 \u003c--DMA外部总线--\u003e L3存储器 DMA的传输方式 DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节，主要涉及四种情况的数据传输，但本质上是一样的，都是从内存的某一区域传输到内存的另一区域（外设的数据寄存器本质上就是内存的一个存储单元）。四种情况的数据传输如下：\n外设到内存 内存到外设 内存到内存 外设到外设 DMA传输参数 数据传输的核心参数：\n数据源地址 数据传输位置的目标地址 传递护具多少的数据传输量 进行多少次传输的传输模式 当用户将参数设置好，主要涉及源地址、目标地址、传输数据量这三个，DMA控制器就会启动数据传输，当剩余传输数据量为0时 达到传输终点，结束DMA传输 ，当然，DMA 还有循环传输模式 当到达传输终点时会重新启动DMA传输。\n[!NOTE]\n也就是说只要剩余传输数据量不是0，而且DMA是启动状态，那么就会发生数据传输。　DMA的主要特征 每个通道都直接连接专用的硬件DMA请求，每个通道都同样支持软件触发。这些功能通过软件来配置；\n在同一个DMA模块上，多个请求间的优先权可以通过软件编程设置（共有四级：很高、高、中等和低），优先权设置相等时由硬件决定（请求0优先于请求1，依此类推）； 独立数据源和目标数据区的传输宽度（字节、半字、全字），模拟打包和拆包的过程。源和目标地址必须按数据传输宽度对齐； 支持循环的缓冲器管理； 每个通道都有3个事件标志（DMA半传输、DMA传输完成和DMA传输出错），这3个事件标志逻辑或成为一个单独的中断请求； 存储器和存储器间的传输、外设和存储器、存储器和外设之间的传输； 闪存、SRAM、外设的SRAM、APB1、APB2和AHB外设均可作为访问的源和目标； 可编程的数据传输数目：最大为65535。 存储器映像 类型 起始地址 存储器 用途 ROM 0x0800 0000 程序存储器Flash 存储C语言编译后的程序代码 : 0x1FFF F000 系统存储器 存储BootLoader，用于串口下载 : 0x1FFF F800 选项字节 存储一些独立于程序代码的配置参数 RAM 0x2000 0000 运行内存SRAM 存储运行过程中的临时变量 : 0x4000 0000 外设寄存器 存储各个外设的配置参数 : 0xE000 0000 内核外设寄存器 存储内核各个外设的配置参数 DMA 系统框图 flash为主闪存，SRAM为运行内存，各个外设可以看作是寄存器，也是一种SRAM存储器，实际上，我们可以将这个框图看作是一个cpu（cortex-M3）和存储器（框图中的所有）\n寄存器是一种特殊的存储器：\n一方面，CPU可以对寄存器进行读写，就像是读写运行内存一样 另一方面，寄存器的每一位背后，都连接了一根导线，这些导线可以控制外设的电路状态，如置引脚高低电平、导通和断开开关、切换数据选择器 在总线矩阵的左端，是主动单元，也就是拥有存储器的访问权，总线矩阵的右端，是被动单元，它们的存储器只能被左边的主动单元读写\n数据流动 在有无DMA时，ADC采集的数据是如何流动的？\n数据流动方向*==ADC数据寄存器-\u0026gt;SRAM==*\n没有DMA\nCPU传输数据需要以内核作为中转站\n内核作为主机通过*==Dcode-\u0026gt;总线矩阵-\u0026gt;AHB从设备中存储的外设ADC采集的数据==*\n内核再通过*==Dcode-\u0026gt;总线矩阵-\u0026gt;SRAM将得到的数据放到SRAM中==*\n有DMA\nDMA传输时外设对DMA控制器（DMA1，DMA2）发送请求\nDMA控制器收到请求，出发DMA工作\nDMA控制器从AHB外设获取的ADC采集的数据，存储到DMA通道中（通道1-7）\nDMA控制器的DMA总线与总线矩阵协调，使用AHB把外设ADC采集的数据经由DMA通道存放到SRAM中，这个数据传输过程中，完全不需要内核参与\nDMA请求 在发生一个事件后，外设向DMA控制器发送一个请求信号。DMA控制器根据通道的优先权处理请求。当DMA控制器开始访问发出请求的外设时，DMA控制器立即发送给它一个应答信号。当从DMA控制器得到应答信号时，外设立即释放它的请求。一旦外设释放了这个请求，DMA控制器同时撤销应答信号。DMA传输结束，如果有更多的请求时，外设可以启动下一个周期。\n总之，每次DMA传送由3个操作组成：\n从外设数据寄存器或者从当前外设/存储器地址寄存器指示的存储器地址取数据，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元； 存数据到外设数据寄存器或者当前外设/存储器地址寄存器指示的存储器地址，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元； 执行一次DMA_CNDTRx寄存器的递减操作，该寄存器包含未完成的操作数目。 DMA通道 DMA资源数量\n对于大容量的STM32芯片有2个DMA控制器 DMA1有七个通道，DMA2有5个通道，每个通道都可以配置一些外设的地址 DMA传输通道\n每个通道都可以有固定地址的外设寄存器和存储器地址之间执行DMA传输，DMA传输的数据量是可编程的，最大可达到65535，包含要传输的数据向数量的寄存器，在每次传输后递减 存储器到存储器模式\nDMA通道的操作可以在没有外设请求的情况下进行，这种操作就是存储器到存储器模式 当设置了DMA_CCRx寄存器中的MEM2MEM位之后，在软件设置了DMA_CCRx寄存器中的EN位启动DMA通道时，DMA传输将马上开始。当DMA_CNDTRx寄存器变为0时，DMA传输结束。存储器到存储器模式不能与循环模式同时使用。 这里要注意仅 DMA2 的外设接口可以访问存储器，所以仅 DMA2 控制器支持存储器到存储器的传输，DMA1 不支持。 存储器到存储器模式不能与循环模式同时使用。 DMA1 control\n从外设（TIMx[x=1、2、3、4]、ADC1、SPI1、SPI/I2S2、I2Cx[x=1、2]和USARTx[x=1、2、3]）产生的7个DMA请求，通过逻辑或输入到DMA1控制器 其中每个通道都对应着具体的外设： 外设 通道1 通道2 通道3 通道4 通道5 通道6 通道7 ADC1 ADC1 SPI/IIS SPI1_RX SPI1_TX SPI/2S2_RX SP/2S2_TX USART USART3_TX USART3_RX USART1_TX USART1_RX USART2_RX USART2_TX IIC 12C2_TX TIM1_TX4 12C2_RX I2C1_TX I2C1_RX TIM1 TIM1_CH1 TIM1_CH2 TIM1_TRIG TIM1_COM TIM1_UP TIM1_CH3 TIM2 TIM2_CH3 TIM2_UP TIM2_CH1 TIM2_CH2 TIM2_CH4 TIM3 TIM3_CH3 TIM3_CH4 TIM3_UP TIM3_CH1 TIM3_TRIG TIM4 TIM4_CH1 TIM4_CH2 TIM4_CH3 TIM4_UP DMA优先级 仲裁器\n仲裁器的作用是确定各个DMA传输的优先级 仲裁器根据通道请求的优先级来启动外设/存储器的访问 DMA优先级\n仲裁器管理DMA通道请求分为两个阶段： 第一阶段（软件阶段）：每个通道的优先级可在DMA_CCRx寄存器中设置，有四个等级：最高、高、中和低优先级。 第二阶段（硬件阶段）：如果两个请求有相同软件优先级，较低偏号的通道比较高偏号的通道有较高的优先级。(大容量芯片中，DMA1控制器拥有高于DMA2控制的优先级) 注意：多个请求通过逻辑或输入到DMA控制器，只能有一个请求有效。 DMA中断 每个DMA通道都可以在DMA传输过半、传输完成和传输错误时产生中断。为应用的灵活性考虑，通过设置寄存器的不同位来打开这些中断。\n中断事件 事件标志位 使能控制位 传输过半 HTIF HTIE 传输完成 TCIF TCIE 传输错误 TEIF TEIE DMA的内存占用 在STM32控制器中，芯片采用Cortex-MX架构，总线结构有了很大的优化，DMA占用另外的地址总线，并不会与CPU的系统总线发生冲突。也就是说，DMA的使用不会影响CPU的运行速度\n但是要注意：\nDMA 控制器和Cortex-M3核共享系统数据总线执行直接存储器数据传输。当CPU和DMA同时访问相同的目标(RAM或外设)时，DMA请求可能会停止 CPU访问系统总线达若干个周期，总线仲裁器执行循环调度，以保证CPU至少可以得到一半的系统总线(存储器或外设)带宽。\n工作过程 实验 DMA寄存器的配置参数包括：通道地址、优先级、数据传输方向、存储器/外设数据宽度、存储器/外设地址是否增量、循环模式、数据传输量。\n配置流程\n在DMA_CPARx寄存器中设置外设寄存器的地址。发生外设数据传输请求时，这个地址将 是数据传输的源或目标。 在DMA_CMARx寄存器中设置数据存储器的地址。发生外设数据传输请求时，传输的数 据将从这个地址读出或写入这个地址。 在DMA_CNDTRx寄存器中设置要传输的数据量。在每个数据传输后，这个数值递减。 在DMA_CCRx寄存器的PL[1:0]位中设置通道的优先级。 在DMA_CCRx寄存器中设置数据传输的方向、循环模式、外设和存储器的增量模式、外 设和存储器的数据宽度、传输一半产生中断或传输完成产生中断。 设置DMA_CCRx寄存器的ENABLE位，启动该通道。 void adc_init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE); RCC_ADCCLKConfig(RCC_PCLK2_Div6); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Pin = ADC_PIN; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(ADC_PORT,\u0026amp;GPIO_InitStruct); ADC_RegularChannelConfig(ADC3,ADC_Channel_4,1,ADC_SampleTime_55Cycles5); //配置规则通道组，填充菜单列表 ADC_InitTypeDef ADC_InitStruct; ADC_InitStruct.ADC_ContinuousConvMode = DISABLE; ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //软件触发 ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; ADC_InitStruct.ADC_NbrOfChannel = 1; ADC_InitStruct.ADC_ScanConvMode = DISABLE; ADC_Init(ADC3,\u0026amp;ADC_InitStruct); ADC_Cmd(ADC3,ENABLE); //开始校准 ADC_ResetCalibration(ADC3); //复位校准 while(ADC_GetResetCalibrationStatus(ADC3) != RESET); //等待复位校准完成 ADC_StartCalibration(ADC3); //开始校准 while(ADC_GetCalibrationStatus(ADC3) == SET);//等待校准完成 } u16 ad_getValue(void) { ADC_SoftwareStartConvCmd(ADC3,ENABLE); while(ADC_GetFlagStatus(ADC3,ADC_FLAG_EOC) == RESET); //等待转换完成，也就是EOC信号 return ADC_GetConversionValue(ADC3); //读取完数据将会自动清除数据位 } u8 data1[] = {0x01, 0x02, 0x03, 0x04}; u8 data2[] = {0, 0, 0, 0}; int main(void){ char str[50]; serial_init(); sprintf(str,\u0026#34;addr1: %x origin 1: %u %u %u %u\\n\u0026#34;,(u32)data1,data1[0],data1[1],data1[2],data1[3]); send_string(str); sprintf(str,\u0026#34;addr2: %x origin 2: %u %u %u %u\\n\u0026#34;,(u32)data2,data2[0],data2[1],data2[2],data2[3]); send_string(str); dma_init((u32)data1,(u32)data2,4); while(1){ data1[0]++; data1[1]++; data1[2]++; data1[3]++; dma_transfer(); sprintf(str,\u0026#34;addr1: %x origin 1: %u %u %u %u\\n\u0026#34;,(u32)data1,data1[0],data1[1],data1[2],data1[3]); send_string(str); sprintf(str,\u0026#34;addr2: %x origin 2: %u %u %u %u\\n\u0026#34;,(u32)data2,data2[0],data2[1],data2[2],data2[3]); send_string(str); dma_init((u32)data1,(u32)data2,4); Delay_s(2); } } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/flash/",
    "title": "",
    
    "content": " 概述 STM32F1系列的FLASH包含程序存储器、系统存储器和选项字节三个部分，通过闪存存储器接口（外设）可以对程序存储器和选项字节进行擦除和编程 读写FLASH的用途： 利用程序存储器的剩余空间来保存掉电不丢失的用户数据 通过在程序中编程(IAP),实现程序的自我更新 在线编程(ln-Circuit Programming-ICP)用于更新程序存储器的全部内容，它通过JTAG、SWD协议或系统加载程序(Bootloader)下载程序 在程序中编程(ln-Application Programming-IAP）可以使用微控制器支持的任一种通信接口下载程序 芯片型号 主频 (MHz) FLASH容量(B) SRAM容量（ (B) STM32F103RCT6 72 256K 48K STM32F103ZET6 72 512K 64K STM32F407ZGT6 168 1024K 192K STM32F429IGT6 180 1024K 256K STM32F76IGT6 216 1024K 512K STM32H7431IT6 480 2048K 1060K STM32F750N8H6 216 64K 320K STM32H750XBH6 400 128K 1060K STM32H750VBT6 480 128K 1060K 内部构成 内部FLASH主要由三部分组成：\n主存储器 信息块 闪存存储器接口寄存器。 闪存模块的子部分 作用 主存储器 用来存放代码和数据常数 （如const类型到的数据） 信息块 分为两个部分：系统存储（启动程序代码）、选项字节（用户选择字节) 闪存存储器接口寄存器 用于控制闪存读写等，是整个闪存模块的控制结构 主存储器：地址范围为0x08000000~0x0807FFFF,分为256页，每页2KB(小/中容量为1K)。当BOOT0接地，系统将从0x08000000地址处开始读取代码（从主存储器启动）。\n信息块：系统存储大小为2KB,用来存储ST自带的启动程序，用来串口下载代码。选项字节大小为16B,一般用于设置内存的写保护、读保护。当BOOT0接VCC,BOOT1接GND(串口下载程序)，系统运行的就是这部分代码。\n基本结构 控制器实际上是闪存的管理员，它可以对程序存储器进行擦除和编程，也可以对选项字节进行擦除和编程，系统存储器是不能擦除和编程的。\n选项字节 一共16个字节，其中有一半的名称前面都带了n，也就是在写入RDP数据的时候，同时要在nRDP中写入数据的反码，如果芯片检测到这两个存储器不是反码的关系，则代表数据无效，有错误，对应的功能就不执行，这是一种安全保障措施\n地址 [31:24] [23:16] [15:8] [7:0] 0x1FFF F800 nUSER USER nRDP RDP 0x1FFF F804 nData1 Data1 nData0 Datao 0x1FFF F808 nWRP1 WRP1 nWRPO WRPO 0x1FFF F80C nWRP3 WRP3 nWRP2 WRP2 RDP:写入RDPRT键(OxO00000A5)后解除读保护 USER：配置硬件看门狗和进入停机/待机模式是否产生复位 Data0/1:用户可自定义使用 WRP0/1/2/3:配置写保护，每一个位对应保护4个存储页（中容量) 选项字节编程 检查FLASH SR的BSY位，以确认没有其他正在进行的编程操作 解锁FLASH CR的OPTWRE位 设置FLASH CR的OPTPG位为1 写入要编程的半字到指定的地址 等待BSY位变为0 读出写入的地址并验证数据 选项字节擦除 检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作 解锁FLASH CR的OPTWRE位 设置FLASH_CR的OPTER位为1 设置FLASH CR的STRT位为1 等待BSY位变为0 读出被擦除的选择字节并做验证 器件电子签名 电子签名存放在闪存存储器模块的系统存储区域，包含的芯片识别信息在出厂时编写，不可更改，使用指针读指定地址下的存储器可获取电子签名\n闪存容量寄存器：\n基地址：0x1FFFF7E0 大小：16位 产品唯一身份标识寄存器：\n基地址：0x1FFFF7E8 大小：96位 读写过程 对FLASH的核心操作就是==读==和==写==。\n[!IMPORTANT]\nFLASH的物理特性：只能写0，不能写1，写1靠擦除。\nFLASH解锁 FPEC共有三个键值：\nRDPRT键=0x000000A5 KEY1 = 0x45670123 KEY2 = 0xCDEF89AB 解锁：\n复位后，FPEC被保护，不能写入FLASH_CR，所以说是默认锁着 在FLASH_KEYR先写入KEY1，再写入KEY2，解锁，这里有两道锁 错误的操作序列会在下次复位前索斯FPEC和FLASH_CR 加锁：\n设置FLASH_CR中的LOCK位所著FPEC和FLASH_CR 使用指针访问存储器 // 使用指针读指定地址下的存储器： uint16 t Data *((__IO uint16_t *)(0x08000000)); // 使用指针写指定地址下的存储器： *((__IO uint16_t*)(0x0800000))=0x1234; // 其中： #define __IO volatile STM32内部的存储器是直接挂载在总线上的，所以这时再读写某个存储器就非常简单了，可以直接使用指针就可以访问\n在数据类型前面加上volatile是一个安全保障措施，就是防止编译器优化\nkeil编译器在默认情况下是最低优化等级，加不加volatile都没有影响，如果提高优化等级，那么程序可能会出现一定的问题\n假设想用变量计数空循环的方式实现延时函数，那么在编译器优化的时候可能会觉得延时函数没有作用，可能会直接将这段代码优化掉，加上volatile之后会告诉编译器，无论对这个变量做什么，都不能优化，需要原封不动的去执行。\n此外，编译器还会利用缓存来加速代码，最常见的优化方式就是把变量转移到高速缓存里来，在stm32内核里，有一个类似缓存的工作组寄存器，这些寄存器的访问速度最快，先将变量放到缓存中，需要读写的时候直接访问缓存即可，用完之后再写回内存。但是如果程序中有多个线程，比如中断函数，在中断函数里，改变某个原始变量，缓存可能并不知道变量已经改变，下次读写的时候，程序还看缓存中的变量，就会造成数据更改不同步的问题，这时，解决的方法是读取变量定义前面加上volatile，告诉编译器这个变量是易变的，每次读取都应该从内存中读取，而不是从缓存中读取\n闪存的读取 直接在通用地址空间直接寻址，任何32位数据的读操作都能访问闪存模块的内容并得到相对应的据。\nCPU运行速度比FLASH快得多，STM32F103的FLASH最快访问速度≤24MHz,CPU频率超过这个速度，得加入等待时间，否则读写FLASH可能出错，导致死机等情况。\n频率范围 等待周期数(LATENCY) 0\u0026lt; SYSCLK \u0026lt;2 24MHz 0个等待周期 24MHz \u0026lt; SYSCLK ≤ 48MHz 1个等待周期 48MHz\u0026lt; SYSCLK≤72MHz 2个等待周期 正确设置好等待周期后，利用指读取据。\n从地址addr,读取数据（字节为8位，半字为16位，字为32位）\n/*读取一个字节数据*/ data = *(volatile uint8 t *)addr; /*读取一个半字数据*/ data *(volatile uint16 t *)addr; /*读取一个字据*/ data *(volatile uint32 t )addr; // 将addr强制转换为uintx_t指针，然后取该指针所指向地址的值，即可获得addr地址的据。 // 注意：在进行写或擦除操作时，不能进行代码或据的读取操作。 // 写操作：*(volatile uint16t)addr=data?并不全是 闪存的写入 闪存编程是由FPEC(闪存编程和擦除控制器)模块处理的。\n写操作有四步：==解锁→擦除→写数据→上锁==\n编程过程 首先读取LOCK位，看看芯片锁没锁 Lock = 1代表被锁，执行解锁过程，在KEYR寄存器中先写入KEY1，再写入KEY2，在库函数中没有判断过程，不管锁没锁都执行解锁操作 首先置控制寄存器中的STRT 为1，STRT为1是触发条件，这个时候芯片才能开始工作。之后将PG位（programming编程）置为1，代表进行的操作是进行写入 在指定的地址写入半字（16位），这时就可以使用指针写入数据，这里只能以半字写入 擦除开始后，程序需要等待一段时间，判断状态寄存器的BSY是否为1，BSY代表芯片是否处于忙状态，BSY为1代表芯片忙 闪存页擦除过程 首先读取LOCK位，看看芯片锁没锁 Lock = 1代表被锁，执行解锁过程，在KEYR寄存器中先写入KEY1，再写入KEY2，在库函数中没有判断过程，不管锁没锁都执行解锁操作 首先置控制寄存器中的STRT 为1，STRT为1是触发条件，这个时候芯片才能开始工作。之后将PER（page erase页擦除）置为1，代表进行的操作是页擦除，在AR地址寄存器中写入需要擦除的页地址 擦除开始后，程序需要等待一段时间，判断状态寄存器的BSY是否为1，BSY代表芯片是否处于忙状态，BSY为1代表芯片忙 闪存全擦除过程 首先读取LOCK位，看看芯片锁没锁 Lock = 1代表被锁，执行解锁过程，在KEYR寄存器中先写入KEY1，再写入KEY2，在库函数中没有判断过程，不管锁没锁都执行解锁操作 首先置控制寄存器中的STRT 为1，STRT为1是触发条件，这个时候芯片才能开始工作。之后将MER（mass erase全擦除）置为1，代表进行的操作是全擦除 擦除开始后，程序需要等待一段时间，判断状态寄存器的BSY是否为1，BSY代表芯片是否处于忙状态，BSY为1代表芯片忙 闪存的擦除和写入 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/gpio/",
    "title": "",
    
    "content": " 是什么 特点 不同型号，IO口数量可能不一样，可通过选型手册快速查询\n快速翻转，每次翻转最快只需要两个时钟周期（F1最高速度可以到50Mhz）\n每个IO口都可以做中断\n支持8种工作模式\n电气特性 基本结构 所有的GPIO都是挂载在APB2外设总线上的（每个GPIO包含16个引脚）\n在GPIO模块中包含寄存器和驱动器 寄存器是一段特殊的存储器，内核可以通过APB2总线对寄存器进行读写，这样就可以完成输出电平和读取电平的功能了，寄存器的每一位对应一个引脚，由于每个GPIO模块上面只有16个引脚，所以寄存器只有低16位用到了，高16位保留。驱动器用来增加信号的驱动能力，寄存器只负责存储数据。 端口的基本结构 保护二极管 对输入电压进行限幅，当电压比3.3v高，那么上方的保护二极管将会导通，电流就直接流到VDD，不会进入内部电路\n施密特触发器 在施密特触发器的箭头前面是数字量，在施密特触发器的后面的是模拟量\nP-MOS管和N-MOS管 输入输出模式 概述 输入输出都相对于ST芯片而言的，比如输入就是从io口进如芯片内部，输出就是信号从芯片到IO引脚\nGPIO八种模式 特点及应用 输入浮空 输入用，完全浮空，状态不定 输入上拉 输入用，用内部上拉，默认是高电平 输入下拉 输入用，用内部下拉，默认是低电平 模拟功能 ADC、DAC 开漏输出 软件IIC的SDA、SCL等 推挽输出 驱动能力强，25mA（max），通用输出 开漏式复用功能 片上外设功能（硬件IIC 的SDA、SCL引脚等） 推挽式复用功能 片上外设功能（SPI 的SCK、MISO、MOSI引脚等） 模式名称 性质 特征 浮空输入 数字输入 可读取引脚电平，若引脚悬空，则电平不确定 上拉输入 数字输入 可读取引脚电平，内部连接上拉电阻，悬空时默认高电平 下拉输入 数字输入 可读取引脚电平，内部连接下拉电阻，悬空时默认低电平 模拟输入 模拟输入 GPIO无效，引脚直接接入内部ADC 开漏输出 数字输出 可输出引脚电平，高电平为高阻态，低电平接VSS 推挽输出 数字输出 可输出引脚电平，高电平接VDD，低电平接VSS 复用开漏输出 数字输出 由片上外设控制，高电平为高阻态，低电平接VSS 复用推挽输出 数字输出 由片上外设控制，高电平接VDD，低电平接VSS 输入浮空 IO-\u0026gt;触发器-\u0026gt;读出\n模拟输入 模拟输入可以说是ADC模数转换器的专属配置\nIo-\u0026gt;模拟输入\n输入上拉 上下拉可以看作是一个弹簧，输入电压的时候就会操纵弹簧使电压为1或0.\n输入下拉 开漏输出 开漏复用输出 推挽输出 推挽复用输出 寄存器介绍 配置步骤 设置需要使用的GPIO外设时钟 设置GPIO模式（八种模式） 初始化GPIO口 int main(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); while (1) { GPIO_ResetBits(GPIOA, GPIO_Pin_0); Delay_ms(500); GPIO_SetBits(GPIOA, GPIO_Pin_0); Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET); Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET); Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)0); Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)1); Delay_ms(500); } } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/pwr/",
    "title": "",
    
    "content": " 概述 PWR(Power Control)电源控制，PWR负责管理STM32内部的电源供电部分，可以实现可编程电压监测器和低功耗模式的功能\n可编程电压监测器(PVD)可以监控VDD电源电压，当VDD下降到PVD阀值以下或上升到PVD阀值之上时，PVD会触发中断，用于执行紧急关闭任务\n低功耗模式包括：\n睡眠模式(Sleep) 停机模式(Stop) 待机模式(Standby) 可在系统空闲时，降低STM32的功耗，延长设备使用时间\n电源系统结构 VDDA供电区域，主要负责模拟部分的供电，包括AD转换、温度传感器、复位模块PLL。这些电路供电正极是VDDA，负极是VSSA，其中AD转换器还有两个参考电压引脚，分别为VREF+和VREF- 由两部分组成，左边部分是VDD供电区域，包括IO电路、待机电路、唤醒电路及看门狗，右边部分是VDD通过电压调节器，降压至1.8V，1.8v区域包括CPU核心、存储器和内置数字外设，stm32内部的关键电路，CPU、存储器和外设其实都是以1.8V的低电压运行的。当这些电路想要和外界进行交流时，才会通过IO电路转换到3.3v。==使用低电压运行的主要目的是为了降低功耗，电压越低，内部电路运行的功耗就相对越低== VBAT后备供电区域，其中包括LSE晶体震荡器、后备寄存器、RCC BDCR寄存器和RTC，其中有一个低电压检测开关，VDD有电时，由VDD供电，VDD没电时，由VBAT供电 电源监控 电源监控即对某些电源电压(VDD/VDDA/VBAT)进行监控。POR/PDR监控器、PVD监控器、BOR监控器、AVD监控器、VBAT阈值、温度阈值\nPOR/PDR(power on/down reset):上电/掉电复位 PVD(programmable voltage detector)):监控VDD电压 BOR(brown out reset):欠压复位 AVD(analog voltage detector)：监控VDDA电压 VBAT阈值(battery voltage thresholds)：监控VBAT电池电压 温度阈值(temperature thresholds):监控结温 注意：不同芯片包括的电源监控功能不同\n上电/掉电复位 当VDD或者VDDA电压过低时，内部电路会直接产生复位，让stm32复位，不能乱操作\n在POR和PDR之间设置了一个40mV的迟滞电压，大于POR产生复位，小于PDR时保持复位，设置两个阈值的作用就是防止电压在某个阈值附近波动时，造成输出也来回抖动\n电压检测器 PVD阈值电压可以使用程序指定，可以自定义调节\nPVD的输出信号可以去申请中断，这个中断申请是由外部中断实现的\n低功耗 STM32具有运行、睡眠、停止和待机四种工作模式。\n上电后默认是在运行模式，当内核不需要继续运行时，可以选择后面三种低功耗模式。\n睡眠模式 通过两个库函数进入睡眠模式：WFI和WFE，WFI和WFE是内核的指令\nWFI：wait for interrupt 等待中断，当中断发生，醒来之后的第一件事就是处理中断 WFE: wait for event 等待事件，这个事件可以事外部中断配置为事件模式，也可以是使能了中断，但是没有配置NVIC，调用的WFE进入的睡眠模式，产生唤醒事件时会立即醒来，醒来之后一般不需要进入中断函数，直接从睡眠的地方继续运行 停止模式 ==只有外部中断才能唤醒，其他中断唤醒不了。==\n当进入待机模式之后，将会关闭1.8v的时钟，也就是说CPU和外设均不可运行。定时器正在定时的会暂停，串口收发数据也会暂停，但是没有关闭电源，所以CPU和外设的寄存器数据都是维持原状的\n待机模式 只有几个指定的信号才能唤醒：\nWKUP引脚的上升沿 RTC闹钟事件 NRST引脚上的外部复位：也就是按下复位键也是可以唤醒的 IWDG复位 由于这里的电源关了，所以CPU和外设中的寄存器数据都是不能保持的\n低功耗模式表 从上到下功耗越来越低，且越来越难唤醒\n低功耗的启动方法就是关闭CPU时钟和关闭电源（电压调节器）\n模式 进入 唤醒 对内核电路时钟 影响 对VDD区 域时钟的影 响 电压调节器 睡眠 (立即休眠或 退出时休眠) WFI 、WFE 任意中断 唤醒事件 CPU时钟关，对 其他时钟或模拟 时钟源无影响 无 开 停止 PDDS和LPDS位 +SLEEPDEEP位 +WFI或WFE 任意外部中断（在外 部中断寄存器中设置) 关闭所有内核电 路时钟 HS和HSE 定) 的振荡器关闭 开启或处于低功 耗模式（依据电 源控制寄存器 PWR_CR的设 待机 PDDS位 +SLEEPDEEP位 +WFI或WFE WKUP引脚的上升沿、 RTC闹钟(唤醒/入侵/ 时间戳)事件、NRST 引脚上的外部复位、 IWDG复位 ： ： 关 三种模式下的功耗 同等条件下(T=25°C,VDD=3.3V,系统时钟72MHz)\n模式 主要影响 唤醒时间 供应电流(典型值) 正常模式 所有外设正常工作 0 51mA 睡眠模式 CPU时钟关闭 1.8us 29.5mA 停止模式 1.8V区域时钟关闭，电压调节器低功耗 5.4us 35uA 待机模式 1.8V区域时钟关闭，电压调节器关闭 50us 3.8uA 模式的选择 WFI和WFE是待机的触发条件，后面所有的寄存器配置都要在这两条指令之后。\n执行WFI(Wait For Interrupt)或者WFE(Vait For Event)指令后，STM32进入低功耗模式。\n睡眠模式 执行完WFI、WFE指令后，STM32进入睡眠模式，程序暂停运行，唤醒后程序从暂停的地方继续运行 SLEEPONEXIT位决定STM32执行完WFI或WFE后，是立刻进入睡眠，还是等STM32从最低优先级的中断处理程序中退出时进入睡眠 在睡眠模式下，所有的/○引脚都保持它们在运行模式时的状态 WFI指令进入睡眠模式，可被任意一个NVIC响应的中断唤醒 WFE指令进入睡眠模式，可被唤醒事件唤醒 停止模式 执行完WFI/WFE指令后，STM32进入停止模式，程序暂停运行，唤醒后程序从暂停的地方继续运行 1.8V供电区域的所有时钟都被停止，PLL、HSI和HSE被禁止，SRAM和寄存器内容被保留下来 在停止模式下，所有的/O引脚都保持它们在运行模式时的状态 当一个中断或唤醒事件导致退出停止模式时，HS被选为系统时钟 当电压调节器处于低功耗模式下，系统从停止模式退出时，会有一段额外的启动延时 WFI指令进入停止模式，可被任意一个EXTI中断唤醒 WFE指令进入停止模式，可被任意一个EXT事件唤醒 待机模式 执行完WFI/WFE指令后，STM32进入待机模式，唤醒后程序从头开始运行\n整个1.8V供电区域被断电，PLL、HSI和HSE也被断电，SRAM和寄存器内容丢失，只有备份的寄存器和待机电路维持供电\n在待机模式下，所有的/O引脚变为高阻态（浮空输入）\nWKUP引脚的上升沿、RTC闹钟事件的上升沿、NRST引脚上外部复位、IWDG复位退出待机模式\n实验 修改主频 [!TIP]\n注意，由于stm32处于低功耗的状态，所以下载的时候，需要先按住复位键，然后点击下载，松开复位键，这时候就能下载成功了\n首先需要修改文件夹(包含时钟的c文件)的属性，从只读变为可读可写\n睡眠模式 u8 rxData; int main(void){ serial_init(); Led_Init(); serial_printf(\u0026#34;SYSCLK: %d\\n\u0026#34;,SystemCoreClock); while(1){ if(serial_getRxFlag() == 1){ rxData = serial_getRxData(); serial_printf(\u0026#34;receive the data: %x\\n\u0026#34;,rxData); } Led_On(); //如果设备不处于睡眠模式，将会led将会一闪一闪，否则led就灭 Delay_s(1); Led_Off(); Delay_s(1); __WFI(); //实际上是一条汇编指令，睡眠模式只需要使用这一个代码即可 } } 停止模式 int main(void){ serial_init(); redRation_Init(); Led_Init(); Led_Off(); RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE); //开启PWR时钟 while(1){ Led_On(); Delay_s(1); Led_Off(); Delay_s(1); PWR_EnterSTOPMode(PWR_Regulator_ON,PWR_STOPEntry_WFI); //使用WFI模式进入停止模式，这个函数将会将所有的寄存器都配置好 SystemInit(); //由于从停止模式唤醒之后，系统将会启动HSI内部时钟，所以当唤醒时，我们需要调用该函数重新配置系统时钟 } } 待机模式 int main(void){ serial_init(); myrtc_init(); u32 alarm = RTC_GetCounter() + 10; RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE);\t//开启PWR时钟 RTC_SetAlarm(alarm);\t//设置闹钟值 serial_printf(\u0026#34;the alarm is %d\\n\u0026#34;,alarm); while(1){ serial_printf(\u0026#34;the counter is %d\\n\u0026#34;,RTC_GetCounter());\t//获取实时时钟计数值 serial_printf(\u0026#34;the alrf is %d\\n\u0026#34;,RTC_GetFlagStatus(RTC_FLAG_ALR));\t//获取闹钟产生的信号 PWR_EnterSTANDBYMode();\t//进入待机模式 } } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/rtc/",
    "title": "",
    
    "content": " 时间戳 概述 Unix时间戳(Unix Timestamp)定义为从UTC/GMT的1970年1月1日0时0分0秒开始所经过的秒数，不考虑闰秒\n时间戳存储在一个秒计数器中，秒计数器为32位/64位的整型变量\n世界上所有时区的秒计数器相同，不同时区通过添加偏移来得到当地时间\nGMT和UTC GMT(Greenwich Mean Time)格林尼治标准时间是一种以地球自转为基础的时间计量系统。它将地球自转一周的时间间隔等分为24小时，以此确定计时标准\nUTC(Universal Time Coordinated)协调世界时是一种以原子钟为基础的时间计量系统。它规定铯133原子基态的两个超精细能级间在零磁场下跃迁辐射9,192,631,770周所持续的时间为1秒。当原子钟计时一天的时间与地球自转一周的时间相差超过0.9秒时，UTC会执行闰秒来保证其计时与地球自转的协调一致\n时间戳转换 函数 作用 time_t time(time_t*); 获取系统时钟 struct tm* gmtime(const time_t*); 秒计数器转换为日期时间（格林尼治时间） struct tm* localtime(const time_t*); 秒计数器转换为日期时间（当地时间） time_t mktime(struct tm*); 日期时间转换为秒计数器（当地时间） char* ctime(const time_t*); 秒计数器转换为字符串（默认格式） char* asctime(const struct tm*); 日期时间转换为字符串（默认格式） size_t strftime(char*, size_t, const char*, const struct tm*); 日期时间转换为字符串（自定义格式） [!TIP]\n需要引入time.h才可以使用上述函数\n实验：时间戳转换\n#include\u0026lt;time.h\u0026gt; time_t time_cnt; //秒计数器 struct tm time_date; //日期时间数据类型 char* time_str; //字符串数据类型 int main(void){ time_cnt = time(NULL); //这里的time_cnt实际上就是一个长整秒，int64类型的 time(\u0026amp;time_cnt); //和上面的代码作用一样 time_date = *gmtime(\u0026amp;time_cnt); //加上*就可以取结构体的内容，将长整秒转换为伦敦时间，也就是格林尼治时间 time_date.tm_year += 1900; //由于时间的基准是1900年，所以需要加上1900 time_date.tm_mon += 1; time_date = *localtime(\u0026amp;time_cnt); //转换长整秒为当地时间，该函数会将时间转换为当地时间 time_cnt = mktime(\u0026amp;time_date); //是转换的逆过程，也就是将日期时间转换为长整秒 time_str = ctime(\u0026amp;time_cnt); //将长整秒转换为字符串 time_str = asctime(\u0026amp;time_date); //将数据类型转换为字符串类型 char t[50]; strftime(t,50,\u0026#34;%H-%M-%S\u0026#34;,\u0026amp;time_date); //类似于printf函数，将数据类型字符串化，可以自定义输出 } RTC 实时时钟(Real Time Clock,RTC),本质是一个计数器，计数频率常为秒，专门用来记录时间。\n[!NOTE]\n普通定时器拿来作时钟可行吗？\n普通定时器无法掉电运行！\nRTC特性\n能提供时间（秒钟数） 能在MCU掉电后运行 低功耗 RTC有以下特点及功能\nRTC是一个独立的定时器，可为系统提供时钟和日历的功能 RTC和时钟配置系统处于后备区域，系统复位时数据不清零，VDD(2.0 ~ 3.6V)断电后可借助VBAT（1.8~3.6V)供电继续走时 32位的可编程计数器，可对应Unix时间戳的秒计数器 20位的可编程预分频器，可适配不同频率的输入时钟 可选择三种RTC时钟源： HSE时钟除以128（通常为8MHz/128) LSE振荡器时钟（通常为32.768KHz) LSI振荡器时钟(40KHz) 常见的解决方案 对比因素 内部RTC 外置RTC 信息差异 提供秒/亚秒信号 提供秒信号和日历 功耗 功耗高 功耗低 体积 不用占用额外体积 体积大 成本 成本低 成本高 [!TIP]\n一般都需要设计RTC外围电路； 一般都可以给RTC设置独立的电源； 多数RTC的寄存器采用BCD码存储 框图 RTC时钟来源：\n接高速晶振，一般接主晶振（8MHz），通过128分频，可以产生RTCCLK时钟。为了在RTC的时钟为1Hz，所以使用高速时钟的时候需要先进行128倍分频 接低速晶振，可以直接给RTCCLK，OSC32的晶振是内部RTC的专用时钟，这个晶振的值不是随便选的，一般和RTC有关的，都是统一的数值，就是32.768KHz（2的次方数15次方），需要注意的是，只有OSC32这个时钟在设备断电后是由VBAT提供电源，其他的LSI和HSE都不接VBAT，所以最好使用OSC32 [!NOTE]\n框图中的组件：\nRTC预分频器 32位可编程计数器 待机唤醒 RTC控制寄存器与APB1接口 3个时钟源：\nHSE/128 LSI 40kHz LSE 32.768kHz RTC预分频器： 一般来说RTCCLK进来都不是1MHz的，所以需要进行分频，这个分频器由两个寄存器组成重装载寄存器（RTC_PRL）和余数寄存器（RTC_DIV）。\n我们在RTC_PRL中写入6，则代表7分频，因为是从零开始的。\nRTC_DIV实际上就是一个计数器，当计数记到7时，自然溢出，产生一个时钟，这就是分频的原理，这里的div是一个递减计数器，每来一个输入时钟，DIV的值就自减一次，当自减为0时，再来一个输入时钟，产生一个溢出信号，同时DIV从PRL获取重装值，继续自减。\n32位可编程计数器 我们可以将这个计数器看作是unix时间戳的秒计数器，所以我们可以使用time.h头文件中的函数读取并且转换时间\n此外，这里还有一个RTC_ALR闹钟寄存器，32位寄存器，在ALR中写入一个秒数，设置一个闹钟，当CNT的值和闹钟值相等时，这时就会产生RTC_Alarm闹钟信号，通往右边的中断系统，在中断函数中就可以执行相应的操作了，同时，这个闹钟还可以让STM32退出待机模式\n待机唤醒 闹钟信号和wake up引脚都可以唤醒设备\n中断系统 将会产生三个中断：\nRTC_Second（秒中断）：每秒进入一次中断 RTC_Overflow（溢出中断）：32位的计数器记满溢出，将会产生一个中断 RTC_Alarm（闹钟中断）：当计数器和闹钟值相等时，将会产生一个中断 简易框图 注意事项 执行以下操作将使能对BKP和RTC的访问： 设置RCC APB1ENR的PWREN和BKPEN,使能PWR和BKP时钟 设置PWR CR的DBP,使能对BKP和RTC的访问 若在读取RTC寄存器时，RTC的APB1接口曾经处于禁止状态，则软件首先必须等待RTC CRL寄存器中的RSF位（寄存器同步标志）被硬件置1 必须设置RTC CRL寄存器中的CNF位，使RTC进入配置模式后，才能写入RTC_PRL、RTC_CNT、RTC_ALR寄存器 对RTC任何寄存器的写操作，都必须在前一次写操作结束后进行。可以通过查询RTC_CR寄存器中的RTOFF,状态位，判断RTC寄存器是否处于更新中。仅当RTOFF状态位是1时，才可以写入RTC寄存器 BKP BKP(Backup Registers)是备份寄存器\nBKP可用于存储用户应用程序数据。当VDD(2.0-3.6V)电源被切断，他们仍然由VBAT(1.8~3.6V)维持供电。当系统在待机模式下被唤醒，或系统复位或电源复位时，他们也不会被复位\nTAMPER引脚产生的侵入事件将所有备份寄存器内容清除\nRTC引脚输出RTC校准时钟、RTC闹钟脉冲或者秒脉冲\n存储RTC时钟校准寄存器\n用户数据存储容量：20字节（中容量和小容量)/84字节（大容量和互联型)\n[!tip]\n橙色部分就是后备区域，当VDD主电源掉电时，后备区域仍然可以由VBAT的备用电池供电，当VDD主电源上电时，后备区域供电就会由VBAT切换到VDD\n实验 测试备份数据寄存器 int main(void){ serial_init(); RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE); PWR_BackupAccessCmd(ENABLE); //备份访问控制 // BKP_WriteBackupRegister(BKP_DR1,0x1234); serial_printf(\u0026#34;the backup value is %x\\n\u0026#34;, BKP_ReadBackupRegister(BKP_DR1)); } 实时时钟 u16 myRtc_time[] = {2023,1,1,23,59,59}; //注意在写数据时最好不要在前面随便补零，因为c语言中的0代表了八进制 void myrtc_init(void) { RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE); PWR_BackupAccessCmd(ENABLE); //备份访问控制 if(BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5){ //当系统完全断电时，BKP_DR1必定为0，所以将会执行以下代码,复位bkp的寄存器也不会为0 // RCC_LSEConfig(RCC_LSE_ON); //配置外部时钟 // while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET); //LSE并不是说启动就能启动的，所以需要等待标志位变为1 // RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE); //选择LSE作为时钟源 RCC_LSICmd(ENABLE); //当LSE起振不了将会一直卡在读取标志位的地方，可以采用LSI while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET); RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI); RCC_RTCCLKCmd(ENABLE); RTC_WaitForSynchro(); //等待同步 RTC_WaitForLastTask(); //等待上次写入操作完成 // RTC_SetPrescaler(32768 - 1); //设置分频系数，我们选择的是LSE，LSE的晶振频率为32.768Khz，也就是32768HZ，如果想要变成1hz，那么就要32768分频 RTC_SetPrescaler(40000 - 1); RTC_WaitForLastTask(); //等待写入完成 myrtc_setTime(); BKP_WriteBackupRegister(BKP_DR1,0xA5A5); //第一次启动完毕之后，将这个标志位置为0xA5A5 }else{ RTC_WaitForSynchro(); //等待同步 RTC_WaitForLastTask(); //等待上次写入操作完成 } } void myrtc_setTime(void) { time_t time_cnt; struct tm time_date; time_date.tm_year = myRtc_time[0] - 1900; //需要先设置一个初始化时间 time_date.tm_mon = myRtc_time[1] - 1; time_date.tm_mday = myRtc_time[2]; time_date.tm_hour = myRtc_time[3]; time_date.tm_min = myRtc_time[4]; time_date.tm_sec = myRtc_time[5]; time_cnt = mktime(\u0026amp;time_date); //将日期数据类型转换为长整秒 // time_cnt = time_cnt - 8 * 60 * 60; //适应于北京时间 RTC_SetCounter(time_cnt); RTC_WaitForLastTask(); } void myrtc_readTime(void) { time_t time_cnt; struct tm time_date; time_cnt = RTC_GetCounter(); // time_cnt = time_cnt + 8 * 60 * 60; //这样就可以计算出北京时间了，也就是在小时的位加上8 time_date = *localtime(\u0026amp;time_cnt); myRtc_time[0] = time_date.tm_year + 1900; //需要先设置一个初始化时间 myRtc_time[1] = time_date.tm_mon + 1; myRtc_time[2] = time_date.tm_mday; myRtc_time[3] = time_date.tm_hour; // myRtc_time[4] = time_date.tm_min; myRtc_time[5] = time_date.tm_sec; } int main(void){ serial_init(); myrtc_init(); while(1){ myrtc_readTime(); serial_printf(\u0026#34;date: %d-%d-%d\\n time: %d-%d-%d\\n\u0026#34;,myRtc_time[0],myRtc_time[1],myRtc_time[2],myRtc_time[3],myRtc_time[4],myRtc_time[5]); } } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/timer/",
    "title": "",
    
    "content": " 定时器概述 定时器分类 定时器类型 主要功能 基本定时器 没有输入输出通道，常用作时基，即定时功能 通用定时器 具有多路独立通道，可用于输入捕获/输出比较，也可用作时基 高级定时器 除具备通用定时器所有功能外，还具备带死区控制的互补信号输出、刹车输入等功能（可用于电机控制、数字电源设计等） 特性表 滴答定时器 SystemCoreClock / 1000 表示配置 SysTick 定时器以 1ms 的间隔触发中断。具体来说，SysTick 定时器是一个递减计数器，当计数器递减到零时会触发中断，然后自动重新加载初始值继续计数。通过设置初始值为 SystemCoreClock / 1000，我们可以使 SysTick 定时器每经过 1ms 触发一次中断。\n解释 SystemCoreClock 是系统核心时钟频率，单位是 Hz。它表示每秒钟内系统时钟的震荡次数。例如，如果 SystemCoreClock 是 84MHz（84,000,000 Hz），则表示每秒钟系统时钟震荡 84,000,000 次。\nSysTick_Config(SystemCoreClock / 1000) 将 SysTick 定时器的重装载值（reload value）设置为 SystemCoreClock / 1000。重装载值是 SysTick 计数器从这个值开始递减的初始值。\n为什么是 1ms：\n假设 SystemCoreClock 是 84MHz。 SystemCoreClock / 1000 等于 84,000,000 / 1000 = 84,000。 这意味着 SysTick 计数器从 84,000 开始递减，每个时钟周期递减一次。 因为系统时钟频率是 84MHz，即每秒钟有 84,000,000 个时钟周期，所以每 1,000 个时钟周期表示 1ms（1,000,000 / 1,000 = 1ms）。 当 SysTick 计数器从 84,000 递减到 0 时，刚好经过了 1ms，然后触发中断，并重新加载为 84,000 继续递减。 SysTick_Config 函数 SysTick_Config 是一个方便的函数，用于配置 SysTick 定时器并启用中断。其原型通常如下：\nuint32_t SysTick_Config(uint32_t ticks); 参数 ticks 是重装载 …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/usart/",
    "title": "",
    
    "content": " 数据通信基础 串行/并行通信 单工/半双工/全双工通信 同步/异步通信 波特率 常见通信接口 名称 引脚 双工 时钟 电平 设备 USART TX、RX 全双工 异步 单端 点对点 I2C SCL、SDA 半双工 同步 单端 多设备 SPI SCLK、MOSI、MISO、CS 全双工 同步 单端 多设备 CAN CAN_H、CAN_L 半双工 异步 差分 多设备 USB DP、DM 半双工 异步 差分 点对点 串口 概念 RS232 VS CMOS/TTL 串口参数及时序 RS232通信 USB通信 电平的区别 USART 简介 主要特征 框图 串口数据低位先行\n框图简化版 数据帧 这里的字长就是数据位长度，空闲帧和断开帧是局域网协议用的，我们的串口用不到\n停止位分别为1、1.5、2、0.5，意思就是0.5个时长\n要保证在采样的时候，数据在时钟边沿的中间，这样可以保证数据的可靠性\n当输入电路侦测到一个数据帧的起始位后，就会以波特率的频率，连续采样一帧数据，同时，从起始位置开始，采样位置就要对齐到位的正中间\n首先数据的部分电路对采样的时钟进行了细分，他会以波特率的16倍进行采样，也就是说，在一位的时间内，可以进行16次采样，采样策略为\n最开始，空闲状态高电平，采样一直为1，在某个位置突然采样采到一个0，就说明出现了下降沿，这个时候在理想情况下应该就要开始采样了，在起始位，会进行16次连续采样，没有噪声的话，那么这16次采样应该都为0，因为串口协议的起始就是检测到下降沿，实际电路还是会出现一点噪声的，所以即使出现下降沿，后续也要再采样几次，以防万一， 设置波特率 波特率的产生实际上就是一个预分频的过程，这里的16就是上面的内部还有一个16倍的采样时钟\n数据模式 实验 简单的发送数据 void serial_init() { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStruct.GPIO_Pin = SERIAL_TX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); USART_InitTypeDef USART_InitStruct; USART_InitStruct.USART_BaudRate = 115200; USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStruct.USART_Mode = USART_Mode_Tx; USART_InitStruct.USART_Parity = USART_Parity_No; USART_InitStruct.USART_StopBits = USART_StopBits_1; USART_InitStruct.USART_WordLength = USART_WordLength_8b; USART_Init(USART2,\u0026amp;USART_InitStruct); USART_Cmd(USART2,ENABLE); } void serial_sendByte(u8 byte) { USART_SendData(USART2,byte); while(USART_GetFlagStatus(USART2,USART_FLAG_TXE) == RESET); } void serial_sendArray(u8 *array,u16 length) { for(u16 i = 0; i \u0026lt; length; i++){ serial_sendByte(array[i]); } } void serial_sendString(char *str) { for(u8 i = 0;str[i] != \u0026#39;\\0\u0026#39;;i++){ serial_sendByte(str[i]); } } u32 serial_pow(u32 x, u32 y) { u32 result = 1; while(y--){ result *= x; } return result; } //将数字以字符的样式发送 void serial_sendNum(u32 number, u8 length) { for(u8 i = 0; i \u0026lt; length; i++){ serial_sendByte(number / serial_pow(10,length - i -1) % 10 + \u0026#39;0\u0026#39;); } } int main(void){ char str[50]; u8 test[] = {0x42,0x43,0x44,0x45}; serial_init(); serial_sendArray(test,4); serial_sendNum(12345,5); while(1){ // sprintf(str,\u0026#34;%x: %hu %hu\\n\u0026#34;,(u32)adValue,adValue[0],adValue[1]); // send_string(str); } } printf重定向 如果想要使用printf函数，需要先使用microlib库\n注意需要引入stdio头文件，还需要重写fputc\n//重写这个函数用于重定向printf函数，这个函数是printf的底层函数，printf在打印的时候就是不断调用这个函数来一个一个打印的 int fputc(int ch, FILE *file) { serial_sendByte(ch); return ch; } 重写完这个函数就可以正常使用printf函数了\n如果想要让printf使用多个串口，那么就需要sprintf函数\nsprintf(str,\u0026#34;%x: %hu %hu\\n\u0026#34;,(u32)adValue,adValue[0],adValue[1]); serial_sendString(str); 为了方便，我们也可以封装sprintf函数，在封装sprintf的时候需要引入头文件stdarg.h头文件。\nvoid serial_printf(char *format, ...) { char string[100]; va_list arg; va_start(arg,format); vsprintf(string,format,arg); va_end(arg); serial_sendString(string); } 解决汉字乱码的情况，如果使用的编码格式为utf-8，则需要先设置编译参数\u0026ndash;no-multibyte-chars\n接收数据 需要修改初始化函数，分为查询式和中断式\n//查询式 void serial_init() { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStruct.GPIO_Pin = SERIAL_TX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStruct.GPIO_Pin = SERIAL_RX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); USART_InitTypeDef USART_InitStruct; USART_InitStruct.USART_BaudRate = 115200; USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; USART_InitStruct.USART_Parity = USART_Parity_No; USART_InitStruct.USART_StopBits = USART_StopBits_1; USART_InitStruct.USART_WordLength = USART_WordLength_8b; USART_Init(USART2,\u0026amp;USART_InitStruct); USART_Cmd(USART2,ENABLE); } int main(void){ u8 rxData; serial_init(); while(1){ if(USART_GetFlagStatus(USART2,USART_FLAG_RXNE) == SET){ rxData = USART_ReceiveData(USART2); serial_printf(\u0026#34;receive: %x\\n\u0026#34;,rxData); } } } //中断式 void serial_init() { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStruct.GPIO_Pin = SERIAL_TX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStruct.GPIO_Pin = SERIAL_RX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); USART_InitTypeDef USART_InitStruct; USART_InitStruct.USART_BaudRate = 115200; USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; USART_InitStruct.USART_Parity = USART_Parity_No; USART_InitStruct.USART_StopBits = USART_StopBits_1; USART_InitStruct.USART_WordLength = USART_WordLength_8b; USART_Init(USART2,\u0026amp;USART_InitStruct); USART_ITConfig(USART2,USART_IT_RXNE,ENABLE); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitTypeDef NVIC_InitStruct; NVIC_InitStruct.NVIC_IRQChannel = USART2_IRQn; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1; NVIC_Init(\u0026amp;NVIC_InitStruct); USART_Cmd(USART2,ENABLE); } u8 serial_rxData,serial_rxFlag; void USART2_IRQHandler(void) { if(USART_GetFlagStatus(USART2,USART_IT_RXNE) == SET){ serial_rxData = USART_ReceiveData(USART2); serial_rxFlag = 1; USART_ClearITPendingBit(USART2,USART_IT_RXNE); } } u8 serial_getRxFlag(void) { if(serial_rxFlag == 1){ serial_rxFlag = 0; return 1; } return 0; } u8 serial_getRxData(void) { return serial_rxData; } int main(void){ u8 rxData; serial_init(); while(1){ if(serial_getRxFlag() == 1){ rxData = serial_getRxData(); serial_printf(\u0026#34;receive %x\\n\u0026#34;,rxData); } } } 数据包的收发 HEX数据包 文本数据包 实验代码 void serial_sendPacket(void) { serial_sendByte(0xFF); serial_sendArray(serial_txPacket,4); serial_sendByte(0xFE); } u8 serial_rxData,serial_rxFlag; u8 serial_txPacket[4],serial_rxPacket[4]; void USART2_IRQHandler(void) { static u8 rxState = 0; static u8 counter = 0; if(USART_GetFlagStatus(USART2,USART_IT_RXNE) == SET){ u8 rxData = USART_ReceiveData(USART2); if(rxState == 0){ if(rxData == 0xff){ rxState = 1; counter = 0; } }else if(rxState == 1){ serial_rxPacket[counter++] = rxData; if(counter \u0026gt;= 4){ rxState = 2; } }else if(rxState == 2){ if(rxData == 0xfe){ rxState = 0; serial_rxFlag = 1; } } } } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/wdg/",
    "title": "",
    
    "content": " WDG 简介 IWDG VS WWDG IWDG独立看门狗 WWDG窗口看门狗 复位 计数器减到0后 计数器T[5:0]减到0后、过早重装计数器 中断 无 早期唤醒中断 时钟源 LSI（40KHz） PCLK1（36MHz） 预分频系数 4、8、32、64、128、256 1、2、4、8 计数器 12位 6位（有效计数） 超时时间 0.1ms~26214.4ms 113us~58.25ms 喂狗方式 写入键寄存器，重装固定值RLR 直接写入计数器，写多少重装多少 防误操作 键寄存器和写保护 无 用途 独立工作，对时间精度要求较低 要求看门狗在精确计时窗口起作用 溢出时间计算原理 计算步骤如下\n首先需要知道看门狗的时钟频率，假设是60kHz 设置分频系数，现在设置为8分频，那么分完频之后的时钟就是60_000Hz / 8=75_00Hz,也就是1s跳动7500次 如果想要设置溢出时间为0.5s的话，那么就是用0.5*7500=3750，就是设置为3750 IWDG 概述 作用 工作原理 框图 实际上就是一个递减计数器，在程序运行期间，适当的提高计数值就可以避免出现复位，手动重装重装载寄存器的操作就是喂狗,递减计数器是12位的，所以最大的计数是 $2 ^ {12}-1 = 4095$。\n当递减计数器自减到0时，会产生一个IWDG的复位信号\n当我们在重装载寄存器中写好值之后，在键寄存器里写一个特定的数据，控制电路进行喂狗，这个时候重装值就会将数值赋给当前计数器\n下图分为上下两部分，上面部分工作在1.8v电压下，下面部分工作在VDD电压下\n键寄存器 由于IWDG_SR是写保护的，所以不用担心该寄存器被干扰，为了防止另外两个寄存器受到干扰，使用键寄存器对寄存器进行写保护，一旦两个寄存器写入之后会被再次保护起来\n配置寄存器 计算溢出时间 WWDG 概述 作用 工作原理 中断产生在复位的前一刻，复位产生时间0x3f，中断产生时刻0x40\n框图 这里的WDGTB和上面的PSC都是一个东西，都是预分频器\n从T6-T0一共七个位，但是却是6位递减计数器，实际上只有T5-T0是计数器，T6用作溢出标志位，T6位为1时，表示计数器未溢出，T6位为0时，表示计数器溢出\n假设我们初始时写入111_1111,依次递减111_1110-\u0026gt;111_1101……直到减到100_0000（0x40）时，如果再向下减，T6位将会变为0，T6将会产生一个信号去往或门\nWDGA是激活位，也就是使能位，WDGA写入1，启用窗口看门狗\n计算最早界限计数值\nW6-W0中是最早界限计数值，这些值写入之后是固定不变的，一旦执行写入CR操作时，与门打开，写入CR其实就是写入计数器，也就是喂狗\n喂狗时，比较器开始工作，当前计数器T6-0 \u0026gt; 窗口值W6-0，比较结果为1，通过或门，产生复位信号\n也就是说喂狗的时候，把当前计数值和预设的窗口计数值进行比较，如果发现狗的余粮还比较充足，但是喂的很频繁，那必定是存在问题的，所以会产生一个复位信号\n工作特性 计算溢出时间 乘以4096的原因是在LSI时钟信号后面有一个固定的4096分频\n实验 IWDG int main(void){ serial_init(); key_init(); if(RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET){ serial_printf(\u0026#34;IWDG RST!\\n\u0026#34;); RCC_ClearFlag(); }else{ serial_printf(\u0026#34;RST!\\n\u0026#34;); } IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); //解除写使能，可以往键寄存器中写入数据 IWDG_SetPrescaler(IWDG_Prescaler_16); //设置预分频，现设置超时时间为1s，那就要求喂狗时间不能超过1s，需要查看手册，选择合适的分频系数 IWDG_SetReload(2499); //设置重装值，通过公式计算，重装值计算：rlr = 1 * 40000 / 16 = 2500 IWDG_ReloadCounter(); //先喂一次狗 IWDG_Enable(); //启动看门狗 while(1){ getKey(); IWDG_ReloadCounter(); //喂狗 serial_printf(\u0026#34;FEED!\\n\u0026#34;); Delay_ms(300); serial_printf(\u0026#34;\\n\u0026#34;); Delay_ms(300); } } WWDG int main(void){ serial_init(); key_init(); if(RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET){ serial_printf(\u0026#34;WWDG RST!\\n\u0026#34;); RCC_ClearFlag(); }else{ serial_printf(\u0026#34;RST!\\n\u0026#34;); } RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG,ENABLE); //wwdg和iwdg不同，wwdg的时钟来源是APB1 WWDG_SetPrescaler(WWDG_Prescaler_8); //设置预分频,我们想要设置超时时间为50ms，T = 0.05 * 36000000 /4096/ 2^3 = 54.93164 = 55,所以T[5:0] = 54 WWDG_SetWindowValue(21 | 0x40); //设置窗口值，我们窗口时间设置为30ms，窗口时间W = 54 - 0.03 * 36000000 / 4096/2^3 = 54 - 33 = 21 WWDG_Enable(54 | 0x40); //这里使用|0x40的目的是为了让T[6]=1 while(1){ getKey(); serial_printf(\u0026#34;FEED!\\n\u0026#34;); Delay_ms(10); serial_printf(\u0026#34;\\n\u0026#34;); Delay_ms(20); WWDG_SetCounter(54 | 0x40); //喂狗，这里不能再WWDG_ENABLE后面直接喂狗，因为执行时间太短，在非窗口期喂狗是会复位的 } } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/%E4%B8%AD%E6%96%AD/",
    "title": "",
    
    "content": " 概述 打断CPU执行正常的程序，转而处理紧急程序，然后返回原暂停的程序继续运行，就叫中断\n中断的作用和意义 实时控制:在确定时间内对相应事件作出响应，如：温度监控 故障处理:检测到故障，需要第一时间处理，如：电梯门夹人了 数据传输:不确定数据何时会来，如：串口数据接收 [!IMPORTANT]\n中断的意义：高效处理紧急程序，不会一直占用CPU资源\n中断的外部简图 执行流程 NVIC 基本概念 用于统一分配中断优先级和管理中断的\n==Nested vectored interrupt controller==,嵌套向量中断控制器，属于内核(M3/4/7)\nNVIC支持：256个中断(16内核+240外部)，支持：256个优先级，允许裁剪！\nSTM32型号 内核中断 外部中断 中断优先级 STM32F103xx 10 60 16 STM32F407xx 10 82 16 STM32F429xx 10 91 16 STM32F750xx 10 98 16 STM32F767xx 10 110 16 STM32H743xx 10 150 16 STM32H750xx 10 150 16 中断向量表 定义一块固定的内存，以字节对齐，存放各个==中断服务函数程序的首地址==。\n中断向量表定义在==启动文件中==，当发生中断，CPU会自动执行对应的中断服务函数\n相关寄存器 NVIC相关寄存器 位数 寄存器个数 备注 中断使能寄存器（ISER) 32 8 每个位控制一个中断 中断除能寄存器（ICER) 32 8 每个位控制一个中断 应用程序中断及复位控制寄存器（AIRCR) 32 1 位[10:8]控制优先级分组 中断优先级寄存器 （IPR) 8 240 8个位对应一个中断，而 STM32只使用高4位 NVIC还有：中断挂起，解挂，激活标志等非常用功能。\n基本结构 NVIC是一个内核外设，是CPU的小助手\n下图为外部中断，其中的n代表一个外设可能同时占用多个中断通道，所以有n条线\nNVIC只有一个输出口，NVIC根据每个中断的优先级分配中断的先后顺序，通过一个输出口告诉CPU应该处理哪个中断\n中断优先级 ==抢占优先级==(pre):高抢占优先级可以打断正在执行的低抢占优先级中断 ==响应优先级==(sub):当抢占优先级相同时，响应优先级高的先执行，但是不能互相打断 抢占和响应都相同的情况下，自然优先级越高的，先执行 ==自然优先级==：中断向量表的优先级 数值越小，表示优先级越高 [!IMPORTANT]\n抢占优先级 \u0026gt; 响应优先级 \u0026gt; 自然优先级\nNVIC的中断优先级由优先级寄存器的4位(0~15)决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队\n优先级分组 AIRCR[10:8] IPRx bit[7:4]分 配 分配结果 0 111 None : [7:4] 0位抢占优先级，4位响应优先级 1 110 [7] : [6:4] 1位抢占优先级，3位响应优先级 2 101 [7:6] : [5:4] 2位抢占优先级，2位响应优先级 3 100 [7:5] : [4] 3位抢占优先级，1位响应优先级 4 011 [7:4] : None 4位抢占优先级，0位响应优先级 [!note]\n特别提示：一个工程中，一般只设置一次中断优先级分组。\n编号 自然优先级 对应外设 抢占 响应 执行顺序 3 10 RTC 2 1 2 6 13 EXTI0 3 0 4 7 14 EXTI1 2 0 1 -1 6 Systick 3 0 3 [!note]\nEXTI1和RTC可以打断：EXTIO和Systick的中断，获得优先执行！\nEXTI External(Extended)interrupt/event Controller,外部（扩展）中断事件控制器包含20个产生事件/中断请求的边沿检测器，即总共：20条EXTI线(F1)\n中断和事件的理解：\n中断：要进入NVIC,有相应的中断服务函数，需要CPU处理 事件：不进入NVIC,仅用于内部硬件自动控制的，如：TIM、DMA、ADC 产生的中断和事件都会有他们的响应函数\n中断响应申请中断，让CPU执行中断函数 事件响应，外部中断信号不会通向CPU,而是通向其他外设，用来触发其他外设的操作(ADC转换、DMA等) EXTI(Extern Interrupt)外部中断\nEXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序 支持的触发方式：上升沿/下降沿/双边沿/软件触发 支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断 通道数：16个GPIO Pin,外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒 触发响应方式：中断响应/事件响应 [!tip]\n当有多个中断引脚的时候，我们需要选择不同PIN的引脚，比如PA10和PB10就不能同时作为中断引脚\n事件请求表 中断线 F1 F4 F7 H7 EXTI线015：对应GPIO PIN 015 ✔ ✔ ✔ ✔ EXTI线16：PVD输出 ✔ ✔ ✔ 参考H7参考手册（中文版）657页 EXTI线17：RTC闹钟事件 ✔ ✔ ✔ EXTI线18：USB OTG FS唤醒事件 ✔ ✔ ✔ EXTI线19：以太网唤醒事件 ✔ ✔ EXTI线20：USB OTG HS唤醒事件 ✔ ✔ EXTI线21：RTC 入侵和时间戳事件 ✔ ✔ EXTI线22：RTC 唤醒事件 ✔ ✔ EXTI线23：LPTIM1 异步事件 ✔ … 整体结构 每个GPIO端口有16个引脚，而EXTI实际上只有16个通道，所以==每个端口只能有一个中断引脚==，GPIO口加上PVD、RTC、USB、ETH等一共20个信号。\n[!TIP]\n注意，EXTI 5 ~ 9使用同一个中断函数，EXTI 10 ~ 15使用一个中断函数，所以在写中断函数的时候，我们需要根据标志位来区分是哪个中断\n到其他外设的20个信号是事件触发时的信号\n信号方向：==输入线 \u0026gt; 边沿检测电路（用于上升沿触发或者下降沿触发）\u0026gt; 检测上升沿、下降沿、双边沿及软件触发 \u0026gt; 出现分支==\n中断：==如果请求挂起寄存器置1 \u0026gt; NVIC中断控制器== 事件：通过事件屏蔽寄存器做一个开关的作用 -\u0026gt; 脉冲发生器，给一个电平脉冲，用来触发其他外设的动作 AFIO Alternate Function IO,即复用功能lO,主要用于重映射和外部中断映射配置\n调试I○配置：AFIO MAPR[26:24],配置JTAG/SWD的开关状态\n重映射配置：AFIO MAPR,部分外设IO重映射配置\n外部中断配置：AFIO EXTICR1 ~ 4,配置EXTI中断线0 ~ 15对应具体哪个1O口\n[!NOTE]\n特别注意：配置AFIO寄存器之前要使能AFIO时钟，方法如下： HAL RCC AFIO CLK ENABLE(); 对应RCC APB.2ENR寄存器位0\nAFIO主要完成两个任务：\n复用功引脚重映射 中断引脚选择 如将GPIO A PIN1引脚作为TIM1的引脚\nEXTI和IO的对应关系 这里可以看出来一条线只能对应一个口，如不能同时使用PA0和PB0，只能从P[A~K]0中选一个\n中断配置 中断配置步骤：\n使能GPIO时钟：使能GPIO时钟 设置GPIO输入模式：上/下拉/浮空输入 使能AFIO/SYSCFGI时钟：设置AFIO/SYSCFGE时钟开启寄存器 设置EXTI和IO对应关系 设置EXTI屏蔽，上/下：设置EXTI对应通道前的屏蔽和上升沿/下降沿确发，IMR、RTSR/FTSR沿 设置NVIC：分3步：设置优先级分组、设置优先级、使能中断 设计中断服务函数：编写对应中断的中断服务函数！清中断标志！ 实验 void GPIO_init(){\t//配置GPIO和AFIO时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //配置GPIO GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB,\u0026amp;GPIO_InitStructure); //配置AFIO GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource9); //配置EXTI EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line = EXTI_Line9; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(\u0026amp;EXTI_InitStructure); //配置NVIC NVIC_InitTypeDef NVIC_InitStruct; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); NVIC_InitStruct.NVIC_IRQChannel = EXTI9_5_IRQn; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 3; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 3; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(\u0026amp;NVIC_InitStruct); } void EXTI9_5_IRQHandler(void){ if(EXTI_GetITStatus(EXTI_Line9) == SET){ EXTI_ClearITPendingBit(EXTI_Line9); } } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/",
    "title": "",
    
    "content": " 参考链接 mcu 启动流程_mcu启动过程-CSDN博客\n嵌入式开发系列教程（二） MCU启动过程 - 简书 (jianshu.com)\n启动流程 MCU启动方式 MCU有三种启动方式：\nflash启动（最常用）：stm32的flash能够擦写数十万次，用户通过JTAG或SWD模式，将程序下载至此，重新启动从此处启动 sytem memory （系统存储器启动）：系统存储器是芯片内的一块特定的区域，系统存储器中预置了一段bootloader,bootloder将程序下载到flash区，通过flash启动 内嵌SRAM启动：从内存中直接启动代码，避免因小修改反复擦写flash内存，一般用于高速调试 MCU程序启动执行过程 对于CortexM3来说，启动过程如下：\n从0x0000 0000地址处取出MSP的初始值 从0x0000 0004地址处取得PC指针初始值，然后执行用户代码。 Vector Table指的是中断向量表，Reset Handler指的是复位向量。从图中我们看出Reset Handler不过是0x0000 0004地址的一个别名，他其中放置的便是==CPU上电后要执行的第一条用户代码指令的地址。将这个值加载到PC指针上，cpu跳转执行用户代码。== [!important]\n程序运行的第一条地址放在了Reset Handler中\n以下是stm32f103的启动方式调用：\nBoot Space是对一段内存空间的别名，根据不同的启动条件，映射到不同的存储设备上，但是访问地址一定是0x0000 0000 - 0x0005 FFFF这个区间\n当从SRAM启动时，Boot Space映射到SRAM上，即0x0000 0000和0x2000 0000两个地址是指的同一块空间 当从Flash启动时，Boot Space映射到Flash上 当从System Memory启动（即bootloader）时，Boot Space映射到st公司保留的System Memory上，这是一段ROM，烧写有st的bootloader代码 以上，假设单片机从flash启动，则\n从0x0000 0000 -\u0026gt; 0x08000 0000地址处取出MSP的初始值 从0x0000 0004 -\u0026gt; 0x08000 0004地址处取出PC指针初始值，然后执行用户代码 中断向量 中断执行过程如下：\n主循环（main)的代码和中断代码都是CPU执行的 中断随时可能发生 CPU在执行主循环指令序列时，如果产生了中断，CPU便会记录当前PC指针，装载中断入口地址，执行中断代码，中断代码执行结束后，手动调用返回指令，CPU便会加载上一次记录的地址（中断前），继续执行原指令序列 手动调用返回指令，在单片机C语言编码过程中，编译器已经帮我们做了，我们感觉不到 我们的主循环代码，中断代码都是烧写到了单片机的flash中的。\ncpu跳转到中断处理函数，必然要先知道中断处理函数的入口地址。而我们不可能控制主函数的代码长度。这样的话，中断处理函数的入口地址是无法固化的。那么如何让CPU找到正确的中断入口函数呢？\n这时候就需要使用中断向量表了：\ninterrupt vector table即为中断向量表\n我们重述一下启动过程\n从0x0000 0000地址处取出MSP的初始值 从0x0000 0004地址处，即中断向量表中第一个元素，复位向量处取得PC指针初始值，然后执行用户代码 复位向量其实就是0x0000 0004地址单元，放的就是用户代码首地址 当中断发生时，CPU会根据中断号，去中断向量表中找对应的中断入口地址，然后执行中断代码，这样的话，这个表结构，记录了所有的中断入口地址。\n不同IDE的启动过程 IAR ICF文件 启动过程 在IAR的启动文件中会定义一个__iar_program_start的handler，这个handler实际上就是Reset Handler。\n__vector_table DCD sfe(CSTACK) ; Top of Stack DCD __iar_program_start ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler 当程序启动时，会从0x0000_0000中读取读取msp的值，向后偏移4得到PC的值，此时开始从PC值开始运行。\n在调试过程中__iar_program_start中存放了启动地址,也就是0x00004725。\nDisassembly 0x0:\t0x18\tDC8\t24 _vector_table: 0x1:\t0x13\tDC8\t19 0x2:\t0x2000\tDC16\t8192 0x4:\t0x00004725\tDC32\t__iar_program_start 0x8:\t0x00003981\tDC32\tNMI Handler 0x0c:\t0x000025ff\tDC32\tACMPO_IRQHandler 接下来跳转到0x00004725的位置\n__iar_program_start: 0x4724:\t0xbf00\tNOP 0x4726:\t0xbf00\tNOP 0x4728:\t0xbf00\tNOP 0x472a:\t0xbf00\tNOP 0x472c:\t0xf7ff 0xffbe\tBL ?main 0x4730:\t0x50\tDC8\t80 0x4731:\t0x30\tDC8\t48 0x4732:\t0x01\tDC8\t_vector_table 0x4733:\t0xf4\tDC8\t244 0x4734:\t0x01\tDC8\t_vector_table 0x4735:\t0xf4\tDC8\t244 0x4736:\t0x00\tDC8\t0 0x4737:\t0x00\tDC8\t0 Keil MAP文件 MAP文件是MDK编译代码后，产生的集程序、数据及IO空间的一种映射列表文件，简单说就是包括了：各种.c文件、函数、符号等的地址、大小、引用关系等信息，分析各.c文件占用FLASH和RAM的大小，方便优化代码。\n文件类型 简介 .o 可重定向对象文件，每个.c/.s文件都对应一个.o文件 .axf 可执行对象文件，由.o文件链接生成，仿真的时候需要用到此文件 .hex INTEL Hex格式文件，用于下载到MCU运行，由.axf转换而来 .map 连接器生成的列表文件，对分析程序存储占用情况非常有用 其他 .crf、.d、.dep、.lnp、.lst、.htm、.build_log.htm等一般用不到 map文件的组成部分 组成部分 简介 程序段交叉引用关系 描述各文件之间函数调用关系 删除映像未使用的程序段 描述工程中未用到而被删除的冗余程序段(函数/数据) 映像符号表 描述各符号（程序段/数据）在存储器中的地址、类型、大小等 映像内存分布图 描述各个程序段（函数）在存储器中的地址及占用大小 映像组件大小 给出整个映像代码（*.o）占用空间汇总信息 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/%E6%97%B6%E9%92%9F/",
    "title": "",
    
    "content": " 参考链接 【STM32】时钟_stm32f405 定时器时钟-CSDN博客\n时钟相关缩写 RCC - Reset and Clock Control（复位与时钟控制） RTC - Real-Time Clock（实时时钟） BKP - Backup Registers（备份寄存器） PWR - Power Control（电源控制） HCLK - AHB Clock（AHB总线时钟） USBCLK - USB Clock（USB时钟） LSCO - Low Speed Clock Output（低速时钟输出） MSI - Multi-Speed Internal Clock（多速内部时钟） CSS - Clock Security System（时钟安全系统） LPTIM - Low Power Timer（低功耗定时器） WDG - Watchdog Timer（看门狗定时器） HSE - High-Speed External Clock（高速外部时钟） HSI - High-Speed Internal Clock（高速内部时钟） LSE - Low-Speed External Clock（低速外部时钟） LSI - Low-Speed Internal Clock（低速内部时钟） PLL - Phase-Locked Loop（锁相环） SYSCLK - System Clock（系统时钟） PCLK - Peripheral Clock（外设时钟） APB - Advanced Peripheral Bus（高级外设总线） AHB - Advanced High-performance Bus（高级高性能总线） 概念 简单来说，时钟是具有周期性的脉冲信号，最常用的是占空比50%的方波\n时钟是单片机的脉搏，搞懂时钟走向及关系，对单片机使用至关重要！\n时钟树 可以使用三种不同的时钟源来驱动系统时钟：\nHSI振荡器时钟 HSE振荡器时钟 主PLL（PLL）时钟 器件有以下两个次级时钟源：\n低速内部 RC (LSI RC)，该 RC 用于驱动独立看门狗，也可选择提供给 RTC 用于停机/待机模式下的自动唤醒。 低速外部晶振（LSE 晶振），用于驱动 RTC 时钟 (RTCCLK)对于每个时钟源来说，在未使用时都可单独打开或者关闭，以降低功耗 时钟源：\n时钟源名称 频率 材料 用途 高速外部振荡器(HSE) 4~16MHz 晶体/陶瓷 SYSCLK/RTC 低速外部振荡器(LSE) 32.768KH Z 晶体/陶瓷 RTC（实时时钟） 高速内部振荡器(HSI) 8MHz RC SYSCLK 低速内部振荡器(LSI) 40KHz RC RTC/IWDG [!TIP]\nH：high L：low S：speed I：internal E：external\n时钟控制器为应用带来了高度的灵活性，用户在运行内核和外设时可选择使用外部晶振或者使用振荡器，既可采用最高的频率，也可为以太网、USB OTG FS 以及 HS、I2S 和 SDIO等需要特定时钟的外设保证合适的频率。\n可通过多个预分频器配置 ==AHB 频率==、==高速 APB (APB2)== 和==低速 APB (APB1)==。\nAHB 域的最大频率为 168 MHz。 高速 APB2 域的最大允许频率为 84 MHz。 低速 APB1 域的最大允许频率为 42 MHz。 除以下时钟外，所有外设时钟均由系统时钟 (SYSCLK) 提供：\n来自于特定 PLL 输出 (PLL48CLK) 的 USB OTG FS 时钟 (48 MHz)、基于模拟技术的随机数发生器 (RNG) 时钟 (\u0026lt;=48 MHz) 和 SDIO 时钟 (\u0026lt;=48 MHz)。\nI2S 时钟\nSTM32F405xx/07xx 和 STM32F415xx/17xx 的定时器时钟频率由硬件自动设置。分为两种情况：\n如果 APB 预分频器为 1，定时器时钟频率等于 APB 域的频率。 否则，等于 APB 域的频率的两倍 (×2)。 配置时钟：==使能时钟 \u0026gt; 调用SystemInit()函数（在system_stm32xxx.c中定义）\u0026gt; 选择时钟源，配置PLL \u0026gt; 选择系统时钟源，配置总线分频器 \u0026gt; 配置扩展外设时钟==\n代码\n#include \u0026#34;stm32f10x.h\u0026#34; void RCC_Configuration(void) { // 1. 开启HSE时钟 RCC_HSEConfig(RCC_HSE_ON); ErrorStatus HSEStartUpStatus = RCC_WaitForHSEStartUp(); if (HSEStartUpStatus == SUCCESS) { // 2. 配置PLL，HSE为PLL输入源，9倍频 RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9); RCC_PLLCmd(ENABLE); // 等待PLL稳定 while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET); // 3. 选择PLL作为系统时钟源 RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); while (RCC_GetSYSCLKSource() != 0x08); // 4. 配置时钟分频 RCC_HCLKConfig(RCC_SYSCLK_Div1); // AHB时钟 RCC_PCLK1Config(RCC_HCLK_Div2); // APB1时钟 RCC_PCLK2Config(RCC_HCLK_Div1); // APB2时钟 // 5. 配置Flash存储器等待状态 FLASH_SetLatency(FLASH_Latency_2); } } HSE时钟 高速外部时钟信号（HSE）有两个时钟源\nHSE外部用户时钟 HSE外部晶振/陶瓷谐振器 外部源（HSE 旁路） 在此模式下，必须提供外部时钟源。此模式通过将 RCC 时钟控制寄存器 (RCC_CR) 中的HSEBYP 和 HSEON 位置 1 进行选择。必须使用占空比约为 50% 的外部时钟信号（方波、正弦波或三角波）来驱动 OSC_IN 引脚，同时 OSC_OUT 引脚应保持为高阻态 (hi-Z)。\n外部晶振/ 陶瓷谐振器（HSE 晶振） HSE 的特点是精度非常高。\nRCC 时钟控制寄存器 (RCC_CR) 中的 HSERDY 标志指示高速外部振荡器是否稳定。在启动时，硬件将此位置 1 后，此时钟才可以使用。如在 RCC 时钟中断寄存器 (RCC_CIR) 中使能中断，则可产生中断。\nHSE 晶振可通过 RCC 时钟控制寄存器 (RCC_CR) 中的 HSEON 位打开或关闭。\n负载电容(起振电容)必须==尽可能的靠近振荡器==/谐振器的引脚，以尽量减小输出失真和起振稳定时间，负载电容值必须根据所选振荡器的不同做适当的调整\n[!TIP]\n晶振（晶体振荡器）：\n利用石英晶体的压电效应来生成稳定的振荡频率。\n主要用于为电路提供一个高精度的时钟信号，如微控制器、电脑等。\n协振器（谐振器）：\n可以是LC电路或陶瓷谐振器，依靠电感、电容或物理振动来产生共振。\n它与晶振相似，可以用于生成振荡信号，但通常精度较低，稳定性也比晶振差。\nHSI时钟 HSI 时钟信号由内部 16 MHz RC（电阻电容） 振荡器生成，可直接用作系统时钟，或者用作 PLL 输入。HSI RC 振荡器的优点是成本较低（无需使用外部组件）。此外，其启动速度也要比 HSE 晶振块，但即使校准后，其精度也不及外部晶振或陶瓷谐振器。\nSTM32中的HSI（High-Speed Internal）内部时钟是指芯片内部产生的高速时钟信号。HSI是STM32微控制器系列的一部分，通常用作系统时钟的一个选项。HSI时钟信号由芯片内部的振荡器产生，其频率通常为16 MHz（具体数值可能因STM32系列而异）。\nHSI时钟通常用于以下用途：\n启动和初始化：在STM32芯片上电后，通常会首先使用HSI时钟来启动和初始化系统，然后再切换到外部时钟源（如HSE）。\n低功耗模式：当系统需要进入低功耗模式时，可以选择将时钟切换回HSI，以减少功耗。\n内部模块时钟：一些内部模块，如看门狗定时器（WDT）和RTC（实时时钟），可能使用HSI时钟。\n频率可选性：HSI时钟通常具有多个频率选项，可以根据应用的需求进行配置。\n需要注意的是，HSI时钟通常比外部时钟源（如HSE，高速外部）的精度和稳定性较差，因此在要求高精度的应用中，通常会选择外部时钟源作为系统时钟。但在许多应用中，HSI时钟足够满足要求，并且可以在降低功耗或简化设计时提供灵活性。\nPLL F4芯片有两个PLL：\n主PLL由HSE和HSI振荡器提供时钟信号，并具有两个不同的输出时钟\n用于生成告诉系统时钟（最高达168MHz）\n输出用于生成USB OTG FS的时钟（48Mhz）、随机数发生器的时钟（\u0026lt;=48MHz）和SDIO时钟（\u0026lt;=48MHz）\n专用PLL（PLLI2S）用于生成精确时钟，从而在I2S接口实现高品质的音频性能\n由于在 PLL 使能后主 PLL 配置参数便不可更改，所以建议先对 PLL 进行配置，然后再使能（选择 HSI 或 HSE 振荡器作为 PLL 时钟源，并配置分频系数 M、N、P 和 Q）。\nPLLI2S 使用与 PLL 相同的输入时钟（PLLM[5:0] 和 PLLSRC 位为两个 PLL 所共用）。但是，PLLI2S 具有专门的使能/禁止和分频系数（N 和 R）配置位。在 PLLI2S 使能后，配置参数便不能更改。\n当进入停机和待机模式后，两个 PLL 将由硬件禁止；如将 HSE 或 PLL（由 HSE 提供时钟信号）用作系统时钟，则在 HSE 发生故障时，两个 PLL 也将由硬件禁止。RCC PLL 配置寄存器 (RCC_PLLCFGR) 和RCC 时钟配置寄存器 (RCC_CFGR) 可分别用于配置 PLL 和 PLLI2S。\nPLL 主要用于以下几个方面：\n时钟生成和同步：PLL 可以用于生成一个稳定的时钟信号，将其锁定到外部参考时钟，从而使系统中的各个部分能够以相同的时间基准运行。这在数字系统、通信系统、计算机系统和许多其他应用中非常重要。\n频率合成：PLL 可以将一个低频率的参考信号合成为高频率的输出信号。这对于需要高频率时钟信号的应用非常有用，如通信设备、射频电路和数字信号处理器。\n时钟恢复：在通信系统中，接收到的信号通常会被传输过程中的噪声和时延所影响。PLL 可以用于从接收到的信号中恢复出其原始时钟，以便正确解码和处理数据。\n频率调制和解调：在调制和解调过程中，PLL 可以用于调整信号的频率，以便将信息嵌入到载波中（调制）或从载波中提取出信息（解调）。\n时钟多路复用：PLL 可以用于将多个输入时钟信号多路复用到一个输出时钟上，以满足复杂系统中的时钟要求。\n频率锁定：PLL 可以用于锁定一个振荡器或电路的输出频率到一个稳定的参考频率，以确保输出频率与所需频率匹配。\nLSE时钟 LSE 晶振是 32.768 kHz 低速外部 (LSE) 晶振或陶瓷谐振器，可作为实时时钟外设 (RTC) 的时钟源来提供时钟/日历或其它定时功能，具有功耗低且精度高的优点。\nLSE 晶振通过 RCC 备份域控制寄存器 (RCC_BDCR) 中的 LSEON 位打开和关闭。\nRCC 备份域控制寄存器 (RCC_BDCR) 中的 LSERDY 标志指示 LSE 晶振是否稳定。在启动时，硬件将此位置 1 后，LSE 晶振输出时钟信号才可以使用。如在 RCC 时钟中断寄存器(RCC_CIR) 中使能中断，则可产生中断。\n外部源（LSE旁路） 在此模式下，必须提供外部时钟源，最高频率不超过 1 MHz。此模式通过将 RCC 备份域控制寄存器 (RCC_BDCR) 中的 LSEBYP 和 LSEON 位置 1 进行选择。必须使用占空比约为 50%的外部时钟信号（方波、正弦波或三角波）来驱动 OSC32_IN 引脚，同时 OSC32_OUT 引脚应保持为高阻态 (Hi-Z)。\nLSI LSI RC 可作为低功耗时钟源在停机和待机模式下保持运行，供独立看门狗 (IWDG) 和自动唤醒单元 (AWU) 使用。时钟频率在 32 kHz 左右。\nLSI RC 可通过 RCC 时钟控制和状态寄存器 (RCC_CSR) 中的 LSION 位打开或关闭。\nRCC 时钟控制和状态寄存器 (RCC_CSR) 中的 LSIRDY 标志指示低速内部振荡器是否稳定。在启动时，硬件将此位置 1 后，此时钟才可以使用。如在 RCC 时钟中断寄存器 (RCC_CIR) 中使能中断，则可产生中断。\nSYSCLK 在系统复位后，默认系统时钟为 HSI。在直接使用 HSI 或者通过 PLL 使用时钟源来作为系统时钟时，该时钟源无法停止。\n只有在目标时钟源已就绪时（时钟在启动延迟或 PLL 锁相后稳定时），才可从一个时钟源切换到另一个。如果选择尚未就绪的时钟源，则切换在该时钟源就绪时才会进行。RCC 时钟控制寄存器 (RCC_CR) 中的状态位指示哪个（些）时钟已就绪，以及当前哪个时钟正充当系统时钟。\nSYSTICK SysTick（滴答）定时器被捆绑在NVIC中，用于产生SYSTICK异常（异常号：15）。\n在以前，大多操作系统需要一个硬件定时器来产生操作系统需要的滴答中断，作为整个系统的==时基==。\n例如，为多个任务许以不同数目的时间片，确保没有一个任务能霸占系统；或者把每个定时器周期的某个时间范围赐予特定的任务等，还有操作系统提供的各种定时功能，都与这个滴答定时器有关。因此，需要一个定时器来产生周期性的中断，而且最好还让用户程序不能随意访问它的寄存器，以维持操作系统“心跳”的节律。\nSystick定时器就是系统滴答定时器，一个24 位的倒计数定时器，计到0 时，将从RELOAD 寄存器中自动重装载定时初值。只要不把它在SysTick 控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作。\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/",
    "title": "",
    
    "content": " 是什么 最小系统是保障MCU正常工作的最小电路的组成单元\nblock-beta\rcolumns 3\rMCU:2\rblock\rcolumns 1\r电源电路\r晶振电路\rend\r下载调试电路\rBOOT启动电路\r复位电路\r其他电路:3\r管脚定义 类型 引脚名称 说明 电源 VDD/VSS 电源正（VDD）/负（VSS）引脚，给STM32供电 VDDA/VSSA 模拟部分电源正/负引脚，给STM32内部模拟部分供电 参考电压正/负引脚，给STM32内部ADC/DAC提供参考电压 VREF+/VREF- 100脚及以上的STM32F103型号才有这两个脚 VBAT RTC\u0026amp;后备区域供电引脚，给RTC和后备区域供电。一般VBAT 接电池，用于断电维持RTC工作，如不需要，直接将VBAT 接VDD即可 复位 NRST 复位引脚，用于复位STM32，低电平复位 启动选择引脚，一般这两个脚各接一个下拉电阻即可 启动 BOOT0/BOOT1 其他启动配置说明详见后续分析 晶振 OSC_IN/ OSC_OUT 外部HSE晶振引脚，用于给STM32提供高精度系统时钟 如果使用内部HSI能满足使用需求，这两个脚可以不接晶振 OSC32_IN / OSC32_OUT 外部LSE晶振引脚，用于给STM32内部RTC提供时钟 如果使用内部LSI能满足使用需求，这两个脚可以不接晶振 调试 SWCLK/SWDIO SWD调试引脚，用于调试STM32程序，同时STM32还支持 JTAG调试，不过我们不推荐使用！因为SWD省IO！ 电源电路 在GND和POWER之间一般会连接一个滤波电容，该电容==保证供电电压的稳定性==，一般遇到供电都会加上滤波电容\nBAT一般使用纽扣电池，备用电池是给RTC和备份寄存器服务的，如果不需要这些则可以不使用纽扣电池，VBAT可以直接接POWER或者直接悬空\n复位电路 手动复位：当按下复位按键，NRST直接接地，变成低电平开始复位，反之，则为高电平\n上电复位：当芯片开始上电的时候，vcc将会给电容充电，电容相当于短路，这时NRST与地直接相连，变成低电平开始复位，当电容充满电时，将会变成高电平，实现了上电复位的功能\n电容==充电==过程：当电容开始充电时，它的两极板之间存在电势差，电路中的电流开始流动，电容逐渐储存电荷。刚充电时，电容像是==导线==。\n电容==充满==电时：当电容两端的电压与电源电压相等时，电容停止继续储存电荷，电流也随之停止。此时，电容器相当于==开路==，因为没有电流流过它。\nBOOT启动电路 通过连接引脚或者开关就可以配置BOOT的高低电平，比如接13，BOOT0就变成了高电平\n晶振电路 在晶振的两侧还需要接两个电容作为==起振电容==，如果需要RTC功能，那么还需要额外接一个晶振，OSC32就是32.768KHz（32768为2的15次方），内部RTC电路通过2的15次方分频就可以生成1秒的时间信号了\n[!TIP]\n起振电容的==作用==：\n稳定振荡频率：起振电容与晶振一起形成一个谐振电路（通常是并联谐振电路），用于确定晶振的振荡频率。通过调整电容的值，可以细微调整振荡频率，使其符合预期的设计。\n辅助启动振荡：起振电容为晶体提供适当的相移，使得反馈回路中的正反馈条件满足，从而启动振荡。它们在起振过程中的作用是提供合适的相位补偿，使得振荡可以迅速建立。\n起振电容的==原理==：\n与晶振和回路形成谐振回路：晶体具有一定的等效电感和电容，外部的起振电容与其一起形成谐振回路，决定晶体的工作频率。外部的起振电容值越大，振荡频率会略微降低；电容值越小，频率会略微升高。\n实现正反馈：振荡电路的基本工作条件是需要正反馈，即输入信号和反馈信号的相位相同或相差整数倍的360°。起振电容通过提供适当的相移，使晶体振荡器电路的正反馈得以满足，从而维持振荡。常见的振荡器电路，如Pierce振荡器，正是依赖这些电容来实现所需的相移。\n稳定电路工作状态：晶振电路中的负载电容可以起到稳定电压和电流的作用，避免电路因高频信号波动而产生不稳定的振荡。\n下载和调试电路 串口一键下载电路 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/bluetooth/",
    "title": "",
    
    "content": " 参考链接 深入浅出低功耗蓝牙(BLE)协议栈及蓝牙连接过程_蓝牙芯片的寄存器组为什么需要分为两块-CSDN博客\n蓝牙核心技术概述（一）:蓝牙概述_蓝牙技术-CSDN博客\n蓝牙核心技术概述（三）： 蓝牙协议规范（射频、基带链路控制、链路管理）_蓝牙3.0技术规范-CSDN博客\n蓝牙核心技术概述（四）：蓝牙协议规范（HCI、L2CAP、SDP、RFOCMM）_蓝牙通信帧分类-CSDN博客\n蓝牙核心技术概述（五）：蓝牙协议规范（irOBEX、BNEP、AVDTP、AVCTP）_蓝牙核心bnep-CSDN博客\nBLE协议学习 – 学习笔记 (giraffexiu.love)\nESP32教程第二章讲义 - 哔哩哔哩 (bilibili.com)\nBluetooth.org - Generic Access Profile (nop.hu)\nCore Specification | Bluetooth® Technology Website\nAssigned Numbers | Bluetooth® Technology Website\n低功耗蓝牙BLE之连接建立_低功耗蓝牙的连接过程-CSDN博客\n低功耗蓝牙BLE之连接事件、连接参数和更新方法_蓝牙设备为什么拼命发包-CSDN博客\n蓝牙配对安全机制解析：防止中间人与被动监听攻击-CSDN博客\n深入理解低功耗蓝牙的配对过程- Part 1 Pairing Feature Exchange - SZ_LM - 博客园\n深入理解低功耗蓝牙的配对过程- Part 2 Key Generation Methods - SZ_LM - 博客园\n低功耗蓝牙配对绑定解读和实践 - iini - 博客园\n蓝牙安全管理(SM:Security Manager)规范详解_蓝牙csrk-CSDN博客\n蓝牙 - 什么是Man-in-the-middle protection_蓝牙中间人攻击-CSDN博客\n了解低功耗蓝牙中的安全密钥_irk ltk-CSDN博客\n传输原理 蓝牙的传输频率是2.4GHZ，也就是说一秒钟之内蓝牙信号可以改变24亿次。\n蓝牙的通信模式有两种：\n经典蓝牙：一帧数据包有357个字节\n前9字节是访问地址用于区分不同的蓝牙设备\n标头是确保数据的可靠性和稳定性\n可以承载0-399字节的数据位，不同的报文会承载不同长度的数据\n最后两字 …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/can/",
    "title": "",
    
    "content": " CAN简介 CAN总线（Controller Area Network Bus）控制器局域网总线\nCAN总线是由BOSCH公司开发的一种简洁易用、传输速度快、易扩展、可靠性高的串行通信总线，广泛应用于汽车、嵌入式、工业控制等领域\nCAN总线特征：\n两根通信线（CAN_H、CAN_L），线路少，无需共地\n差分信号通信，抗干扰能力强\n高速CAN（ISO11898）：125k~1Mbps, \u0026lt;40m\n低速CAN（ISO11519）：10k~125kbps, \u0026lt;1km\n异步，无需时钟线，通信速率由设备各自约定\n半双工，可挂载多设备，多设备同时发送数据时通过仲裁判断先后顺序\n11位/29位报文ID，用于区分消息功能，同时决定优先级\n可配置1~8字节的有效载荷\n可实现广播式和请求式两种传输方式\n应答、CRC校验、位填充、位同步、错误处理等特性\n主流通信协议对比 名称 引脚 双工 时钟 电平 设备 应用场景 UART TX、RX 全双工 异步 单端 点对点 两个设备互相通信 I2C SCL、SDA 半双工 同步 单端 多设备 一个主控外挂多个模块 SPI SCK、MOSI、MISO、SS 全双工 同步 单端 多设备 一个主控外挂多个模块（高速） CAN CAN_H、CAN_L 半双工 异步 差分 多设备 多个主控互相通信 CAN硬件电路 每个设备通过CAN收发器挂载在CAN总线网络上\nCAN控制器引出的TX和RX与CAN收发器相连，CAN收发器引出的CAN_H和CAN_L分别与总线的CAN_H和CAN_L相连\n高速CAN使用闭环网络，CAN_H和CAN_L两端添加120Ω的终端电阻，增加电阻的作用有两个，一是防止回波反射，二是在没有设备进行操作的时候，将两根差分线的电压收紧，使其电压一致\n低速CAN使用开环网络，CAN_H和CAN_L其中一端添加2.2kΩ的终端电阻\nCAN的电平标准 CAN总线采用差分信号，即两线电压差（VCAN_H-VCAN_L）传输数据位 高速CAN规定： ​\t电压差为0V时表示逻辑1（隐性电平，总线收紧状态）\n​\t电压差为2V时表示逻辑0（显性电平，总线张开状态）\n低速CAN规定：（电压有压降，所以拉大了两个信号线的电压差） ​\t电压差为-1.5V时表示逻辑1（隐性电平）\n​\t电压差为3V时表示逻辑0（显性电平）\n高速CAN，总线回归隐性电平快，传输速度就会快，低速CAN总线回归隐性电平慢，传输速度就会慢。\nCAN收发器（TJA1050，高速CAN） 接收端\n如果CANH和CANL之间有电压差，则Receiver就输出1，否则就输出0\n当Receiver输出为1时，上管断开，下管导通，输出0。输出为0时，上管导通，下管断开，输出1。RXD为输入部分\n发送端通过两个三级管来控制输出的电压差，当TXD为0时，上面的三极管将CANH线的电平拉高，下面的三极管将CANL线的电平拉低，出现电压差，显示为0\n其中的两个电阻为中拉电阻，通过两个电阻，可以将CANH和CANL两根线都拉到0.5倍VCC的中间电平，使CANH和CANL的默认对地电压都是2.5v左右，同时，这两个电阻还有一定的收紧作用，但是由于阻值较大，所以收紧电压一般都使用外部的电阻来实现 。\nCAN物理层 CAN总线帧格式 CAN协议规定了以下5种类型的帧：\n帧类型 用途 数据帧 发送设备主动发送数据（广播式） 遥控帧 接收设备主动请求数据（请求式） 错误帧 某个设备检测出错误时向其他设备通知错误 过载帧 接收设备通知其尚未做好接收准备 帧间隔 用于将数据帧及遥控帧与前面的帧分离开 数据帧 灰色方块表示只能发送0，白的方块表示只能发送1，紫色的方块表示既能发送0也能发送1。其中的数字为位数。\n标准格式 ​\t在发送数据之前，总线必须要为空闲状态，空闲状态时，总线是隐性电平（1），当开始发送数据帧时，首位必须要为显性电平0（SOF）。随后是报文ID，一般为11位。之后发送RTR，RTR必须要为0，用于区分数据帧（0）还是遥控帧（1）。后面按照图片进行控制。\n数据帧的各部分用途简介 SOF（Start of Frame）：帧起始，表示后面一段波形为传输的数据位 ID（Identify）：标识符，区分功能，同时决定优先级 RTR（Remote Transmission Request ）：远程请求位，区分数据帧和遥控帧 IDE（Identifier Extension）：扩展标志位，区分标准格式和扩展格式，标准格式为0，扩展格式为1 SRR（Substitute Remote Request）：替代RTR，协议升级时留下的无意义位 r0/r1（Reserve）：保留位，为后续协议升级留下空间 DLC（Data Length Code）：数据长度，指示数据段有几个字节 Data：数据段的1~8个字节有效数据 CRC（Cyclic Redundancy Check）：循环冗余校验，校验数据是否正确 ACK（Acknowledgement）：应答位，判断数据有没有被接收方接收 CRC/ACK界定符：为应答位前后发送方和接收方释放总线留下时间 EOF（End of Frame ）：帧结束，表示数据位已经传输完毕 遥控帧 遥控帧无数据段，RTR为隐性电平1，其他部分与数据帧相同\nCAN总线的数据主要靠发送方自觉广播出来的，一般发送方会定一个周期，定时广播自己的数据，但如果发送方没有及时发送自己的数据，或者这个数据的使用频率太低了，广播太频繁了，用不到就会浪费总线资源，广播太慢了，偶尔有用的话，有不能及时拿到。此时就可以规定，发送方不要主动广播数据，而是设备有需要的话，首先接收方发出一个遥控帧，遥控帧包含报文ID，遥控帧也是通过广播出来的，每个设备都能收到遥控帧，如果其中某个设备有这个ID的数据，就会通过数据帧广播出来，这样接收方就可以及时获取这个数据了\n错误帧 总线上所有设备都会监督总线的数据，一旦发现“位错误”或“填充错误”或“CRC错误”或“格式错误”或“应答错误” ，这些设备便会发出错误帧来破坏数据，同时终止当前的发送设备\n发现数据帧数据有错，所以破坏了该数据帧，是一种错误处理机制\n主动错误 发了6个0表示主动错误，中间有0到6位的延长时间，是错误标志的重叠部分。之后发送错误界定符，也就是8个1 被动错误 发了6个1表示被动错误，之后发送错误界定符，也就是8个1 过载帧 当接收方收到大量数据而无法处理时，其可以发出过载帧，延缓发送方的数据发送，以平衡总线负载，避免数据丢失\n发送方发送数据太快，接受方处理不了，由接收方产生\n帧间隔 将数据帧和遥控帧与前面的帧分离开\n位填充 位填充规则：发送方每发送5个相同电平后，自动追加一个相反电平的填充位，接收方检测到填充位时，会自动移除填充位，恢复原始数据\n例如：\n​ 即将发送： 100000110 10000011110 0111111111110\n​ 实际发送： 1000001110 1000001111100 011111011111010\n​ 实际接收： 1000001110 1000001111100 011111011111010\n​ 移除填充后： 100000110 10000011110 0111111111110\n位填充作用：\n增加波形的定时信息，利于接收方执行“再同步”，防止波形长时间无变化，导致接收方不能精确掌握数据采样时机 将正常数据流与“错误帧”和“过载帧”区分开，标志“错误帧”和“过载帧”的特异性 保持CAN总线在发送正常数据流时的活跃状态，防止被误认为总线空闲 接收方数据采样 CAN总线没有时钟线，总线上的所有设备通过约定波特率的方式确定每一个数据位的时长 发送方以约定的位时长每隔固定时间输出一个数据位 接收方以约定的位时长每隔固定时间采样总线的电平，输入一个数据位 理想状态下，接收方能依次采样到发送方发出的每个数据位，且采样点位于数据位中心附近 接收方数据采样遇到的问题 采样指的是对于数据的读取，使用固定时间间隔对数据进行采样。\n接收方以约定的位时长进行采样，但是采样点没有对齐数据位中心附近，假设每次采样的时候都会采到数据的跳变，这时就不知道采样采的是0还是1了 接收方刚开始采样正确，但是时钟有误差，随着误差积累，采样点逐渐偏离 位时序 为了灵活调整每个采样点的位置，使采样点对齐数据位中心附近，CAN总线对每一个数据位的时长进行了更细的划分，分为同步段（SS）、传播时间段（PTS）、相位缓冲段1（PBS1）和相位缓冲段2（PBS2），每个段又由若干个最小时间单位（Tq，Time Quantum）构成\n其中，Tq的时间是自己指定的，如可以指定1Tq=0.5us\nSS段为同步段，如果数据跳变沿正好出现在SS段，则说明当前设备与波形达成同步，如果当前跳变沿不在SS段，则需要调整当前设备的位时序，使跳变沿正好出现在同步段，也就是采用硬同步和再同步手段，使得跳变沿再次出现在SS段 PTS段为传播时间段，PTS用于吸收网络上的物理延迟，网络的物理延迟指定发送单元的输出延迟，总线上信号的传播延迟、接收单元的输入延迟。PTS的时间为以上各延迟时间的和的两倍。控制器想发信号，由于硬件电路的限制，这个信号输出到总线，总会有延迟，所以设计该段。也就是说当开始发送数据时，SS结束后要稍微等一等，等待传播的延迟。 PBS1和PBS2为相位缓冲段，其作用为确定采样点的位置，采样点会在PBS1和PBS2中间，所以调节PBS1和PBS2的时间长短就可以条件采样位置 硬同步 每个设备都有一个位时序计时周期，当某个设备（发送方）率先发送报文，其他所有设备（接收方）收到SOF的下降沿时，接收方会将自己的位时序计时周期拨到SS段的位置，与发送方的位时序计时周期保持同步 硬同步只在帧的第一个下降沿（SOF下降沿）有效 经过硬同步后，若发送方和接收方的时钟没有误差，则后续所有数据位的采样点必然都会对齐数据位中心附近 再同步 若发送方或接收方的时钟有误差，随着误差积累，数据位边沿逐渐偏离SS段，则此时接收方根据再同步补偿宽度值（SJW）通过加长PBS1段，或缩短PBS2段，以调整同步 再同步可以发生在第一个下降沿之后的每个数据位跳变边沿 上图是发送方信号沿快于SS，图中的红色部分就是SJW，下图是发送方信号沿慢于SS\n硬同步用于一帧波形初始的位置对齐，所以硬同步更加激进一些，直接在波形边沿，把自己的秒表拨到SS段，一旦一帧波形开始，就不能再这么激进的调整同步了。所以再同步的补偿需要限定范围，一次只补偿一点，不能再多了\n波特率计算 $$ 波特率 = \\frac {1} {一个数据位的时长} = \\frac {1} {TSS + TPTS + TPBS1 + TPBS2} $$例如： $$ SS = 1Tq，PTS = 3Tq，PBS1 = 3Tq，PBS2 = 3Tq \\\nTq = 0.5us\\\n波特率 = \\frac{1} {0.5us + 1.5us + 1.5us + 1.5us}=0.2 \\times 10^6 bps= 200kbps $$\n总线的资源分配规则 多设备同时发送所遇到的问题 CAN总线只有一对差分信号线，同一时间只能有一个设备操作总线发送数据，若多个设备同时有发送需求，该如何分配总线资源？ 解决问题的思路：制定资源分配规则，依次满足多个设备的发送需求，确保同一时间只有一个设备操作总线 现假设两个设备想要同时发送数据，有以下两种情况：\n一个波形正在发送，另外一个想要发送 多个波形在同一起始段都想要发送数据 问题1解决方案-先占先得 若当前已经有设备正在操作总线发送数据帧/遥控帧，则其他任何设备不能再同时发送数据帧/遥控帧（可以发送错误帧/过载帧破坏当前数据） 任何设备检测到连续11个隐性电平，即认为总线空闲，只有在总线空闲时，设备才能发送数据帧/遥控帧 一旦有设备正在发送数据帧/遥控帧，总线就会变为活跃状态，必然不会出现连续11个隐性电平，其他设备自然也不会破坏当前发送 若总线活跃状态其他设备有发送需求，则需要等待总线变为空闲，才能执行发送需求 问题2解决方案-非破坏性仲裁 若多个设备的发送需求同时到来或因等待而同时到来，则CAN总线协议会根据ID号（仲裁段）进行非破坏性仲裁，ID号小的（优先级高）取到总线控制权，ID号大的（优先级低）仲裁失利后将转入接收状态，等待下一次总线空闲时再尝试发送 实现非破坏性仲裁需要两个要求： 线与特性：总线上任何一个设备发送显性电平0时，总线就会呈现显性电平0状态，只有当所有设备都发送隐性电平1时，总线才呈现隐性电平1状态，即：0 \u0026amp; X \u0026amp; X = 0，1 \u0026amp; 1 \u0026amp; 1 = 1 回读机制：每个设备发出一个数据位后，都会读回总线当前的电平状态，以确认自己发出的电平是否被真实的发送出去了，根据线与特性，发出0读回必然是0，发出1读回不一定是1 非破坏性仲裁过程 数据位从前到后依次比较，出现差异且数据位为1的设备仲裁失利\n单元1和单元2代表的是两个设备，根据线与特性，总线显示为空闲状态，所以此时单元1和单元2同时向总线发送请求，也就是同时发送SOF（0），两个单元同时回读，此时总线电平呈现0状态，单元1和单元2会继续同时向总线发送且回读，如果发送的和回读的不一样，代表仲裁失利，从下一位开始转为接收状态工作。\n数据帧和遥控帧的优先级 数据帧和遥控帧ID号一样时，数据帧的优先级高于遥控帧\n标准格式和扩展格式的优先级 标准格式的优先级高于扩展格式（SRR必须始终为1，以保证此要求）\n错误处理 错误类型 错误共有5种： 位错误、填充错误、CRC错误、格式错误、应答错误\n错误状态 每个设备内部管理一个TEC和REC，根据TEC和REC的值确定自己的状态 主动错误状态的设备正常参与通信并在检测到错误时发出主动错误标志 被动错误状态的设备正常参与通信但检测到错误时只能发出被动错误标志 总线关闭状态的设备不能参与通信 错误计数器 对于接收的错误较为宽容\nCAN外设 简介 STM32内置bxCAN外设（CAN控制器），支持CAN2.0A和2.0B，可以自动发送CAN报文和按照过滤器自动接收指定CAN报文，程序只需处理报文数据而无需关注总线的电平细节 波特率最高可达1兆位/秒 3个可配置优先级的发送邮箱 2个3级深度的接收FIFO 14个过滤器组（互联型28个）：用于过滤总线上不需要的报文（通过id） 时间触发通信、自动离线恢复、 自动唤醒、禁止自动重传、 接收FIFO溢出处理方式可配置、 发送优先级可配置、双CAN模式 STM32F103C8T6 CAN资源：CAN1 网络拓扑结构 CAN的控制器在MCU中，而收发器在外部属于外设，CAN控制器将会引出两个引脚，CAN的发送和CAN的接收，CAN的收发器将会将收到的Rx或Tx的数据转换成差分数据，也就是这里的CAN High和CAN Low\nCAN收发器原理图：\n对MCU端的接口为TX、RX、VCC和GND，对外接口为CANH和CANL\n内部设计 CAN2辅助CAN1工作，共同管理同一个CAN总线\n主发送邮箱：每个邮箱存一个CAN报文，如果想要发出一个CAN报文，那就需要将这个报文写入道其中的一个空置邮箱中，之后设置寄存器请求发送就行了，其余的如位同步、仲裁等等都靠硬件电路自动实现就好\n接受滤波器：当接收到一个报文时，首先需要经过接收过滤器，无论收到遥控帧还是远程帧，CAN硬件电路都会将该帧报文缓存下来，之后再传输进入过滤器。过滤器内可以设置过滤规则，告诉硬件想要指定的ID的报文\n主接收FIFO：当一个报文通过过滤器时，就可以进入主接受FIFO（由邮箱组成）\nMCU对外提供CAN_TX和CAN_RX，而引脚内部就需要配置相关的GPIO：\nCAN_TX是输出，引脚控制权在CAN外设，所以需要将引脚配置为复用推挽输出模式\nCAN_RX是输入，可以配置为上拉输入\n从GPIO进入之后，将会由发送和接收控制器全权控制\n当我们想要发送数据时，只需要将需要发送的数据写入发送邮箱中，发送和接收控制器会自动帮我们发送报文。并且发送时，可以配置发送模式，比如按照发送ID的优先级发送或者按照FIFO模式发送 当我们想要接收数据时，发送和接收控制器会匹配过滤器，如果符合要求将会自动存入邮箱中，不需要人为的干涉 基本过程 发送过程 邮箱有以下描述：\nRQCP：请求完成 TXOK：发送成功 TME：发送邮箱空 TXRQ：发送请求控制位 ABRQ：中止发送 NART：自动重传 发送流程详述：\n空置状态下，等待被填充数据，当有一个发送请求时，将会转到挂号状态 挂号状态表示此邮箱的数据已准备好了，但是邮箱有三个，可能别的邮箱也有数据已经准备好了，所以该邮箱需要排队，如果邮箱已经时最高优先级了，那么就表明下一次发送就轮到该邮箱了，邮箱立马进入预定状态 在预定状态下，等待总线为空闲，如果为空闲，就正式进入发送状态 在正式发送状态时，成功则转到空置且发送成功状态，如果使用自动重传（NART=0）则返回预定状态，否则返回空置且发送未完成状态。 接收过程 状态有以下描述：\nFMP：报文数量 FOVR：FIFO溢出 FULL：FIFO存满 RFOM：释放FIFO 接收到一个报文→匹配过滤器后进入FIFO 0或FIFO 1→CPU读取\n在初始状态下，当收到有效报文时，进入挂号1状态，报文数量为1（0x01） 当进入挂号1状态时，收到有效报文，进入状态2，此时报文数量为2（0x02，==下图写错了==） 当进入挂号状态2时，收到有效报文，进入状态3，此时报文数量为3（0x03） 当进入挂号状态3时，收到有效报文，进入溢出状态，此时FIFO溢出标志位设为1 当读取数据时，就会释放邮箱，一级一级回到挂号及空状态 [!NOTE]\n发送和接收配置位：\nNART：置1，关闭自动重传，CAN报文只被发送1次，不管发送的结果如何（成功、出错或仲裁丢失）；置0，自动重传，CAN硬件在发送报文失败时会一直自动重传直到发送成功 TXFP：置1，优先级由发送请求的顺序来决定，先请求的先发送；置0，优先级由报文标识符来决定，标识符值小的先发送（标识符值相等时，邮箱号小的报文先发送） RFLM：置1，接收FIFO锁定，FIFO溢出时，新收到的报文会被丢弃；置0，禁用FIFO锁定，FIFO溢出时，FIFO中最后收到的报文被新报文覆盖 过滤器 标识符过滤器：\n==每个==过滤器的核心由两个32位寄存器组成：R1[31:0]和R2[31:0]\nFSCx：位宽设置，置0，16位；置1，32位\nFBMx：模式设置，置0，屏蔽模式；置1，列表模式\nFFAx：关联设置，置0，FIFO 0；置1，FIFO 1\nFACTx：激活设置， 置0，禁用；置1，启用\n其中x可以为0-13\n过滤的配置有：\n让指定ID通过（标识符列表） 让指定组ID（组ID有着相同的数据段）通过（标识符屏蔽） 根据FSC和FBM两位的配置，过滤器可以工作在4中状态下：\n如果FSC=1，FBM=0，那么就工作在图中的第一行的状态下\n如果FSC=1，FBM=1，那么就工作在图中的第二行的状态下\n如果FSC=0，FBM=0，那么就工作在图中的第三行的状态下\n如果FSC=0，FBM=1，那么就工作在图中的第四行的状态下\n标识符列表模式：\n对于2个32位过滤器而言，用户可以写入两个目标ID，R1和R2中都包含数据\n当收到一个报文时，就和R1和R2中的ID做比对，如果相同就通过过滤器，否则则舍弃\n在存储映像中，32位寄存器的高11位存标准格式的ID号，后面的18位存的是拓展格式的ID号\n如果想要区分拓展ID还是标准ID就需要看后面的IDE的数据位（置1为拓展ID，置0为标准ID）\n如果想要区分遥控帧，就需要控制RTR位，RTR为是遥控帧标识位，写0就过滤数据帧，写1就过滤遥控帧\n而对于4个16位过滤器而言，只过滤标准格式的ID就可以使用FSC=0，此时的长度为16位，那么一个过滤器就可以写入4个目标ID\n标识符屏蔽模式\n对于1个32过滤器而言，用户可以设置需要屏蔽的ID（R1）和相应的掩码（R2）\n假设现在需求是过滤出以0x01开头的所有标准ID号\n那么ID号应该为001 xxxxxxx\n在R1中就可以填001 00000（当然，后面是任意填的，不是0填充也行）\n在掩码中，位为1表示必须匹配，位为0表示不需要匹配\n那么为了解决需求，则需要给R2设置为111 00000000（高三位为1表示必须匹配，低位为0表示可以为任意数）\n过滤器示例：\n总线上存在的ID 想要接收的ID 过滤器模式 R1[31:0]配置值 R2[31:0]配置值 0x123, 0x234, 0x345, 0x456, 0x567, 0x678 0x234, 0x345, 0x567 16位/列表 ID: R1[15:0]=0x234\u0026laquo;5 ID: R1[31:16]=0x345\u0026laquo;5 ID: R2[15:0]=0x567\u0026laquo;5 ID: R2[31:16]=0x000\u0026laquo;5 0x1000x1FF,0x2000x2FF, 0x3100x31F, 0x3200x32F 0x2000x2FF, 0x3200x32F 16位/屏蔽 ID: R1[15:0]=0x200\u0026laquo;5 Mask: R1[31:16]= (0x700\u0026laquo;5)|0x10|0x8 ID: R2[15:0]=0x320\u0026laquo;5 Mask: R2[31:16]= (0x7F0\u0026laquo;5)|0x10|0x8 0x123, 0x234, 0x345, 0x456, 0x12345678, 0x0789ABCD 0x123, 0x12345678 32位/列表 ID: R1[31:0]= 0x123\u0026laquo;21 ID: R2[31:0]= (0x12345678\u0026laquo;3)|0x4 0x12345600~ 0x123456FF, 0x0789AB00~ 0x0789ABFF 0x12345600~ 0x123456FF 32位/屏蔽 ID: R1[31:0]= (0x12345600\u0026laquo;3)|0x4 Mask: R2[31:0]= (0x1FFFFF00\u0026laquo;3)|0x4|0x2 任意ID 只要遥控帧 32位/屏蔽 ID: R1[31:0]=0x2 Mask: R2[31:0]=0x2 任意ID 所有帧 32位/屏蔽 ID: R1[31:0]=随意 Mask: R2[31:0]=0 [!NOTE]\n注意：赋值语句默认是右对齐的，在配置过滤器时，低位是标志位，所以在进行赋值的时候需要进行左移操作，至于需要左移几位就需要看需要使用哪种报文格式了\n测试模式 在测试模式下，发送和接收的线路在内部会进行变更\n静默模式：用于分析CAN总线的活动，不会对总线造成影响。发送端直接接到接收端，在这个模式下可以进行自发自收测试，还可以默默的监测CAN总线数据。\n如果只想看一下总线上有哪些报文，而不想输出任何电平，就可以使用静默模式\n环回模式：用于自测试，同时发送的报文可以在CAN_TX引脚上检测到。RX引脚直接断开，且自己发送的数据，自己也可以收回来\n环回静默模式：用于热自测试，自测的同时不会影响CAN总线\n一般为了确保自己的硬件是没问题的，会使用环回静默模式，自己发送一个报文，看看自己能不能进行接收\n工作模式 初始化模式：用于配置CAN外设，禁止报文的接收和发送 正常模式：配置CAN外设后进入正常模式，以便正常接收和发送报文 睡眠模式：低功耗，CAN外设时钟停止，可使用软件唤醒或者硬件自动唤醒 AWUM：置1，自动唤醒，一旦检测到CAN总线活动，硬件就自动清零SLEEP，唤醒CAN外设；置0，手动唤醒，软件清零SLEEP，唤醒CAN外设 工作状态寄存器描述：\nSLAK：睡眠确认状态位，置1后表示硬件已经确认进入睡眠模式了 INAK：初始化确认位，置0表示硬件目前没有进入初始化模式 SLEEP：置0后就是请求退出睡眠 INRQ：置1后表示请求进入初始化，置0表示请求退出初始化 位时间特性 正常的时间分段分为：\n同步段：SS=1Tq 时间段1：BS1=1~16Tq 时间段2：BS2=1~8Tq SJW=1~4Tq [!TIP]\n注意：前面说过位时序的组成：由SS+PTS+PBS1+PBS2组成，采样点位于PBS1和PBS2之间\n但是现在将PTS和PBS1合并叫BS1段，采样点位于BS1和BS2段之间\n$$ 波特率 =\\frac{ APB1时钟频率} {分频系数 \\times 一位的Tq数量} \\\\= \\frac{36MHz} {(BRP[9:0]+1) \\times ((1 + (TS1[3:0]+1) + (TS2[2:0]+1)))} $$ 中断 CAN外设占用4个专用的中断向量 发送中断：发送邮箱空时产生 FIFO 0中断：收到一个报文/FIFO 0满/FIFO 0溢出时产生 FIFO 1中断：收到一个报文/FIFO 1满/FIFO 1溢出时产生 状态改变错误中断：出错/唤醒/进入睡眠时产生 时间触发通信 TTCM：置1，开启时间触发通信功能；置0，关闭时间触发通信功能 CAN外设内置一个16位的计数器，用于记录时间戳 TTCM置1后，该计数器在每个CAN位的时间自增一次，溢出后归零 每个发送邮箱和接收FIFO都有一个TIME[15:0]寄存器，发送帧SOF时，硬件捕获计数器值到发送邮箱的TIME寄存器，接收帧SOF时，硬件捕获计数器值到接收FIFO的TIME寄存器 发送邮箱可配置TGT位，捕获计数器值的同时，也把此值写入到数据帧数据段的最后两个字节，为了使用此功能，DLC必须设置为8 错误处理和离线恢复 TEC和REC根据错误的情况增加或减少 ABOM：置1，开启离线自动恢复，进入离线状态后，就自动开启恢复过程；置0，关闭离线自动恢复，软件必须先请求进入然后再退出初始化模式，随后恢复过程才被开启 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/iic/",
    "title": "",
    
    "content": " 参考链接 STM32 IIC通讯协议详解—小白入门_stm32 iic速率修改-CSDN博客\n概述 IIC:Inter Integrated Circuit,集成电路总线，是一种同步串行半双工通信总线。\n总线：传输数据的通道\n协议：传输数据的规则\n物理层 物理层描述：\n它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个IIC通信总线中，可连接==多个IIC通信设备==，支持多个通信主机及多个通信从机。 一个IIC总线只使用两条总线线路。 一条双向串行数据线（SDA），数据线用来表示数据 一条串行时钟线（SCL），时钟线用于同步数据的收发。 每个连接到总线的设备都有一个==独立==的地址，主机可以利用这个地址进行不同设备之间的访问。 总线通过上拉电阻接到电源。 当IIC设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态，由上拉电阻把总线拉成高电平。 当总线上开始发送数据，会将总线拉低，所以同一时刻，总线上只能有一条数据 多个主机同时使用总线时，为了防止数据冲突，会利用==仲裁==的方式决定由哪个设备占用总线。 具有三种传输模式： 标准模式传输速率为100kbps 快速模式为400kbps 高速模式可达3.4Mbps，但目前大多IIC设备尚不支持高速模式。 连接到相同总线的IIC设备数量收到总线的最大电容400pF限制。 在一主多从的情况下\n主机拥有SCL的绝对控制权，所以主机的SCL可以配置成推挽输出，所有从机的SCL都配置成浮空输入或者上拉输入，主机发送，从机接收\n由于是半双工的协议，所以主机的SDA在发送的时侯是输出，在接收的时候是输入，同样的，从机的SDA也会在输入和输出之间反复切换，为了协调这一点，==禁止所有设备输出强上拉的高电平，采用外置弱上拉电阻加开漏输出的电路结构==。\n图中的SCLK就是连接的结构图的SCL，SDA同理，所以才规定SCL和SDA都必须配置成==开漏输出==模式\n如果使用的是推挽输出，那么当SDA释放时，输出为强。 上图就是主机内部结构，左边为SCL，右侧为SDA，SCL经过一个施密特触发器对数据进行缓冲，任何设备在任何时候都是可以输入的。 输出低电平时，下管导通，强下拉，输出高电平时，下管断开，但是没有上管了，此时引脚属于浮空的状态，这样的话所有的设备只能输出低电平，而不能输出高电平，为了避免输出出现浮空状态，在外部添加一个上拉电阻（弱上拉），这样做的好处 完全杜绝了电源短路的现象，保证电路的安全 避免了引脚模式的频繁切换，开漏加弱上拉的模式，同时兼具了输入和输出的功能，如果想输出，就去拉杆子或者放手，操作杆子的变化即可，如果想输入，只需要直接放手，然后观察杆子的高低即可 存在线与的现象，只要有一个或者多个设备输出了低电平，总线就处于低电平，只有所有的设备都输出高电平，总线才处于高电平 协议层 基本时序单元 开始\nSCL初始保持高电平也是通过上拉电阻实现的，默认输出高电平\n如果想要开始通讯，就先将SDA拉下来，当从机捕获到SCL高电平且SDA==下降沿==信号时，就会进行自身的复位，等待主机的召唤，主机将SCL拉下来，将SCL拉下来一方面是为了占用这个总线，另外一方面也方便基本单元的拼接\nSCL高电平期间，SDA从高电平切换到低电平\n结束\n和起始相反，结束信号是SCL先放手，SDA再放手，产生一个上升沿，这个上升沿触发终止条件\nSCL高电平期间，SDA从低电平切换到高电平\n发送\n发送一个字节：SCL低电平期间，主机将数据位依次放到SDA线上(高位先行)，然后释放SCL,从机将在SCL高电平期间读取数据位所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节\n[!NOTE]\nI2C是高位先行，也就是先发送最高位B7，串口是低位先行。SCL低电平期间，允许改变SDA电平，也就是说在低电平期间，SDA可以切换1或0。当SCL变成高电平时，从机读取SDA，所以高电平期间，SDA不允许变化，一般都是在上升沿这个时刻，从机就已经完成了读取。从图中可以看出，主机基本上不用着急数据的存放读取，因为主机有时钟的主导权，但是从机就必须要尽快的读取和存放数据.可以理解为所有设备和从机都始终处于输入模式。当主机需要发送的时候，就可以主动去拉低SDA，而主机在被动接收的时候，就必须先释放SDA\n发送应答：主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答\n接收\n接收一个字节：SCL低电平期间，从机将数据位依次放到SDA线上(高位先行)，然后释放SCL,主机将在SCL高电平期间读取数据位所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA)\n[!TIP]\n要理解一旦有一个设备为低电平，整个总线都为低电平。当主机将SDA松开时（发送完一个字节的数据之后），如果没有设备下拉为低电平，那么整条总线就为高电平，说明没有设备给予应答，但是一旦有设备下拉SDA，就说明有设备收到数据，且给出应答\n接收应答：主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA)\n基本读写过程 S 表示由主机的 I2C 接口产生的传输起始信号(S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。 起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号(SLAVE_ADDRESS)。在 I2C 总线上，每个设备的地址都是唯一的（每个从机地址码不同，如果相同，可以通过调整从机上的引脚改变从机地址） 当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7 位或 10 位。 七位地址就是第一个字节就是地址+读写方向 十位地址就是使用两个字节作为地址，其中前面是标志位，表示使用10位地址，即11110+地址+读写方向。 在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。 从机接收到匹配的地址后，主机或从机会返回一个应答(ACK)或非应(NACK)信号，只有接收到应答信号后，主机才能继续发送或接收数据。 写数据\n若配置的方向传输位为“写数据”方向，广播完地址，接收到应答信号后，一般设备都会向从机发送一个寄存器的地址，用于目标寄存器，当收到应答时，主机开始正式向从机传输数据(DATA)，数据包的大小为 8位，主机每发送完一个字节数据，都要等待从机的应答信号(ACK)，重复这个过程，可以向从机传输 N 个数据，这个 N 没有大小限制。当数据传输结束时，主机向从机发送一个停止传输信号§，表示不再传输数据。\n读数据 若配置的方向传输位为“读数据”方向，广播完地址，接收到应答信号后:\n未指定地址读 主机立马就开始读取数据，但是没有指定寄存器地址，那么从机是读的哪里的数据呢？ 实际上在从机中，所有的寄存器被分配到了一个线性区域中，并且有一个单独的指针变量。指示其中一个寄存器，这个指针上电默认指向0地址，并且没写入或者读取一个字节后，这个指针就会自动自增一次，移动到下一个位置。 所以当主机要读取数据时，主机没有指定读取哪个地址，从机就会返回当前指针指向的寄存器中的值。 指定地址读 主机会发送一个写操作，接收到应答之后，主机会再次发送一个字节，用来指定需要读的地址，当从机接收到这个地址之后就会将寄存器指针改写为接收到的地址。这个时候我们就要切换成读数据模式了，所以要重新发送一个起始信号，重新开始读 从机开始向主机返回数据(DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号(ACK)，重复这个过程，可以返回 N 个数据，这个 N 也没有大小限制。当主机希望停止接收数据时，就向从机返回一个非应答信号(NACK)，则从机自动停止数据传输。\n读和写数据\n除了基本的读写，I2C 通讯更常用的是复合格式，该传输过程有两次起始信号(S)。一般在第一次传输中，主机通过SLAVE_ADDRESS 寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与 SLAVE_ADDRESS 的区别)；在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。\n数据的有效性\nIIC 使用 SDA 信号线来传输数据，使用 SCL 信号线进行数据同步。SDA数据线在 SCL 的每个时钟周期传输一位数据。传输时，SCL 为高电平的时候 SDA 表示的数据有效，即此时的 SDA 为高电平时表示数据“1”，为低电平时表示数据“0”。当 SCL为低电平时，SDA 的数据无效，一般在这个时候 SDA 进行电平切换，为下一次表示数据做好准备。\n地址和数据方向\nI2C 总线上的每个设备都有自己的独立地址，主机发起通讯时，通过 SDA 信号线发送设备地址(SLAVE_ADDRESS)来查找从机。I2C 协议规定设备地址可以是 7 位或 10 位，实际中 7 位的地址应用比较广泛。紧跟设备地址的一个数据位用来表示数据传输方向，它是数据方向位(R/W)，第 8 位或第 11 位。数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写数据。\n响应\nI2C 的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。作为数据接收端时，当设备(无论主从机)接收到 I2C 传输的一个字节数据或地址后，若希望对方继续发送数据，则需要向对方发送“应答(ACK)”信号，发送方会继续发送下一个数据；若接收端希望结束数据传输，则向对方发送“非应答(NACK)”信号，发送方接收到该信号后会产生一个停止信号，结束信号传输。\n完整的传输过程 IIC架构 通信引脚 I2C 的所有硬件架构都是根据图中左侧 SCL 线和 SDA 线展开的(其中的SMBA 线用于SMBUS 的警告信号，I2C 通讯没有使用)。STM32 芯片有多个 I2C 外设，它们的 I2C 通讯信号引出到不同的 GPIO 引脚上，使用时必须配置到这些指定的引脚。\n时钟的控制逻辑 SCL 线的时钟信号，由 I2C 接口根据时钟控制寄存器(CCR)控制，控制的参数主要为时钟频率。配置 I2C 的 CCR 寄存器可修改通讯速率相关的参数：可选择 I2C 通讯的“标准/快速”模式，这两个模式分别 I2C 对应 100/400Kbit/s 的通讯速率。\n在快速模式下可选择 SCL 时钟的占空比，可选 Tlow/Thigh=2 或Tlow/Thigh=16/9模式，我们知道 I2C 协议在 SCL 高电平时对 SDA 信号采样，SCL 低电平时 SDA准备下一个数据，修改 SCL 的高低电平比会影响数据采样，但其实这两个模式的比例差别并不大，若不是要求非常严格，这里随便选就可以了。\nCCR 寄存器中还有一个 12 位的配置因子 CCR，它与 I2C 外设的输入时钟源共同作用，产生 SCL 时钟，STM32 的 I2C 外设都挂载在 APB1 总线上，使用 APB1 的时钟源 PCLK1，SCL 信号线的输出时钟公式如下：\n$$ Thigh = CCR*TPCKL1 \\\\ Tlow = CCR*TPCLK1 $$$$ Thigh = CCR*TPCKL1 \\\\ Tlow = 2*CCR*TPCKL1 $$$$ Thigh = 9*CCR*TPCKL1 \\\\ Tlow = 16*CCR*TPCKL1 $$ 例如，我们的 PCLK1=36MHz，想要配置 400Kbit/s 的速率，计算方式如下：\nPCLK 时钟周期： TPCLK1 = 1/36000000\n目标 SCL 时钟周期： TSCL = 1/400000\nSCL 时钟周期内的高电平时间： THIGH = TSCL/3\nSCL 时钟周期内的低电平时间： TLOW = 2TSCL/3\n计算 CCR 的值： CCR = THIGH/TPCLK1 = 30\n计算结果得出 CCR 为 30，向该寄存器位写入此值则可以控制 IIC 的通讯速率为400KHz，其实即使配置出来的 SCL 时钟不完全等于标准的 400KHz，IIC 通讯的正确性也不会受到影响，因为所有数据通讯都是由 SCL 协调的，只要它的时钟频率不远高于标准即可。\n数据控制逻辑 I2C 的 SDA 信号主要连接到数据移位寄存器上，数据移位寄存器的数据来源及目标是数据寄存器(DR)、地址寄存器(OAR)、PEC 寄存器以及 SDA 数据线。\n当向外发送数据的时候，将一个字节的数据写入到数据寄存器（DR）中，数据移位寄存器以“数据寄存器”为数据源，把数据一位一位地通过 SDA 信号线发送出去。这时，置状态寄存器的TEX位为1，表示发送寄存器为空；\n当从外部接收数据的时候，数据移位寄存器把 SDA 信号线采样到的数据一位一位地存储到移位寄存器中，当一个字节的数据收齐之后，数据就整体从移位寄存器转到数据寄存器中，同时置RXNE，表示接收寄存器非空。\n若使能了数据校验，接收到的数据会经过 PEC 计算器运算，运算结果存储在“PEC 寄存器”中。\n当 STM32 的 I2C 工作在从机模式的时候，接收到设备地址信号时，数据移位寄存器会把接收到的地址与 STM32 的自身“I2C 地址寄存器”的值作比较，以便响应主机的寻址。STM32 的自身 I2C 地址(自定义地址)可通过修改“自身地址寄存器”修改，支持同时使用两个 I2C 设备地址，两个地址分别存储在 OAR1 和 OAR2 中，当有主机广播从机地址时，通过比较器比较，发现相同，则会作为从机响应外部主机的召唤。\n整体逻辑控制 整体控制逻辑负责协调整个 I2C 外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1/CR2)”的参数而改变。在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器(SR1 和 SR2)”，我们只要读取这些寄存器相关的寄存器位，就可以了解 I2C的工作状态。除此之外，控制逻辑还根据要求，负责控制产生 I2C 中断信号、DMA 请求及各种 I2C 的通讯信号(起始、停止、响应信号等)。\n通信过程 使用 I2C 外设通讯时，在通讯的不同阶段它会对“状态寄存器(SR1 及 SR2)”的不同数据位写入参数，我们通过读取这些寄存器标志来了解通讯状态。\n主发送器 主发送器发送流程及事件说明如下：\n(1) 控制产生起始信号(S)，当发生起始信号后，它产生事件“EV5”，并会对 SR1 寄存器的“SB”位置 1，表示起始信号已经发送；\n(2) 紧接着发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”及“EV8”，这时 SR1 寄存器的“ADDR”位及“TXE”位被置 1，ADDR 为 1 表示地址已经发送，TXE 为 1 表示数据寄存器为空；\n(3) 以上步骤正常执行并对 ADDR 位清零后，我们往 I2C 的“数据寄存器 DR”写入要发送的数据，这时 TXE 位会被重置 0，表示数据寄存器非空，I2C 外设通过SDA 信号线一位位把数据发送出去后，又会产生“EV8”事件，即 TXE 位被置 1，重复这个过程，就可以发送多个字节数据了；\n(4) 当我们发送数据完成后，控制 I2C 设备产生一个停止信号§，这个时候会产生EV8_2 事件，SR1 的 TXE 位及 BTF 位都被置 1，表示通讯结束。\n主接受器 主接收器接收流程及事件说明如下：\n(1) 同主发送流程，起始信号(S)是由主机端产生的，控制发生起始信号后，它产生事件“EV5”，并会对 SR1 寄存器的“SB”位置 1，表示起始信号已经发送；\n(2) 紧接着发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”这时SR1 寄存器的“ADDR”位被置 1，表示地址已经发送。\n(3) 从机端接收到地址后，开始向主机端发送数据。当主机接收到这些数据后，会产生“EV7”事件，SR1 寄存器的 RXNE 被置 1，表示接收数据寄存器非空，我们读取该寄存器后，可对数据寄存器清空，以便接收下一次数据。此时我们可以控制 I2C 发送应答信号(ACK)或非应答信号(NACK)，若应答，则重复以上步骤接收数据，若非应答，则停止传输；\n(4) 发送非应答信号后，产生停止信号§，结束传输。\n在发送和接收过程中，有的事件不只是标志了我们上面提到的状态位，还可能同时标志主机状态之类的状态位，而且读了之后还需要清除标志位，比较复杂。我们可使用STM32 标准库函数来直接检测这些事件的复合标志，降低编程难度。\n实验 软件实现 简介 EEPROM是一种掉电后据不丢失的储存器，常用来存储一些配置信息，在系统重新上电时就可以加载。\nAT24C02是一个2Kbit的EEPROM存储器，使用IIC通信方式。\n详细参数 AT24Cxx **容量（**bit） 页数 页内字节数 数据地址(占用bit数) AT24C01 1K bit (128 B) 16 8 Byte 7bit AT24C02 2K bit (256 B) 32 8 Byte 8bit AT24C04 4K bit (512 B) 32 16 Byte 9bit AT24C08 8K bit (1024 B) 64 16 Byte 10bit AT24C16 16K bit (2048 B) 128 16 Byte 11bit AT24C32 32K bit (4096 B) 128 32 Byte 12bit AT24C64 64K bit (8192 B) 256 32 Byte 13bit AT24C128 128K bit (16384 B) 256 64 Byte 14bit AT24C256 256K bit (32768 B) 512 64 Byte 15bit AT24C512 512K bit (65535 B) 512 128 Byte 16bit 通讯地址 通讯地址的高位一般都是由厂家设置好的，用户只可调整低位\n读写时序 写操作：\nAT24C02支持字节写模式和页写模式。 字节写模式就是一个地址一个数据进行写入。 页写模式就是连续写入数据。只需要写一个地址，连续写入据时地址会自增，但存在页的限制，超出一页时，超出数据覆盖原先写入的数据。但读会自动翻页。 读操作：\nAT24C02支持当前地址读模式，随机地址读模式和顺序读模式。 当前读模式是基于上一次读/写操作的最后位置继续读出数据。 随机地址读模式是指定地址读出数据。 顺序读模式是连续读出数据。 软件和硬件实现的区别 IIC 用法 速度 稳定性 管脚 硬件IIC 比较复杂 快 较稳定 需使用特定管脚 软件IIC 操作过程比较清晰 较慢 稳定 任意管脚，比较灵活 代码 void SCL_set(u8 bitValue) { GPIO_WriteBit(SCL_PORT,SCL_PIN,(BitAction)bitValue); Delay_us(10); } void SDA_set(u8 bitValue) { GPIO_WriteBit(SDA_PORT,SDA_PIN,(BitAction)bitValue); Delay_us(10); } u8 SDA_read(void) { u8 bitValue; bitValue = GPIO_ReadInputDataBit(SDA_PORT,SDA_PIN); Delay_us(10); return bitValue; } void myi2c_init(void) { GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(IIC_CLK,ENABLE); GPIO_InitStruct.GPIO_Pin = SCL_PIN | SDA_PIN; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(SCL_PORT,\u0026amp;GPIO_InitStruct); GPIO_SetBits(SCL_PORT,SCL_PIN | SDA_PIN); //将SCL和SDA都释放 } void myi2c_start(void) { //首先先释放SCL和SDA SDA_set(1); SCL_set(1); //起始信号开始,先拉低SDA，之后再拉低SCL SDA_set(0); SCL_set(0); } void myi2c_stop(void) { //为了确保SDA出现上升沿，我们需要先将SDA拉低，然后再释放 SDA_set(0); SCL_set(1); SDA_set(1); } void myi2c_sendByte(u8 data) { //保证发送完毕后使得SCL为低 for(u8 i = 0;i \u0026lt; 8; i++){ SDA_set(data \u0026amp; (0x80 \u0026gt;\u0026gt; i)); SCL_set(1); SCL_set(0); } } u8 myi2c_receiveByte() { u8 data = 0x00; SDA_set(1); //主机释放SDA，这个时候从机就可以开始任意写数据了 for(u8 i = 0; i \u0026lt; 8; i++){ SCL_set(1); //主机释放SCL，主机开始从SDA读取数据，此时SCL不能改变 if(SDA_read() == 1){ data |= (0x80 \u0026gt;\u0026gt; i); } SCL_set(0); } return data; } void myi2c_sendAck(u8 ACKbit) { SDA_set(ACKbit); SCL_set(1); SCL_set(0); } u8 myi2c_receiveAck() { u8 ACKbit = 0x00; SDA_set(1); //主机释放SDA，这个时候从机就可以开始任意写数据了 SCL_set(1); //主机释放SCL，主机开始从SDA读取数据，此时SCL不能改变 ACKbit = SDA_read(); SCL_set(0); return ACKbit; } void eeprom_writeReg(u8 address,u8 data) { myi2c_start(); myi2c_sendByte(EEPROM_ADDRESS); myi2c_receiveAck(); myi2c_sendByte(address); myi2c_receiveAck(); myi2c_sendByte(data); myi2c_receiveAck(); myi2c_stop(); //由于eeprom写入较慢，所以需要延迟10ms才能生效 Delay_ms(10); } u8 eeprom_readReg(u8 address) { u8 data; myi2c_start(); myi2c_sendByte(EEPROM_ADDRESS); myi2c_receiveAck(); myi2c_sendByte(address); myi2c_receiveAck(); myi2c_start(); myi2c_sendByte(EEPROM_ADDRESS | 0x01); myi2c_receiveAck(); data = myi2c_receiveByte(); myi2c_sendAck(1); myi2c_stop(); return data; } int main(void){ char str[50]; u8 data = 0x00; myi2c_init(); serial_init(); eeprom_writeReg(0x19,0x55); data = eeprom_readReg(0x19); sprintf(str,\u0026#34;get the data: %x\\n\u0026#34;,data); send_string(str); while(1){ } } 硬件实现 主机发送\n当起始信号来临时，会产生一个EV5事件，可以将这些EV事件看作是标志位\n主机接收 代码 void hareWare_myi2c_init() { RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2,ENABLE); RCC_APB2PeriphClockCmd(HARDWARE_IIC_CLK,ENABLE); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Pin = HARDWARE_IIC_SCL_PIN | HARDWARE_IIC_SDA_PIN; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(HARDWARE_IIC_PORT,\u0026amp;GPIO_InitStruct); I2C_InitTypeDef I2C_InitStruct; I2C_InitStruct.I2C_Ack = I2C_Ack_Enable; I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; I2C_InitStruct.I2C_ClockSpeed = 50000; I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;\t//只有在时钟频率大于100KHz的情况下才有用，在小于100KHz的情况下，低电平时间比高电平时间约为1：1 I2C_InitStruct.I2C_Mode = I2C_Mode_I2C; I2C_InitStruct.I2C_OwnAddress1 = 0x00; I2C_Init(I2C2,\u0026amp;I2C_InitStruct); I2C_Cmd(I2C2,ENABLE); } //防止等待不到事件而出现卡死状态 void waitEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT) { u32 timeout = 10000; while(I2C_CheckEvent(I2Cx,I2C_EVENT) != SUCCESS){ timeout--; if(timeout == 0) return; } } void hardware_eeprom_writeReg(u8 address,u8 data) { I2C_GenerateSTART(I2C2,ENABLE); waitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);\t//相较于软件的阻塞型的通信，硬件I2C需要每次检查事件（EV5）是否发生 I2C_Send7bitAddress(I2C2,EEPROM_ADDRESS,I2C_Direction_Transmitter); waitEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);\t//这里就不需要等待ACK了，只需要检查事件（EV6）是否发生即可 I2C_SendData(I2C2,address); waitEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING);\t//等待发送事件（EV8），如果想要连续发送，只需要每次发送完等待EV8即可 I2C_SendData(I2C2,data); waitEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED);\t//发送结束后，我们需要等待EV8_2事件，标志传输结束 I2C_GenerateSTOP(I2C2,ENABLE); } u8 hardware_eeprom_readReg(u8 address) { u8 data; I2C_GenerateSTART(I2C2,ENABLE); waitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);\t//相较于软件的阻塞型的通信，硬件I2C需要每次检查事件（EV5）是否发生 I2C_Send7bitAddress(I2C2,EEPROM_ADDRESS,I2C_Direction_Transmitter); waitEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);\t//这里就不需要等待ACK了，只需要检查事件（EV6）是否发生即可 I2C_SendData(I2C2,address); waitEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED);\t//这里等待的事件可以是TRANSMITTING，也可以是TRANSMITED I2C_GenerateSTART(I2C2,ENABLE); waitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);\t//重复起始条件 I2C_Send7bitAddress(I2C2,EEPROM_ADDRESS,I2C_Direction_Receiver); waitEvent(I2C2,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);\t//设置读取模式 I2C_AcknowledgeConfig(I2C2,DISABLE);\t//在接收最后一个字节之前，就需要提前将ack置零，同时设置停止位STOP,对应于EV6_1事件，EV6_1事件仅用于等待接收一个字节的情况 I2C_GenerateSTOP(I2C2,ENABLE); waitEvent(I2C2,I2C_EVENT_MASTER_BYTE_RECEIVED);\t//等待事件EV7 data = I2C_ReceiveData(I2C2);\t//该函数可以读取DR中的数值 I2C_AcknowledgeConfig(I2C2,ENABLE);\t//这里是为了程序收多个字节 return data; } int main(void){ char str[50]; u8 data = 0x00; hareWare_myi2c_init(); serial_init(); hardware_eeprom_writeReg(0x19,0x66); Delay_ms(20); //注意，写完之后一定要延时20ms，因为eeprom写入较慢，所以如果不延时20ms的话将会卡死 data = hardware_eeprom_readReg(0x19); sprintf(str,\u0026#34;get the data: %x\\n\u0026#34;,data); send_string(str); while(1){ } } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/mqtt/",
    "title": "",
    
    "content": "",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/spi/",
    "title": "",
    
    "content": " 参考链接 SPI协议详解（图文并茂+超详细） - 知乎 (zhihu.com)\n串口 因为UART没有时钟信号，无法控制何时发送数据，也无法保证双方按照完全相同的速度接收数据。因此，双方以不同的速度进行数据接收和发送，就会出现问题。\n如果要解决这个问题，UART为每个字节添加额外的起始位和停止位，以帮助接收器在数据到达时进行同步；\n双方还必须事先就传输速度达成共识（设置相同的波特率，例如每秒9600位）。\n传输速率如果有微小差异不是问题，因为接收器会在每个字节的开头重新同步。相应的协议如下图所示：\n[!NOTE]\n图中的11001010不等于0x53。这是因为串口协议通常会首先发送最低有效位，因此最小位在最左边LSB。低四位字节实际上是0011 = 0x3，高四位字节是0101 = 0x5。\n串口先发送低位，后发送高位\n异步串行工作得很好，但是在每个字节发送的时候都需要额外的起始位和停止位以及在发送和接收数据所需的复杂硬件方面都有很多开销。\n不难发现，如果接收端和发送端设置的速度都不一致，那么接收到的数据将是垃圾（乱码）。\n因为UART没有时钟信号，无法控制何时发送数据，也无法保证双方按照完全相同的速度接收数据。因此，双方以不同的速度进行数据接收和发送，就会出现问题。\n于是我们想有没有更好一点的串行通讯方式；相比较于UART，SPI的工作方式略有不同。\nSPI是一个同步的数据总线，也就是说它是用单独的数据线和一个单独的时钟信号来保证发送端和接收端的完美同步。 时钟是一个振荡信号，它告诉接收端在确切的时机对数据线上的信号进行采样。 产生时钟的一侧称为主机，另一侧称为从机。总是只有一个主机（一般来说可以是微控制器/MCU），但是可以有多个从机（后面详细介绍）； 数据的采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低）。 介绍 SPI:串行外设设备接口(Serial Peripheral Interface),是一种高速的、全双工、同步的通信总线。\n功能说明 SPI总线 IIC总线 通信方式 同步串行全双工 同步串行半双工 总线接口 MOSI、MISO、SCL、CS SDA、SCL 拓扑结构 一主多从/一主一从 多主从 从机选择 片选引脚选择 SDA上设备地址片选 通信速率 般50MHz以下 100kHz、400kHz、3.4MHz 数据格式 8位/16位 8位 传输顺序 MSB/LSB MSB SP接口主要应用在存储芯片、AD转换器以及LCD中。\n[!IMPORTANT]\n输出引脚配置为推挽输出，输入引脚配置为浮空或者上拉输入，推挽输出高低电平都有着很强的驱动能力，和i2c不同，i2c电平下降快，上升缓慢，而SPI电平不仅上升快，下降也快\n主机一个输入引脚，这个引脚将会接收来自多个从机传输的数据，这势必会产生冲突，所以SPI规定，当从机未被选中时，MISO引脚必须切换为高阻态（相当于引脚断开，不输出任何电平）\n原理 基本收发电路就是一个==移位模型==\nSPI主机中有一个8位移位寄存器，SPI从机中也有一个8位的移位寄存器，移位寄存器有一个时钟输入端，SPI一般都是==高位==先行的，每来一个时钟，移位寄存器都会向左进行移位，从机中的移位寄存器也是同理。移位寄存器的时钟源由主机提供（波特率发生器），它产生的时钟驱动主机的移位寄存器进行移位，同时，这个时钟也通过SCK引脚进行输出给到从机的移位寄存器中，主机移位寄存器左边移出去的数据，通过MOSI输入到从机移位寄存器的右边，从机移位寄存器左边移出去的数据，通过MISO输入到主机移位寄存器的右边\n如果是主机只是发送（只是接收），那么还是和上面同时收发一样，只是从机会随便发送一串数据（一般会给0xff或0x00），只要将数据置换出来即可，主机不会关注接收到的数据\n特性 框架图 信号线 MISO：Master input slave output 主机输入，从机输出（数据来自从机）； MOSI：Master output slave input 主机输出，从机输入（数据来自主机）； SCLK ：Serial Clock 串行时钟信号，由主机产生发送给从机； SS：Slave Select 片选信号，由主机发送，以控制与哪个从机通信，通常是低电平有效信号。 时钟极性 除了配置串行时钟速率（频率）外，SPI主设备还需要配置时钟极性。\n根据硬件制造商的命名规则不同，时钟极性通常写为CKP或CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据；\nCKP可以配置为1或0。这意味着您可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。您必须参考设备的数据手册才能正确设置CKP和CKE。\nCKP = 0：时钟空闲IDLE为低电平 0； CKP = 1：时钟空闲IDLE为高电平1； 时钟相位 除配置串行时钟速率和极性外，SPI主设备还应配置时钟相位（或边沿）。根据硬件制造商的不同，时钟相位通常写为CKE或CPHA；\n顾名思义，时钟相位/边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；\nCKE = 0：在时钟信号SCK的第一个跳变沿采样； CKE = 1：在时钟信号SCK的第二个跳变沿采样； 如何确定数据的有效性：\n时钟极性(CPOL)：没有数据传输时时钟线的空闲状态电平\n0:SCK在空闲状态保持低电平 1：SCK在空闲状态保持高电平 时钟相位(CPHA):时钟线在第几个时钟边沿采样数据\n0:SCK的第一（奇数）边沿进行数据位采样，据在第一个时钟边沿被锁存 1：SCK的第二（偶数边沿进行数据位采样，数据在第二个时钟边沿被锁存 SPI工作模式 CPOL CPHA SCL空闲状态 采样边沿 采样时刻 0 0 0 低电平 上升沿 奇数边沿 1 0 1 低电平 下降沿 偶数边沿 2 1 0 高电平 下降沿 奇数边沿 3 1 1 高电平 上升沿 偶数边沿 SPI协议也需要MCU和芯片使用相同的时钟相位和极性来进行数据通信，比如芯片使用0状态进行通信，那么MCU就不能配置1/2/3状态进行通信，所以配置MCU需要看芯片手册支持什么时钟\n数据传输过程 基本时序单元 起始条件 SS从高电平切换到低电平\n终止条件 SS从低电平切换到高电平\n交换一个字节的数据传输过程 模式0\nCPOL=0:空闲状态时，SCK为低电平\nCPHA=0:SCK第一个边沿移入数据，第二个边沿移出数据\n模式1\nCPOL=O:空闲状态时，SCK为低电平\nCPHA=1:SCK第一个边沿移出数据，第二个边沿移入数据\n模式2\nCPOL=1:空闲状态时，SCK为高电平\nCPHA=0:SCK第一个边沿移入数据，第二个边沿移出数据\n模式3\nCPOL=1:空闲状态时，SCK为高电平\nCPHA=1:SCK第一个边沿移出数据，第二个边沿移入数据\n整体数据传输过程 数据的传输分为以下几个步骤：\n主机先将NSS信号拉低，这样保证开始接收数据； 当接收端检测到时钟的边沿信号时，它将立即读取数据线上的信号，这样就得到了一位数据（1bit）; 由于时钟是随数据一起发送的，因此指定数据的传输速度并不重要，尽管设备将具有可以运行的最高速度（稍后我们将讨论选择合适的时钟边沿和速度）。 主机发送到从机时：主机产生相应的时钟信号，然后数据一位一位地将从MOSI信号线上进行发送到从机； 主机接收从机数据：如果从机需要将数据发送回主机，则主机将继续生成预定数量的时钟信号，并且从机会将数据通过MISO信号线发送； [!NOTE]\n注意，SPI是“全双工”（具有单独的发送和接收线路），因此可以在同一时间发送和接收数据，另外SPI的接收硬件可以是一个简单的移位寄存器。这比异步串行通信所需的完整UART要简单得多，并且更加便宜；\n多从机模式 多NSS 通常，每个从机都需要一条单独的SS线。\n如果要和特定的从机进行通讯，可以将相应的NSS信号线拉低，并保持其他NSS信号线的状态为高电平；如果同时将两个NSS信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条MISO线上传输数据，最终导致接收数据乱码。\n菊花链 在数字通信世界中，在设备信号（总线信号或中断信号）以串行的方式从一 个设备依次传到下一个设备，不断循环直到数据到达目标设备的方式被称为菊花链。\n菊花链的最大缺点是因为是信号串行传输，所以一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了； 另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况； 具体的连接如下图所示；\n实验 Flash FLASH是常用的用于储存数据的半导体器件，它具有容量大，可重复擦写、按“扇区/块”擦除、掉电后数据可继续保存的特性。\nFLASH是有一个物理特性：只能写0，不能写1，写1靠擦除。\nFLASH:主要有NOR FIash和NAND FIash两种类型，NOR和NAND是两种数字门电路。\n类型 特点 应用举例 NOR FLASH 基于字节读写，读取速度快，独立地址/数据线，无坏块，支持XIP 25Qxx、程序ROM NAND FLASH 基于块读写，读取速度稍慢，地址数据线共用，有坏块，不支持XIP EMMC、SSD、U盘等 芯片简介 NM25Q18\nNM25Q128,串行闪存器件，属于N0 R FLASH中的一种，容量为128Mb。擦写周期可达10W次，可以将数据保存达20年之久。\nSPI数据传输时序:支持模式0(CPOL=0,CPHA=0)和模式3(CPOL=1,CPHA=1) 数据格式:数据长度8位大小，先发高位，再发低位 传输速度:支持标准模式104 M bit/s NM25Q18存储结构 存储器的地址范围为0x000000 ~0xFFFFFF\n那么一个模块大存储大小 = 256 * 16 * 16 * 256 = 2^24 = 0xFFFFFF\n一般将一个flash分为多个模块来使用？\n例如：使用0x00 ~ 0x0000ff作为文件系统使用\n使用0x0000ff~0x00ffff作为文件存储使用等等\n[!IMPORTANT]\n当我们使用的时候只需要往分配好的模块写入或者读出数据即可\n擦除只能擦除最小单元，比如页擦除、扇区擦除及整个芯片擦除，擦除的时间比写入的时间要更长\n写入不能跨页，但是读可以跨页\n常用命令 NOR FLASHE的指令总数比较多，但是如果只需要实现基本操作，还是比较简单的\n一般我们只需要5条指令即可完成对NOR FLASH的基本使用\n指令 (HEX) 名称 作用 0X06 写使能 写入数据/擦除之前，必须先发送该指令 0X05 读SR1 判定FLASH是否处于空闲状态，擦除用 0X03 读数据 用于读取NOR FLASH数据 0X02 页写 用于写入NOR FLASH数据，最多写256字节 0X20 扇区擦除 扇区擦除指令，最小擦除单位 （4096字节) 写使能06H\n执行Page Program（页写），Sector Erase（扇区擦除），Block Erase（块擦除），Chip Erase（片擦除），Write Status Register（写状态寄存器）等指令前，都需要写使能\n读状态寄存器05H\n读时序03H\n页写时序02H\n页写命令最多可以向FLASH传输256个字节的数据\n扇区擦除时序20H\n写入数据前，检查内存空间情况是否满足，不满足需擦除\n[!NOTE]\nFLASH初始化的时候，数据全为1，当我们想要写入零时，可以直接将1写为0，但是我们将0写为1时，就不能直接写，一般flash都是先擦除后写入，也就是写入0的过程\n状态寄存器表\n状态寄存器 Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bito 状态寄存器1 SPR RV TB BP2 BP1 BPO WEL BUSY 状态寄存器2 SUS CMP LB3 LB2 LB1 (R) QE SRP1 状态寄存器3 HOLD/RST DRV1 DRVO (R) (R) WPS ADP ADS SR寄存器：跟踪芯片的状态\nBUSY位指示当前状态：\n0:空闲状态（硬件自动清除） 1:当前处于忙碌状态 WEL位：\n执行Write Enable指令该位为1，可以页写/扇区or块or片擦除/写状态寄存器 0:写禁止，不能页编程/扇区or块or片擦除/写状态寄存器 软件模拟 void myspi_ss_set(u8 bitValue) { GPIO_WriteBit(SPI_PORT,SPI_SS,(BitAction)bitValue); } void myspi_sck_set(u8 bitValue) { GPIO_WriteBit(SPI_PORT,SPI_SCK,(BitAction)bitValue); } void myspi_si_set(u8 bitValue) { GPIO_WriteBit(SPI_PORT,SPI_SI,(BitAction)bitValue); } u8 myspi_so_get() { return GPIO_ReadInputDataBit(SPI_PORT,SPI_SO); } void myspi_init(void) { GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(SPI_CLK,ENABLE); GPIO_InitStruct.GPIO_Pin = SPI_SS | SPI_SCK | SPI_SI; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = SPI_SO; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); myspi_ss_set(1); myspi_sck_set(0); } void myspi_start(void) { myspi_ss_set(0); } void myspi_stop(void) { myspi_ss_set(1); } u8 myspi_swapByte(u8 data) { u8 receiveData = 0x00; for(u8 i = 0; i \u0026lt; 8 ; i++){ myspi_si_set(data \u0026amp; (0x80 \u0026gt;\u0026gt; i)); //模式0，先移除最高位，发送数据 myspi_sck_set(1); //第一个上升沿来临 if(myspi_so_get() == 1){ receiveData |= (0x80 \u0026gt;\u0026gt; i); //接收数据 } myspi_sck_set(0); //下降沿来临 } return receiveData; } void w25q_init(void) { myspi_init(); } void w25q_readId(u8* MID,u16* DID) { myspi_start(); myspi_swapByte(GET_W25Q_ID); //发送读取flash的制造商ID和设备ID的指令号9f *MID = myspi_swapByte(SPI_DUMMY); //接收从机返回来的数据，为了交换数据，我们任意给一个数据ff，ff的目的就是将对面有意义的数据置换过来 *DID = myspi_swapByte(SPI_DUMMY); //读取高八位 *DID \u0026lt;\u0026lt;= 8; *DID |= myspi_swapByte(SPI_DUMMY); //读取低八位，注意需要使用| myspi_stop(); } void w25q_writeEnable(void) { myspi_start(); myspi_swapByte(W25Q_WRITEENABLE); myspi_stop(); } void w25q_waitBusy() { u32 timeOut = 100000; myspi_start(); myspi_swapByte(W25Q_READ_REGISTER_1); while((myspi_swapByte(SPI_DUMMY) \u0026amp; 0x01) == 0x01){ //判断芯片是否空闲，使用掩码取出最低位，最低位为busy位，1为繁忙，0为空闲 timeOut--; if(timeOut == 0){ break; } } myspi_stop(); } void w25q_pageProgram(u32 address,u8* dataArray,u16 count)//页只能写0-256，如果超过256，则后续的页将会覆盖之前的页 { w25q_writeEnable(); myspi_start(); myspi_swapByte(W25Q_PAGEPROGRAM); //发送指令 myspi_swapByte(address \u0026gt;\u0026gt; 16); //发送地址，先发送高字节 myspi_swapByte(address \u0026gt;\u0026gt; 8); myspi_swapByte(address); for(u16 i = 0; i \u0026lt; count; i++){ myspi_swapByte(dataArray[i]); } myspi_stop(); w25q_waitBusy(); } //擦除扇区 void w25q_sectorErase(u32 address) { w25q_writeEnable(); myspi_start(); myspi_swapByte(W25Q_SECTOR_EARSE_4KB); //发送指令 myspi_swapByte(address \u0026gt;\u0026gt; 16); //发送地址，先发送高字节 myspi_swapByte(address \u0026gt;\u0026gt; 8); myspi_swapByte(address); myspi_stop(); w25q_waitBusy(); } void w25q_readData(u32 address,u8* dataArray,u16 count) { myspi_start(); myspi_swapByte(W25Q_READ_DATA); //发送指令 myspi_swapByte(address \u0026gt;\u0026gt; 16); //发送地址，先发送高字节 myspi_swapByte(address \u0026gt;\u0026gt; 8); myspi_swapByte(address); for(u32 i = 0; i \u0026lt; count; i++){ dataArray[i] = myspi_swapByte(SPI_DUMMY); } myspi_stop(); } int main(void){ char str[50]; char str_tmp[50]; u8 arrayWrite[] = {0x01,0x02,0x03,0x04}; u8 arrayRead[4]; w25q_init(); serial_init(); w25q_sectorErase(0x000000); w25q_pageProgram(0x000000,arrayWrite,4); w25q_readData(0x000000,arrayRead,4); sprintf(str,\u0026#34;write: %u %u %u %u\\n \u0026#34;,arrayWrite[0],arrayWrite[1],arrayWrite[2],arrayWrite[3]); send_string(str); sprintf(str_tmp,\u0026#34;read: %u %u %u %u\\n \u0026#34;,arrayRead[0],arrayRead[1],arrayRead[2],arrayRead[3]); send_string(str_tmp); while(1){ } } 硬件部分 主模式全双工连续传输\n使用模式3：\n非连续传输：\n代码\nvoid hardware_myspi_init() { GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(SPI_CLK,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE); GPIO_InitStruct.GPIO_Pin = SPI_SS; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = SPI_SCK | SPI_SI; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = SPI_SO; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); SPI_InitTypeDef SPI_InitStruct; SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128; SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge; SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low; SPI_InitStruct.SPI_CRCPolynomial = 7; SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b; //8bit SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex; SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB; //高位先行 SPI_InitStruct.SPI_Mode = SPI_Mode_Master; SPI_InitStruct.SPI_NSS = SPI_NSS_Soft; SPI_Init(SPI2,\u0026amp;SPI_InitStruct); SPI_Cmd(SPI2,ENABLE); myspi_ss_set(1); } u8 hardware_myspi_swapData(u8 data) { while(SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_TXE) != SET); //等待TEX变为1，发送寄存器为空，如果发送寄存器不为空，则需要等待 SPI_I2S_SendData(SPI2,data); //传入data之后，将会写入到TDR中，之后TDR将会自动转入移位寄存器。由于使用非连续传输，所以在传入数据的这一时间段，下一个数据不会转移到TDR中 while(SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_RXNE) != SET);//在发送的同时，MISO还会接收，发送和接收是同步的，也就是说接收移位完成也代表发送移位完成，接收数据完成后，会置RXNE标志位，所以只需要等待RXNE出现即可 return SPI_I2S_ReceiveData(SPI2); } ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/tcp%E5%92%8Cudp/",
    "title": "",
    
    "content": " 参考链接 OSI七层模型、TCP/IP四层模型（超详细！！！！！）-CSDN博客\nOSI 七层模型，亦称==OSI==（Open System Interconnection）。参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/",
    "title": "",
    
    "content": " 参考链接 《UDS协议从入门到精通（UDS速查手册）》（完结撒花版）_obdonuds-CSDN博客\n简介 UDS (Unified Diagnostic Services) 是一种标准化的==车辆诊断协议==，广泛应用于汽车电子控制单元（ECU）的诊断和维修。它是ISO 14229标准的一部分，主要用于车辆诊断、故障排除、软件更新和其他与车辆维护相关的服务。\nUDS协议栈 UDS（Unified Diagnostic Services）协议栈是实现UDS协议功能的分层架构，确保汽车电子控制单元（ECU）与诊断工具之间的通信。UDS协议栈通常包括以下几层：\n应用层（Application Layer）：应用层是UDS协议栈的最高层，负责实现具体的诊断服务。它定义了各种诊断服务，如读取数据、清除故障码、重置ECU等。这一层的功能由==ISO 14229标准==规定。 传输层（Transport Layer）：传输层负责数据的分段、重组和流量控制。UDS协议通常使用ISO 15765-2（CAN TP）作为其传输层协议。传输层处理较大的诊断消息，通过将它们分成较小的帧进行传输，然后在接收端重组这些帧。 网络层（Network Layer）：网络层管理数据包的寻址和路由。在UDS协议中，网络层通常依赖于ISO 15765-3标准，这一标准定义了如何在CAN网络上传输诊断信息。网络层确保诊断消息能够正确到达目标ECU。 数据链路层（Data Link Layer）：数据链路层负责物理网络上的数据帧传输和错误检测。在UDS协议中，数据链路层通常基于CAN（Controller Area Network）协议，由ISO 11898标准定义。数据链路层处理数据帧的发送和接收，并提供基本的错误检测和恢复机制。 物理层（Physical Layer）：物理层定义了实际的硬件接口和信号传输特性。在UDS协议中，物理层通常是基于CAN总线的物理层，由ISO 11898标准定义。这一层包括信号的电气特性、连接器和传输介质（如电缆）的规范。 不同层的数据格式 物理层：比特（Bit）：物理层传输的是原始的二进制数据，即 0 和 1 的比特流。\n数据链路层：帧（Frame）：数据链路层的 PDU 是帧，它包括数据包的开始和结束标志、帧同步信息、地址信息、控制信息以及实际的数据负载。\n网络层： …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/",
    "title": "",
    
    "content": " 软件的使用 IAR 出现的问题 解决方法 使用IAR时，使用自己安装的jlink IAR 9.32.1版本 用自安装版本的jlink驱动替代IAR下自带版本下载驱动-CSDN博客 KEIL 出现的问题 解决方法 在使用keil时，找不到ARM5编译器 https://www.bilibili.com/opus/792171310244429829 wireShark的使用 低功耗蓝牙协议栈入门（四）空中抓包 （WireShark + nRF Sniffer）BalanceTWK的博客 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%A1%AC%E4%BB%B6/%E6%A8%A1%E7%94%B5/",
    "title": "",
    
    "content": " 参考链接 02-PN结的形成_4K_哔哩哔哩_bilibili\n绪论 模拟信号 电子电路中信号的分类\n数字信号：离散性\n数字信号不仅仅在时间上是离散的，在数值上也是离散的。信号必须是整数值\n如果出现了夹在两个整数中间的小数（k\u0026rsquo;）,那么k\u0026rsquo;就需要根据阈值确定为k还是k+1\n模拟信号：连续性。==大多数物理量为模拟信号==。\n模拟信号不仅在时间上连续，在数值上也是连续的\n常见半导体 本征半导体 ==纯净的具有晶体结构的半导体==称为本征半导体。\n==半导体==\n物质的导电性能决定于原子结构。导体一般为低价元素，它们的最外层电子极易挣脱原子核的束缚成为自由电子，在外电场的作用下产生定向移动，形成电流。高价元素（如惰性气体）或高分子物质（如橡胶），它们的最外层电子受原子核束缚力很强，很难成为自由电子，所以导电 性极差，成为绝缘体。常用的半导体材料硅(Si)和锗(G)均为四价元素，它们的最外层电子既不像导体那么容易挣脱原子核的束缚，也不像绝缘体那样被原子核束缚得那么紧，因而其导电性介于二者之间。 在形成晶体结构的半导体中，人为地参入特定的杂质元素时，导电性能具有可控性：并且，在光照和热辐射条件下，其导电性还有明显的变化：这些特殊的性质就决定了半导体可以制成各种电子器件。\n==本征半导体的晶体结构==\n==将纯净的半导体经过一定的工艺过程制成单晶体，即为本征半导体==。晶体中的原子在空间形成排列整齐的点阵，称为晶格。由于相邻原子间的距离很小，因此，相邻的两个原子的一对最外层电子（即价电子）不但各自围绕自身所属的原子核运动，而且出现在相邻原子所属的轨道上，成为共用电子，这样的组合称为共价键结构，如下图所示。图中标有“+4”的圆圈表示除价电子外的正离子。\n==本征半导体中的两种载流子==\n晶体中的共价键具有很强的结合力，因此，在常温下，仅有极少数的价电子由于热运动（热激发)获得足够的能量，从而挣脱共价键的束缚变成为自由电子。与此同时，在共价键中留下一个空位置，称为==空穴==。原子因失掉一个价电子而带正电，或者说空穴带正电。在本征半导体中，自由电子与空穴是成对出现的，即自由电子与空穴数目相等，如下图所示。\n若在本征半导体两端外加一电场，则一方面自由电子将产生定向移动，形成电子电流； 另一方面由于空穴的存在，价电子将按一定的方向依次填补空穴，也就是说空穴也产生定向移动，形成空穴电流。 运载电荷的粒子称为载流子。导体导电只有一种载流子，即自由电子导电；==而本征半导体有两种载流子，即自由电子和空穴均参与导电==，这是半导体导电的特殊性质。\n[!tip]\n空穴是相对运动，由于自由电子和空穴所带电荷极性不同，所以它们的运动方向相反，==本征半导体中的电流是两个电流之和==。\n==本征半导体中载流子的浓度==\n半导体在热激发下产生自由电子和空穴对的现象称为==本征激发==。 自由电子在运动的过程中如果与空穴相遇就会填补空穴，使两者同时消失，将这种现象称为==复合==。 在不同的热激发下，半导体的浓度不同：\n在一定的温度下，本征激发所产生的自由电子与空穴对，与复合的自由电子与空穴对数目相等，故达到==动态平衡==。换言之，在一定温度下，本征半导体中载流子的浓度是一定的，并且自由电子与空穴的浓度相等。 当环境温度升高时，热运动加剧，挣脱共价键束缚的自由电子增多，空穴也随之增多，即载流子的浓度升高，因而必然使得导电性能增强。 若环境温度降低，则载流子的浓度降低，因而导电性能变差，可见，本征半导体载流子的浓度是环境温度的函数。理论分析表明，本征半导体载流子的浓度为： $$\rn_i=p_i=K_iT^{\\frac{3}{2}}e^{\\frac{E_{co}}{2kT}}\r$$ 式中$n_i$,和$p_i$分别表示自由电子与空穴的浓度($cm^{-3}$),T为热力学温度，k为玻尔兹曼常数($8.63×10^{-5}eV/K$),$E_{co}$为热力学零度时破坏共价键所需的能量，又称禁带宽度（硅为1.21eV,锗为0.785eV),$K_i$是与半导体材料载流子有效质量、有效能级密度有关的常量（硅为$3.87×10^{16}cm^{-3} \\cdot K^{\\frac{-3}{2}}$,锗为$1.76×10^{16}cm^{-3} \\cdot K^{\\frac{-3}{2}}$)。上式表明，当T=0 K时，自由电子与空穴的浓度均为零，本征半导体成为绝缘体；在一定范围内，当温度升高时，本征半导体载流子的浓度近似按指数曲线升高。在常温下，即T=300K时，硅材料的本征载流子浓度$n_i=P_i=1.43×10^{10}cm^{-3}$,锗材料的本征载流子浓度$n_i=p_i=2.38×10^{13}cm^{-3}$。\n应当指出，本征半导体的导电性能很差，且与环境温度密切相关。半导体材料性能对温度的这种敏感性，既可以用来制作热敏和光敏器件，又是造成半导体器件温度稳定性差的原因。\n[!tip]\n半导体的导电能力和半导体中的载流子浓度有关。实际上本征半导体的导电能力很差，也不咋导电、也不咋绝缘。\n从公式中可以看出，载流子的浓度和温度有关‼\n杂质半导体 通过扩散工艺，在本征半导体中掺入少量合适的杂质元素，便可得到==杂质半导体==。按掺入的杂质元素不同，可形成N型半导体和P型半导体：控制掺入杂质元素的浓度，就可控制杂质半导体的导电性能。\nN型半导体 在纯净的硅晶体中掺入==五价元素==（如磷（P）），使之取代晶格中硅原子的位置，就形成了==N型半导体==。由于杂质原子的最外层有五个价电子，所以除了与其周围硅原子形成共价键外，还多出一个电子，如图所示。\n多出的电子不受共价键的束缚，只需获得很少的能量，就成为自由电子。在常温下，由于热激发，就可使它们成为自由电子。而杂质原子因在晶格上，且又缺少电子，故变为不能移动的正离子。N型半导体中，自由电子的浓度大于空穴的浓度，故称自由电子为==多数载流子==，空穴为==少数载流子==：简称前者为==多子==，后者为==少子==。\n由于杂质原子可以提供电子，故称之为==施主原子==。N型半导体主要靠自由电子导电，掺入的杂质越多，多子（自由电子）的浓度就越高，导电性能也就越强。\n[!tip]\n电子较多，所以叫多子。空穴较少，所以叫少子。（多子和少子的判定规则）\n[!important]\n如果半导体中的某一个特性和少子相关，那么他受温度影响较大。\nP型半导体 在纯净的硅晶体中参入三价元素（如硼），使之取代晶格中硅原子的位置，就形成P型半导体。由于杂质原子的最外层有3个价电子，所以当它们与周围的硅原子形成共价键时，就产生了一个“空位”（空位为电中性），当硅原子的外层电子填补此空位时，其共价键中便产生一个空穴，如图所示，而杂质原子成为不可移动的负离子。\n因而P型半导体中，空穴为多子，自由电子为少子，主要靠空穴导电。与N型半导体相同，掺入的杂质越多，空穴的浓度就越高，使得导电性能越强。因杂质原子中的空位吸收电子，故称之为受主原子。\n[!note]\n从以上分析可知，由于掺入的杂质使多子的数目大大增加，从而使多子与少子复合的机会大大增多。因此，对于杂质半导体，多子的浓度愈高，少子的浓度就愈低。可以认为，多子的浓度约等于所掺杂质原子的浓度，因而它受温度的影响很小；而少子是本征激发形成的，所以尽管其浓 度很低，却对温度非常敏感，这将影响半导体器件的性能。\n[!tip]\nN为Negative(负)的字头，由于电子带负电，故得此名。\nP为Positive(正)的字头，由于空穴带正电，故得此名。\nPN结 采用不同的掺杂工艺，将P型半导体与N型半导体制作在同一块硅片上，在它们的交界面就形成PN结。PN结具有单向导电性。\nPN结的形成 物质总是从浓度高的地方向浓度低的地方运动，这种由于浓度差而产生的运动称为==扩散运动==。当把P型半导体和N型半导体制作在一起时，在它们的交界面，两种载流子的浓度差很大因而P区的空穴必然向N区扩散，与此同时，N区的自由电子也必然向P区扩散，如下图所示。\n图中P区标有负号的小圆图表示除空穴外的负离子（即受主原子），N区标有正号的小圆圈表示除自由电子外的正离子（即施主原子）。由于扩散到P区的自由电子与空穴复合，而扩散到N区的空穴与自由电子复合，所以在交界面附近多子的浓度下降，P区出现负离子区，N区出现正离子区，它们是不能移动的，称为空间电荷区，从而形成内电场。随着扩散运动的进行，空间电荷区加宽，内电场增强，其方向由N区指向P区，正好阻止扩散运动的进行。\n在电场力作用下，载流子的运动称为==漂移运动==。当空间电荷区形成后，在内电场作用下，少子产生漂移运动，空穴从N区向P区运动，而自由电子从P区向N区运动。在无外电场和其它激发作用下，==参与扩散运动的多子数目等于参与漂移运动的少子数目，从而达到动态平衡==，形成PN结，如下图所示。\n此时，空间电荷区具有一定的宽度，电位差为U。,电流为零。空间电荷区内，正、负电荷的电量相等；因此，当P区与N区杂质浓度相等时，负离子区与正离子区的宽度也相等，称为==对称结==：而当两边杂质浓度不同时，浓度高一侧的离子区宽度低于浓度低的一侧，称为不对称PN结：两种结的外部特性是相同的。\n[!tip]\n绝大部分空间电荷区内自由电子和空穴都非常少，在分析PN结特性时常忽略载流子的作用，而只考虑离子区的电荷，这种方法称为“耗尽层近似”，故也称空间电荷区为耗尽层。\n[!note]\n电子向左移动，空穴向右移动，出现复合现象，导致P区边缘带负电，N区左侧带正电，当形成PN结之后，在电场力的作用下，空穴和电子就不会那么激烈的移动，实际上还是有扩散运动的。\nPN结的单向导电性 如果在PN结的两端外加电压，就将破坏原来的平衡状态。此时，扩散电流不再等于漂移电流，因而PN结将有电流流过。当外加电压极性不同时，PN结表现出截然不同的导电性能，即呈现出单向导电性。\nPN结外加正向电压时处于导通状态：\n当电源的正极（或正极串联电阻后）接到PN结的P端，且电源的负极（或负极串联电阻后）接到PN结的N端时，称PN结外加正向电压，也称正向接法或正向偏置。此时外电场将多数载流子推向空间电荷区，使其变窄，削弱了内电场，破坏了原来的平衡，使扩散运动加剧，漂移运动 减弱。由于电源的作用，扩散运动将源源不断地进行，从而形成正向电流，PN结导通，如下图所示。\n[!note]\n外电场从0开始升压到PN节导通范围之内，称为死区电压。在死区电压内，外电场内没有电流。\n增加外电场的过程中，实际上是在削弱势垒电压，当势垒电压变低的时候，扩散运动恢复，导致电流迅速增大。\nPN结导通时的结压降只有零点几伏，因而应在它所在的回路中串联一个电阻，以限制回路的电流，防止PN结因正向电流过大而损坏。\nPN结外加反向电压时处于截止状态 当电源的正极（或正极串联电阻后）接到PN结的N端，且电源的负极（或负极串联电阻后）接到PN结的P端时，称PN结外加反向电压，也称反向接法或反向偏置，如下图所示。此时外电场使空间电荷区变宽，加强了内电场，阻止扩散运动的进行，而加剧漂移运动的进行，形成反向电流，也称为漂移电流。因为少子的数目极少，即使所有的少子都参与漂移运动，反向电流也非常小，所以在近似分析中常将它忽略不计，认为PN结外加反向电压时处于截止状态。\n[!note]\n此时内电场和外电场的方向一致。\n反向电压增大势垒，扩散运动变弱，虽然漂移运动增强但是是少子的漂移，量太少了影响可以忽略（反向饱和电流）。\nPN结电流方程 $$\ri=I_s(e^{\\frac{qu}{kr}}-1)\r$$$$\ri=I_s(e^{\\frac{u}{U_T}}-1)\r$$ 常温下，即T=300K时，$U_T \\approx 26mV$,称$U_T$为温度的电压当量。\nPN结的伏安特性 由式(1.1.3)可知，当PN结外加正向电压，且u\u0026gt;U②时，i≈1e,即i随u按指数规律变 化；当PN结外加反向电压，且u\u0026gt;U,时，i≈-Is。画出i与u的关系曲线如图1.1.8所示， 称为PN结的伏安特性。其中\u0026gt;0的部分称为正向特性，u\u0026lt;0的部分称为反向特性。\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%A1%AC%E4%BB%B6/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/",
    "title": "",
    
    "content": " 元器件 电阻 欧姆定律 $$\rI = \\frac{U}{R}:只要知道电阻值以及电阻两端的电压，就能够求出流过电阻的电流\\\\\rR = \\frac{U}{I}:只要知道电阻值以及流过电阻的电流，就能够求出电阻两端的电压\\\\\rU=I\\times R:只要知道电阻两端的电压，以及流过电阻的电流，就能够求出电阻\r$$ 阻值的识别 色环法\n平常使用的色环电阻可以分为四环和五环，通常用四环。其中四环电阻前二环为数字，第三环表示阻值倍乘的数（$10^n$），最后一环为误差；五环电阻前三环为数字，第四环表示阻值倍乘的数，最后一环为误差。误差通常也是金、银和棕三种颜色（金的误差：5%，银的误差：10%，棕色的误差：1%，无色的误差：20%，很少用的绿色表示误差：0.5%）。\n[!tip]\n在计算倍乘的数的时候，金色和银色的0.1和0.01表示的是$10^{-1}$和$10^{-2}$\n电阻色环表小口诀： 棕一红二橙是三，四黄五绿六为蓝，七紫八灰九对白，黑是零，金五银十表误差。\n**四色环电阻：**读法示例：\n红，黄，棕，金 24 * 10=240Ω 误差为5% 绿，红，黄，银 52 * 10000=520KΩ 误差为10% **五色环电阻:**一般五环电阻是相对较精密的电阻，读法示例：\n红，红，黑，黑，棕 220 * 1=220Ω 误差为1% 紫，红，棕，红，绿 521*100=52.1KΩ 误差为0.5% **六色环电阻：**就是指用六色环表示阻值的电阻，六色环电阻前五色环与五色环电阻表示方法一样，第六色环表示该电阻的温度系数。只在有特定要求的场合下的电子产品才会使用，一般使用非常少。\n数码法\n整数型电阻：前两（三）位有效数字，第三（四）位为10的幂次($10^n$)\n小数型电阻：R前面为整数，R后面为整数\n[!note]\n贴片电阻阻值误差精度有$\\pm$1％、$\\pm$2％、$\\pm$5％、$\\pm$10％精度，常规用的最多的是$\\pm$1％和$\\pm$5％，\n$\\pm$5％精度的常规是用==三位数==来表示 1000Ω＝1KΩ,1000000Ω=1MΩ\n$\\pm$1％的电阻常规多数用==四位数==来表示\n电阻的功率 $$\rP=I \\times U\\\\\rP = I^2 \\times R \\\\\rP = \\frac{U^2}{R}\r$$设计电路过程中，一定不能超过电阻的额定功率，否则电阻发热会很严重\n电阻的限流 当供电电压大于负载的工作电压时，可以利用电阻限流\n(注意：电路中不能超过电阻的功率，同 同时尽可能只工作在供电电压与负载工作电压相差不大或者工作电流很小的场景）\n[!tip]\n电阻会限制电荷的移动，所以叫电阻。\n电阻的分流 $$\rI_总 = I_1+I_2+I_3\r$$ 当负载中的电流较大时，需要进行分流来规避器件损坏的风险。\n如果上图中的发光二极管换成电机，电机的额定电压为10V 500mA，那么如果想要对电机进行限流，使用一个电阻（0.2W）就明显不够，所以需要使用电阻的分流的作用，将小功率的电阻并在一起即可。\n电阻的分压 $$\rV_R=\\frac{(V_1-V_2)\\times R_2}{R_1 +R_2}+V_2\r$$\n[!tip]\n很多时候，V2是GND，电阻的分压功能也可以作为参考电压\n电容 电容是两块不连通的导体加上中间的绝缘材料。\n通过控制中间部分绝缘材料的材质和两个导体之间的相对面积大小来控制电容的容值。\n[!note]\n电解电容是有方向的（分正负极），一般来说，插针式电解电容的负极的侧边上有白色条纹标志，贴片电解电容负极的一侧是黑色。\n最重要的是，电解电容是不能反接的，不然会爆炸！！！💥💥💥\n所以在使用电解电容的时候，一旦发现电路中电流过大，电解电容可能会发生爆炸。\n之所以会炸，是因为内部发生了化学反应，产生了大量气体，导致爆炸。\n[!important]\n电容的单位为F（法），一般电容上标的是耐压多少伏（最多只能承受的电压值），电容容量多少F\n以下贴片电容分别是：普通电容、普通电解电容、钽电容、固态电解电容、二氧化锰类型坦电容、液态电解电容\n​\t其中，ESR是等效电阻，ESL是等效电感\n电容的电压 ==电容两端的相对电压不能突变==，只要电容不充电或放电，电容两端的电压就不变\n注意：电容两端的相对电压不能突变，但是两端的电压可以==同时突变==\n当S2闭合之后，电源将会给电容充电，充电一段时间后，电容两端的压差达到5V 此时打开S2，闭合S3，此时，R7上端电压至5V，此时电容上端的电压会变为10V（因为电容两端的电压可以同时进行突变） 如果在一个供电电路中，没有放置电容，那么可能会出现电压跌落（电压会突然下降然后重新上升）的情况。增加电容可以起到一个稳压（滤波）的作用。\n[!tip]\n这里的滤波指的是可以保证不会出现波形的跳变（稳压）。\n上面的电路，当S4没有闭合的时候，$V_{out}$的值将会是一个大于零的值，当S4闭合时，$V_{out}$会立即被电容拉到0V（电压跌落），如果$V_{out}$后面接了电路，那么电路可能会受到影响。 对于下面的电路，当S5闭合的一瞬间，由于电容两端的电压不能突变，所以将会把$V_{out}$的值维持住（可能会下降，但是会下降的很少） 电容的储能 $$\rT=R\\times C\r$$ 首先计算出充电时间常数，在第一个RC的时候，电容可以充到63%的电压值，一般来说，3到5个RC就可以充满。\n$$\rV_t = V_0 +(V_{cc} -V_0) \\times [1-e^{-\\frac{t}{R \\times C}}]\r$$ 电容初始电压$V_0$，充电电阻R，充电电容C，充电电压$V_{CC}$，充电时间t，当电阻单位为kΩ，电容单位为uF的时候，充电时间单位为ms\n[!tip]\n当想要选取合适的充电电路的容值和阻值时，需要先选择容值，后再调整阻值，因为电容的容值的选择很少。\n利用电容的储能特性可以实现关断延时。\n左边的电路一断电，LED灯会立即就灭，而右边的电路断电之后，LED还会等待一会再灭。\n电容的容抗 $$\rX_c= \\frac{1}{2 \\times \\pi \\times f \\times c}\r$$ 此处，$X_c$为容抗，$f$为频率（电源频率），$c$为电容容值\n当通直流电的时候,频率为0，那么容抗就无穷大，所以可以看作是断路 当通交流电时，频率是个确定值，那么容值就是一个确定值 电感 电感就是一根导线加一个磁性材料，单位为H（亨）。生活中，所有由线圈组成的器件，都是电感。\n[!tip]\n电感中的磁芯实际上是为了增加电感量，任意一个使用导线绕成的线圈都是一个电感，但是没有磁芯的电感的电感量较小\n任意一条导线都有电感特性，只不过电感量较小\n电感的电流 ==流过电感的电流不能突变==，当S6闭合之后，电路中的电流是慢慢上升的，不会突然上升。\n[!important]\n电感只能限制电流的变化速度，但是不能改变电路中的电流最大值\n电感的感抗 电感流过电流时，如果电感回路的电阻突变变得很大，电感会感生出一个很高的电压，此时容易击穿器件，所以应用电感时，必须要考虑电感的续流回路\n当开关闭合的时候，产生回路，给电容充电，直至电流稳定。当打开S8的时候，此时电感没有回路，但是电感中仍旧存在电流，所以电感会强制释放电流，将电流==存放在开关的两端==（开关没有闭合的时候是两个不接触的导体片，此时就可以看作是一个电容），所以在开关断开的一瞬间，开关两端电压会非常高，可能达到上百伏。\n[!tip]\n当开关一断开，我们可以将开关看作是一个无穷大的电阻量，而电感为了保持其电流不会进行突变，检测到外部电阻变大，所以会产生一个很大的电压去维持这个电流。将会击穿回路中的器件。\n为了防止出现这种情况，需要合理设计续流回路。\n我们可以在电感左侧和地中间接一个二极管，当S8断开的时候，电感将会和二极管构成回路，将电感中的电流释放掉。\n$$\rR_L = 2 \\pi fL\r$$ [!tip]\n当频率为单位为KHz，电感单位为uH，感抗单位为Ω\n二极管 二极管的结构就是一个PN（Positive-Negative）节，导通后肯定会存在压降（硅管≈0.7V;锗管≈0.3V)，其结构就像一个漏斗结构，普通二极管只能单向导通。==二极管的导通压降并不是一成不变的，它还和它的导通电流有关，导通电流越大，导通压降越大==。\n[!note]\n二极管两端不能直接接大于二极管导通压降的电压，否则电流会很大，烧毁二极管。\n==不能直接和电源并联==\n二极管的单向导通 如下图，假设现在供电是5V，那么D1两侧电压应为0.7V，R25两端电压为0V，D4两端电压为5V\n利用二极管可以控制电路中的电流方向，这样可以实现==反接保护==。\n假设当电机的电流从上往下的时候，电机正转，电流从下往上的时候，电机反转，当我们需要让电机至只正转，那么我们就接一个二极管就可以实现控制电流方向的作用。\n[!important]\n一般来说，不建议将二极管接到GND做反接保护，因为这样GND就不是0V了\n二极管承受反向电压时会自动截止，但是每一个二极管都有最大反向耐压值。一旦超过反向耐压值，二极管将会被击穿。\n而稳压二极管是工作在反向击穿状态，当其发生反向击穿时，稳压二极管两端的电压会保持在某个电压值。（一般的二极管被击穿之后会直接导通）\n稳压二极管的稳压值就是击穿电压，假设这里的稳压二极管的击穿值是5.6V，那么当电源电压小于5.6V时，D6截止，当电源电压大于5.6V（假设不考虑电阻的分压）时，稳压二极管就会被击穿，击穿之后，D6两端的电压就会维持为5.6V。==但是实际上稳压管的电压还和流经它的电流有关，电流越大，电压越大，所以使用稳压二极管做一个稳压的时候，一定要注意稳压电流。==稳压电流不能太大，也不能太小。\n[!note]\n普通的稳压管的工作电流会让它工作在5毫安左右。\n二极管的漏电 二极管反向截止并不代表完全关断，其实会有微弱的漏电流。其中肖特基二极管的漏电流会比较大。\n二极管的钳位 利用二极管的导通电压特性，可以实现对信号线进行钳位。一般来说，二极管的钳位功能都是用于保护电路。\n上图中，假设是直流电源，且没有二极管，那么A点的电压就是$\\frac{3}{10+10} = 0.15V$，如果加上二极管之后，由于电阻的电压是高于0.7V的，所以二极管就会导通，==二极管导通之后，它两端的电压近乎稳定，保持为0.7V（硅管）==，而电阻和它并联，所以也会保持0.7V的电压。从而实现了钳位的功能。\n三极管 三极管的结构 ==三极管简单来说就是一个电子开关。==\n三极管有三个主要部分：\n发射极（Emitter） 基极（Base） 集电极（Collector）。 有两种主要类型的三极管：\nNPN三极管（N型三极管）：发射极是N型半导体，基极是P型半导体，集电极是N型半导体。 PNP三极管（P型三极管）：发射极是P型半导体，基极是N型半导体，集电极是P型半导体。 三极管的不同封装如下：\n三极管的开关作用 三极管可以当电子开关来使用，现假设有一个开关，开关两侧为A和B，开关闭合时，A和B导通，我们可以将三极管的C和E类比于A和B。当B到E之间有电流流过，那么C和E之间就会导通。\n工作模式 三极管的工作模式取决于其偏置状态，主要有三个模式：\n放大模式：当==基极和发射极之间的电压大于发射结的阈值==（通常是0.7V左右）时，三极管处于放大模式。在这个模式下，小的基极电流（IB）可以控制大的集电极电流（IC），从而实现信号放大。 饱和模式：当基极电流足够大，三极管的集电极-发射极之间的电压接近于零（对NPN型来说，VCE接近0V），此时三极管处于饱和状态，像一个闭合开关一样，集电极和发射极之间的电阻很小。 截止模式：当基极电流非常小或为零，三极管处于截止状态，集电极和发射极之间的电流几乎为零，相当于开路。 工作原理 NPN三极管：在NPN三极管中，当==基极电压高于发射极电压==时，发射结导通，电子从发射极注入基极。由于基极很薄，大部分电子会穿过基极到达集电极，使得集电极电流IC大于基极电流IB。==电子方向 ：E -\u0026gt; C== PNP三极管：PNP三极管的工作原理与NPN类似，只是电流方向相反。基极电压低于发射极电压时，三极管导通。==空穴方向：C -\u0026gt; E== NPN三极管：基极电流控制从发射极到集电极的电子流。\nPNP三极管：基极电流控制从集电极到发射极的空穴流。\n所以三极管实际上是通过控制==基极==来控制输出\n电流放大 理想的开关只有“开”和“关”两种状态，但是三极管不是一个理想的开关，它有“似开不开、似关不关”的第三种状态（放大）。\n$$\r\\beta = \\frac{I_C}{I_B}\r$$\nR4电阻是一个限流电阻，为了防止$I_B$过大\n[!tip]\n当$V_{ce}=V_{cc}$，三极管处于断开（截止）状态 当$V_{ce}\u003c=0.3$，三极管处于饱和导通的状态 当$0.3",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/capl/",
    "title": "",
    
    "content": " 1 概述 CAPL全称为Communication Access Programming Language，即通信访问编程语言。它是Vector公司专门为CANoe开发环境设计的编程语言，在语法和概念上与C语言类似。借助CAPL，用户可以编写程序并应用到网络的各个节点上，也可以利用CAPL编程加强测量分析功能，以及搭建高效的自动化测试模块。\n2 CAPL开发环境 3 数据类型 3.1 全局变量和局部变量 在CAPL中，全局变量需要被声明在variables部分，同时可以使用直接赋值方法进行初始化。如果没有初始化，编译器会执行自动初始化，默认值为0。全局变量的作用域包括整个CAPL文件以及与此文件有链接的其他CAPL文件。\n与C语言不同，局部变量在CAPL中总是被静态地创建。这意味着初始化只在程序体启动时执行，当再次进入程序时，局部变量被假定是上一次跳出程序时的值。局部变量的作用域，仅限于当前函数体范围内，即该函数的大括号范围内。\n3.2 简单变量 3.2.1 整型 整数就是没有小数部分的数字，如3、201、-3412和0。根据数值的大小不同，CAPL提供了以下几种整型。\n3.2.2 字符 区别于C语言，CAPL未将char类型（长度1B）归类至整型中，这是因为在CANoe中提供了byte类型。如果数据是具体数值则应使用byte，而对于字符，则应用char（字符串使用char数组）。char类型和byte类型之间可以直接转换。\nbyte data1 = 100; char ch1 = \u0026#39;d\u0026#39;; ch1 = 0x62; data1 = \u0026#39;s\u0026#39;; 3.2.3 浮点型 CAPL提供两种浮点型变量：float和double。\n3.3 复合类型 3.3.1 结构体 CAPL中可以简单地按照C语言的方法来声明结构（struct），但结构名在程序中必须是唯一的。简单类型、枚举类型或者其他的结构都可以作为结构的成员。\nstruct b{ struct a a1; enum clolrs c1; int p; long l; } 结构b中包含：一个结构成员a，变量名为a1；一个枚举成员colors，变量名为c1；一个整型变量p；最后还有一个长整型变量l。 用户可以在类型定义时直接声明结构类型的变量，在这种情况下，类型的名称可以省略，也可以直接使用结构的名字来引用类型。\nstruct cost mycost; struct { int chinese; int math; int english; }scores; 关于结构初始化，可以在变量声明期间直接初始化结构成员，不需要单独命名单个成员，编译器将按照结构定义的顺序默认初始化它们。例如：\nstruct Scores myScores = { Chinese = 79, Math = 99, English = 88 }; struct Scores myScores = {79,99,88}; 使 用 “.” 操 作 符 可 以 访 问 结 构 中 的 成 员 ， 例 如 ， myScores.Chinese ＝ 100。另外，结构体可以作为参数传给函数，但不能作为函数的返回值。\n3.3.2 枚举 枚举（enum）类型的声明也与C语言中的语法完全一致，但需要注意的是，枚举的成员名必须唯一，否则将有可能代替隐藏数据库中同名的报文和信号。如果没有在声明枚举的同时对成员进行赋值，编译器将按照成员声明的顺序对成员进行初始化。即第一个成员被初始化为0，往后依次加1。例如：\nenum {Apple, Pear, Banana} Fruit = Apple; enum Colors {Red = 1, Green = 3, Blue = 9}; 3.3.3 数组 数组（Array）作为一种基本的数据结构，也同样被CAPL支持，就像在C语言中一样。但为了方便使用，CAPL支持直接用字符串初始化字符数组的行为。\nint a[3] = {1,2,3}; char b[13] = \u0026#34;Hello World!\u0026#34;; 同 样 ， CAPL 也 支 持 多 维 数 组 ， 并 且 可 以 通 过 内 建 函 数elCount（数组名）来获得数组成员的个数。如果数组的索引超出范围，即小于零或大于等于数组长度，CAPL将会在数组下标前提示错误。例如：\nint v[3][3] = {{1,2,3},{4,5,6},{7,8,9}}; int a[3] = {1,2,3}; int b = elCount(a); 3.3.4 特殊类型 3.3.4.1 报文 报文（CAN/LIN messages）是车载网络最基本的构成部分， CAPL提供了各种网络相对应的报文类。这里主要介绍CAN报文和LIN报文。\n使用关键字message来声明一个报文变量，当使用message声明报文变量时，默认变量为CAN报文变量。当有数据库支撑的时候，一个 完 整 的 声 明 应 该 包 括 message ID 或 者 message name 。 结 合database的例子，使用ID 0xA或者报文名来声明一条数据库中的EngineData报文。例如\nmessage 0xA ml; message 100 m2; message EngineData m3; 以标识符“x”结尾的ID表示这是一个扩展帧ID，例如，100x。而“*”则表明这条报文在声明时还不含有CAN ID。例如：\non message CAN1.* { message *msg; if(this.dir!= rx) return; msg = this; } 切记，使用这种方式声明报文时，一定要指定ID后才能将msg发送出去。\nCAPL提供了一系列的选择器（Selector）以保证用户能够按照自己的意图去修改CAN message的属性。\n例如，如果需要在CAN1网络上发送一条指定的报文，报文名： magicMessage；报文ID：0x252；包含8个字节0x03 3B 40 00 00 00 00 00；可以定义如下。\nmagicMessage.CAN = 1; magicMessage.ID = 0x252; magicMessage.DLC = 8; magicMessage.Byte(0)=0x03; magicMessage.Byte(1)=0x3B; magicMessage.Byte(2)=0x40: magicMessage.Byte(3)=0x00: magicMessage.Byte(4)=0x00; magicMessage.Byte(5)=0x00; magicMessage.Byte(6)=0x00; magicMessage.Byte(7)=0x00; output (magicMessage); 3.3.4.2 诊断报文 CAPL 通 过 诊 断 请 求 （ DiagRequest ） 和 诊 断 响 应（DiagResponse）这两种对象来实现跟ECU之间的诊断服务交互。通常情况下，诊断服务需要首先对Diagnostic对象声明和初始化。\nDiagRequest ServiceQualifier request; DiagResponse ServiceQualifier response; 上述声明语句分别声明了诊断请求对象“request”和诊断响应对象“response”；并通过给出的诊断服务“ServiceQualifier”进行初始化。这种初始化将在节点仿真开始时被执行一次，并在每次诊断目标（DiagTarget）改变时被执行一次。 如果使用*来代替“ServiceQualifier”，诊断对象将被初始化为未添加诊断描述的空对象，但对象的数据必须在发送之前完成设置。\n3.3.4.3 系统变量 系统变量是一种特殊的变量，用来描述某种特殊状态（例如某种事件触发）或者记录测量数据。一般有系统定义和用户自定义两种，它们的作用域都是在各自的命令空间内。\n3.3.4.4 定时器 CAPL 提 供 了 两 种 定 时 器 变 量 ： timer 基 于 秒 的 时 间 单 位 ； msTimer基于毫秒的时间单位，例如：\nmsTimer myTimer;//声明一个毫秒定时器 Timer myTimer1;//声明一个秒定时器myTimer1 4 常见运算 与C语言一样，CAPL也提供了算术、逻辑和位运算的运算符，其用法也与C语言保持一致。\n5 流程控制 5.1 if条件语句 if(表达式) 语句; if(表达式) 语句1; else 语句2; 5.2 switch句 switch(表达式){ case常量表达式1： 语句1; case常量表达式2： 语句2; case常量表达式n: 语句n; default: 语句n+1; } 5.3 while循环语句 whi1e(表达式) 语句; 5.4 do-while循环 do{ 循环体语句; }while(表达式); 6 程序结构 6.1 头文件 CAPL提供了*.cin文件（callback interface file），用户可以通过该文件搭建自定义的测试框架。比如，将基本的函数接口按照不同类型分别定义在各自的*.cin文件中，然后再在不同的*.can文件中包含所需要的*.cin文件，从而形成二层引用结构。同时也可以在*.cin中包含其他的*.cin文件，然后在*.can文件中包含上层*.cin文件，进而形成多层的引用结构，从而达到提高代码复用效率的目的。\n例如，基本诊断服务定义在BaseServices.cin中，基本函数定义在CommonFunctions.cin中，测试用例函数定义在TestFunctions.cin中，将相关的测试用例定义在测试模块文件ECU_01.can中，那么在各个文件中的头文件结构如下。\n在TestFunctions.cin中：\nincludes { #include \u0026#34;CommonFunctions.cin\u0026#34; #include \u0026#34;Baseservices.cin\u0026#34; } 在ECU_01.can中：\nincludes { #include \u0026#34;TestFunctions.cin\u0026#34; } 这样，在ECU_01.can中可以调用三个*.cin文件中的所有函数。如果需要编写另一个测试模块ECU_02，只需要在ECU_02.can中包含TestFunctions.cin即可。\n6.2 全局变量声明 CAPL跟C语言一样，变量的作用域和生命周期仅限于变量声明的函数体（即大括号范围）内。CAPL在每个程序的开始部分提供了variables区域给用户声明全局变量。\nvariables{ int i 0; message 100 msg; msTimer myTimer; byte ECU_SERIAL_NUMBER[3]={0x31,0x32,0x33}: } 在此部分声明的全局变量的生命周期从仿真开始持续到仿真结束，其作用域为整个CAPL文件。而在*.cin文件中声明的全局变量在包含它的*.can或*.cin中视为可见。\n6.3 事件处理 在什么条件下，在什么时间节点，发生了什么样的报文传递，得到了什么样的报文反馈。而这种面向事件的机制是通过event handler来实现的。\n6.3.1 事件起始关键字on on * { 语句; } on后面加某种条件，一旦条件满足则执行下面函数体内的语句。函数体内的语句是实现接下来需要完成的操作。\n6.3.2 关键字this 在can的报文事件或变量事件中，可以使用关键字this访问数据内容\non message 100 { byte byte0; byte0 = this.byte(0); } 这里的this就代表的是message这个报文\n6.3.3 系统事件 系统事件主要用于处理CANoe测量系统的控制功能，主要有on start、on preStart、on stopMeasurement、on preStop、on key＜ newKey＞以及on timer。\n栗子：\non prestart{ write(\u0026#34;Measurement started!\u0026#34;); msg_Count = 0; } on start{ write(\u0026#34;start Node A\u0026#34;); setTimer(cycTimer,20); CallAll0nEnwar(); } on prestop{ message ShutdownReg m; output (m); Deferstop(1000); } on stopMeasurement{ write(\u0026#34;Message 0xx received:\u0026amp;d\u0026#34;,msg.id,msg_Count); } 6.3.4 CAN控制器事件 CAN控制器事件是对硬件接口设备中CAN控制器状态变化事件的响应 。\n栗子：下面的代码在侦测到Bus Off状态时，系统会输出信息到Write窗口，并复位ECU。\non busoff{ //在Bus off状态下复位CAN控制器 Write(\u0026#34;The CAN controller is in Bus off state\u0026#34;); resetCanEx(Channel); } 6.3.5 CAN报文事件 CAN报文事件在CAN总线上有指定的或任意报文出现时被调用。关键字为：on message xxx。例如，下面列出了不同的on message事件。\non message 123\t//对报文123(dec)反应 on message 0x123\t//对报文123(hex)反应 on message MotorData\t//对报文MotorData反应 on message CAN1.123\t//对CAN通道1收到报文123反应 on message *\t//对所有报文反应 on message 100-200\t//对CAN ID在100~200间报文反应 6.3.6 CAN信号事件 CAN信号事件是在CAN总线上出现指定的信号时被调用（需要配合DBC文件使用）。关键字为：on signal xxx或on signal_update xxx。需要注意的是，前者只在指定信号的值发生变化时被调用，后者在每次接收到指定信号时均被调用。\non signal Lightswitch:：Onoff{ STAT1=this; } on signal_update Lightswitch::Onoff{ STAT2=this; } 6.3.7 定时事件 定时器变量可以用来创建一个定时事件，SetTimer函数用来设定时间间隔。当定时器运行到达设定的时间间隔时，将触发该事件，这时on timer函数中的程序块将被执行。需要提醒的是，周期性触发需要在每次触发结束后使用SetTimer复位。若在定时器运行中需要停止计时，可以使用cancelTimer函数来取消计时。\n定时器事件关键字为on timer xxx。以下代码通过定时器事件实现每100ms发送一次报文0x555。\nvariables{ message 0x555 msgl {dlc=1}; msTimer myTimer;\t//将myTimer声明ms为单位的定时器变量 } on start{ setTimer (myTimer,100);\t//将定时值设定为100ms,并启动 } on timer myTimer { setTimer (myTimer,100);\t//不能遗漏，复位定时器 msg1.byte(0) = msg1.byte(0) + 1;\t//更新报文byte(0)数据 output (msg1);\t//输出报文 } 6.3.8 键盘事件 在测量的过程中，通常需要由用户来触发某些事件来模拟实际测试环境的人工操作，例如，开始记录log、改变信号或变量的值、停止测量等。利用CAPL提供的键盘事件可以方便地完成这些操作。键盘事件的关键字为on key xxx。\non key \u0026#39;a\u0026#39;\t//按a键反应 on key \u0026#39; \u0026#39;\t//按空格键反应 on key 0x20\t//按空格键反应 on key F1\t//按F1键反应 on key Ctrl-F12\t//按Ctr1+F12组合键反应 on key PageUp\t//按Page Up键反应 on key Home\t//按Home键反应 on key\t*\t//按所有键反应 on key \u0026#39;s\u0026#39; { Write(\u0026#34;Logging starts\u0026#34;); } 6.3.9 错误帧事件 当总线上出现错误帧或者过载帧时，错误帧处理机制将被调用。下面的代码将输出总线错误码，同时将错误帧的信息输出到Write窗口中。\non errorFrame { const int buffersize 256; char buffer[buffersize]; char cdirection[2][3]{\u0026#34;RX\u0026#34;,\u0026#34;TX\u0026#34;}; int ndir; word ecc; word extInfo; int isProtocolException; ecc = (this.ErrorCode \u0026gt;\u0026gt; 6)\u0026amp;0x3f; extInfo = (this.ErrorCode \u0026gt;\u0026gt;12)\u0026amp;0x3; isProtocolException (this.ErrorCode \u0026amp;(1 \u0026lt;15))!=0; ndir extInfo ==0 extInfo ==2 0:1; //根据extInfo来判断错误帧传输方向：接收或发送 } 6.3.10 环境变量事件 环境变量事件是对环境变量发生变化的响应，关键字为on enVar xxx\non envVar Switch { //声明一个CAN报文变量，用于传输 message Controller msg; //读取环境变量Switch的数值，并赋值给信号Stop msg.Stop = getvalue(this); //发送报文到总线上 output(msg); } 可以使用getValue（）和putValue（）读写环境变量的值\n//读取环境变量Switch的数值，并赋值给变量val val = getvalue (Switch); //将数值0赋值给环境变量Switch putvalue(Switch,0); 6.3.10.1 环境变量事件 与环境变量事件类似，系统变量事件是对系统变量发生变化的响应，关键字为==on sysVar xxx或on sysVar_update xxx==\non sysvar IO::DI_0 { $Gateway:IOValuel = @this; } on sysvar update IO::DI_0 { SGateway::IOValue2 = @this; } 6.3.10.2 诊断事件 诊断事件是在诊断请求或诊断响应发生时产生\non diagRequest ECU.DefaultSession_start { //发生诊断请求事件 Write(\u0026#34;Default Session Switch request received\u0026#34;) } on diagRequestSent ECU.HardReset { //诊断请求发送完成 Write(\u0026#34;HardReset service sent completely,ECU should reset\u0026#34;) } on diagResponse ECU.VehicleIdentification_Number_Read { //收到相应的诊断请求的响应 Write(\u0026#34;VehicleIdentification Number Read response received successfully\u0026#34;) } 6.3.10.3 自定义函数 当返回值类型省略时，被默认解释为void类型。 正如C＋＋一样，允许函数包含一个空的形参列表。 允许重载函数（即同一个函数名，但每个函数的形参列表必须不同，例如，不同的形参类型或者在形参列表中的不同次序）。 函数会对实参进行类型检查，如果类型不同则检查是否能够通过隐式类型转换，如不能，则无法通过编译。 任意维度或大小的数组都可被作为函数参数传递。 大部分CAPL支持的数据类型都可以直接声明为函数参数，例如，整型、浮点型、枚举、结构、定时器以及它们的引用。 但是有一些类型不能被直接声明，而需要加上号（注意该符号并不是C语言中指针的意思）。例 如 ， signal * s 、 envvarInt * ev 、 sysvarFloat * sv 、diagRequest * dr、diagResponse * dr、int matrix［］［］，以及所有来自于database的变量，均需要加上 * 号声明。需要注意的是message类型比较特殊，如果该变量是用户自定义的，那么在函数参数声明时，message和message均可以，但如果该变 量 来 自 database ， 那 么 只 有 message * 可 用 。 7 常用库函数 7.1 通用函数 7.2 计算函数 7.3 字符串函数 7.4 CAN总线函数 7.5 LIN总线函数 7.6 诊断函数 8 变量和信号的访问 8.1 访问信号 signal在CAPL中代表的是总线信号交互层的表示，它不同于message。message是CAPL的数据类型，而signal不是。因此，不能在CAPL中定义一个类型为signal的变量。\n当用户需要访问信号缓冲区并期望读到最后接收到的信号值时，可以使用$符号。\nvalue = $EngineSpeed;\t//读取信号EngineSpeed的值 value = $EngineSpeed.raw;\t//读取信号EngineSpeed的raw数据 $EngineSpeed = 500.0;\t//将信号Enginespeed的值设为500 if ($Enginespeed !=500.0)write(\u0026#34;Unequal!\u0026#34;); 一个工程中可能包含多个相同名称的信号名。所以CAPL中需要增加通道（Channel）、网络（Network）、节点（Node）和报文（Message）的信息。完整的语法格式如下。\n(channel | network):: [dbNode::]node:: [dbMsg::]message:: [dbsig::] signal 栗子：\n$Lightswitch::Onoff\t//Node + signal $Lightswitch::Lightstate::Onoff\t//Node + Message + Signal $CAN1:Gateway:Status\t//Channel + Node + signal $PowerTrain::Gateway::Status\t//Network + Node + Signal $CAN1::Status\t//Channel + Signal 8.2 访问系统变量 可以在CAPL中直接访问系统变量而不需要通过函数调用（例如使用SysGetVariableInt 、SysGetVariableFloat等获取变量值，使用SysSetVariableInt 、SysSetVariableFloat等函数修改变量值），以下是需要采取的语法格式：\n@Namespace:Variable [!CAUTION]\n需要注意的是，对于array或struct类的变量，直接访问方式只能访问单个元素，\nintValue = @Namespacel::Parameter2; @Debug::MotorValues::EngineSpeed = $Enginespeed; intvalue=@Namespacel::ParameterArray[2];\t//访问数组变量的单个成员 @XCP::EcU_2::KL2.Curve2[0]=1.3;\t//访问结构体中的数组变量的单个成员 比 较 通 用 的 访 问 操 作 方 式 是 使 用 以 sysGetVariable 开 头 和sysSetVariable开头的访问函数。\n//字符串修改操作 char demo[20] = {\u0026#39;M\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;g\u0026#39;}: sysSetvariablestring(sysvar::IPC::Music_tag,demo); //long数组类的系统变量读取操作 long 1VarArr[10]; sysGetvariableLongArray(sysvar::MyNamespace::LongArrayvar,lVarArr,elcount(1VarArr)); 8.3 访问环境变量 访问环境变量和系统变量的语法一样，都使用@符号进行访问。比较常用的访问函数为\n//getValue相关操作 int val; float fval; char cBuf [25]; byte bBuf[64]; long copiedBytes; //获取环境变量Switch(整型)的数值并赋值给整数val变量 val = getvalue(Switch); //获取环境变量Temperature(浮点型)的数值并赋值给浮点数fval变量 fval = getvalue(Temperature); //读取环境变量NodeName(字符串型)的数值，赋值给字符串cBuf,返回复制的字符长度 copiedBytes = getvalue(NodeName,cBuf); //读取环境变量DiagData(字符串型)的数值，从32位置赋值给字符串bBuf,返回复制的字符长度 copiedBytes = getvalue(DiagData,bBuf,32); //putValue相关操作 byte dataBuf [64]; //将0赋值给环境变量Switch putvalue(Switch,0); //将22.5赋值给环境变量Temperature putvalue(Temperature,22.5); //将\u0026#34;Master\u0026#34;赋值给环境变量NodeName putvalue (NodeName,\u0026#34;Master\u0026#34;); //复制dataBuf字符串变量中的64个字节给环境变量DiagData putvalue(DiagData,dataBuf,64); ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/kconfig/",
    "title": "",
    
    "content": " 参考链接 从零到一搭建Kconfig配置系统-CSDN博客\n安装 由于在window上使用Kconfig需要依赖Curses，所以要先安装window-curses，但是curses本身是应用在Linux平台上的，所以想要安装在window上，就需要使用whl包进行安装。\ncurses的下载地址：windows-curses · PyPI\n在安装的时候需要检查一下安装的python版本，然后根据python版本安装相应的whl文件\npython --version ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/",
    "title": "",
    
    "content": " 公式 公式基本语法 行内公式：用 $...$ 包围公式。 块级公式：用 $$...$$ 或 \\[...\\] 包围公式。 数学符号 基本符号 描述 符号 LaTeX 代码 加号 $+$ + 减号 $-$ - 正负号 $\\pm$ \\pm 乘号 $\\times$ \\times 除号 \\ \\ 根号 $\\sqrt{x}$ \\sqrt{} 分数 $\\frac{a}{b}$ \\frac{a}{b} 等于 $=$ = 不等于 $\\neq$ \\neq 小于 $\u003c$ \u0026lt; 大于 $\u003e$ \u0026gt; 小于等于 $\\leq$ \\leq 大于等于 $\\geq$ \\geq 向下取整 $\\lfloor x \\rfloor$ \\lfloor\\rfloor 向上取整 $\\lceil x \\rceil$ \\lceil\\rceil 集合符号 描述 符号 LaTeX 代码 属于 $\\in$ \\in 不属于 $\\notin$ \\notin 包含（真子集） $\\subset$ \\subset 包含等于 $\\subseteq$ \\subseteq 并集 $\\cup$ \\cup 交集 $\\cap$ \\cap 空集 $\\emptyset$ \\emptyset 所有实数集合 $\\mathbb{R}$ \\mathbb{R} 所有自然数集合 $\\mathbb{N}$ \\mathbb{N} 所有整数集合 $\\mathbb{Z}$ \\mathbb{Z} 运算符 描述 符号 LaTeX 代码 求和 $\\sum$ \\sum 积分 $\\int$ \\int 重积分 $\\iint$ \\iint 极限 $\\lim$ \\lim 微分 $\\frac{dy}{dx}$ \\frac{dy}{dx} 逻辑符号 描述 符号 LaTeX 代码 与 $\\land$ \\land 或 $\\lor$ \\lor 非 $\\neg$ \\neg 蕴含 $\\implies$ \\implies 等价 $\\iff$ \\iff 希腊字母 描述 符号 LaTeX 代码 α (Alpha) $\\alpha$ \\alpha β (Beta) $\\beta$ \\beta γ (Gamma) $\\gamma$ \\gamma Δ (Delta) $\\Delta$ \\Delta π (Pi) $\\pi$ \\pi Ω (Omega) $\\Omega$ \\Omega 上下标 描述 符号 LaTeX 代码 上标（幂） $x^2$ x^2 下标 $x_i$ x_i 同时有上标和下标 $x_i^2$ x_i^2 顶部加^ $\\hat{a}$ \\hat{1} 顶部加横线 $\\overline{a}$ \\overline{a}$ 顶部加波浪线 $\\widetilde{a}$ \\widetilde{a} 顶部加点 $\\dot{a}$ \\dot{a} 顶部加两点 $\\ddot{a}$ \\ddot{a}$ 顶部加箭头 $\\vec{a}$ \\vec{a} 大括号 为了表示一组内容，可以使用 \\left 和 \\right，配合不同类型的括号：\n$$ \\left( \\frac{a}{b} \\right) $$ 也可以使用 \\{ \\} 来显示大括号：\n$$ \\{ x \\mid x \u003e 0 \\} $$ 矩阵 使用 \\begin{matrix} ... \\end{matrix}，或者带括号的 \\begin{pmatrix} ... \\end{pmatrix}：\n$$ \\begin{matrix} a \u0026 b \\\\ c \u0026 d \\end{matrix} $$$$ \\begin{pmatrix} a \u0026 b \\\\ c \u0026 d \\end{pmatrix} $$ 方程组 $$ \\left\\{ \\begin{array}{l} x + y = 1 \\\\ x - y = 2 \\end{array} \\right. $$",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/makefile/",
    "title": "",
    
    "content": " 参考链接 跟我一起写Makefile — 跟我一起写Makefile 1.0 文档 (seisman.github.io)\n概述 targets: prerequisites commands targets:prerequisties;commands targets\n可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。 targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。 prerequisites\n目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。 commands\n该target要执行的命令（任意的shell命令）。 commands是命令行，如果其不与“target:prerequisites”在一行，那么，必须以 Tab 键开头。 如果和prerequisites在一行，那么可以用分号做为分隔。（见上） 如果命令太长，可以使用反斜杠（ \\ ）作为换行符。make对一行上有多少个字符没有限制。 [!NOTE]\n这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:\n==prerequisites中如果有一个以上的文件比target文件要新的话，commands所定义的命令就会被执行。==\n[!IMPORTANT]\n注意：makefile有着严格的缩进格式，命令前面需要使用tab键对齐\n下面将会按照以下的例子来介绍相关知识：\nedit : main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/markdown/",
    "title": "",
    
    "content": " 语法 Markdown 是一种轻量级标记语言，使用简单的文本格式来创建格式化的文档。以下是常用的 Markdown 语法命令：\n标题 使用 # 来创建标题，# 的数量表示标题的级别。\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 [!note]\n需要注意的是，在#符号后面需要加一个空格，这样markdown才能知道是标题\n字体样式 使用 ** 或 __ 包围文本表示粗体\n使用 * 或 _ 包围文本表示斜体。\n使用==包围为高亮\n使用~~包围的为删除线\n使用包围为下划线\n**这是粗体文本** __这是粗体文本__ *这是斜体文本* _这是斜体文本_ ==这是高亮文本== ~~这是删除线~~ \u0026amp;lt;u\u0026amp;gt;这是下划线\u0026amp;lt;/u\u0026amp;gt; 列表 无序列表使用 *、- 或 + 表示，有序列表使用数字加点表示。\n* 项目 1 * 项目 2 * 子项目 2.1 * 子项目 2.2 1. 项目 1 2. 项目 2 3. 项目 3 链接和图片 图片使用 ![替代文本](图片URL)。\n![这是一个图片](https://www.example.com/image.jpg)\t网络图片 ![这是一个图片](../image.jpg)\t本地图片 链接使用 [显示文本](URL)。\n[这是一个链接](https://www.example.com) 网络链接 [将要链接的标题](#一级标题名)\t链接到本文中的标题，需要注意的是，这里几级标题就要写几个#号 [将要链接的标题](##二级标题名) \u0026amp;lt;a id=\u0026amp;#34;test\u0026amp;#34;\u0026amp;gt;\u0026amp;lt;/a\u0026amp;gt;\t使用HTML的标签功能方便引用 ![图片1](../image.jpg)\t正常使用图片 [点击这里跳转图片1](#test)\t注意，当想要引用图片时，只需要使用1个#号，#号后面跟的是id号 引用块 使用 \u0026amp;gt; 表示引用\n使用多个\u0026amp;gt;表示区块以此表示层级效果，在typora中，回车会自动添加\u0026amp;gt;符号\n\u0026amp;gt; 这是一个引用。 \u0026amp;gt; 区块引用 \u0026amp;gt;\u0026amp;gt; 二级区块 \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; 三级区块 区块引用\n二级区块\n三级区块\n代码 单行代码使用 `` 包围，多行代码使用三个反引号 ```。 …",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/",
    "title": "",
    
    "content": " Python基础 [!IMPORTANT]\nPython语言有着严格的缩进模式，同一个Tab表示在同一个作用域（和Makefile同样的Tab控制）\n在Python中的缩进相当于是C语言中的{}，用于控制作用域\n注意缩进❗❗❗❗❗❗\n否则会导致程序报错或者出现很多奇奇怪怪的bug🙉\n数据类型 在Python中无需定义变量的数据类型，编译器会自动解析当前定义的变量是什么数据类型。\n整数 (int) 定义：表示整数值。\n基本用法：\n# 定义整数 age = 25 print(age) # 输出：25 # 基本运算 sum = age + 5 print(sum) # 输出：30 浮点数 (float) 定义：表示带小数的数字。\n基本用法：\n# 定义浮点数 temperature = 36.6 print(temperature) # 输出：36.6 # 基本运算 area = 3.14 * (5 ** 2) print(area) # 输出：78.5 字符串 (str) 定义：表示文本数据，使用单引号或双引号包裹。\n基本用法：\n# 定义字符串 name = \u0026#34;Alice\u0026#34; print(name) # 输出：Alice # 字符串拼接 greeting = \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34; print(greeting) # 输出：Hello, Alice! # 字符串方法 upper_name = name.upper() print(upper_name) # 输出：ALICE 布尔值 (bool) 定义：表示真或假，只有两个值：True 和 False。\n基本用法：\n# 定义布尔值 is_student = True print(is_student) # 输出：True # 布尔运算 has_passed = True is_adult = False print(has_passed and is_adult) # 输出：False 列表 (list) 定义：有序可变集合，可以存储不同类型的元素。（C++中的vector）\n基本用法：\n# 定义列表 fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(fruits) # 输出：[\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] # 访问元素 first_fruit = fruits[0] print(first_fruit) # 输出：apple # 添加元素 fruits.append(\u0026#34;orange\u0026#34;) print(fruits) # 输出：[\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;orange\u0026#39;] # 删除元素 fruits.remove(\u0026#34;banana\u0026#34;) print(fruits) # 输出：[\u0026#39;apple\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;orange\u0026#39;] 元组 (tuple) 定义：有序不可变集合，类似于列表，但不能修改元素。\n基本用法：\n# 定义元组 coordinates = (10.0, 20.0) print(coordinates) # 输出：(10.0, 20.0) # 访问元素 x = coordinates[0] print(x) # 输出：10.0 字典 (dict) 定义：无序可变集合，用键值对存储数据。（C++中的hash map）\n基本用法：\n# 定义字典 person = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(person) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} # 访问值 name = person[\u0026#34;name\u0026#34;] print(name) # 输出：Alice # 添加新键值对 person[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(person) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 集合 (set) 定义：无序不重复元素的集合，适用于需要唯一性的数据。（C++中的set）\n基本用法：\n# 定义集合 unique_numbers = {1, 2, 3, 3} print(unique_numbers) # 输出：{1, 2, 3} # 添加元素 unique_numbers.add(4) print(unique_numbers) # 输出：{1, 2, 3, 4} # 删除元素 unique_numbers.remove(2) print(unique_numbers) # 输出：{1, 3, 4} 控制结构 条件语句 条件语句用于根据特定条件执行不同的代码块。\nif 语句 # 定义变量 score = 85 # 使用 if 语句 if score \u0026gt;= 90: print(\u0026#34;优秀\u0026#34;) elif score \u0026gt;= 80: print(\u0026#34;良好\u0026#34;) elif score \u0026gt;= 70: print(\u0026#34;中等\u0026#34;) else: print(\u0026#34;需要努力\u0026#34;) 其他条件语句 短路条件：\nis_pass = True is_registered = True if is_pass and is_registered: print(\u0026#34;可以参加考试\u0026#34;) 条件表达式 (三元运算符，行迭代器)：\nage = 18 status = \u0026#34;成人\u0026#34; if age \u0026gt;= 18 else \u0026#34;未成年人\u0026#34; print(status) # 输出：成人 循环语句 循环语句用于重复执行特定代码块，直到满足退出条件。\nfor 循环 用于遍历序列（如列表、字符串等）。\n# 遍历列表 fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) # 使用 range 函数 for i in range(5): print(i) # 输出：0, 1, 2, 3, 4 while 循环 在满足条件时重复执行代码块。\ncount = 0 while count \u0026lt; 5: print(count) count += 1 # 输出：0, 1, 2, 3, 4 跳转语句 跳转语句用于改变程序的执行顺序。\nbreak 用于立即退出循环。\nfor i in range(10): if i == 5: break print(i) # 输出：0, 1, 2, 3, 4 continue 用于跳过当前循环的剩余部分，进入下次迭代。\nfor i in range(5): if i == 2: continue print(i) # 输出：0, 1, 3, 4 pass 用于占位，表示一个空的代码块，通常用于结构体。\nif True: pass # 这里什么都不做，但可以保持代码结构完整 函数是组织和重用代码的基本构件，允许你将特定的任务封装成一个可重复调用的块。Python 中的函数可以有参数和返回值。以下是函数的详细介绍：\n函数 定义函数 使用 def 关键字来定义函数。\ndef greet(name): print(f\u0026#34;Hello, {name}!\u0026#34;) 调用函数 定义函数后，可以通过函数名和括号调用它。\ngreet(\u0026#34;Alice\u0026#34;) # 输出：Hello, Alice! 函数参数 函数可以接受参数，支持位置参数和关键字参数。\n位置参数 def add(a, b): return a + b result = add(3, 5) print(result) # 输出：8 关键字参数 可以在调用时指定参数名称。\ndef describe_pet(animal_type, pet_name): print(f\u0026#34;I have a {animal_type} named {pet_name}.\u0026#34;) describe_pet(animal_type=\u0026#34;dog\u0026#34;, pet_name=\u0026#34;Buddy\u0026#34;) 默认参数 可以为参数指定默认值，如果调用时不传入该参数，则使用默认值。\ndef power(base, exponent=2): return base ** exponent print(power(4)) # 输出：16 print(power(4, 3)) # 输出：64 可变参数 使用 *args 和 **kwargs 来处理不确定数量的参数。\n*args 接收任意数量的位置参数。\ndef sum_all(*args): return sum(args) print(sum_all(1, 2, 3)) # 输出：6 **kwargs 接收任意数量的关键字参数。\ndef print_info(**kwargs): for key, value in kwargs.items(): print(f\u0026#34;{key}: {value}\u0026#34;) print_info(name=\u0026#34;Alice\u0026#34;, age=30) 返回值 使用 return 语句返回值。如果没有 return，函数默认返回 None。\ndef multiply(x, y): return x * y result = multiply(4, 5) print(result) # 输出：20 文档字符串 可以为函数添加文档字符串，用于描述函数的功能。\ndef factorial(n): \u0026#34;\u0026#34;\u0026#34;计算 n 的阶乘\u0026#34;\u0026#34;\u0026#34; if n == 0: return 1 else: return n * factorial(n - 1) print(factorial.__doc__) # 输出：计算 n 的阶乘 函数作为对象 函数是第一类对象，可以赋值给变量，作为参数传递，或者作为返回值。\ndef square(x): return x * x def apply_function(func, value): return func(value) result = apply_function(square, 5) print(result) # 输出：25 面向对象编程 类与对象 类是对象的蓝图或模板，定义了一组属性和方法。 对象是类的实例，包含类定义的属性和方法的具体值。 定义类 class Dog: # 属性 species = \u0026#34;Canis lupus familiaris\u0026#34; def __init__(self, name, age): self.name = name # 实例属性 self.age = age # 方法 def bark(self): return f\u0026#34;{self.name} says Woof!\u0026#34; 创建对象 my_dog = Dog(\u0026#34;Buddy\u0026#34;, 3) print(my_dog.name) # 输出：Buddy print(my_dog.bark()) # 输出：Buddy says Woof! 属性 属性是对象的特征，分为实例属性和类属性。\n实例属性：特定于某个对象的属性。 类属性：属于类本身的属性，所有对象共享。 print(my_dog.species) # 输出：Canis lupus familiaris 方法 方法是定义在类中的函数，用于执行与对象相关的操作。\nclass Circle: pi = 3.14 # 类属性 def __init__(self, radius): self.radius = radius # 实例属性 def area(self): return Circle.pi * (self.radius ** 2) # 方法访问类属性 继承 继承是面向对象编程的重要特性，可以创建一个新类，从现有类继承属性和方法。\nclass Labrador(Dog): # 继承自 Dog 类 def fetch(self): return f\u0026#34;{self.name} is fetching!\u0026#34; my_lab = Labrador(\u0026#34;Rex\u0026#34;, 2) print(my_lab.fetch()) # 输出：Rex is fetching! 多态 多态允许不同类的对象以相同的方式调用相同的方法，具体的行为由对象的类型决定。\nclass Cat: def bark(self): return \u0026#34;Meow!\u0026#34; def make_sound(animal): print(animal.bark()) make_sound(my_dog) # 输出：Buddy says Woof! make_sound(Cat()) # 输出：Meow! 封装 封装是将对象的状态（属性）与行为（方法）结合在一起，限制外部直接访问对象的内部状态。可以通过命名约定和 getter/setter 方法实现。\nclass BankAccount: def __init__(self, balance=0): self.__balance = balance # 私有属性 def deposit(self, amount): if amount \u0026gt; 0: self.__balance += amount def get_balance(self): return self.__balance account = BankAccount() account.deposit(100) print(account.get_balance()) # 输出：100 好的，下面是关于Python中模块和包的详细说明：\n模块 定义：模块是一个包含Python代码的文件，文件名以.py结尾。模块可以包含函数、类和变量，方便代码的组织和重用。\n导入模块：\n使用import语句导入模块，例如： import math print(math.sqrt(16)) # 输出 4.0 使用from ... import ...导入特定的函数或变量，例如： from math import pi print(pi) # 输出 3.141592653589793 模块的创建：创建模块只需将相关的函数和变量写入一个.py文件中。例如，创建一个名为mymodule.py的文件，内容如下：\ndef greet(name): return f\u0026#34;Hello, {name}!\u0026#34; 模块的作用域：模块内的变量和函数具有模块作用域，避免与其他模块的命名冲突。\n包 定义：包是一个包含多个模块的文件夹，用于组织相关模块。包通过__init__.py文件标识，可以是空文件，也可以包含包的初始化代码。\n创建包：创建一个包只需创建一个文件夹并在其中添加模块和一个__init__.py文件。例如，创建一个名为mypackage的文件夹，里面有module1.py和module2.py，并添加一个空的__init__.py文件。\n导入包：\n导入整个包： import mypackage 导入包中的特定模块： from mypackage import module1 导入包中的特定函数或类： from mypackage.module1 import my_function 命名空间：包提供了命名空间，可以避免模块之间的命名冲突。\n示例 假设我们有如下目录结构：\nmypackage/ __init__.py module1.py module2.py 在module1.py中：\ndef func1(): return \u0026#34;Function 1 from module 1\u0026#34; 在module2.py中：\ndef func2(): return \u0026#34;Function 2 from module 2\u0026#34; 在主程序中使用包：\nfrom mypackage import module1, module2 print(module1.func1()) # 输出 \u0026#34;Function 1 from module 1\u0026#34; print(module2.func2()) # 输出 \u0026#34;Function 2 from module 2\u0026#34; ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/",
    "title": "",
    
    "content": " 参考链接 进入 Rust 编程世界 - Rust语言圣经(Rust Course)\n编程环境：\nVscode rust（vscode插件） rust-analyzer（vscode插件，用于rust） Even Better TOML（vscode插件，用于toml文件） Cargo cargo 提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为 Rust 项目的管理提供尽可能完整的手段。同时，与 Rust 语言及其编译器 rustc 紧密结合，可以说用了后就忘不掉，如同初恋般的感觉。\n使用cargo创建一个项目\ncargo new world_hello cd world_hello 上述命令创建了一个cargo项目，该项目由cargo管理，创建好的项目结构如下\n$ tree . ├── .git ├── .gitignore ├── Cargo.toml └── src └── main.rs 运行 运行cargo程序有两种方法\ncargo run 手动运行 cargo run\ncargo run Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello) Finished dev [unoptimized + debuginfo] target(s) in 0.43s Running `target/debug/world_hello` Hello, world! 手动运行\n编译\ncargo build Finished dev [unoptimized + debuginfo] target(s) in 0.00s 运行\n./target/debug/world_hello Hello, world! 当我们使用使用上面两种方法运行的时候，，编译速度会非常快，但是运行速度就很慢，因为是在debug模式下，所以我们可以使用--release命令\ncargo run --release cargo build --release Cargo check cargo check 是我们在代码开发过程中最常用的命令，它的作用很简单：快速的检查一下代码能否编译通过。因此该命令速度会非常快，能节省大量的编译时间\ncargo check Checking world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello) Finished dev [unoptimized + debuginfo] target(s) in 0.06s Cargo的配置文件 Cargo.toml 和 Cargo.lock 是 cargo 的核心文件，它的所有活动均基于此二者。\nCargo.toml 是 cargo 特有的项目数据描述文件。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 Cargo.toml。 Cargo.lock 文件是 cargo 工具根据同一项目的 toml 文件生成的项目依赖详细清单，因此我们一般不用修改它，只需要对着 Cargo.toml 文件撸就行了。 什么情况下该把 Cargo.lock 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 Cargo.lock，如果是一个依赖库项目，那么请把它添加到 .gitignore 中。\n现在用 VSCode 打开上面创建的\u0026quot;世界，你好\u0026quot;项目，然后进入根目录的 Cargo.toml 文件，可以看到该文件包含不少信息：\npackage 配置段落 package 中记录了项目的描述信息，典型的如下：\n[package] name = \u0026#34;world_hello\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; name 字段定义了项目名称，version 字段定义当前版本，新项目默认是 0.1.0，edition 字段定义了我们使用的 Rust 大版本。因为本书很新（不仅仅是现在新，未来也将及时修订，跟得上 Rust 的小步伐），所以使用的是 Rust edition 2021 大版本，详情见 Rust 版本详解\n定义项目依赖 使用 cargo 工具的最大优势就在于，能够对该项目的各种依赖项进行方便、统一和灵活的管理。\n在 Cargo.toml 中，主要通过各种依赖段落来描述该项目的各种依赖项。引入依赖项有三种方法：\n基于 Rust 官方仓库 crates.io，通过版本说明来描述 基于项目源代码的 git 仓库地址，通过 URL 来描述 基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述 这三种形式具体写法如下：\n[dependencies] rand = \u0026#34;0.3\u0026#34; hammer = { version = \u0026#34;0.5.0\u0026#34;} color = { git = \u0026#34;https://github.com/bjz/color-rs\u0026#34; } geometry = { path = \u0026#34;crates/geometry\u0026#34; } 变量的绑定与解构 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/",
    "title": "",
    
    "content": " 参考链接 第十章、认识与学习BASH | 鸟哥的 Linux 私房菜：基础学习篇 第四版 (gitbooks.io)\n课程概览与 shell · the missing semester of your cs education (missing-semester-cn.github.io)\n第十二章、学习 Shell Scripts | 鸟哥的 Linux 私房菜：基础学习篇 第四版 (gitbooks.io)\nBASH ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%8B%B1%E8%AF%AD%E7%AC%94%E8%AE%B0/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87/",
    "title": "",
    
    "content": " My holiday My holiday is so long, so i plan to do many things.\nI did my holiday homework in the morning. The weather was very hot in the afternoon, so i watched TV and stayed at home. I went for a walk with my friends in the evening. When i finished my holiday homework, i invited my friends to watch a film. I went on a trip with my family. This is my holiday.\n==修改：==\nMy holiday is so long, so i plan to do many things. I do a planning list for my holiday.\nI did my holiday homework in the morning. we have a lot of homework to complete, so i have to spend much time for completing my homework. Because the weather was very hot in the afternoon, i watched TV and stayed at home. And i usually watch movies about animals, it is interesting. I went for a walk with my friends in the evening, we always walked along the river.\nWhen i finished my holiday homework, i invited my friends to watch a film and went on a trip with my family. This is my holiday, i am enjoy my holiday.\n==新单词：==\ncomplete完成\nmovies电影\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%8B%B1%E8%AF%AD%E7%AC%94%E8%AE%B0/%E8%AF%8D%E6%80%A7/",
    "title": "",
    
    "content": " 介词 介词的原理 preposition介词:表面的意思是放在前面的词，即==前置词==。通常放在==名词，代词==之前，用来给他们增添附加信息的词。\n附加信息可以为：\n时间信息 空间信息 方式信息 逻辑信息（原因，目的，对象） 介词的本义原指==空间含义==，它的引申义表达非空间含义\n[!IMPORTANT]\nprep + 名词或代词、数词、副词、形容词\n常见英语介词用法 表示空间的介词 ==in==\n在\u0026hellip;的内部\n==on==\n在\u0026hellip;的上面，一般说在物体的表面，和物体有接触\n==at==\n在某处，表示地点的时候，指确定具体的点\n[!TIP]\nin the tree 和on the tree有着不同的含义\non the tree表示长在树上的，是树本身就有的\nin the tree表示在树里，是外来事物进入树里\nover覆盖，在...上方，越过上空：有可能接触，也有可能不接触，如果有接触则表示覆盖的意思\nabove高于某个平面之上\n[!TIP]\non over above辨析\non表示与物体接触\nover和above在表示不与物体接触的上方时，over表示正上方，并且可以描述动态，而above不行。\n如:The rabbit jumped over the table.\nunder在...下方：与over相对，可以表示物体之间有接触，也可以留有一定的空间，指在某物的正下方，包含垂直在下方的意思\nbelow在...下方：与above相对，表示低于某个平面，可以是正下方，也可以不是。\nnear在...附近，在...周边\nby在...旁边\nbeside在...旁边\nnext to靠近，紧挨着\n[!TIP]\nnear by beside next to都可以表示在\u0026hellip;旁边\nnear表示附近，往往是有一段距离的\n而by beside，next to都表示比较接近，往往可互换\nacross从表面穿过：与物体有接触\nthrough从内部穿过\npast经过，路过\nin front of在...前方\nbefore在...之前：一般不用于空间介词，除非表达在观众或者众人前\nbehind在...之后：与in front of相对\nbetween在...之间：侧重两者之间\namong在...之间：侧重三者及以上之间\nround围绕，环绕\naround环绕，围绕：和round可互换\nalong沿着，顺着\nto向，朝\ntoward朝着...的方向\ntowards朝着...的方向\nonto到...上面\ninto到...里面\nout of从...里面出来\nopposite在...对面\nagainst与...相反，倚靠\nup沿...向上\ndown沿...向下\noff离...有一定的距离\n表示时间的介词 ==in==\n在\u0026hellip;里面，表示在大范围内\n==on==\n在\u0026hellip;之上，说明有一面确定了，只能在这个平面上移动，自然范围小一点\n==at==\n通常在一个很明确地一个点上\n表示在大范围内就可以使用in：in a year，除了年以外还包括月份、星期。\n范围再小一点就可以使用on：on the day，除此之外还可以指定到周几、几月几号\n范围更小就可以使用at：at that moment，固定到时间点就可以使用at\n[!NOTE]\n注意，on，in，at是相对的使用，如一个小时有60分钟，这里的小时相较于分钟就是一个大范围了，所以使用\nThere are 60 minutes in an hour.\nduring持续，在...期间\nfor因为，因...持续\nsince自从\nbefore在...之前\nafter在...之后\nfrom .. to ..从...到...\nby不迟于...前：相较于before，by限定了一条时间线，更侧重于不超过，不迟于这条时间线\nuntil直到...为止\n表示方式的介词 in用...方式:后面可以跟语言，表示用\u0026hellip;语言\nthrough通过某种方式\nby通过...的方式，依靠...的方式\nwith用...，和...一起：with后一般加具体的有形工具\non后接电子通讯设备较多\n表示原因的介词 for因为...，由于...\nwith...是和...分不开的原因\nbecause of因为：后接名词，because后接从句\n由于，因为due to,owing to，on account of\n表示关于的介词 about关于\nof此外的，附加的\non关于\n表示数值的介词 at表示价格，比率等数值点\nby后接度量标准\nfor以...的价钱\n表示状态的介词 in在...的状态中\non受到之下...的支持（的状态）：如on a diet：在节食\nat在某个状态:at work在工作\nunder在...前提之下\n表示排除的介词 besides除了...还\nexcept除了...\nexcept for对之前的描述进行反驳\n介词固定搭配 for example比如\nat ease自在\nin turn依次\nneed for需要...\nlong for渴望...\nready for准备\n名词 名词分为\n普通名词（日常可以见到的物体） 专有名词（专指一个事物或者人的名字，如中国、亚洲、地球、银行等，为了表明名词是专有的，所以将首字母大写） 单数名词和复数名词\n可数普通名词\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%AE%BE%E8%AE%A1/pr/",
    "title": "",
    
    "content": "",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%AE%BE%E8%AE%A1/ps/",
    "title": "",
    
    "content": " 撕纸效果 步骤：\n==打开==一张图片\n在右侧的图层页面选中刚刚打开的图片（背景），按下Ctrl J==复制==一份图片\n选择*==图像\u0026gt;调整\u0026gt;去色==*\n记得需要在图层页面选中刚刚复制的图片\n使用套索工具==绘制==一个斜的带有曲边的四边形。\n注意图形需要闭合\n点击右侧图层页面，==新建==一个图层\n按下Ctrldelete==填充==白色\n填充色和当前使用的背景色有关，当前背景色是白色，那么填充的就是白色\n选中刚才新建的图层，新建==蒙版==\n按下Ctrl再点击图层即可选中刚刚的选区\n将刚刚选中的蒙版填充为黑色，然后按下Ctrli反选\n选择*==滤镜\u0026gt;像素化\u0026gt;晶格化==*\n晶格化的功能是使选取的边缘变得透明\n选择*==选择\u0026gt;修改\u0026gt;收缩==*\n收缩量可以使用10\n新建图层，选择刚刚的选取，按下ALTDelete填充为黑色\n填充色和当前使用的前景色有关，当前选择的前景色是黑色，那么填充的就是黑色\n将背景图层复制一份拖到最顶层，按住ALT,鼠标放在最顶层和下一层的中间，当出现一个向下的箭头，松开鼠标即可\n最终效果：\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/ad/",
    "title": "",
    
    "content": " 快捷键 快捷键 功能 鼠标右键 拖动图纸或PCB 原理图 快捷键 功能 PCB 快捷键 功能 2 转换为2D图 3 转换为3D图 v + b 翻转PCB图 CTRL + 鼠标左键 跟踪线路走向 [!TIP]\n注意，所有的快捷键都在英文状态下执行\n查找 在原理图中：\n知道其中一个信号在哪\n在一个文件中查找：按住ALT，鼠标左键点击信号 鼠标右键网络标号，点击Find Similar Objects，将text改为same即可。 不知道网络标号在哪\nCTRL + F 输入网络标号，点击搜索 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/canoe/",
    "title": "",
    
    "content": " 软件简介 CANoe 是一款由 Vector Informatik 提供的专业软件工具，用于开发、测试和分析基于 CAN（Controller Area Network）总线和其他汽车网络协议（如 LIN、FlexRay、Ethernet、MOST）的嵌入式系统。CANoe 是一款功能强大且广泛应用于汽车电子系统开发和测试的工具。\nCANoe 的主要功能 总线仿真和分析： 支持 CAN、LIN、FlexRay、MOST、Ethernet 等多种总线协议。 提供实时总线仿真和消息分析功能，可以捕获和记录总线数据。 节点仿真： 可以仿真汽车电子系统中的多个节点，支持仿真真实硬件环境下的行为。 支持通过 CAPL（CAN Access Programming Language）脚本编写复杂的仿真逻辑。 网络管理： 提供网络管理功能，支持 CAN、LIN 和 FlexRay 等网络协议的管理。 诊断功能： 支持 UDS（Unified Diagnostic Services）等诊断协议，能够执行故障诊断和错误处理。 集成开发环境： 提供图形化的用户界面和脚本编写环境，方便用户进行配置和测试。 使用场景 汽车电子系统开发：CANoe 常用于汽车电子控制单元（ECU）的开发和测试，可以仿真和测试不同的汽车总线网络。 功能验证和测试：在汽车开发过程中，用于功能验证、系统集成测试和回归测试。 故障诊断和分析：用于捕获和分析总线数据，帮助工程师进行故障诊断和问题定位。 主要组件 Measurement Setup：配置和管理测试环境，包括总线配置、节点配置和信号监控。 CAPL Browser：用于编写和调试 CAPL 脚本，实现复杂的仿真和测试逻辑。 Trace Window：实时显示和记录总线上的消息和事件，方便进行分析和调试。 Panel Designer：设计用户界面面板，用于控制和监控仿真环境中的节点和信号。 CANoe在ECU项目开发中的作用 第一阶段：全仿真网络系统 也就是所有的节点都是虚拟的\n第二阶段：真实节点和部分仿真节点共存 可以使用部分真实的ECU代替虚拟节点，形成半虚拟半真实的网络\n第三阶段：全真实节点的网络系统 使用真实的节点代替所有的仿真节点，形成全真实的节点\nCANoe软件界面功能介绍 CANoe主页面\nCANoe主界面主要有以下功能区部分。\nFile（文件） Home（主功能区） Analysis（分析） Simulation（仿真） Test（测试） Diagnostics（诊断） Environment（环境） Hardware（硬件） Tools（工具） Layout（布局） 文件菜单 File菜单主要用于工程文件的相关操作及属性设定(CANoe项目为cfg结尾).\nHome功能区 Analysis功能区 Simulation功能区 Test功能区 Diagnostics功能区 Environment功能区 Hardware功能区 Tools功能区 Layout功能区 第一个CANoe仿真工程 CANoe仿真环境基本架构 需求 创建两个节点（Switch模块和Light模块） 创建两个控制面板（开关面板和指示灯面板） 通过CAPL代码实现两个节点间的通信 当用户操作开关以后，节点Switch将这个动作通过CAN通知给节点Light；节点Light收到这个CAN报文后，根据信号的值将指示灯点亮或熄灭。\n新建项目 打开CANoe主界面，单击File→New可以看到CANoe提供的工程模板.这里双击选择模板CAN 500kBaud 1ch，将生成一个空白的支持单通道的CAN总线仿真工程。根据之前介绍的工程文件夹的命名习惯，在文件夹FirstDemo下面分别创建文件夹CANdb、Panels和Nodes。\n添加CAN数据库 CANdb的主要功能和用途 定义消息和信号：\nCANdb文件详细定义了网络中每个消息的格式，包括消息ID、数据长度、周期时间等。 还定义了每条消息包含的信号，以及这些信号的属性，如起始位、长度、缩放因子和偏移量。 提供信号解释和转换：\nCANdb文件将原始的CAN数据帧转换为有意义的信号值（如速度、温度等），便于工程师理解和使用。 反过来也可以将信号值转换为CAN数据帧，方便数据发送。 支持网络仿真和分析：\n在CANoe中使用CANdb文件可以仿真和分析CAN网络通信。 CANoe通过CANdb文件识别并解析收到的CAN消息，显示信号的实际值。 自动化测试和诊断：\n自动化测试脚本可以使用CANdb文件中的定义来生成和验证CAN消息。 CANdb文件支持故障注入和诊断测试，帮助发现和解决通信问题。 生成报表和文档：\nCANdb文件中的信息可以用于生成通信协议和信号定义的文档。 有助于在开发团队和供应商之间共享和维护网络通信规范。 使用CANdb文件的具体步骤 创建和编辑CANdb文件：\n使用Vector的CANdb++ Editor或其他支持DBC格式的工具创建和编辑CANdb文件。 定义网络中的节点、消息和信号，并设置相应的属性。 加载CANdb文件到CANoe：\n在CANoe项目中加载创建好的CANdb文件。 CANoe会解析该文件，并在网络仿真和分析中使用这些定义。 仿真和测试：\n使用CANoe的仿真功能，根据CANdb文件定义的消息和信号进行网络仿真。 自动化测试脚本可以引用CANdb文件中的信号定义，生成测试用例和检查结果。 监控和分析：\n在CANoe的信号监控窗口中查看和分析通过CAN网络传输的信号。 使用CANdb文件中的信息，将原始CAN数据帧转换为易于理解的信号值。 示例 假设你有一个CANdb文件，定义了以下信息：\n节点：ECU1, ECU2 消息：Message1 (ID: 0x100, 周期时间: 100ms) 信号：Signal1 (起始位: 0, 长度: 16位, 缩放因子: 0.1, 偏移量: 0) 在CANoe中，你可以：\n加载这个CANdb文件。 配置仿真环境，使得ECU1和ECU2按照CANdb文件定义的规则通信。 使用监控窗口查看Signal1的实际值，并根据这个信号进行进一步分析或故障排除。 新建CAN数据库 现在创建一个含有报文Msg1和信号bsSwitch的数据库。\n单击Tools功能区打开CANdb＋＋Editor（CAN数据库编辑器）。\n在CANdb＋＋Editor界面中单击File→Create database并选择CAN Template.dbc作为模板。\n将新建文件命名为FirstDemo.dbc并保存在工程FirstDemo下面的文件夹CANdb中。\n添加报文和信号(在CANdb++Editor页面) 在Messages下面创建一条报文Msg1\n在Signals下面创建一个信号bsSwitch，单击OK按钮保存。\n可 以 将 信 号 bsSwitch 拖 曳 到 报 文 Msg1 下 面 ， 这 样bsSwitch就变成报文Msg1的一条信号\n添加数据库到工程中 进 入 Simulation Setup 窗 口 ， 在 System View 视 图 中 单 击Networks→CAN Networks→CAN→Databases ， 右 击 鼠 标 选 择Add，如图7.6所示，可以将FirstDemo.dbc文件加入仿真工程.\n定义系统变量 在CANoe中，系统变量（System Variables）是用于在仿真和测试过程中存储和共享数据的变量。它们为用户提供了一种方便的方法来定义和管理仿真环境中的全局状态和参数。系统变量在多种应用场景中非常有用，包括自动化测试、仿真控制和数据监控等。以下是系统变量的主要用途和具体应用：\n系统变量的主要用途 数据共享和通信：\n系统变量可以在不同的CAPL脚本、测试模块和仿真模型之间共享数据。 提供一种全局数据存储机制，使不同组件可以方便地访问和修改变量的值。 仿真控制：\n系统变量可以用于控制仿真场景的行为，例如启动和停止仿真、触发特定事件或模式等。 可以通过改变系统变量的值来动态调整仿真的运行参数。 自动化测试：\n在自动化测试脚本中使用系统变量来存储测试参数和结果。 系统变量可以用作测试条件和断言的基础，帮助验证系统行为是否符合预期。 监控和记录：\n系统变量可以用来监控仿真过程中重要参数的变化。 可以记录系统变量的值，用于后续分析和报告生成。 如何在CANoe中定义和使用系统变量 1. 定义系统变量 在CANoe中，可以通过如下步骤定义系统变量：\n打开CANoe项目。 导航到Variables窗口（通常可以通过“View”菜单找到）。 右键点击变量窗口，选择New System Variable。 为系统变量指定一个名称和类型（如整型、浮点型、布尔型等）。 设置变量的初始值（可选）。 2. 使用系统变量 在CAPL脚本中使用 CAPL（CAN Access Programming Language）是CANoe中用于编写测试脚本的语言。可以在CAPL脚本中读取和写入系统变量。\nvariables { msTimer myTimer; } on start { // 初始化系统变量 setValue(\u0026#34;SystemVarName\u0026#34;, 0); } on timer myTimer { // 读取系统变量的值 int value = getValue(\u0026#34;SystemVarName\u0026#34;); write(\u0026#34;Current value: %d\u0026#34;, value); // 更新系统变量的值 setValue(\u0026#34;SystemVarName\u0026#34;, value + 1); // 重新启动定时器 setTimer(myTimer, 1000); // 每秒更新一次 } on key \u0026#39;a\u0026#39; { // 手动修改系统变量的值 setValue(\u0026#34;SystemVarName\u0026#34;, 42); } 在测试模块中使用 在CANoe的测试模块中，也可以使用系统变量来控制测试流程和检查条件。\n// 定义一个系统变量 systemvar myTestVar; // 在测试用例中使用系统变量 testcase myTest { // 设置系统变量的值 myTestVar := 10; // 使用系统变量的值作为测试条件 if myTestVar == 10 { teststep \u0026#34;Check myTestVar is 10\u0026#34; { // 测试步骤 } } } 实际应用示例 假设你有一个CAN网络仿真项目，包含两个ECU。你可以使用系统变量来监控和控制仿真过程。例如，你可以定义一个布尔型系统变量isEngineRunning，用于表示发动机是否正在运行。\n定义系统变量：\nSystem Variable: isEngineRunning (Boolean, initial value: false) 在CAPL脚本中使用：\non message CAN1.EngineStatus { // 更新系统变量 if (this.EngineRunning) { setValue(\u0026#34;isEngineRunning\u0026#34;, true); } else { setValue(\u0026#34;isEngineRunning\u0026#34;, false); } } 在测试模块中使用：\ntestcase checkEngineStatus { // 检查系统变量的值 teststep \u0026#34;Engine should be running\u0026#34; { if isEngineRunning == true { write(\u0026#34;Test passed: Engine is running.\u0026#34;); } else { write(\u0026#34;Test failed: Engine is not running.\u0026#34;); } } } 创建系统变量 单击Environment功能区打开System Variables（系统变量）配置对话框。创建一个系统变量svLight.\n按 相 同 的 方 法 创 建 另 一 个 系 统 变 量 svSwitch ， 相 关 设 置 ： Namespace ： MyNamespace；Name ： svSwitch；Data type ： Integer。设置完毕后，可以在列表中看到已设置的两个系统变量.\n创建仿真面板 CANoe中为了方便用户模拟真实环境中的操作和显示，可以把需要的相关控制或显示控件设计在一个或多个面板中。一般用户很容易上手操作这些面板，并可以查看相关数据的图形化显示。\n首先创建一个开关面板，用于模拟开关操作。\n单击Tools功能区的Panel Designer（面板设计器）。 新建一个Panel，命名为SWITCH，并保存在文件夹Panels下。 在Panel Designer窗口的Toolbox（工具箱）中选择添加控件Switch/Indicator。在Properties（属性）对话框里将相关参数设置如下，其他属性保持默认值。 State Count:2。 Mouse Activation Type:LeftRight。 Symbol Filter:Variable。 Symbol:svSwitch。 Namespace:MyNamespace。 在 开 关 左 边 添 加 控 件 Static Text ， 将 Text 属 性 设 置 为Switch。 创建一个指示灯面板\n新建另一个Panel，命名为LIGHT，也保存在Panels文件夹下。\n在工具栏中选择添加控件LED Control。在“属性”对话框里将相关属性设置如下，其他属性保持默认值。\nDisplay Only:True。\nSymbol Filter:Variable。\nSymbol:svlight。\nNamespace:MyNamespace。\n在 开 关 左 边 添 加 控 件 Static Text ， 将 Text 属 性 设 置 为Light。\n创建网络节点 系统变量的变化处理以及报文发送与接收等功能需要由CAPL实现，接下来需要创建节点，并在节点中添加对应的CAPL程序。\n添加网络节点 可 以 在 Simulation Setup 窗 口 中 添 加 两 个 ECU 节 点（ECU1和ECU2），当开关按下后，ECU1发送一个CAN报文，ECU2收到报文后将指示灯点亮。 在CAN1的连线上右击，选择Insert Network Node命令，分别创建两个节点为ECU1和ECU2。\n右 击 ECU1 ， 选 择 Configuration 命 令 ， 可 以 打 开 Node Configuration（节点配置）对话框。在Node Configuration对话框中，单击File按钮，为该节点创建一个Switch.can文件，并将Title改为Switch.\nNode Configuration对话框是最常用的界面之一，下面将相关设定简介如下。\nTitle（名称）：用户可以在该文本框中给Network Node指定名称。需要注意的是，该名称只用于在Simulation Setup窗口中的System View中显示（图标节点名称也会改变）。\nNetwork Node（网络节点）：用户可以在该下拉菜单中选择database中已经定义的网络节点。\nState（状态）：用户可以将该Network Node设置为真实节点或仿真节点。simulated代表仿真节点，off代表真实节点（off只是将该节点Block掉）。\nExecution（执行）：在Execution区域，用户可以指定CAPL程序在该节点的运行方式。①Standard：指定CAPL或C#等将会在仿真工程中执行。②On hardware interface（CAPL-on-Board）： CAPL程序可以在Vector的硬件接口卡上运行（VN1630/VN3000／ VN7600）。\nExtended（扩展）：为用户提供了Start Delay和Dift/Jitter选项，前者设置了延迟开始的时间，后者则影响了该节点的定时器。\nNode specification（节点规范）：用户可以在该处选择File区添加CAPL程序，也可以编辑（Edit）和编译（Compile）所添加的CAPL程序文件。\nComponents（模块）：在该选项卡下，列出了该节点所用的所有模块（这里主要指动态链接库文件*.dll），用户也可以在此处添加自己所需的dll文件。\nBuses（总线)：在该选项卡下，列出了该节点可用的和已指定的总线。\n使用同样的方法配置ECU2，命名为Light，代码文件设定为Light.can。\n添加Hello world代码 使用CANoe的CAPL编写一个类似程序。双击节点Switch或者单击该节点的Edit图标，可以进入CAPL Browser（CAPL浏览器）。读者可以看到系统为Switch.can自动创建了如下空白的CAPL模板 . 现 在 添 加 一 个 输 出 类 似 “Hello World” 的 代 码 。 单 击 CAPL Functions浏览框，右键System→New Event Hander→On preStart到代码行。添加一行write函数，仿真工程开始之前将在Write窗口输出一行“This is my first CANoe Simulation！”。\non preStart { write(\u0026#34;This is my first CANoe Simulation!\\n\u0026#34;); } 添加Switch代码 基 于 上 面 的 代 码 ， 在 CAPL Functions 浏 览 框 ， 拖 曳 Value Objects→On sysvar＜sysvar＞到代码行，并将代码修改如下。\non sysvar sysvar::MyNamespace::svSwitch{ message Msg1 msg; msg.bsSwitch = SysGetVarialeInt(sysvar::MyNamespace::svSwitch); output(msg); } 这段代码使得节点Switch根据系统变量svSwitch的变化，修改bsSwitch 信 号 值 ， 并 将 更 新 的 报 文 发 送 到 总 线 上 。 单 击 工 具 栏Compile（F9）完成编译，并退出CAPL Browser。\n添加Light代码 双击Light节点打开对应的CAPL程序文件Light.can。在CAPL Functions浏览框，拖曳CAN→on message＜newMessage＞到代码行，并将代码修改如下\non message Msg1{ SysSetVariableInt(sysvar::MyNamespace::svLight,this.bsSwitch); } 这段代码将在Light节点中处理收到的CAN报文Msg1，根据报文中信号bsSwitch修改系统变量svLight的值，从而实现LED指示灯的点亮或熄灭。单击工具栏中Compile（F9）图标 完成编译，并退出CAPL Browser。\n总线数据库的设计 概述 总线系统中，ECU之间的通信、信息的交互以及相互之间的关系，都是通过总线数据库来管理的。总线数据库定义了总线系统中各个ECU所要发送和接收的报文，以及每个报文所有比特值的具体定义。\n[!TIP]\n提示：数据库中的message中包含了signal，在报文中设置信号就是设置报文的组成形式\nCANdb++Editor 可以使用CANdb++Editor对数据库文件进行编辑\nFile菜单 工具栏 创建CAN数据库（dbc） 基于模板新建总线数据库 在CANdb＋＋Editor主界面，选择File→Create Database命令新建数据库文件，此时可以查看到软件自带的数据库模板 。\n根据不同的需求在模板的基础上进行创建数据库。\nNetwork 双击新建的xvehicle\n在窗口中有4个选项卡，分别为Definition、Nodes、Attributes和Comment。此处将Definition中的Protocol属性改为CAN总线。\nECUs 在ECUs（电子控制单元）项下，列出了当前网络中所含的电控单元，它们之间通过网络节点（Network Nodes）实现信息的交互。通常情况下，ECU与网络节点是一一对应的。当ECU作为网关时，一个ECU可以包含多个网络节点。在CAN数据库中，双击某个ECU可以查看该ECU所对应的网络节点以及环境变量等信息。\n需要提醒读者的是，在CAN数据库中并不能直接创建ECU, CANdb＋＋会在创建网络节点的同时，创建一个名称相同的ECU。\nNetwork Nodes Network Nodes（网络节点）是ECUs的通信接口，各ECU通过Network Nodes实现总线上信息的发送和接收，每个Network Nodes包含对应的名称和地址 。\n新建一个node之后会弹出设置这个node的页面，设置地址为0x01\n同样的再新建一个ndoe\u0026ndash;door，地址为0x02，display地址为0x03\n当新建node之后会发现同步新建了三个同门ECU，并且同名ECU和node之间是关联的。\nMessage Messages（报文）是总线上节点相互通信的数据，数据库中每个报文应包含下列属性\nName（报文名称）\nCAN ID（CAN标识符）\nDLC（Data Length Code，数据长度）\nType（传输类型）\nCycle Time（周期）\nSignals（信号）\nTransmitters（发送节点）\nReceivers（接收节点）\nLayout（布局）\nAttributes（通用属性）\nComment（说明）\n==在报文中可以添加信号，信号组成报文==\n在 导 航 区 栏 中 右 击 Message 选 择 New ，创 建 一 个 名 为 EngineState 的 报 文 ， 选 择 标 准CAN（CAN Standard）报文，标识符为（ID）0x150，数据长度（DLC）为2。\n在Transmitters选项卡下单击Add按钮，将Engine节点添加到发送节点。在Transmitters设定界面中指定了该报文由节点Engine发送，\n用同样的方法，创建名为DoorState的报文，选择标准CAN（CAN Standard）报文，标识符（ID）为0x200，数据长度（DLC）为1，发送节点为Door。\nSignals Signal（信号）是总线通信的最小单元，数据库中一个信号由下列属性组成。\nName（信号名称） Length［Bits］（信号长度） Byte Order（字节顺序） Value Type（数据类型） Unit（物理单位） Init.Value（初始值） Factor（加权） Maximum（最大值） Minimum（最小值） Value Table（数值表） Messages（报文） Receivers（接收节点） Attributes（通用属性） Value Descriptions（数值描述） Comment（说明） CANdb ＋ ＋ 中 ， 信 号 的 数 据 类 型 分 为 4 种 ： Signed 、 Unsigned 、 IEEE Float 和 IEEE Double，\n接下来，将创建4个信号：引擎速度（EngineSpeed）\n在左侧栏中右击Signal选择New，创建信号EngineSpeed, Length为15b, Byte Order为Intel, Unit为r.p.m.，Value Type为Signed, Maximum为5500，其他设置可以使用默认值，如图8.10所示。\nFactor和Offset定义了raw value与physical value之间的关系。\nraw value是CAN报文发到总线上的十六进制数据 physical value是信号所代表的物理量的值 例如，车速、转速、温度等。Init.Value、Minimum和Maximum均为physical value。 $$ physical value ＝ （［ raw value ］ \\times ［Factor］）＋［Offset］。 $$ 在Message选项卡中单击Add按钮将该信号关联到报文EngineState中\n前面设置了Message的发送方Node，实际上Node还有接受方，接受使用singal的形式。\n单击左侧栏中的Network Nodes，右击Display，选择Edit Node，在弹出的对话框中，选择Mapped Rx Sig.选项卡，单击Add按钮，将信号EngineSpeed添加到其中。\nEnvironment Variable Environment Variable（环境变量）是==ECU、面板和CAPL程序相连接的媒介==。例如，在CAPL程序中，通过改变或监控某一环境变量的值可以触发特定的动作，同样，环境变量的值也可以与面板上控制控件或显示控件相关联。\n在CANdb＋＋的导航区中，右击Environment Variable，选择New命令创建一个名为EnvDoorState的环境变量\n参数解释如下\nAttribute Attribute（属性）定义了Vector CAN工具的通用属性，有预定义属性和用户自定义属性。在CANdb＋＋主界面上，单击工具栏中属性图标进入Attribute Definitions界面，也可以通过View→Attribute Definitions打开。\n双击进去就可以看到各个参数的页面。\n数据库的常见属性\nValue Table Value Table（数值表）用来文字化地指定信号或环境变量的值所代表的含义，例如，前面创建的信号OnOff，0代表Off状态，1代表On状态。 类似于c语言中的宏定义。\nByte Order 数据库中信号Byte Order（字节顺序）分为Motorola和Intel两种数据格式（也称为大端模式和小端模式），两种格式的字节顺序排列如下。\nPANEL设计 点击*==Tools \u0026gt; Panel Designer==*打开设计面板\n面板介绍 控件介绍 和系统变量交互 首先需要新建一个系统变量\n点击*==Environment \u0026gt; System Variable==*新建一个系统变量\n点击左侧的新建按钮\n创建完成系统变量之后就是将系统变量和面板上的控件关联起来。这样才能实现系统变量和面板的交互。\n切换到panel编辑器中，点击控件，首先点击symbol filter，选择variable，之后选择sysmbol中的环境变量即可。\n访问和设置环境变量中CAPL笔记中有相关的读取和设置参数。\n仿真工程编译和调试 为了创建==CBF==（CAPL Binary Format）格式的可执行文件，用户需要使用CAPL编译器对所编写的程序进行编译。用户可以单击工具栏中的Compile图标或者按F9键启动编译命令。如果CAPL程序还未命名，CAPL浏览器会提示用户输入文件名并保存。如果程序已命名，则*.cbf文件的名称将直接来自源文件名。编译成功后，CBF文件会自动保存在与CAPL程序文件相同的文件夹下\n[!TIP]\n提示：CAPL语言基本上和C语言很类似，所以也支持条件编译\n#ifdef #elif #endif CAPL的调试和一般调试相同。\nCAN仿真 整体架构 仿真工程的工作流如下图所示\n工程仿真 创建仿真工程 设计或导入DBC文件 创建相关的系统变量 设计面板，将面板中的控件和系统变量绑定在一起 使用CAPL语言进行编程 完成上述步骤之后就可以开始仿真\nTrace窗口 Trace（追踪）窗口主要用于记录和显示测量过程中的所有活动，包括收发报文、错误帧、系统变量、环境变量和诊断服务等。在已加载了Database的工程文件中，Trace窗口可以解析出每个报文和信号。Trace窗口主要有以下功能。\n预定义过滤器（Predefined Filter）：单击Trace窗口工具栏图标 ，打开预定义过滤器视图。这些不同形式的过滤器可以设置Measurement Setup的过滤器、总线系统事件（Bus Systems）过滤器、系统变量／环境变量过滤器、系统报文（System Messages）过滤器等。 分析过滤器（Analysis Filter）：单击Trace窗口工具栏图标 ，打开分析过滤器视图。用于减少窗口中的显示数据，可以把Trace 中 不 关 心 的 项 拖 曳 到 Stop Filter ， 将 关 心 的 项 拖 曳 到 Pass Filter。 淡出无变化的数据：为了提高查看的便利性，固定时间内没有更新的数据显示将逐渐淡出。单击Trace窗口工具栏图标 ，将删除淡出的事件或数据。 设定marker（标识）：marker可以将指定的事件标识出来，并与对应的时间戳相关联。设定的maker也可以在其他分析窗口中显示（如Graphic窗口）。该功能只能在measurement暂停或停止时设定。 显示统计数据：显示报文、信号、变量等各种信息，包括当前数值、时间戳等，可以详细地以不同形式显示。 日志数据：窗口输出可以部分或全部导出，也可以直接保存到指定的文件中。已保存的日志文件，也可以导入到Trace窗口，进行离线分析。日志数据的设定、导入、导出等相关详细介绍. Graphics窗口 在Graphic（图形）窗口中，信号、变量和诊断参数可以以图形化形式显示（XY图形）。用户可以将X轴配置成时间或其他变量。以下为Graphic窗口支持的主要功能。\n设定marker（标识）：marker可以将指定的事件标识出来，并与对应的时间戳相关联。设定的maker也可以在其他分析窗口中显示。该功能只能在measurement暂停或停止时设定。 显示测量栏：在图例中，每个信号的全局和局部数据的最大值和最小值会自动表示出来，同一类型的信号可以比较数值的差异。 显示数据统计：信号的最小值、最大值、平均值和标准偏差显示在Graphic窗口中。该功能只能在measurement停止时可用。 X/Y mode：在信号列表中右击任何一条信号，都可以设置为X轴的变量。 日志数据：Graphic窗口中的信号可以自动保存到事先定义的log文件中（MDF格式），也可以导入已保存的文件分析signal数据 State Tracker窗口 State Tracker（状态追踪）窗口是用来显示比特值和一些状态值，特别适合显示数字输入量和输出量，以及状态信息，如图4.9所示。该功能适合用于分析状态及状态转换相关的信号和变量。以下为State Tracker窗口支持的主要功能。\n发现错误：基于状态响应时间、信号和状态切换的分析，可以有效地监控相关功能，及时发现错误。 分析信息：不同的信息，如ECU内部通信，总线信号以及I/O口的状态，可以放在一起分析。 设定触发：用户可以定义开始测量后的触发条件。 设定marker：可以用marker标识不同的时间点，两个marker点的时间间隔可以测量出来。 Data窗口 Data（数据）窗口可以显示信号、系统变量和诊断参数的数值、单位等信息，并以不同的方式显示出来。\n显示数值：可以显示数据的原始值（Raw Value）、物理值、单位等信息。可以显示信号在全部或部分时间内的最大值和最小值。 日志数据：测量过程中可记录信号并保存到log文件中（MDF格式）。 Statistics窗口 Statistics（统计）窗口用于统计Measurement Setup窗口运行过程中的总线（CAN、LIN、FlexRay等）活动，可以在Measurement Setup窗口中插入Statistics功能。下图所示为CAN总线活动情况，主要显示的信息包括总线负载（也可基于节点级、报文级）、突发帧、标准帧、扩展帧、远程帧、错误帧和控制器状态等。\n显示各个通道的统计数据：显示数据可以限定在指定的通道，或者配置为针对所有可用通道。\n设定刷新间隔：可以修改刷新间隔修改统计的时间间隔。\n暂停统计：用户可以在Measurement运行过程中暂停统计\nScope窗口 Scope （ 示 波 器 ） 窗 口 需 要 配 置 额 外 的 授 权 选 项 （ CANoe Option.Scope）和对应的硬件接口，可以观察总线电平，用于分析总线协议，可以使用EYE图表评估信号品质。 ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/configuration-wizard/",
    "title": "",
    
    "content": " 参考链接 可视化的Keil工程配置模板，一招提高单片机开发效率-CSDN博客\nKeil5 Configuration Wizard配置向导的使用方法_keil configuration wizard-CSDN博客\n实现 Configuration Wizard可以实现可视化配置宏定义文件。\n首先在官方文档（Keil Product Manuals）中搜索Configuration Wizard（µVision User\u0026rsquo;s Guide (arm.com)）\n网页中的文档描述得非常详细，也提供了一个配置模板，我们只需要照着文档描述写好相应的格式即可生成一个图形化的配置界面。\n[!note]\n注意：Keil并没有那么智能，写完这个模板它并不能立马自动匹配到，需要重新关掉Keil工程再开才能加载成图形配置模板，然后才能够实现即时修改即时响应！！！\n将h文件或者c文件转换为可视化界面是很简单的，只需要在文件的开头和结尾加上以下的标识符即可：\n// \u0026lt;\u0026lt;\u0026lt; Use Configuration Wizard in Context Menu \u0026gt;\u0026gt;\u0026gt; // \u0026lt;\u0026lt;\u0026lt; end of configuration section \u0026gt;\u0026gt;\u0026gt; 然后关掉工程再重新打开，就可以实现可视化界面了\n语法 注释 使用标签i来进行注释\n// \u0026lt;i\u0026gt;这里加上注释 组 使用标签h来控制组\n// \u0026lt;h\u0026gt; 组名 // \u0026lt;/h\u0026gt; 复选框 复选框组 使用标签e来控制复选框组\n// \u0026lt;e\u0026gt;系统信息 // \u0026lt;q\u0026gt; 负载锁定 #define _EPCM_LOAD_LOCK 1 //BIT15; 0：不使能负载锁定; 1：使能负载锁定 // \u0026lt;/e\u0026gt; 复选框 复选框(\u0026lt;c\u0026gt; \u0026lt;/c\u0026gt; or \u0026lt;!c\u0026gt; \u0026lt;/c\u0026gt;：创建一个复选框来取消注释或注释代码。\n\u0026lt;c\u0026gt; \u0026lt;/c\u0026gt;勾选不注释代码，不勾选注释代码。 \u0026lt;!c\u0026gt; \u0026lt;/c\u0026gt;勾选注释代码，不勾选不注释代码。 // \u0026lt;c\u0026gt;复选框1 需要开关的代码段 // \u0026lt;/c\u0026gt; // \u0026lt;!c\u0026gt;复选框2 需要开关的代码段 // \u0026lt;/c\u0026gt; 标志位模式 标志位模式\u0026lt;q\u0026gt;：可以通过复选框设置的位值选项。使用符号.来控制位数\n// \u0026lt;q.0\u0026gt; E2ucID第0位 // \u0026lt;q.1\u0026gt; E2ucID第1位 #define E2ucID 0x00 上述代码中E2ucID初始值为0x00，当我选中q.0的复选框时，E2ucID的第一位就会变为1，变为0x01，当我勾选q.1的时候，E2ucID的值的第二位就会变为1，也就是0x02。以此类推。\n组合框 组合框\u0026lt;o\u0026gt;用于选项与选择或数字的输入。\n// \u0026lt;o\u0026gt;电芯串数 // \u0026lt;7=\u0026gt; 7串 // \u0026lt;6=\u0026gt; 6串 // \u0026lt;5=\u0026gt; 5串 // \u0026lt;4=\u0026gt; 4串 #define EPCM_CELL_NUM 7 这里会展示下拉框，其中选项有4串,5串,6串,7串，当选中其中一个选项之后，EPCM_CELL_NUM的值就会变为相应（尖括号中的）的值。\n字符串输入框 使用标签s来控制字符串输入：可修改包含ASCII字符串条目。\n// \u0026lt;s.12\u0026gt;制造商名称 #define _E2ucMNFName \u0026#34;tenxun\u0026#34;//U8 xdata E2ucMNFName[12] 其中的.12表示字符串的长度是12，初始值是tenxun，当在value中修改值的时候，宏_E2ucMNFName的值就会变为你修改的内容\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/gcc/",
    "title": "",
    
    "content": " 参考链接 GCC online documentation - GNU Project\n[books/c/GCC 中文手册.pdf at master · YuxuanLing/books (github.com)](https://github.com/YuxuanLing/books/blob/master/c/GCC 中文手册.pdf)\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/gdb/",
    "title": "",
    
    "content": " 参考链接 CSCI 2021 Quick Guide to gdb: The GNU Debugger (umn.edu)\nGDB Documentation (sourceware.org)\n快速启动 使用-g命令生成debug的相关特征符号\ngcc -Wall -g -c resource.c #这个时候会产生一个a.out文件 #或者使用 gcc -Wall -g -o target resource.c 使用TUI模式对代码进行调试\ngdb -tui ./target [!NOTE]\n推荐使用TUI模式，TUI模式即能看到源码，又能使用命令行\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/git/",
    "title": "",
    
    "content": " Git 的基本概念 Git 是一个分布式版本控制系统，广泛用于软件开发中来跟踪代码变更、协作开发和版本管理。以下是 Git 的基本使用指南，涵盖常见的操作和命令。\nRepository（仓库）：存储项目及其版本历史的地方。 Commit（提交）：对文件或目录的快照。 Branch（分支）：代码开发的独立分支。 Merge（合并）：将分支的修改合并到主分支中。 Remote（远程）：存储在服务器上的仓库。 Git 的基本操作 安装 Git Windows：从 Git 官网 下载并安装。 macOS：使用 Homebrew 安装：brew install git Linux：使用包管理器安装，例如 Ubuntu：sudo apt-get install git 配置 Git git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your.email@example.com\u0026#34; 创建一个新的 Git 仓库 mkdir myproject cd myproject git init 克隆一个现有的仓库 git clone https://github.com/username/repository.git 检查仓库状态 git status 添加文件到仓库 git add filename git add . 提交更改 git commit -m \u0026#34;Commit message\u0026#34; 查看提交历史 git log 创建和切换分支 git branch new-branch git checkout new-branch 或者创建并切换到新分支\ngit checkout -b new-branch 合并分支 切换到你要合并到的分支（例如 main）\ngit checkout main git merge new-branch 删除分支 git branch -d new-branch 添加远程仓库 下面的栗子是添加一个远程仓库，远程仓库的名字为origin，url为https://github.com/username/repository.git\ngit remote add origin https://github.com/username/repository.git 推送到远程仓库 首次推送需要先设置公钥\nssh-keygen -t rsa -C \u0026#34;your_email@example.com\u0026#34; 生成密钥之后查看密钥文件中的内容，将密钥文件中的内容复制到github的设置中的SSH中即可开始推送\ncat ~/.ssh/id_rsa.pub 可使用以下命令测试密钥是否配置成功\nssh -T git@github.com 推送的语法为\ngit push [添加的仓库名] [仓库的分支名] 下面的栗子是向origin仓库的branch-name分支推送代码\ngit push origin branch-name 从远程仓库拉取更新 git pull origin branch-name 解决冲突 在合并或拉取过程中，如果有冲突，Git 会提示冲突文件。你需要手动解决冲突并提交解决后的更改。\n常用 Git 命令总结 git init：初始化一个新的 Git 仓库 git clone \u0026lt;repo\u0026gt;：克隆一个远程仓库 git status：查看仓库状态 git add \u0026lt;file\u0026gt;：添加文件到暂存区 git commit -m \u0026quot;message\u0026quot;：提交更改 git log：查看提交历史 git branch：列出分支 git checkout \u0026lt;branch\u0026gt;：切换到分支 git checkout -b \u0026lt;branch\u0026gt;：创建并切换到新分支 git merge \u0026lt;branch\u0026gt;：合并分支 git branch -d \u0026lt;branch\u0026gt;：删除分支 git remote add origin \u0026lt;url\u0026gt;：添加远程仓库 git push origin \u0026lt;branch\u0026gt;：推送分支到远程仓库 git pull origin \u0026lt;branch\u0026gt;：从远程仓库拉取分支更新 通过这些基本的 Git 操作和命令，你可以有效地管理和协作开发项目。\n.gitignore的使用规则 在Git中，.gitignore 文件用于告诉Git哪些文件和目录应该被忽略，不需要被版本控制。.gitignore 文件中的语法规则非常灵活，支持多种模式和通配符。以下是一些常用的语法规则和示例：\n注释：以 # 开头的行是注释。\n# 这是一个注释 忽略文件或目录：直接写文件或目录的名称。\n# 忽略所有 .log 文件 *.log # 忽略名为 temp 的目录 temp/ 通配符 *：匹配零个或多个字符。\n# 忽略所有 .log 文件 *.log # 忽略所有的临时文件 *~ 问号 ?：匹配任意一个字符。\n# 忽略所有扩展名为 .l?g 的文件（例如 .log 和 .l1g） *.l?g 方括号 []：匹配括号内的任意一个字符。\n# 忽略所有扩展名为 .log 或 .lbg 的文件 *.l[ob]g 斜杠 /：用于分隔目录。如果以 / 开头，表示相对于仓库根目录。如果以 / 结尾，表示一个目录。\n# 忽略根目录下的 temp 目录 /temp/ # 忽略所有子目录中的 temp 目录 temp/ 否定模式 !：将某些文件从忽略列表中排除。\n# 忽略所有的 .log 文件 *.log # 但不要忽略特定的 debug.log 文件 !debug.log 双星号 **：匹配任意目录深度。\n# 忽略任何子目录中的 temp 目录 **/temp/ # 忽略所有子目录中的 .log 文件 **/*.log 注释行中的 \\：用于转义字符。\n# 忽略所有以 # 开头的文件 \\#*.log 以下是一个示例 .gitignore 文件，结合了上述规则：\n# 忽略所有的 .log 文件 *.log # 忽略所有的临时文件 *~ # 忽略根目录下的 temp 目录 /temp/ # 忽略任何子目录中的 temp 目录 **/temp/ # 忽略所有子目录中的 .log 文件 **/*.log # 但不要忽略特定的 debug.log 文件 !debug.log 问题 如果使用ssh -T git@github.com命令显示Connection reset by 20.205.243.166 port 22，说明是网络有问题，可以在~/.ssh/config或C:\\Users\\Administrator\\.ssh文件中修改config(没有的话创建一个)内容如下：\nHost github.com Hostname ssh.github.com User git Port 443 IdentityFile ~/.ssh/id_rsa IdentityFile的内容要改为id_rsa的文件路径\n",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
  , 
  {
    "objectID": "-62135596800",
    "permalink": "/youShouldTrustMe/youShouldTrustMe.github.io/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/jyyslide/",
    "title": "",
    
    "content": " 下载、安装 参考链接 sunnysky29/jyy-slides: jyy OS PPT (github.com)\n工具的安装 首先需要安装python，python版本需要在3.10及以上\n安装poetry\npip install poetry 克隆库\ngit clone https://github.com/zweix123/jyyslide-md.git cd jyyslide-md 安装第三方库\npoetry install 转换 转换可以使用两种方法：\n使用虚拟环境\npoetry shell python main.py 需要转换的文件地址 直接转换\npoetry run python main.py 需要转换的文件地址 windows的快捷转换：\n首先需要先给md文件设置一个右键命令\n按下 Win + R 打开“运行”窗口，输入 regedit，然后按回车进入注册表编辑器。\n导航到以下路径：\n复制代码 HKEY_CLASSES_ROOT\\*\\shell 右键点击 shell 文件夹，选择“新建” \u0026gt; “项”，将其命名为 Convert to HTML。\n在 Convert to HTML 项下，右键点击右侧窗格中的 (默认)，选择“修改”，将“数值数据”设置为你希望显示的右键菜单项的名称，比如“Convert Markdown to HTML”。\n右键点击 Convert to HTML 项，选择“新建” \u0026gt; “项”，将其命名为 command。\n选择 command 项，然后右键点击右侧窗格中的 (默认)，选择“修改”。在“数值数据”中输入以下内容：\n\u0026#34;D:\\jyyPPT\\md2html.bat\u0026#34; \u0026#34;%1\u0026#34; 请确保路径替换为你实际的批处理文件路径。\n这个时候右键的时候就能发现已经创建成功了\n设置一个bat文件\n@echo off cd /d \u0026#34;D:\\jyyPPT\\jyyslide-md\\\u0026#34; poetry run python main.py \u0026#34;%1\u0026#34; pause 语法 水平分割使用---\n垂直分割使用----\n渐变垂直使用++++\n在同一张幻灯片中依次出现的页面使用-- 作者信息页使用+++++，语法格式使用json或yaml\n{ \u0026#34;author\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;蒋炎岩\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ics.nju.edu.cn/~jyy/\u0026#34; }, \u0026#34;departments\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34; 南京大学 \u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.nju.edu.cn/main.htm\u0026#34;, \u0026#34;img\u0026#34;: \u0026#34;./img/nju-logo.jpg\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;计算机科学与技术系\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://cs.nju.edu.cn/main.htm\u0026#34;, \u0026#34;img\u0026#34;: \u0026#34;./img/njucs-logo.jpg\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;计算机软件研究所\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.nju.edu.cn/main.htm\u0026#34;, \u0026#34;img\u0026#34;: \u0026#34;./img/ics-logo.png\u0026#34; } ] } author: name: 蒋炎岩 url: https://ics.nju.edu.cn/~jyy/ departments: - name: \u0026#34; 南京大学 \u0026#34; url: https://www.nju.edu.cn/main.htm, img: ./img/nju-logo.jpg - name: 计算机科学与技术系 url: https://cs.nju.edu.cn/main.htm, img: ./img/njucs-logo.jpg - name: 计算机软件研究所 url: https://www.nju.edu.cn/main.htm, img: ./img/ics-logo.png ",
    
    "date": "0001-01-01 00:00:00",
    "updated": "0001-01-01 00:00:00"
  }
  
]