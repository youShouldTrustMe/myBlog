
[
  
  
  {
    "objectID": "1740960000",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/",
    "title": "计算机系统基础",
    
    "content": " 参考链接 计算机系统基础(一)：程序的表示、转换与链接_南京大学_中国大学MOOC(慕课)\n概述 计算机基本工作原理 冯诺依曼结构 硬件模型基本结构\n模型中包含以下四个部分\n用来存放指令和数据的主存储器，简称==主存或内存==； 用来进行算术逻辑运算的部件，即算术逻辑部件(Arithmetic Logic Unit,简称==ALU==),在ALU操作控制 信号ALUop的控制下，ALU可以对输人端A和B进行不同的运算，得到结果F; 用于自动逐条取出指令并进行译码的部件，即控制部件(Control Unit,简称CU),也称==控制器==； 用来和用户交互的==输入设备和输出设备==。 CPU内部不同的组件\n为了临时存放从主存取来的数据或运算的结果，还需要若干通用寄存器(General Purpose Register)组成通用寄存器组(==GPRs==)，ALU两个输入端A和B的数据来自通用寄存器； ALU运算的结果会产生标志信息，例如，结果是否为0（零标志ZF)、是否为负数（符号标志SF)等，这些标志信息需要记录在专门的==标志寄存器==中； 从主存取来的指令需要临时保存在指令寄存器(Instruction Register,简称==IR==)中； CPU为了自动按序读取主存中的指令，还需要有一个程序计数器(Program Counter,简称==PC==),在执行当前指令过程中，自动 计算出下一条指令的地址并送到PC中保存。 通常把控制部件、运算部件和各类寄存器互连组成的电路称为中央处理器(Central Processing Unit,简称CPU),简称处理器。 CPU读取数据过程\nCPU需要从通用寄存器中取数据到ALU运算，或把ALU运算的结果保存到通用寄存器中，因此，需要给每个通用寄存器编号；\n同样，主存中每个单元也需要编号，称为主存单元地址，简称主存地址。\n通用寄存器和主存都属于存储部件，通常，计算机中的存储部件从0开始编号，例如，4个通用寄存器编号分别为0 ~ 3；16个主存单元编号分别为0 ~ 15。\nCPU为了从主存取指令和存取数据，需要通过传输介质与主存相连，通常把连接不同部件进行信息传输的介质称为==总线==，其中，包含了用于传输地址信息、数据信息和控制信息的地址线、数据线和控制线。\nCPU访问主存时，需先将主存地址、读/写命令分别送到总线的 …",
    
    "date": "2025-03-03 00:00:00",
    "updated": "2025-03-03 00:00:00"
  }
  
  , 
  {
    "objectID": "1740852000",
    "permalink": "/post/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/",
    "title": "算法",
    
    "content": " 参考链接 Hello 算法 (hello-algo.com)\n复杂度分析 迭代 迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。\nfor循环 for 循环是最常见的迭代形式之一，适合在预先知道迭代次数时使用。\n以下函数基于 for 循环实现了求和 1+2+⋯+𝑛 ，求和结果使用变量 res 记录。需要注意的是，Python 中 range(a, b) 对应的区间是“左闭右开”的，对应的遍历范围为 𝑎,𝑎+1,…,𝑏−1 ：\n/* for 循环 */ int forLoop(int n) { int res = 0; // 循环求和 1, 2, ..., n-1, n for (int i = 1; i \u0026lt;= n; i++) { res += i; } return res; } 此求和函数的操作数量与输入数据大小 𝑛 成正比，或者说成“线性关系”。实际上，时间复杂度描述的就是这个“线性关系”。\nwhile循环 与 for 循环类似，while 循环也是一种实现迭代的方法。在 while 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。\n下面我们用 while 循环来实现求和 1+2+⋯+𝑛 ：\n/* while 循环 */ int whileLoop(int n) { int res = 0; int i = 1; // 初始化条件变量 // 循环求和 1, 2, ..., n-1, n while (i \u0026lt;= n) { res += i; i++; // 更新条件变量 } return res; } while 循环比 for 循环的自由度更高。在 while 循环中，我们可以自由地设计条件变量的初始化和更新步骤。\n例如在以下代码中，条件变量 𝑖 每轮进行两次更新，这种情况就不太方便用 for 循环实现：\n/* while 循环（两次更新） */ int whileLoopII(int n) { int res = 0; int i = 1; // 初始化条件变量 // 循环求和 1, 4, 10, ... while (i \u0026lt;= n) { res += i; // 更新条件变量 i++; i *= 2; } return res; } 总的来说，for 循环的代码更加紧凑，while 循环更加灵活，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。\n嵌套循环 我们可以在一个循环结构内嵌套另一个循环结构，下面以 for 循环为例：\n/* 双层 for 循环 */ char *nestedForLoop(int n) { // n * n 为对应点数量，\u0026#34;(i, j), \u0026#34; 对应字符串长最大为 6+10*2，加上最后一个空字符 \\0 的额外空间 int size = n * n * 26 + 1; char *res = malloc(size * sizeof(char)); // 循环 i = 1, 2, ..., n-1, n for (int i = 1; i \u0026lt;= n; i++) { // 循环 j = 1, 2, ..., n-1, n for (int j = 1; j \u0026lt;= n; j++) { char tmp[26]; snprintf(tmp, sizeof(tmp), \u0026#34;(%d, %d), \u0026#34;, i, j); strncat(res, tmp, size - strlen(res) - 1); } } return res; } 在这种情况下，函数的操作数量与 $n^2$ 成正比，或者说算法运行时间和输入数据大小 𝑛 成“平方关系”。\n我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。\n递归 递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。\n递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。 归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。 而从实现的角度看，递归代码主要包含三个要素。\n终止条件：用于决定什么时候由“递”转“归”。 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。 返回结果：对应“归”，将当前递归层级的结果返回至上一层。 观察以下代码，我们只需调用函数 recur(n) ，就可以完成 1+2+⋯+𝑛 的计算：\n/* 递归 */ int recur(int n) { // 终止条件 if (n == 1) return 1; // 递：递归调用 int res = recur(n - 1); // 归：返回结果 return n + res; } 虽然从计算角度看，迭代与递归可以得到相同的结果，但它们代表了两种完全不同的思考和解决问题的范式。\n迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。 递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。 以上述求和函数为例，设问题 𝑓(𝑛)=1+2+⋯+𝑛 。\n迭代：在循环中模拟求和过程，从 1 遍历到 𝑛 ，每轮执行求和操作，即可求得 𝑓(𝑛) 。 递归：将问题分解为子问题 𝑓(𝑛)=𝑛+𝑓(𝑛−1) ，不断（递归地）分解下去，直至基本情况 𝑓(1)=1 时终止。 调用栈 递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。\n函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。 在触发终止条件前，同时存在 𝑛 个未返回的递归函数，递归深度为 𝑛 。\n在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。\n尾递归 有趣的是，如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。\n普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。 以计算 1+2+⋯+𝑛 为例，我们可以将结果变量 res 设为函数参数，从而实现尾递归：\n/* 尾递归 */ int tailRecur(int n, int res) { // 终止条件 if (n == 0) return res; // 尾递归调用 return tailRecur(n - 1, res + n); } 对比普通递归和尾递归，两者的求和操作的执行点是不同的。\n普通递归：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。 尾递归：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。 [!tip]\n请注意，许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。\n递归树 当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。\n问题：\n给定一个斐波那契数列0,1,2,3,4\u0026hellip;\u0026hellip;,求该数列的第n个数字\n设斐波那契数列的第 𝑛 个数字为 𝑓(𝑛) ，易得两个结论。\n数列的前两个数字为 𝑓(1)=0 和 𝑓(2)=1 。 数列中的每个数字是前两个数字的和，即 𝑓(𝑛)=𝑓(𝑛−1)+𝑓(𝑛−2) 。 按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。调用 fib(n) 即可得到斐波那契数列的第 𝑛 个数字：\n/* 斐波那契数列：递归 */ int fib(int n) { // 终止条件 f(1) = 0, f(2) = 1 if (n == 1 || n == 2) return n - 1; // 递归调用 f(n) = f(n-1) + f(n-2) int res = fib(n - 1) + fib(n - 2); // 返回结果 f(n) return res; } 观察以上代码，我们在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。这样不断递归调用下去，最终将产生一棵层数为 𝑛 的递归树（recursion tree）。\n从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。\n从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。 时间复杂度 运行时间可以直观且准确地反映算法的效率。如果我们想准确预估一段代码的运行时间，应该如何操作呢？\n确定运行平台，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。 评估各种计算操作所需的运行时间，例如加法操作 + 需要 1 ns ，乘法操作 * 需要 10 ns ，打印操作 print() 需要 5 ns 等。 统计代码中所有的计算操作，并将所有操作的执行时间求和，从而得到运行时间。 例如在以下代码中，输入数据大小为 𝑛 ：\n// 在某运行平台下 void algorithm(int n) { int a = 2; // 1 ns a = a + 1; // 1 ns a = a * 2; // 10 ns // 循环 n 次 for (int i = 0; i \u0026lt; n; i++) { // 1 ns printf(\u0026#34;%d\u0026#34;, 0); // 5 ns } } $$ 1+1+10+(1+5)×𝑛=6𝑛+12 $$ 但实际上，统计算法的运行时间既不合理也不现实。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。\n统计时间增长趋势 时间复杂度分析统计的不是算法运行时间，==而是算法运行时间随着数据量变大时的增长趋势==。\n“时间增长趋势”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 𝑛 ，给定三个算法 A、B 和 C ：\n// 算法 A 的时间复杂度：常数阶 void algorithm_A(int n) { printf(\u0026#34;%d\u0026#34;, 0); } // 算法 B 的时间复杂度：线性阶 void algorithm_B(int n) { for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d\u0026#34;, 0); } } // 算法 C 的时间复杂度：常数阶 void algorithm_C(int n) { for (int i = 0; i \u0026lt; 1000000; i++) { printf(\u0026#34;%d\u0026#34;, 0); } } 三个函数的时间复杂度为：\n算法 A 只有 1 个打印操作，算法运行时间不随着 𝑛 增大而增长。我们称此算法的时间复杂度为“常数阶”。 算法 B 中的打印操作需要循环 𝑛 次，算法运行时间随着 𝑛 增大呈线性增长。此算法的时间复杂度被称为“线性阶”。 算法 C 中的打印操作需要循环 1000000 次，虽然运行时间很长，但它与输入数据大小 𝑛 无关。因此 C 的时间复杂度和 A 相同，仍为“常数阶”。 相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？\n时间复杂度能够有效评估算法效率。例如，算法 B 的运行时间呈线性增长，在 𝑛\u0026gt;1 时比算法 A 更慢，在 𝑛\u0026gt;1000000 时比算法 C 更慢。事实上，只要输入数据大小 𝑛 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势的含义。 时间复杂度的推算方法更简便。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。 时间复杂度也存在一定的局限性。例如，尽管算法 A 和 C 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 B 的时间复杂度比 C 高，但在输入数据大小 𝑛 较小时，算法 B 明显优于算法 C 。对于此类情况，我们时常难以仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。 函数渐进上界 给定一个输入大小为n的函数：\nvoid algorithm(int n) { int a = 1; // +1 a = a + 1; // +1 a = a * 2; // +1 // 循环 n 次 for (int i = 0; i \u0026lt; n; i++) { // +1（每轮都执行 i ++） printf(\u0026#34;%d\u0026#34;, 0); // +1 } } $$ 𝑇(𝑛)=3+2𝑛 $$ 𝑇(𝑛) 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。\n我们将线性阶的时间复杂度记为 𝑂(𝑛) ，这个数学符号称为大 𝑂 记号（big-𝑂 notation），表示函数 𝑇(𝑛) 的渐近上界（asymptotic upper bound）。\n时间复杂度分析本质上是计算“操作数量 𝑇(𝑛)”的渐近上界，它具有明确的数学定义。\n[!TIP]\n若存在正实数 𝑐 和实数 𝑛0 ，使得对于所有的 𝑛\u0026gt;𝑛0 ，均有 𝑇(𝑛)≤𝑐⋅𝑓(𝑛) ，则可认为 𝑓(𝑛) 给出了 𝑇(𝑛) 的一个渐近上界，记为 𝑇(𝑛)=𝑂(𝑓(𝑛)) 。\n计算渐近上界就是寻找一个函数 𝑓(𝑛) ，使得当 𝑛 趋向于无穷大时，𝑇(𝑛) 和 𝑓(𝑛) 处于相同的增长级别，仅相差一个常数项 𝑐 的倍数。\n推算方法 渐近上界的数学味儿有点重，如果你感觉没有完全理解，也无须担心。我们可以先掌握推算方法，在不断的实践中，就可以逐渐领悟其数学意义。\n根据定义，确定 𝑓(𝑛) 之后，我们便可得到时间复杂度 𝑂(𝑓(𝑛)) 。那么如何确定渐近上界 𝑓(𝑛) 呢？总体分为两步：首先统计操作数量，然后判断渐近上界。\n统计操作数量 针对代码，逐行从上到下计算即可。然而，由于上述 𝑐⋅𝑓(𝑛) 中的常数项 𝑐 可以取任意大小，因此操作数量 𝑇(𝑛) 中的各种系数、常数项都可以忽略。根据此原则，可以总结出以下计数简化技巧。\n忽略 𝑇(𝑛) 中的常数项。因为它们都与 𝑛 无关，所以对时间复杂度不产生影响。 省略所有系数。例如，循环 2𝑛 次、5𝑛+1 次等，都可以简化记为 𝑛 次，因为 𝑛 前面的系数对时间复杂度没有影响。 循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用第 1. 点和第 2. 点的技巧。 给定一个函数，我们可以用上述技巧来统计操作数量：\nvoid algorithm(int n) { int a = 1; // +0（技巧 1） a = a + n; // +0（技巧 1） // +n（技巧 2） for (int i = 0; i \u0026lt; 5 * n + 1; i++) { printf(\u0026#34;%d\u0026#34;, 0); } // +n*n（技巧 3） for (int i = 0; i \u0026lt; 2 * n; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { printf(\u0026#34;%d\u0026#34;, 0); } } } $$ T(n)=2n(n+1)+(5n+1)+2=2n^2+7n+3\\\\ T(n)=n^2+n $$ 判断渐近上界 时间复杂度由 𝑇(𝑛) 中最高阶的项来决定。这是因为在 𝑛 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。\n下表展示了一些栗子，其中一些夸张的值是为了强调“系数无法撼动阶数”这一结论。当 𝑛 趋于无穷大时，这些常数变得无足轻重。\n操作数量T(n) 时间复杂度 O(f(n)) 100000 O(1) 3n+2 O(n) 2$n^2$+ 3n + 2 O($n^2$) $n^2$+10000$n^2$ O(n) $2^n+10000n^{10000}$ O($2^n$) 常见类型 $$ O(1)",
    
    "date": "2025-03-01 11:00:00",
    "updated": "2025-03-01 11:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/adc/",
    "title": "ADC",
    
    "content": " ADC简介 介绍 •ADC（Analog-Digital Converter）模拟-数字转换器\n•ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁\n•12位逐次逼近型ADC，1us转换时间\n•输入电压范围：03.3V，转换结果范围：04095\n•18个输入通道，可测量16个外部和2个内部信号源\n•规则组和注入组两个转换单元\n•模拟看门狗自动监测输入电压范围\n•STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道\n原理 常见ADC类型 ADC电路类型 优点 缺点 并联比较型 转换速度最快 成本高、功耗高，分辨率低 逐次逼近型 结构简单，功耗低 转换速度较慢 并联比较型 将输入的参考电压和模拟电压输入进行比较，比较器会输出0或1从而获得二进制的数字量\n逐次逼近型 特性 特性参数 各系列主要特性 主要特性 F1 F4 F7 H7 ADC类型 逐次逼近型 分辨率 12位 6/8/10/12位 6/8/10/12位 8/10/12/14/16位 ADC时钟频率 14MHz（max） 36MHz（max） 采样时间 采样时间越长, 转换结果相对越准确, 但是转换速度就越慢 转换时间 与ADC时钟频率、分辨率和采样时间等有关 供电电压 VSSA ：0V，VDDA ：2.4V~3.6V（全速运行） 参考电压 VREF– ：0V，VREF+一般为3.3V 输入电压 VREF–≤VIN≤VREF+ 整体结构 结构框图 参考电压/模拟部分电压 ADC所能测量的电压范围是Vref- \u0026lt; VIN \u0026lt; Vref+,如果把VSSA和VREF-接地，把VREF+和VDDA接3V3，得到ADC的输入范围为0-3.3v\n输入通道 ADC的信号输入通过通道来实现的，信号通过通道输入到单片机中，单片机经过转换后，将模拟信号转换为数字信号。Stm32中的ADC有18个通道，其中外部16个通道已经在图中标出，这16个通道对应着不同的IO口，除此之外ADC1/2/3还有内部通道。\nADC1 IO ADC2 IO ADC3 IO 通道0 PA0 通道0 PA0 通道0 PA0 通道1 PA1 通道1 PA1 通道1 PA1 通道2 PA2 通道2 PA2 通道2 PA2 通道3 PA3 通道3 PA3 通道3 PA3 通道4 PA4 通道4 PA4 通道4 PF6 通道5 PA5 通道5 PA5 通道5 PF7 通道6 PA6 通道6 PA6 通道6 PF8 通道7 PA7 通道7 PA7 通道7 PF9 通道8 PB0 通道8 PB0 通道8 PF10 通道9 PB1 通道9 PB1 通道9 连接内部VSS 通道10 PC0 通道10 PC0 通道10 PC0 通道11 PC1 通道11 PC1 通道11 PC1 通道12 PC2 通道12 PC2 通道12 PC2 通道13 PC3 通道13 PC3 通道13 PC3 通道14 PC4 通道14 PC4 通道14 连接内部VSS 通道15 PC5 通道15 PC5 通道15 连接内部VSS 通道16 连接内部温度传感器 通道16 连接内部VSS 通道16 连接内部VSS 通道17 连接内部Vrefint 通道17 连接内部VSS 通道17 连接内部VSS 外部的16个通道在转换时又分为规则通道和注入通道，其中规则通道最多有16路，注入通道最多有4路\n规则通道 规则通道是用于普通的周期性 ADC 数据采集的通道。它们适用于周期性地采集模拟信号，例如传感器测量、输入信号的连续转换等。在规则通道中，可以设置 ADC 转换的采样时间、分辨率等参数。\n注入通道 注入通道是用于触发式或突发式 ADC 数据采集的通道。它们适用于在特定事件或条件下进行数据采集，例如外部触发或中断事件。注入通道可以用于实现对不同事件的响应并采集模拟信号。在注入通道中，您可以设置触发源、采样时间等参数。\n转换顺序 知道了ADC的转换通道后，如果ADC只使用一个通道来转换，那就很简单，但如果是使用多个通道进行转换就涉及到一个先后顺序了，毕竟规则转换通道只有一个数据寄存器。所以将转换的顺序分组，每组转换的顺序组成一个序列。\n多个通道的使用顺序分为俩种情况：\n规则通道的转换顺序\n注入通道的转换顺序\n这里的规则组只有一个寄存器，所以说当数据转换完成之后就需要尽快转移数据，防止数据覆盖。注入组有四个寄存器，可以将转换的数据存在各自的寄存器中。\n规则通道转换顺序 规则通道中的转换顺序由三个寄存器控制：SQR1、SQR2、SQR3，它们都是32位寄存器。SQR寄存器控制着转换通道的数目和转换顺序，只要在对应的寄存器位SQx中写入相应的通道，这个通道就是第x个转换。具体的对应关系如下\n优先级比较 注入组优先级高于规则组，注入组的转换可以打断规则组。\n规则序列 规则序列寄存器控制关系汇总 寄存器 寄存器位 功能 取值 SQR3 SQ1 [ 4 : 0 ] 设置第1个转换的通道 通道0~17 SQ2 [ 4 : 0 ] 设置第2个转换的通道 通道0~17 SQ3 [ 4 : 0 ] 设置第3个转换的通道 通道0~17 SQ4 [ 4 : 0 ] 设置第4个转换的通道 通道0~17 SQ5 [ 4 : 0 ] 设置第5个转换的通道 通道0~17 SQ6 [ 4 : 0 ] 设置第6个转换的通道 通道0~17 SQR2 SQ7 [ 4 : 0 ] 设置第7个转换的通道 通道0~17 SQ8 [ 4 : 0 ] 设置第8个转换的通道 通道0~17 SQ9 [ 4 : 0 ] 设置第9个转换的通道 通道0~17 SQ10 [ 4 : 0 ] 设置第10个转换的通道 通道0~17 SQ11 [ 4 : 0 ] 设置第11个转换的通道 通道0~17 SQ12 [ 4 : 0 ] 设置第12个转换的通道 通道0~17 SQR1 SQ13 [ 4 : 0 ] 设置第13个转换的通道 通道0~17 SQ14 [ 4 : 0 ] 设置第14个转换的通道 通道0~17 SQ15 [ 4 : 0 ] 设置第15个转换的通道 通道0~17 SQ16 [ 4 : 0 ] 设置第16个转换的通道 通道0~17 SQL [ 3 : 0 ] 设置规则序列要转换的通道数 0~15 注入序列 和规则通道转换顺序的控制一样，注入通道的转换也是通过注入寄存器来控制，只不过只有一个JSQR寄存器来控制，控制关系如下\n需要注意的是，只有当JL=4的时候，注入通道的转换顺序才会按照JSQ1、JSQ2、JSQ3、JSQ4的顺序执行。当JL\u0026lt;4时，注入通道的转换顺序恰恰相反，也就是执行顺序为：JSQ4、JSQ3、JSQ2、JSQ1。\n注入序列寄存器控制关系汇总 寄存器 寄存器位 功能 取值 JSQR JSQ1 [ 4 : 0 ] 设置第1个转换的通道 通道0~17 JSQ2 [ 4 : 0 ] 设置第2个转换的通道 通道0~17 JSQ3 [ 4 : 0 ] 设置第3个转换的通道 通道0~17 JSQ4 [ 4 : 0 ] 设置第4个转换的通道 通道0~17 JL [ 1 : 0 ] 设置注入序列要转换的通道数 0~3 触发源 ADC转换的输入、通道、转换顺序都已经说明了，但ADC转换是怎么触发的呢？就像通信协议一样，都要规定一个起始信号才能传输信息，ADC也需要一个触发信号来实行模/数转换。\n1、通过直接配置寄存器触发，通过配置控制寄存器CR2的ADON位，写1时开始转换，写0时停止转换。在程序运行过程中只要调用库函数，将CR2寄存器的ADON位置1就可以进行转换。\n2、通过内部定时器或者外部IO触发转换，也就是说可以利用内部时钟让ADC进行周期性的转换，也可以利用外部IO使ADC在需要时转换，具体的触发由控制寄存器CR2决定。\n转换时间 ADC的每一次信号转换都要时间，这个时间就是转换时间，转换时间由输入时钟和采样周期来决定。\n输入时钟 由于ADC在STM32中是挂载在APB2总线上的，所以ADC得时钟是由PCLK2（72MHz）经过分频得到的，分频因子由 RCC 时钟配置寄存器RCC_CFGR 的位 15:14 ADCPRE[1:0]设置，可以是 2/4/6/8 分频，一般配置分频因子为8，即8分频得到ADC的输入时钟频率为9MHz。\n采样周期 采样周期是确立在输入时钟上的，配置采样周期可以确定使用多少个ADC时钟周期来对电压进行采样，采样的周期数可通过 ADC采样时间寄存器 ADC_SMPR1 和 ADC_SMPR2 中的 SMP[2:0]位设置，ADC_SMPR2 控制的是通道 09， ADC_SMPR1 控制的是通道 1017。每个通道可以配置不同的采样周期，但最小的采样周期是1.5个周期，也就是说如果想最快时间采样就设置采样周期为1.5.\n转换时间 转换时间=采样时间+12.5个周期\n12.5个周期是固定的，一般我们设置 PCLK2=72M，经过 ADC 预分频器能分频到最大的时钟只能是 12M，采样周期设置为 1.5 个周期，算出最短的转换时间为 1.17us。\n数据寄存器 当使用ADC独立模式（也就是只使用一个ADC，可以使用多个通道）时，数据存放在低16位中，当使用ADC多模式时高16位存放ADC2的数据。需要注意的是ADC转换的精度是12位，而寄存器中有16个位来存放数据，所以要规定数据存放是左对齐还是右对齐。\n当使用多个通道转换数据时，会产生多个转换数据，然鹅数据寄存器只有一个，多个数据存放在一个寄存器中会覆盖数据导致ADC转换错误，所以我们经常在一个通道转换完成之后就立刻将数据取出来，方便下一个数据存放。一般开启DMA模式将转换的数据，传输在一个数组中，程序对数组读操作就可以得到转换的结果。\n注入通道转换的数据寄存器有4个，由于注入通道最多有4个，所以注入通道转换的数据都有固定的存放位置，不会跟规则寄存器那样产生数据覆盖的问题。 ADC_JDRx 是 32 位的，低 16 位有效，高 16 位保留，数据同样分为左对齐和右对齐，具体是以哪一种方式存放，由ADC_CR2 的 11 位 ALIGN 设置。\n中断 从框图中可以知道数据转换完成之后可以产生中断，有三种情况：\n规则通道转换完成中断\n规则通道数据转换完成之后，可以产生一个中断，可以在中断函数中读取规则数据寄存器的值。这也是单通道时读取数据的一种方法。\n注入通道转换完成中断\n注入通道数据转换完成之后，可以产生一个中断，并且也可以在中断中读取注入数据寄存器的值，达到读取数据的作用。\n模拟看门狗事件\n当输入的模拟量（电压）不再阈值范围内就会产生看门狗事件，就是用来监视输入的模拟量是否正常。\n以上中断的配置都由ADC_SR寄存器决定：\n电压转换 $$\ry=\\frac{3.3 \\times x}{4096}\r$$ 单次转换和连续转换 一组只转换一个通道\n连续转换，在一轮转换结束后，继续下一轮的转换\n每次转换后都会停下来，但是和非扫描模式不同的是，扫描模式会扫描序列，然后对列表中的序列转换出来\n连续转换，扫描模式\n扫描模式\n不同模式的组合 实验 使用ADC的步骤\n电位器作为ADC输入\n确定ADC挂载在哪个总线上，并开启ADC的时钟 配置与ADC通道相对应的GPIO引脚为模拟输入模式 配置规则组通道，包括通道号、顺序和采样时间 设置ADC的工作模式、数据对齐方式 、外部触发源、通道数量等参数 使能ADC 校准ADC void adc_init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE); RCC_ADCCLKConfig(RCC_PCLK2_Div6); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Pin = ADC_PIN; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(ADC_PORT,\u0026amp;GPIO_InitStruct); ADC_RegularChannelConfig(ADC3,ADC_Channel_4,1,ADC_SampleTime_55Cycles5);\t//配置规则通道组，填充菜单列表 ADC_InitTypeDef ADC_InitStruct; ADC_InitStruct.ADC_ContinuousConvMode = DISABLE; ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;\t//软件触发 ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; ADC_InitStruct.ADC_NbrOfChannel = 1; ADC_InitStruct.ADC_ScanConvMode = DISABLE; ADC_Init(ADC3,\u0026amp;ADC_InitStruct); ADC_Cmd(ADC3,ENABLE); //开始校准 ADC_ResetCalibration(ADC3);\t//复位校准 while(ADC_GetResetCalibrationStatus(ADC3) != RESET);\t//等待复位校准完成 ADC_StartCalibration(ADC3);\t//开始校准 while(ADC_GetCalibrationStatus(ADC3) == SET);//等待校准完成 } u16 ad_getValue(void) { ADC_SoftwareStartConvCmd(ADC3,ENABLE); while(ADC_GetFlagStatus(ADC3,ADC_FLAG_EOC) == RESET);\t//等待转换完成，也就是EOC信号 return ADC_GetConversionValue(ADC3);\t//读取完数据将会自动清除数据位 } int main(void){ char str[50]; serial_init(); adc_init();\twhile(1){ sprintf(str,\u0026#34;read: %u\\n \u0026#34;,ad_getValue()); send_string(str); Delay_ms(1000); } } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/asm/",
    "title": "Asm",
    
    "content": " 参考链接 汇编语言入门教程 - 阮一峰的网络日志\n汇编语言 教程 | 参考手册 (cankaoshouce.com)\nGuide to x86 Assembly\nGCC-Inline-Assembly-HOWTO \u0026amp;mdash; GCC-Inline-Assembly-HOWTO\n译：GCC内联汇编入门 - 简书 (jianshu.com)\nArm A-profile A32/T32 Instruction Set Architecture\n基础知识 引言 我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。\n这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。\n对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。\n汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。\n[!important]\n以下教程开发环境为NAsm，使用Inte格式。\nNASM 更适合跨平台、轻量级的汇编开发，语法简洁，灵活性高。\nMASM 则更适合 Windows 平台上的专业开发，功能丰富，语法较复杂，集成度高，适合开发大规模的 Windows 应用程序和驱动。\n[!TIP]\n汇编语法主要有两大派系：AT\u0026amp;amp;T语法 和 Intel语法。\nGAS (GNU Assembler) 编译器默认是基于AT\u0026amp;amp;T语法；MASM、NASM等编译器默认基于Intel语法。\n需要说明的是，GAS汇编器除了支持AT\u0026amp;amp;T语法之外，自己也定义了一些额外的directives，用于辅助完成汇编操作。关于GAS汇编器及其语法可以参考GAS的官方文档：https://sourceware.org/binutils/docs/as/\n寄存器 CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存 …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/batch/",
    "title": "Batch",
    
    "content": " 批处理基础 注释 REM 或 :: 用于添加注释。注释不会被执行。\nREM 这是一个注释 :: 这也是一个注释 显示文本 echo 显示文本。@echo off 可以关闭回显（即关闭命令本身的显示），但保留输出。\necho Hello, World! @echo off echo 这行代码只显示输出，不显示命令本身 变量 set 用于定义变量，%variable% 用于访问变量值。\nset myVar=Hello echo %myVar% World! set /p 从用户输入中获取变量值。\nset /p userInput=Please enter your name: echo Hello, %userInput%! 条件语句 if 用于执行条件检查，可以用于字符串比较、数值比较和文件存在性检查。\nif \u0026#34;%myVar%\u0026#34;==\u0026#34;Hello\u0026#34; echo It is Hello! if exist \u0026#34;file.txt\u0026#34; echo File exists! /i：忽略大小写。 比较操作符：\n字符串比较：== 数值比较：equ（equal，等于）、neq（not equal，不等于）、lss（less than，小于）、leq（less than or equal to，小于等于）、gtr（greater than，大于）、geq（greater than or equal to)，大于等于 set /a num1=5 set /a num2=10 if %num1% leq %num2% echo num1 is less than or equal to num2 [!TIP]\n当一个判断（循环或其他）语句之后的操作有多行时，可以用圆括号括起来表示一个作用域\n循环 for 用于创建循环，用于遍历文件、字符串、命令输出等。%%表示的是脚本内部的变量\nfor %%i in (1 2 3) do echo Loop number %%i /L 参数用于创建计数循环。从start开始，一次增加step，到end结束\nfor /L %%variable in (start,step,end) do command for /L %%i in (1,1,5) do echo %%i 遍历目录中的文件名：\n::打印文件名 for %%f in (*.txt) do echo Found file: %%f ::打印文件完整路径 for %%f in (*.txt) do echo Found file: %%~f %%~ 修饰符 在 for 循环中，%%~ 后面的字符可以用来获取文件的不同信息： 假设现在循环的内部变量是f %%~f: 获取文件的完整路径。 %%~dpf: 获取文件的驱动器和路径。 %%~nxf: 获取文件的名称和扩展名。 %%~dpnxf: 获取文件的完整路径、名称和扩展名。 遍历命令输出：\n:: for /f [\u0026#34;options\u0026#34;] %%variable in (file) do command for /f [\u0026#34;options\u0026#34;] %%variable in (\u0026#39;command\u0026#39;) do command for /f \u0026#34;tokens=*\u0026#34; %%i in (\u0026#39;dir /b *.txt\u0026#39;) do echo %%i 跳转与标签 goto 和 : 用于跳转到脚本中的指定位置。\ngoto myLabel echo This won\u0026#39;t be displayed. :myLabel echo Jumped to myLabel 调用其他脚本 call 用于从一个批处理文件中调用另一个批处理文件或子例程。\ncall otherScript.bat 暂停执行 pause 用于暂停脚本执行，并提示用户按任意键继续。\npause 退出脚本 exit 用于退出批处理文件，并返回到命令提示符。\nexit 常用命令 文件操作 type：创建文件。\ntype non \u0026gt; file.txt copy: 复制文件。\ncopy source_file destination_path /v：验证文件是否正确写入。\n/y：覆盖现有目标文件时不提示。\n/a：将文件标记为 ASCII 文本模式。\n/b：将文件标记为二进制模式。\ndel: 删除文件。\ndel file_path /f：强制删除只读文件。\n/q：安静模式，删除时不提示确认。\n/s：删除指定目录及所有子目录中的文件。\nmove: 移动（重命）文件。\nmove source_file destination_path xcopy: 复制文件和目录，包括子目录。\nxcopy source_path destination_path /e /i /i: 如果目标不存在，假设目标是一个目录。 /s：复制所有非空子目录。 /e：复制所有子目录，包括空的子目录。 /v：验证文件是否正确写入目标位置。 /y：覆盖现有目标文件时不提示。 目录操作 dir:显示目录内容\ndir /p：分页显示结果。 /w：以宽列表格式显示结果。 /s：递归显示目录及其所有子目录中的文件。 /b：使用简洁格式显示结果，仅显示文件和目录名。 /o：按指定顺序排序显示文件和目录。 N：按名称排序。 S：按大小排序。 E：按扩展名排序。 D：按日期/时间排序。 G：首先列出目录，然后是文件。 -：逆序排序。 /q：显示文件的所有者。 /a：显示具有特定属性的文件。 R：只读文件。 H：隐藏文件。 S：系统文件。 D：目录。 A：准备归档的文件。 L：符号链接。 /c：显示文件大小时包含千位分隔符（默认行为）。 /n：以默认格式显示文件名（与 /o 结合使用）。 /x：显示 8.3 短文件名。 /t：指定用于排序或显示的时间字段。 C：创建时间。 A：上次访问时间。 W：上次写入时间。 mkdir: 创建目录。\nmkdir directory_name rmdir: 删除目录。\nrmdir directory_name /S /Q /S: 删除目录及其所有子目录和文件。 /Q: 安静模式，不提示确认。 cd: 更改当前目录。\ncd directory_path cd .. 返回上一级目录。 获取文件路径\n%~f1：获取文件的完整路径。\n%~d1：获取文件的驱动器号。\n%~p1：获取文件的路径（不包括文件名）。\n%~n1：获取文件名（不包括扩展名）。\n%~x1：获取文件扩展名。\nset filepath=%~f1 echo File path: %filepath% 流程控制 if: 条件判断。\nif condition (command1) else (command2) Example: if exist file.txt ( echo File exists. ) else ( echo File does not exist. ) for: 循环执行命令。\nfor %%variable in (set) do command Example: for %%f in (*.txt) do ( echo %%f ) goto: 跳转到指定标签。\ngoto label_name Example: goto end :end echo Script finished. call: 调用另一个批处理文件或标签。\ncall script.bat exit: 退出批处理脚本。\nexit exit /b: 退出子批处理文件并返回父脚本。 输入/输出 echo: 输出文本。\necho Hello, World! echo. 输出空行。 pause: 暂停执行并等待用户按键。\npause set /p: 获取用户输入并赋值给变量。\nset /p variable_name=Enter value: 字符串处理 获取子字符串： :~ 用于从变量中提取子字符串。\nset string=HelloWorld echo %string:~0,5% REM 输出 \u0026#34;Hello\u0026#34; 字符串替换： :\u0026lt;old\u0026gt;=\u0026lt;new\u0026gt; 用于替换字符串中的子串。\nset string=HelloWorld echo %string:World=Universe% REM 输出 \u0026#34;HelloUniverse\u0026#34; 处理错误 检查错误代码： 通过 if errorlevel 检查上一个命令的退出代码。\nsome_command if errorlevel 1 echo Error occurred 设置退出代码： 使用 exit /b 设置批处理脚本的退出代码。\nexit /b 0 特殊符号 %：用于引用变量（如 %variable%）。\n\u0026amp;：用于将多条命令放在同一行上执行。\necho First command \u0026amp; echo Second command |：管道符号，用于将前一命令的输出作为下一命令的输入。\ndir /b | find \u0026#34;keyword\u0026#34; \u0026gt; 和 \u0026gt;\u0026gt;：重定向符号，用于将输出写入文件（覆盖或追加）。\necho Hello \u0026gt; output.txt ::覆盖 echo World \u0026gt;\u0026gt; output.txt ::追加 \u0026lt;：输入重定向，用于将文件内容作为命令的输入。\nfindstr \u0026#34;keyword\u0026#34; \u0026lt; input.txt ^：转义符号，用于转义特殊字符。\necho This is a caret ^ symbol \u0026amp;\u0026amp; 和 ||：条件执行符号，分别表示“如果成功则执行”和“如果失败则执行”。\nsome_command \u0026amp;\u0026amp; echo Success || echo Failure 综合示例 以下是一个更复杂的 Batch 脚本示例，它演示了各种操作：\n@echo off setlocal REM 获取当前日期和时间 set currentDate=%date% set currentTime=%time:~0,8% echo Starting backup process at %currentDate% %currentTime% REM 创建备份目录 set backupDir=C:\\Backup\\%date:~-4,4%-%date:~-10,2%-%date:~-7,2% if not exist \u0026#34;%backupDir%\u0026#34; mkdir \u0026#34;%backupDir%\u0026#34; REM 复制重要文件 xcopy C:\\ImportantFiles\\* \u0026#34;%backupDir%\u0026#34; /s /e /y if errorlevel 1 ( echo Failed to copy files. Exiting. exit /b 1 ) REM 删除旧备份（超过7天） forfiles /p \u0026#34;C:\\Backup\u0026#34; /d -7 /c \u0026#34;cmd /c rmdir /s /q @path\u0026#34; REM 结束备份 echo Backup completed successfully. pause ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/bluetooth/",
    "title": "Bluetooth",
    
    "content": " 参考链接 深入浅出低功耗蓝牙(BLE)协议栈及蓝牙连接过程_蓝牙芯片的寄存器组为什么需要分为两块-CSDN博客\n蓝牙核心技术概述（一）:蓝牙概述_蓝牙技术-CSDN博客\n蓝牙核心技术概述（三）： 蓝牙协议规范（射频、基带链路控制、链路管理）_蓝牙3.0技术规范-CSDN博客\n蓝牙核心技术概述（四）：蓝牙协议规范（HCI、L2CAP、SDP、RFOCMM）_蓝牙通信帧分类-CSDN博客\n蓝牙核心技术概述（五）：蓝牙协议规范（irOBEX、BNEP、AVDTP、AVCTP）_蓝牙核心bnep-CSDN博客\nBLE协议学习 – 学习笔记 (giraffexiu.love)\nESP32教程第二章讲义 - 哔哩哔哩 (bilibili.com)\nBluetooth.org - Generic Access Profile (nop.hu)\nCore Specification | Bluetooth® Technology Website\nAssigned Numbers | Bluetooth® Technology Website\n低功耗蓝牙BLE之连接建立_低功耗蓝牙的连接过程-CSDN博客\n低功耗蓝牙BLE之连接事件、连接参数和更新方法_蓝牙设备为什么拼命发包-CSDN博客\n蓝牙配对安全机制解析：防止中间人与被动监听攻击-CSDN博客\n深入理解低功耗蓝牙的配对过程- Part 1 Pairing Feature Exchange - SZ_LM - 博客园\n深入理解低功耗蓝牙的配对过程- Part 2 Key Generation Methods - SZ_LM - 博客园\n低功耗蓝牙配对绑定解读和实践 - iini - 博客园\n蓝牙安全管理(SM:Security Manager)规范详解_蓝牙csrk-CSDN博客\n蓝牙 - 什么是Man-in-the-middle protection_蓝牙中间人攻击-CSDN博客\n了解低功耗蓝牙中的安全密钥_irk ltk-CSDN博客\n传输原理 蓝牙的传输频率是2.4GHZ，也就是说一秒钟之内蓝牙信号可以改变24亿次。\n蓝牙的通信模式有两种：\n经典蓝牙：一帧数据包有357个字节\n前9字节是访问地址用于区分不同的蓝牙设备\n标头是确保数据的可靠性和稳定性\n可以承载0-399字节的数据位，不同的报文会承载不同长度的数据\n最后两字 …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/bootloader/",
    "title": "BootLoader",
    
    "content": " 参考链接 基于UDS的BootLoader设计——架构设计及规范_nxp s32k144 bootloader 基于uds-CSDN博客\nBootloader升级方式一————擦、写flash在RAM中运行 - isAndyWu - 博客园 (cnblogs.com)\n基础介绍 BootLoader的作用 Boot Loader又称为引导加载程序，引导加载程序是系统上电后运行的第一段软件代码，常被用来加载系统或者更新系统等。因此，大部分的Boot Loader存在两种不同的操作模式：\n==启动模式==：启动加载（BootLoading）模式也称为自主模（Autonmous）式，即BootLoader从目标机上某个固态存储设备上将操作系统加载至RAM中运行，整个过程中并没有用户的介入。 ==下载模式==：在下载（DownLoading）模式下，目标机上的Boot Loader将通过串口连接或者网络连接等通信手段下载文件，如下载内核映像和根文件系统映像等。通常文件会保存在RAM中，然后将其写入目标地址完后系统的更新等。 ==Bootloader=Boot + loader==\nBoot的目的： 最终目的：跳到C语言中；为了C语言运行程序会进行一系列的初始化，系统一上电后如何通过一系列的设置让软件程序员进入C语言/更高级语言环境的开发，这个过程就是boot的主要目的。\nLoader的目的： 主要目的是开始执行应用逻辑，比如点灯：需要灯的接口开发；串口输入输出：需要串口编程；加载linux的内核：flash的编程、网卡的编程、内核启动前的初始化部分。根据不同的应用会有不同的变化。\n==一个开发板要想执行loader，要先看boot做了什么事。==\nBootLoader的基本需求 两个SWC（Software Component）：\n启动管理——控制器的启动管理等 应用程序——ECU软件下载升级及标定数据再编程等 四个服务模块：\n内存管理——软件更新主要是将Flash中的Application及标定数据重编程，内存擦除与重写驱动必不可少的模块； CAN协议栈——软件更新媒介 看门狗模块——软件运行保护 安全模块——软件数据保护，下载数据校验等 BOOT设计流程 流程：\n关闭看门狗、中断、MMU、CACHE，通过汇编语言对相应的寄存器进行置位即可实现。 配置系统工作时钟，通过 …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/",
    "title": "C",
    
    "content": " 宏 宏 [!important]\n宏是一个纯粹的文本替换\n#define 宏名 宏体 当宏体包含运算符时，需要增加括号来==限制==宏体和外部的计算优先级\n#define 宏名 (带有运算的的宏体) 条件编译 条件编译语句：编译中的分支语句\n#ifdef your_macro\t//条件编译语句 #else\t//条件编译语句 #endif\t//条件编译语句 #if your_macro == constant\t//条件编译语句 #endif\t//条件编译语句 提示编译语句\n#ifdef your_macro\t#else #error \u0026amp;#34;error information durnning in the compile\u0026amp;#34;\t//在编译过程中会显示的错误信息 #warning \u0026amp;#34;warning information durnning in the compile\u0026amp;#34;\t//在编译过程中会显示的警告信息 #endif 宏函数 [!important]\n宏函数可以减少内存开销\n简单使用\n#define FUNC(a,b) a*b //上面说了，带有运算的宏体需要添加括号，所以想要实现功能需要修改为如下代码 #define FUNC(a,b) ((a)*(b)) 使用\\可以实现宏函数的多行显示\n#define FUNC(a,b) ((a) = (a) * (b)); \\(a++) [!note]\n在多行显示的代码中，可以看到(a++)后没有==冒号==\n实际上由于宏是纯粹的文本替代，所以在调用FUNC函数时会加上冒号，所以在宏体中不需要加冒号\n宏函数与分支语句的联动，如果不适用花括号来控制分支语句的作用域，可能会出现不符合预期的结果\nif(0) FUNC(a,b); //此时可以通过在if语句中加花括号，亦可以在宏体中使用花括号 #define FUNC(a,b) {((a) = (a) * (b)); \\(a++)；} //此时只能使用一条if语句，而不能使用else语句，否则会报错，因为我们在宏体中加了分号，展开为 if(0) { ((a) = (a) * (b)); (a++)； }; //如果此时增加else语句 if(0) FUNC(a,b); else FUNC(a,b); //那么展开为 if(0) { ((a) = (a) * …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c++/",
    "title": "C++",
    
    "content": " 数据类型 vector 增加数据 在C++中，可以使用std::vector来动态管理数据。要向std::vector中增加数据，有几种常用的方法：\n使用push_back方法：向vector的末尾添加一个元素。\nmyVector.push_back(10); 使用emplace_back方法：在vector的末尾原地构造一个元素。这通常比push_back更高效，尤其是在处理复杂对象时。\nmyVector.emplace_back(30); 使用insert方法：在vector的指定位置插入一个或多个元素。\nmyVector.insert(myVector.begin() + 1, 40); 使用resize方法：调整vector的大小，并对新增加的元素进行初始化。\n// 将vector大小调整为5，并用0初始化新增的元素 myVector.resize(5, 0); 使用assign方法：给vector分配新的内容，替换其当前内容。\nmyVector.assign({1, 2, 3, 4, 5}); hash map 引入头文件 首先需要包含 unordered_map 头文件：\n#include \u0026lt;unordered_map\u0026gt; 基本用法 定义一个 unordered_map：\nstd::unordered_map\u0026lt;int, std::string\u0026gt; myMap; 这里定义了一个 unordered_map，键是 int 类型，值是 std::string 类型。\n插入元素：\n可以通过 [] 运算符或 insert 函数来插入元素。\nmyMap[1] = \u0026#34;Hello\u0026#34;; myMap[2] = \u0026#34;World\u0026#34;; // 使用 insert 函数 myMap.insert({3, \u0026#34;C++\u0026#34;}); 访问元素：\n可以使用键访问元素，如果键不存在则会插入一个默认值。\nstd::string value = myMap[1]; // \u0026#34;Hello\u0026#34; 如果不确定键是否存在，可以使用 at 方法，这样在键不存在时会抛出 std::out_of_range 异常。\ntry { std::string value = myMap.at(4); // 会抛出异常 } catch (const std::out_of_range\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Key not found\u0026#34; \u0026lt;\u0026lt; std::endl; } 查找元素：\n可以使用 find 函数来查找元素，返回一个迭代器。\nauto it = myMap.find(2); if (it != myMap.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; // 输出 \u0026#34;Found: World\u0026#34; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\u0026#34; \u0026lt;\u0026lt; std::endl; } 遍历 unordered_map：\n可以使用范围 for 循环或迭代器来遍历所有键值对。\nfor (const auto\u0026amp; pair : myMap) { std::cout \u0026lt;\u0026lt; pair.first \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; pair.second \u0026lt;\u0026lt; std::endl; } 删除元素：\n可以使用 erase 方法删除某个键值对。\nmyMap.erase(1); // 删除键为 1 的元素 获取大小和检查是否为空：\nstd::cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; myMap.size() \u0026lt;\u0026lt; std::endl; if (myMap.empty()) { std::cout \u0026lt;\u0026lt; \u0026#34;Map is empty\u0026#34; \u0026lt;\u0026lt; std::endl; } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/can/",
    "title": "CAN",
    
    "content": " CAN简介 CAN总线（Controller Area Network Bus）控制器局域网总线\nCAN总线是由BOSCH公司开发的一种简洁易用、传输速度快、易扩展、可靠性高的串行通信总线，广泛应用于汽车、嵌入式、工业控制等领域\nCAN总线特征：\n两根通信线（CAN_H、CAN_L），线路少，无需共地\n差分信号通信，抗干扰能力强\n高速CAN（ISO11898）：125k~1Mbps, \u0026lt;40m\n低速CAN（ISO11519）：10k~125kbps, \u0026lt;1km\n异步，无需时钟线，通信速率由设备各自约定\n半双工，可挂载多设备，多设备同时发送数据时通过仲裁判断先后顺序\n11位/29位报文ID，用于区分消息功能，同时决定优先级\n可配置1~8字节的有效载荷\n可实现广播式和请求式两种传输方式\n应答、CRC校验、位填充、位同步、错误处理等特性\n主流通信协议对比 名称 引脚 双工 时钟 电平 设备 应用场景 UART TX、RX 全双工 异步 单端 点对点 两个设备互相通信 I2C SCL、SDA 半双工 同步 单端 多设备 一个主控外挂多个模块 SPI SCK、MOSI、MISO、SS 全双工 同步 单端 多设备 一个主控外挂多个模块（高速） CAN CAN_H、CAN_L 半双工 异步 差分 多设备 多个主控互相通信 CAN硬件电路 每个设备通过CAN收发器挂载在CAN总线网络上\nCAN控制器引出的TX和RX与CAN收发器相连，CAN收发器引出的CAN_H和CAN_L分别与总线的CAN_H和CAN_L相连\n高速CAN使用闭环网络，CAN_H和CAN_L两端添加120Ω的终端电阻，增加电阻的作用有两个，一是防止回波反射，二是在没有设备进行操作的时候，将两根差分线的电压收紧，使其电压一致\n低速CAN使用开环网络，CAN_H和CAN_L其中一端添加2.2kΩ的终端电阻\nCAN的电平标准 CAN总线采用差分信号，即两线电压差（VCAN_H-VCAN_L）传输数据位 高速CAN规定： ​\t电压差为0V时表示逻辑1（隐性电平，总线收紧状态）\n​\t电压差为2V时表示逻辑0（显性电平，总线张开状态）\n低速CAN规定：（电压有压降，所以拉大了两个信号线的电压差） ​\t电压差为-1.5V时表示逻辑1（隐性电平）\n​\t电压差为3V时表示逻辑0（显性电平）\n高速CAN，总线回归隐性电平快，传输速度就会快，低速CAN总线回归隐性电平慢，传输速度就会慢。\nCAN收发器（TJA1050，高速CAN） 接收端\n如果CANH和CANL之间有电压差，则Receiver就输出1，否则就输出0\n当Receiver输出为1时，上管断开，下管导通，输出0。输出为0时，上管导通，下管断开，输出1。RXD为输入部分\n发送端通过两个三级管来控制输出的电压差，当TXD为0时，上面的三极管将CANH线的电平拉高，下面的三极管将CANL线的电平拉低，出现电压差，显示为0\n其中的两个电阻为中拉电阻，通过两个电阻，可以将CANH和CANL两根线都拉到0.5倍VCC的中间电平，使CANH和CANL的默认对地电压都是2.5v左右，同时，这两个电阻还有一定的收紧作用，但是由于阻值较大，所以收紧电压一般都使用外部的电阻来实现 。\nCAN物理层 CAN总线帧格式 CAN协议规定了以下5种类型的帧：\n帧类型 用途 数据帧 发送设备主动发送数据（广播式） 遥控帧 接收设备主动请求数据（请求式） 错误帧 某个设备检测出错误时向其他设备通知错误 过载帧 接收设备通知其尚未做好接收准备 帧间隔 用于将数据帧及遥控帧与前面的帧分离开 数据帧 灰色方块表示只能发送0，白的方块表示只能发送1，紫色的方块表示既能发送0也能发送1。其中的数字为位数。\n标准格式 ​\t在发送数据之前，总线必须要为空闲状态，空闲状态时，总线是隐性电平（1），当开始发送数据帧时，首位必须要为显性电平0（SOF）。随后是报文ID，一般为11位。之后发送RTR，RTR必须要为0，用于区分数据帧（0）还是遥控帧（1）。后面按照图片进行控制。\n数据帧的各部分用途简介 SOF（Start of Frame）：帧起始，表示后面一段波形为传输的数据位 ID（Identify）：标识符，区分功能，同时决定优先级 RTR（Remote Transmission Request ）：远程请求位，区分数据帧和遥控帧 IDE（Identifier Extension）：扩展标志位，区分标准格式和扩展格式，标准格式为0，扩展格式为1 SRR（Substitute Remote Request）：替代RTR，协议升级时留下的无意义位 r0/r1（Reserve）：保留位，为后续协议升级留下空间 DLC（Data Length Code）：数据长度，指示数据段有几个字节 Data：数据段的1~8个字节有效数据 CRC（Cyclic Redundancy Check）：循环冗余校验，校验数据是否正确 ACK（Acknowledgement）：应答位，判断数据有没有被接收方接收 CRC/ACK界定符：为应答位前后发送方和接收方释放总线留下时间 EOF（End of Frame ）：帧结束，表示数据位已经传输完毕 遥控帧 遥控帧无数据段，RTR为隐性电平1，其他部分与数据帧相同\nCAN总线的数据主要靠发送方自觉广播出来的，一般发送方会定一个周期，定时广播自己的数据，但如果发送方没有及时发送自己的数据，或者这个数据的使用频率太低了，广播太频繁了，用不到就会浪费总线资源，广播太慢了，偶尔有用的话，有不能及时拿到。此时就可以规定，发送方不要主动广播数据，而是设备有需要的话，首先接收方发出一个遥控帧，遥控帧包含报文ID，遥控帧也是通过广播出来的，每个设备都能收到遥控帧，如果其中某个设备有这个ID的数据，就会通过数据帧广播出来，这样接收方就可以及时获取这个数据了\n错误帧 总线上所有设备都会监督总线的数据，一旦发现“位错误”或“填充错误”或“CRC错误”或“格式错误”或“应答错误” ，这些设备便会发出错误帧来破坏数据，同时终止当前的发送设备\n发现数据帧数据有错，所以破坏了该数据帧，是一种错误处理机制\n主动错误 发了6个0表示主动错误，中间有0到6位的延长时间，是错误标志的重叠部分。之后发送错误界定符，也就是8个1 被动错误 发了6个1表示被动错误，之后发送错误界定符，也就是8个1 过载帧 当接收方收到大量数据而无法处理时，其可以发出过载帧，延缓发送方的数据发送，以平衡总线负载，避免数据丢失\n发送方发送数据太快，接受方处理不了，由接收方产生\n帧间隔 将数据帧和遥控帧与前面的帧分离开\n位填充 位填充规则：发送方每发送5个相同电平后，自动追加一个相反电平的填充位，接收方检测到填充位时，会自动移除填充位，恢复原始数据\n例如：\n​ 即将发送： 100000110 10000011110 0111111111110\n​ 实际发送： 1000001110 1000001111100 011111011111010\n​ 实际接收： 1000001110 1000001111100 011111011111010\n​ 移除填充后： 100000110 10000011110 0111111111110\n位填充作用：\n增加波形的定时信息，利于接收方执行“再同步”，防止波形长时间无变化，导致接收方不能精确掌握数据采样时机 将正常数据流与“错误帧”和“过载帧”区分开，标志“错误帧”和“过载帧”的特异性 保持CAN总线在发送正常数据流时的活跃状态，防止被误认为总线空闲 接收方数据采样 CAN总线没有时钟线，总线上的所有设备通过约定波特率的方式确定每一个数据位的时长 发送方以约定的位时长每隔固定时间输出一个数据位 接收方以约定的位时长每隔固定时间采样总线的电平，输入一个数据位 理想状态下，接收方能依次采样到发送方发出的每个数据位，且采样点位于数据位中心附近 接收方数据采样遇到的问题 采样指的是对于数据的读取，使用固定时间间隔对数据进行采样。\n接收方以约定的位时长进行采样，但是采样点没有对齐数据位中心附近，假设每次采样的时候都会采到数据的跳变，这时就不知道采样采的是0还是1了 接收方刚开始采样正确，但是时钟有误差，随着误差积累，采样点逐渐偏离 位时序 为了灵活调整每个采样点的位置，使采样点对齐数据位中心附近，CAN总线对每一个数据位的时长进行了更细的划分，分为同步段（SS）、传播时间段（PTS）、相位缓冲段1（PBS1）和相位缓冲段2（PBS2），每个段又由若干个最小时间单位（Tq，Time Quantum）构成\n其中，Tq的时间是自己指定的，如可以指定1Tq=0.5us\nSS段为同步段，如果数据跳变沿正好出现在SS段，则说明当前设备与波形达成同步，如果当前跳变沿不在SS段，则需要调整当前设备的位时序，使跳变沿正好出现在同步段，也就是采用硬同步和再同步手段，使得跳变沿再次出现在SS段 PTS段为传播时间段，PTS用于吸收网络上的物理延迟，网络的物理延迟指定发送单元的输出延迟，总线上信号的传播延迟、接收单元的输入延迟。PTS的时间为以上各延迟时间的和的两倍。控制器想发信号，由于硬件电路的限制，这个信号输出到总线，总会有延迟，所以设计该段。也就是说当开始发送数据时，SS结束后要稍微等一等，等待传播的延迟。 PBS1和PBS2为相位缓冲段，其作用为确定采样点的位置，采样点会在PBS1和PBS2中间，所以调节PBS1和PBS2的时间长短就可以条件采样位置 硬同步 每个设备都有一个位时序计时周期，当某个设备（发送方）率先发送报文，其他所有设备（接收方）收到SOF的下降沿时，接收方会将自己的位时序计时周期拨到SS段的位置，与发送方的位时序计时周期保持同步 硬同步只在帧的第一个下降沿（SOF下降沿）有效 经过硬同步后，若发送方和接收方的时钟没有误差，则后续所有数据位的采样点必然都会对齐数据位中心附近 再同步 若发送方或接收方的时钟有误差，随着误差积累，数据位边沿逐渐偏离SS段，则此时接收方根据再同步补偿宽度值（SJW）通过加长PBS1段，或缩短PBS2段，以调整同步 再同步可以发生在第一个下降沿之后的每个数据位跳变边沿 上图是发送方信号沿快于SS，图中的红色部分就是SJW，下图是发送方信号沿慢于SS\n硬同步用于一帧波形初始的位置对齐，所以硬同步更加激进一些，直接在波形边沿，把自己的秒表拨到SS段，一旦一帧波形开始，就不能再这么激进的调整同步了。所以再同步的补偿需要限定范围，一次只补偿一点，不能再多了\n波特率计算 $$ 波特率 = \\frac {1} {一个数据位的时长} = \\frac {1} {TSS + TPTS + TPBS1 + TPBS2} $$例如： $$ SS = 1Tq，PTS = 3Tq，PBS1 = 3Tq，PBS2 = 3Tq \\\nTq = 0.5us\\\n波特率 = \\frac{1} {0.5us + 1.5us + 1.5us + 1.5us}=0.2 \\times 10^6 bps= 200kbps $$\n总线的资源分配规则 多设备同时发送所遇到的问题 CAN总线只有一对差分信号线，同一时间只能有一个设备操作总线发送数据，若多个设备同时有发送需求，该如何分配总线资源？ 解决问题的思路：制定资源分配规则，依次满足多个设备的发送需求，确保同一时间只有一个设备操作总线 现假设两个设备想要同时发送数据，有以下两种情况：\n一个波形正在发送，另外一个想要发送 多个波形在同一起始段都想要发送数据 问题1解决方案-先占先得 若当前已经有设备正在操作总线发送数据帧/遥控帧，则其他任何设备不能再同时发送数据帧/遥控帧（可以发送错误帧/过载帧破坏当前数据） 任何设备检测到连续11个隐性电平，即认为总线空闲，只有在总线空闲时，设备才能发送数据帧/遥控帧 一旦有设备正在发送数据帧/遥控帧，总线就会变为活跃状态，必然不会出现连续11个隐性电平，其他设备自然也不会破坏当前发送 若总线活跃状态其他设备有发送需求，则需要等待总线变为空闲，才能执行发送需求 问题2解决方案-非破坏性仲裁 若多个设备的发送需求同时到来或因等待而同时到来，则CAN总线协议会根据ID号（仲裁段）进行非破坏性仲裁，ID号小的（优先级高）取到总线控制权，ID号大的（优先级低）仲裁失利后将转入接收状态，等待下一次总线空闲时再尝试发送 实现非破坏性仲裁需要两个要求： 线与特性：总线上任何一个设备发送显性电平0时，总线就会呈现显性电平0状态，只有当所有设备都发送隐性电平1时，总线才呈现隐性电平1状态，即：0 \u0026amp; X \u0026amp; X = 0，1 \u0026amp; 1 \u0026amp; 1 = 1 回读机制：每个设备发出一个数据位后，都会读回总线当前的电平状态，以确认自己发出的电平是否被真实的发送出去了，根据线与特性，发出0读回必然是0，发出1读回不一定是1 非破坏性仲裁过程 数据位从前到后依次比较，出现差异且数据位为1的设备仲裁失利\n单元1和单元2代表的是两个设备，根据线与特性，总线显示为空闲状态，所以此时单元1和单元2同时向总线发送请求，也就是同时发送SOF（0），两个单元同时回读，此时总线电平呈现0状态，单元1和单元2会继续同时向总线发送且回读，如果发送的和回读的不一样，代表仲裁失利，从下一位开始转为接收状态工作。\n数据帧和遥控帧的优先级 数据帧和遥控帧ID号一样时，数据帧的优先级高于遥控帧\n标准格式和扩展格式的优先级 标准格式的优先级高于扩展格式（SRR必须始终为1，以保证此要求）\n错误处理 错误类型 错误共有5种： 位错误、填充错误、CRC错误、格式错误、应答错误\n错误状态 每个设备内部管理一个TEC和REC，根据TEC和REC的值确定自己的状态 主动错误状态的设备正常参与通信并在检测到错误时发出主动错误标志 被动错误状态的设备正常参与通信但检测到错误时只能发出被动错误标志 总线关闭状态的设备不能参与通信 错误计数器 对于接收的错误较为宽容\nCAN外设 简介 STM32内置bxCAN外设（CAN控制器），支持CAN2.0A和2.0B，可以自动发送CAN报文和按照过滤器自动接收指定CAN报文，程序只需处理报文数据而无需关注总线的电平细节 波特率最高可达1兆位/秒 3个可配置优先级的发送邮箱 2个3级深度的接收FIFO 14个过滤器组（互联型28个）：用于过滤总线上不需要的报文（通过id） 时间触发通信、自动离线恢复、 自动唤醒、禁止自动重传、 接收FIFO溢出处理方式可配置、 发送优先级可配置、双CAN模式 STM32F103C8T6 CAN资源：CAN1 网络拓扑结构 CAN的控制器在MCU中，而收发器在外部属于外设，CAN控制器将会引出两个引脚，CAN的发送和CAN的接收，CAN的收发器将会将收到的Rx或Tx的数据转换成差分数据，也就是这里的CAN High和CAN Low\nCAN收发器原理图：\n对MCU端的接口为TX、RX、VCC和GND，对外接口为CANH和CANL\n内部设计 CAN2辅助CAN1工作，共同管理同一个CAN总线\n主发送邮箱：每个邮箱存一个CAN报文，如果想要发出一个CAN报文，那就需要将这个报文写入道其中的一个空置邮箱中，之后设置寄存器请求发送就行了，其余的如位同步、仲裁等等都靠硬件电路自动实现就好\n接受滤波器：当接收到一个报文时，首先需要经过接收过滤器，无论收到遥控帧还是远程帧，CAN硬件电路都会将该帧报文缓存下来，之后再传输进入过滤器。过滤器内可以设置过滤规则，告诉硬件想要指定的ID的报文\n主接收FIFO：当一个报文通过过滤器时，就可以进入主接受FIFO（由邮箱组成）\nMCU对外提供CAN_TX和CAN_RX，而引脚内部就需要配置相关的GPIO：\nCAN_TX是输出，引脚控制权在CAN外设，所以需要将引脚配置为复用推挽输出模式\nCAN_RX是输入，可以配置为上拉输入\n从GPIO进入之后，将会由发送和接收控制器全权控制\n当我们想要发送数据时，只需要将需要发送的数据写入发送邮箱中，发送和接收控制器会自动帮我们发送报文。并且发送时，可以配置发送模式，比如按照发送ID的优先级发送或者按照FIFO模式发送 当我们想要接收数据时，发送和接收控制器会匹配过滤器，如果符合要求将会自动存入邮箱中，不需要人为的干涉 基本过程 发送过程 邮箱有以下描述：\nRQCP：请求完成 TXOK：发送成功 TME：发送邮箱空 TXRQ：发送请求控制位 ABRQ：中止发送 NART：自动重传 发送流程详述：\n空置状态下，等待被填充数据，当有一个发送请求时，将会转到挂号状态 挂号状态表示此邮箱的数据已准备好了，但是邮箱有三个，可能别的邮箱也有数据已经准备好了，所以该邮箱需要排队，如果邮箱已经时最高优先级了，那么就表明下一次发送就轮到该邮箱了，邮箱立马进入预定状态 在预定状态下，等待总线为空闲，如果为空闲，就正式进入发送状态 在正式发送状态时，成功则转到空置且发送成功状态，如果使用自动重传（NART=0）则返回预定状态，否则返回空置且发送未完成状态。 接收过程 状态有以下描述：\nFMP：报文数量 FOVR：FIFO溢出 FULL：FIFO存满 RFOM：释放FIFO 接收到一个报文→匹配过滤器后进入FIFO 0或FIFO 1→CPU读取\n在初始状态下，当收到有效报文时，进入挂号1状态，报文数量为1（0x01） 当进入挂号1状态时，收到有效报文，进入状态2，此时报文数量为2（0x02，==下图写错了==） 当进入挂号状态2时，收到有效报文，进入状态3，此时报文数量为3（0x03） 当进入挂号状态3时，收到有效报文，进入溢出状态，此时FIFO溢出标志位设为1 当读取数据时，就会释放邮箱，一级一级回到挂号及空状态 [!NOTE]\n发送和接收配置位：\nNART：置1，关闭自动重传，CAN报文只被发送1次，不管发送的结果如何（成功、出错或仲裁丢失）；置0，自动重传，CAN硬件在发送报文失败时会一直自动重传直到发送成功 TXFP：置1，优先级由发送请求的顺序来决定，先请求的先发送；置0，优先级由报文标识符来决定，标识符值小的先发送（标识符值相等时，邮箱号小的报文先发送） RFLM：置1，接收FIFO锁定，FIFO溢出时，新收到的报文会被丢弃；置0，禁用FIFO锁定，FIFO溢出时，FIFO中最后收到的报文被新报文覆盖 过滤器 标识符过滤器：\n==每个==过滤器的核心由两个32位寄存器组成：R1[31:0]和R2[31:0]\nFSCx：位宽设置，置0，16位；置1，32位\nFBMx：模式设置，置0，屏蔽模式；置1，列表模式\nFFAx：关联设置，置0，FIFO 0；置1，FIFO 1\nFACTx：激活设置， 置0，禁用；置1，启用\n其中x可以为0-13\n过滤的配置有：\n让指定ID通过（标识符列表） 让指定组ID（组ID有着相同的数据段）通过（标识符屏蔽） 根据FSC和FBM两位的配置，过滤器可以工作在4中状态下：\n如果FSC=1，FBM=0，那么就工作在图中的第一行的状态下\n如果FSC=1，FBM=1，那么就工作在图中的第二行的状态下\n如果FSC=0，FBM=0，那么就工作在图中的第三行的状态下\n如果FSC=0，FBM=1，那么就工作在图中的第四行的状态下\n标识符列表模式：\n对于2个32位过滤器而言，用户可以写入两个目标ID，R1和R2中都包含数据\n当收到一个报文时，就和R1和R2中的ID做比对，如果相同就通过过滤器，否则则舍弃\n在存储映像中，32位寄存器的高11位存标准格式的ID号，后面的18位存的是拓展格式的ID号\n如果想要区分拓展ID还是标准ID就需要看后面的IDE的数据位（置1为拓展ID，置0为标准ID）\n如果想要区分遥控帧，就需要控制RTR位，RTR为是遥控帧标识位，写0就过滤数据帧，写1就过滤遥控帧\n而对于4个16位过滤器而言，只过滤标准格式的ID就可以使用FSC=0，此时的长度为16位，那么一个过滤器就可以写入4个目标ID\n标识符屏蔽模式\n对于1个32过滤器而言，用户可以设置需要屏蔽的ID（R1）和相应的掩码（R2）\n假设现在需求是过滤出以0x01开头的所有标准ID号\n那么ID号应该为001 xxxxxxx\n在R1中就可以填001 00000（当然，后面是任意填的，不是0填充也行）\n在掩码中，位为1表示必须匹配，位为0表示不需要匹配\n那么为了解决需求，则需要给R2设置为111 00000000（高三位为1表示必须匹配，低位为0表示可以为任意数）\n过滤器示例：\n总线上存在的ID 想要接收的ID 过滤器模式 R1[31:0]配置值 R2[31:0]配置值 0x123, 0x234, 0x345, 0x456, 0x567, 0x678 0x234, 0x345, 0x567 16位/列表 ID: R1[15:0]=0x234\u0026laquo;5 ID: R1[31:16]=0x345\u0026laquo;5 ID: R2[15:0]=0x567\u0026laquo;5 ID: R2[31:16]=0x000\u0026laquo;5 0x1000x1FF,0x2000x2FF, 0x3100x31F, 0x3200x32F 0x2000x2FF, 0x3200x32F 16位/屏蔽 ID: R1[15:0]=0x200\u0026laquo;5 Mask: R1[31:16]= (0x700\u0026laquo;5)|0x10|0x8 ID: R2[15:0]=0x320\u0026laquo;5 Mask: R2[31:16]= (0x7F0\u0026laquo;5)|0x10|0x8 0x123, 0x234, 0x345, 0x456, 0x12345678, 0x0789ABCD 0x123, 0x12345678 32位/列表 ID: R1[31:0]= 0x123\u0026laquo;21 ID: R2[31:0]= (0x12345678\u0026laquo;3)|0x4 0x12345600~ 0x123456FF, 0x0789AB00~ 0x0789ABFF 0x12345600~ 0x123456FF 32位/屏蔽 ID: R1[31:0]= (0x12345600\u0026laquo;3)|0x4 Mask: R2[31:0]= (0x1FFFFF00\u0026laquo;3)|0x4|0x2 任意ID 只要遥控帧 32位/屏蔽 ID: R1[31:0]=0x2 Mask: R2[31:0]=0x2 任意ID 所有帧 32位/屏蔽 ID: R1[31:0]=随意 Mask: R2[31:0]=0 [!NOTE]\n注意：赋值语句默认是右对齐的，在配置过滤器时，低位是标志位，所以在进行赋值的时候需要进行左移操作，至于需要左移几位就需要看需要使用哪种报文格式了\n测试模式 在测试模式下，发送和接收的线路在内部会进行变更\n静默模式：用于分析CAN总线的活动，不会对总线造成影响。发送端直接接到接收端，在这个模式下可以进行自发自收测试，还可以默默的监测CAN总线数据。\n如果只想看一下总线上有哪些报文，而不想输出任何电平，就可以使用静默模式\n环回模式：用于自测试，同时发送的报文可以在CAN_TX引脚上检测到。RX引脚直接断开，且自己发送的数据，自己也可以收回来\n环回静默模式：用于热自测试，自测的同时不会影响CAN总线\n一般为了确保自己的硬件是没问题的，会使用环回静默模式，自己发送一个报文，看看自己能不能进行接收\n工作模式 初始化模式：用于配置CAN外设，禁止报文的接收和发送 正常模式：配置CAN外设后进入正常模式，以便正常接收和发送报文 睡眠模式：低功耗，CAN外设时钟停止，可使用软件唤醒或者硬件自动唤醒 AWUM：置1，自动唤醒，一旦检测到CAN总线活动，硬件就自动清零SLEEP，唤醒CAN外设；置0，手动唤醒，软件清零SLEEP，唤醒CAN外设 工作状态寄存器描述：\nSLAK：睡眠确认状态位，置1后表示硬件已经确认进入睡眠模式了 INAK：初始化确认位，置0表示硬件目前没有进入初始化模式 SLEEP：置0后就是请求退出睡眠 INRQ：置1后表示请求进入初始化，置0表示请求退出初始化 位时间特性 正常的时间分段分为：\n同步段：SS=1Tq 时间段1：BS1=1~16Tq 时间段2：BS2=1~8Tq SJW=1~4Tq [!TIP]\n注意：前面说过位时序的组成：由SS+PTS+PBS1+PBS2组成，采样点位于PBS1和PBS2之间\n但是现在将PTS和PBS1合并叫BS1段，采样点位于BS1和BS2段之间\n$$ 波特率 =\\frac{ APB1时钟频率} {分频系数 \\times 一位的Tq数量} \\\\= \\frac{36MHz} {(BRP[9:0]+1) \\times ((1 + (TS1[3:0]+1) + (TS2[2:0]+1)))} $$ 中断 CAN外设占用4个专用的中断向量 发送中断：发送邮箱空时产生 FIFO 0中断：收到一个报文/FIFO 0满/FIFO 0溢出时产生 FIFO 1中断：收到一个报文/FIFO 1满/FIFO 1溢出时产生 状态改变错误中断：出错/唤醒/进入睡眠时产生 时间触发通信 TTCM：置1，开启时间触发通信功能；置0，关闭时间触发通信功能 CAN外设内置一个16位的计数器，用于记录时间戳 TTCM置1后，该计数器在每个CAN位的时间自增一次，溢出后归零 每个发送邮箱和接收FIFO都有一个TIME[15:0]寄存器，发送帧SOF时，硬件捕获计数器值到发送邮箱的TIME寄存器，接收帧SOF时，硬件捕获计数器值到接收FIFO的TIME寄存器 发送邮箱可配置TGT位，捕获计数器值的同时，也把此值写入到数据帧数据段的最后两个字节，为了使用此功能，DLC必须设置为8 错误处理和离线恢复 TEC和REC根据错误的情况增加或减少 ABOM：置1，开启离线自动恢复，进入离线状态后，就自动开启恢复过程；置0，关闭离线自动恢复，软件必须先请求进入然后再退出初始化模式，随后恢复过程才被开启 ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/canoe/",
    "title": "CANoe",
    
    "content": " 软件简介 CANoe 是一款由 Vector Informatik 提供的专业软件工具，用于开发、测试和分析基于 CAN（Controller Area Network）总线和其他汽车网络协议（如 LIN、FlexRay、Ethernet、MOST）的嵌入式系统。CANoe 是一款功能强大且广泛应用于汽车电子系统开发和测试的工具。\nCANoe 的主要功能 总线仿真和分析： 支持 CAN、LIN、FlexRay、MOST、Ethernet 等多种总线协议。 提供实时总线仿真和消息分析功能，可以捕获和记录总线数据。 节点仿真： 可以仿真汽车电子系统中的多个节点，支持仿真真实硬件环境下的行为。 支持通过 CAPL（CAN Access Programming Language）脚本编写复杂的仿真逻辑。 网络管理： 提供网络管理功能，支持 CAN、LIN 和 FlexRay 等网络协议的管理。 诊断功能： 支持 UDS（Unified Diagnostic Services）等诊断协议，能够执行故障诊断和错误处理。 集成开发环境： 提供图形化的用户界面和脚本编写环境，方便用户进行配置和测试。 使用场景 汽车电子系统开发：CANoe 常用于汽车电子控制单元（ECU）的开发和测试，可以仿真和测试不同的汽车总线网络。 功能验证和测试：在汽车开发过程中，用于功能验证、系统集成测试和回归测试。 故障诊断和分析：用于捕获和分析总线数据，帮助工程师进行故障诊断和问题定位。 主要组件 Measurement Setup：配置和管理测试环境，包括总线配置、节点配置和信号监控。 CAPL Browser：用于编写和调试 CAPL 脚本，实现复杂的仿真和测试逻辑。 Trace Window：实时显示和记录总线上的消息和事件，方便进行分析和调试。 Panel Designer：设计用户界面面板，用于控制和监控仿真环境中的节点和信号。 CANoe在ECU项目开发中的作用 第一阶段：全仿真网络系统 也就是所有的节点都是虚拟的\n第二阶段：真实节点和部分仿真节点共存 可以使用部分真实的ECU代替虚拟节点，形成半虚拟半真实的网络\n第三阶段：全真实节点的网络系统 使用真实的节点代替所有的仿真节点，形成全真实的节点\nCANoe软件界面功能介绍 CANoe主页面\nCANoe主界面主要有以下功能区部分。\nFile（文件） Home（主功能区） Analysis（分析） Simulation（仿真） Test（测试） Diagnostics（诊断） Environment（环境） Hardware（硬件） Tools（工具） Layout（布局） 文件菜单 File菜单主要用于工程文件的相关操作及属性设定(CANoe项目为cfg结尾).\nHome功能区 Analysis功能区 Simulation功能区 Test功能区 Diagnostics功能区 Environment功能区 Hardware功能区 Tools功能区 Layout功能区 第一个CANoe仿真工程 CANoe仿真环境基本架构 需求 创建两个节点（Switch模块和Light模块） 创建两个控制面板（开关面板和指示灯面板） 通过CAPL代码实现两个节点间的通信 当用户操作开关以后，节点Switch将这个动作通过CAN通知给节点Light；节点Light收到这个CAN报文后，根据信号的值将指示灯点亮或熄灭。\n新建项目 打开CANoe主界面，单击File→New可以看到CANoe提供的工程模板.这里双击选择模板CAN 500kBaud 1ch，将生成一个空白的支持单通道的CAN总线仿真工程。根据之前介绍的工程文件夹的命名习惯，在文件夹FirstDemo下面分别创建文件夹CANdb、Panels和Nodes。\n添加CAN数据库 CANdb的主要功能和用途 定义消息和信号：\nCANdb文件详细定义了网络中每个消息的格式，包括消息ID、数据长度、周期时间等。 还定义了每条消息包含的信号，以及这些信号的属性，如起始位、长度、缩放因子和偏移量。 提供信号解释和转换：\nCANdb文件将原始的CAN数据帧转换为有意义的信号值（如速度、温度等），便于工程师理解和使用。 反过来也可以将信号值转换为CAN数据帧，方便数据发送。 支持网络仿真和分析：\n在CANoe中使用CANdb文件可以仿真和分析CAN网络通信。 CANoe通过CANdb文件识别并解析收到的CAN消息，显示信号的实际值。 自动化测试和诊断：\n自动化测试脚本可以使用CANdb文件中的定义来生成和验证CAN消息。 CANdb文件支持故障注入和诊断测试，帮助发现和解决通信问题。 生成报表和文档：\nCANdb文件中的信息可以用于生成通信协议和信号定义的文档。 有助于在开发团队和供应商之间共享和维护网络通信规范。 使用CANdb文件的具体步骤 创建和编辑CANdb文件：\n使用Vector的CANdb++ Editor或其他支持DBC格式的工具创建和编辑CANdb文件。 定义网络中的节点、消息和信号，并设置相应的属性。 加载CANdb文件到CANoe：\n在CANoe项目中加载创建好的CANdb文件。 CANoe会解析该文件，并在网络仿真和分析中使用这些定义。 仿真和测试：\n使用CANoe的仿真功能，根据CANdb文件定义的消息和信号进行网络仿真。 自动化测试脚本可以引用CANdb文件中的信号定义，生成测试用例和检查结果。 监控和分析：\n在CANoe的信号监控窗口中查看和分析通过CAN网络传输的信号。 使用CANdb文件中的信息，将原始CAN数据帧转换为易于理解的信号值。 示例 假设你有一个CANdb文件，定义了以下信息：\n节点：ECU1, ECU2 消息：Message1 (ID: 0x100, 周期时间: 100ms) 信号：Signal1 (起始位: 0, 长度: 16位, 缩放因子: 0.1, 偏移量: 0) 在CANoe中，你可以：\n加载这个CANdb文件。 配置仿真环境，使得ECU1和ECU2按照CANdb文件定义的规则通信。 使用监控窗口查看Signal1的实际值，并根据这个信号进行进一步分析或故障排除。 新建CAN数据库 现在创建一个含有报文Msg1和信号bsSwitch的数据库。\n单击Tools功能区打开CANdb＋＋Editor（CAN数据库编辑器）。\n在CANdb＋＋Editor界面中单击File→Create database并选择CAN Template.dbc作为模板。\n将新建文件命名为FirstDemo.dbc并保存在工程FirstDemo下面的文件夹CANdb中。\n添加报文和信号(在CANdb++Editor页面) 在Messages下面创建一条报文Msg1\n在Signals下面创建一个信号bsSwitch，单击OK按钮保存。\n可 以 将 信 号 bsSwitch 拖 曳 到 报 文 Msg1 下 面 ， 这 样bsSwitch就变成报文Msg1的一条信号\n添加数据库到工程中 进 入 Simulation Setup 窗 口 ， 在 System View 视 图 中 单 击Networks→CAN Networks→CAN→Databases ， 右 击 鼠 标 选 择Add，如图7.6所示，可以将FirstDemo.dbc文件加入仿真工程.\n定义系统变量 在CANoe中，系统变量（System Variables）是用于在仿真和测试过程中存储和共享数据的变量。它们为用户提供了一种方便的方法来定义和管理仿真环境中的全局状态和参数。系统变量在多种应用场景中非常有用，包括自动化测试、仿真控制和数据监控等。以下是系统变量的主要用途和具体应用：\n系统变量的主要用途 数据共享和通信：\n系统变量可以在不同的CAPL脚本、测试模块和仿真模型之间共享数据。 提供一种全局数据存储机制，使不同组件可以方便地访问和修改变量的值。 仿真控制：\n系统变量可以用于控制仿真场景的行为，例如启动和停止仿真、触发特定事件或模式等。 可以通过改变系统变量的值来动态调整仿真的运行参数。 自动化测试：\n在自动化测试脚本中使用系统变量来存储测试参数和结果。 系统变量可以用作测试条件和断言的基础，帮助验证系统行为是否符合预期。 监控和记录：\n系统变量可以用来监控仿真过程中重要参数的变化。 可以记录系统变量的值，用于后续分析和报告生成。 如何在CANoe中定义和使用系统变量 1. 定义系统变量 在CANoe中，可以通过如下步骤定义系统变量：\n打开CANoe项目。 导航到Variables窗口（通常可以通过“View”菜单找到）。 右键点击变量窗口，选择New System Variable。 为系统变量指定一个名称和类型（如整型、浮点型、布尔型等）。 设置变量的初始值（可选）。 2. 使用系统变量 在CAPL脚本中使用 CAPL（CAN Access Programming Language）是CANoe中用于编写测试脚本的语言。可以在CAPL脚本中读取和写入系统变量。\nvariables { msTimer myTimer; } on start { // 初始化系统变量 setValue(\u0026#34;SystemVarName\u0026#34;, 0); } on timer myTimer { // 读取系统变量的值 int value = getValue(\u0026#34;SystemVarName\u0026#34;); write(\u0026#34;Current value: %d\u0026#34;, value); // 更新系统变量的值 setValue(\u0026#34;SystemVarName\u0026#34;, value + 1); // 重新启动定时器 setTimer(myTimer, 1000); // 每秒更新一次 } on key \u0026#39;a\u0026#39; { // 手动修改系统变量的值 setValue(\u0026#34;SystemVarName\u0026#34;, 42); } 在测试模块中使用 在CANoe的测试模块中，也可以使用系统变量来控制测试流程和检查条件。\n// 定义一个系统变量 systemvar myTestVar; // 在测试用例中使用系统变量 testcase myTest { // 设置系统变量的值 myTestVar := 10; // 使用系统变量的值作为测试条件 if myTestVar == 10 { teststep \u0026#34;Check myTestVar is 10\u0026#34; { // 测试步骤 } } } 实际应用示例 假设你有一个CAN网络仿真项目，包含两个ECU。你可以使用系统变量来监控和控制仿真过程。例如，你可以定义一个布尔型系统变量isEngineRunning，用于表示发动机是否正在运行。\n定义系统变量：\nSystem Variable: isEngineRunning (Boolean, initial value: false) 在CAPL脚本中使用：\non message CAN1.EngineStatus { // 更新系统变量 if (this.EngineRunning) { setValue(\u0026#34;isEngineRunning\u0026#34;, true); } else { setValue(\u0026#34;isEngineRunning\u0026#34;, false); } } 在测试模块中使用：\ntestcase checkEngineStatus { // 检查系统变量的值 teststep \u0026#34;Engine should be running\u0026#34; { if isEngineRunning == true { write(\u0026#34;Test passed: Engine is running.\u0026#34;); } else { write(\u0026#34;Test failed: Engine is not running.\u0026#34;); } } } 创建系统变量 单击Environment功能区打开System Variables（系统变量）配置对话框。创建一个系统变量svLight.\n按 相 同 的 方 法 创 建 另 一 个 系 统 变 量 svSwitch ， 相 关 设 置 ： Namespace ： MyNamespace；Name ： svSwitch；Data type ： Integer。设置完毕后，可以在列表中看到已设置的两个系统变量.\n创建仿真面板 CANoe中为了方便用户模拟真实环境中的操作和显示，可以把需要的相关控制或显示控件设计在一个或多个面板中。一般用户很容易上手操作这些面板，并可以查看相关数据的图形化显示。\n首先创建一个开关面板，用于模拟开关操作。\n单击Tools功能区的Panel Designer（面板设计器）。 新建一个Panel，命名为SWITCH，并保存在文件夹Panels下。 在Panel Designer窗口的Toolbox（工具箱）中选择添加控件Switch/Indicator。在Properties（属性）对话框里将相关参数设置如下，其他属性保持默认值。 State Count:2。 Mouse Activation Type:LeftRight。 Symbol Filter:Variable。 Symbol:svSwitch。 Namespace:MyNamespace。 在 开 关 左 边 添 加 控 件 Static Text ， 将 Text 属 性 设 置 为Switch。 创建一个指示灯面板\n新建另一个Panel，命名为LIGHT，也保存在Panels文件夹下。\n在工具栏中选择添加控件LED Control。在“属性”对话框里将相关属性设置如下，其他属性保持默认值。\nDisplay Only:True。\nSymbol Filter:Variable。\nSymbol:svlight。\nNamespace:MyNamespace。\n在 开 关 左 边 添 加 控 件 Static Text ， 将 Text 属 性 设 置 为Light。\n创建网络节点 系统变量的变化处理以及报文发送与接收等功能需要由CAPL实现，接下来需要创建节点，并在节点中添加对应的CAPL程序。\n添加网络节点 可 以 在 Simulation Setup 窗 口 中 添 加 两 个 ECU 节 点（ECU1和ECU2），当开关按下后，ECU1发送一个CAN报文，ECU2收到报文后将指示灯点亮。 在CAN1的连线上右击，选择Insert Network Node命令，分别创建两个节点为ECU1和ECU2。\n右 击 ECU1 ， 选 择 Configuration 命 令 ， 可 以 打 开 Node Configuration（节点配置）对话框。在Node Configuration对话框中，单击File按钮，为该节点创建一个Switch.can文件，并将Title改为Switch.\nNode Configuration对话框是最常用的界面之一，下面将相关设定简介如下。\nTitle（名称）：用户可以在该文本框中给Network Node指定名称。需要注意的是，该名称只用于在Simulation Setup窗口中的System View中显示（图标节点名称也会改变）。\nNetwork Node（网络节点）：用户可以在该下拉菜单中选择database中已经定义的网络节点。\nState（状态）：用户可以将该Network Node设置为真实节点或仿真节点。simulated代表仿真节点，off代表真实节点（off只是将该节点Block掉）。\nExecution（执行）：在Execution区域，用户可以指定CAPL程序在该节点的运行方式。①Standard：指定CAPL或C#等将会在仿真工程中执行。②On hardware interface（CAPL-on-Board）： CAPL程序可以在Vector的硬件接口卡上运行（VN1630/VN3000／ VN7600）。\nExtended（扩展）：为用户提供了Start Delay和Dift/Jitter选项，前者设置了延迟开始的时间，后者则影响了该节点的定时器。\nNode specification（节点规范）：用户可以在该处选择File区添加CAPL程序，也可以编辑（Edit）和编译（Compile）所添加的CAPL程序文件。\nComponents（模块）：在该选项卡下，列出了该节点所用的所有模块（这里主要指动态链接库文件*.dll），用户也可以在此处添加自己所需的dll文件。\nBuses（总线)：在该选项卡下，列出了该节点可用的和已指定的总线。\n使用同样的方法配置ECU2，命名为Light，代码文件设定为Light.can。\n添加Hello world代码 使用CANoe的CAPL编写一个类似程序。双击节点Switch或者单击该节点的Edit图标，可以进入CAPL Browser（CAPL浏览器）。读者可以看到系统为Switch.can自动创建了如下空白的CAPL模板 . 现 在 添 加 一 个 输 出 类 似 “Hello World” 的 代 码 。 单 击 CAPL Functions浏览框，右键System→New Event Hander→On preStart到代码行。添加一行write函数，仿真工程开始之前将在Write窗口输出一行“This is my first CANoe Simulation！”。\non preStart { write(\u0026#34;This is my first CANoe Simulation!\\n\u0026#34;); } 添加Switch代码 基 于 上 面 的 代 码 ， 在 CAPL Functions 浏 览 框 ， 拖 曳 Value Objects→On sysvar＜sysvar＞到代码行，并将代码修改如下。\non sysvar sysvar::MyNamespace::svSwitch{ message Msg1 msg; msg.bsSwitch = SysGetVarialeInt(sysvar::MyNamespace::svSwitch); output(msg); } 这段代码使得节点Switch根据系统变量svSwitch的变化，修改bsSwitch 信 号 值 ， 并 将 更 新 的 报 文 发 送 到 总 线 上 。 单 击 工 具 栏Compile（F9）完成编译，并退出CAPL Browser。\n添加Light代码 双击Light节点打开对应的CAPL程序文件Light.can。在CAPL Functions浏览框，拖曳CAN→on message＜newMessage＞到代码行，并将代码修改如下\non message Msg1{ SysSetVariableInt(sysvar::MyNamespace::svLight,this.bsSwitch); } 这段代码将在Light节点中处理收到的CAN报文Msg1，根据报文中信号bsSwitch修改系统变量svLight的值，从而实现LED指示灯的点亮或熄灭。单击工具栏中Compile（F9）图标 完成编译，并退出CAPL Browser。\n总线数据库的设计 概述 总线系统中，ECU之间的通信、信息的交互以及相互之间的关系，都是通过总线数据库来管理的。总线数据库定义了总线系统中各个ECU所要发送和接收的报文，以及每个报文所有比特值的具体定义。\n[!TIP]\n提示：数据库中的message中包含了signal，在报文中设置信号就是设置报文的组成形式\nCANdb++Editor 可以使用CANdb++Editor对数据库文件进行编辑\nFile菜单 工具栏 创建CAN数据库（dbc） 基于模板新建总线数据库 在CANdb＋＋Editor主界面，选择File→Create Database命令新建数据库文件，此时可以查看到软件自带的数据库模板 。\n根据不同的需求在模板的基础上进行创建数据库。\nNetwork 双击新建的xvehicle\n在窗口中有4个选项卡，分别为Definition、Nodes、Attributes和Comment。此处将Definition中的Protocol属性改为CAN总线。\nECUs 在ECUs（电子控制单元）项下，列出了当前网络中所含的电控单元，它们之间通过网络节点（Network Nodes）实现信息的交互。通常情况下，ECU与网络节点是一一对应的。当ECU作为网关时，一个ECU可以包含多个网络节点。在CAN数据库中，双击某个ECU可以查看该ECU所对应的网络节点以及环境变量等信息。\n需要提醒读者的是，在CAN数据库中并不能直接创建ECU, CANdb＋＋会在创建网络节点的同时，创建一个名称相同的ECU。\nNetwork Nodes Network Nodes（网络节点）是ECUs的通信接口，各ECU通过Network Nodes实现总线上信息的发送和接收，每个Network Nodes包含对应的名称和地址 。\n新建一个node之后会弹出设置这个node的页面，设置地址为0x01\n同样的再新建一个ndoe\u0026ndash;door，地址为0x02，display地址为0x03\n当新建node之后会发现同步新建了三个同门ECU，并且同名ECU和node之间是关联的。\nMessage Messages（报文）是总线上节点相互通信的数据，数据库中每个报文应包含下列属性\nName（报文名称）\nCAN ID（CAN标识符）\nDLC（Data Length Code，数据长度）\nType（传输类型）\nCycle Time（周期）\nSignals（信号）\nTransmitters（发送节点）\nReceivers（接收节点）\nLayout（布局）\nAttributes（通用属性）\nComment（说明）\n==在报文中可以添加信号，信号组成报文==\n在 导 航 区 栏 中 右 击 Message 选 择 New ，创 建 一 个 名 为 EngineState 的 报 文 ， 选 择 标 准CAN（CAN Standard）报文，标识符为（ID）0x150，数据长度（DLC）为2。\n在Transmitters选项卡下单击Add按钮，将Engine节点添加到发送节点。在Transmitters设定界面中指定了该报文由节点Engine发送，\n用同样的方法，创建名为DoorState的报文，选择标准CAN（CAN Standard）报文，标识符（ID）为0x200，数据长度（DLC）为1，发送节点为Door。\nSignals Signal（信号）是总线通信的最小单元，数据库中一个信号由下列属性组成。\nName（信号名称） Length［Bits］（信号长度） Byte Order（字节顺序） Value Type（数据类型） Unit（物理单位） Init.Value（初始值） Factor（加权） Maximum（最大值） Minimum（最小值） Value Table（数值表） Messages（报文） Receivers（接收节点） Attributes（通用属性） Value Descriptions（数值描述） Comment（说明） CANdb ＋ ＋ 中 ， 信 号 的 数 据 类 型 分 为 4 种 ： Signed 、 Unsigned 、 IEEE Float 和 IEEE Double，\n接下来，将创建4个信号：引擎速度（EngineSpeed）\n在左侧栏中右击Signal选择New，创建信号EngineSpeed, Length为15b, Byte Order为Intel, Unit为r.p.m.，Value Type为Signed, Maximum为5500，其他设置可以使用默认值，如图8.10所示。\nFactor和Offset定义了raw value与physical value之间的关系。\nraw value是CAN报文发到总线上的十六进制数据 physical value是信号所代表的物理量的值 例如，车速、转速、温度等。Init.Value、Minimum和Maximum均为physical value。 $$ physical value ＝ （［ raw value ］ \\times ［Factor］）＋［Offset］。 $$ 在Message选项卡中单击Add按钮将该信号关联到报文EngineState中\n前面设置了Message的发送方Node，实际上Node还有接受方，接受使用singal的形式。\n单击左侧栏中的Network Nodes，右击Display，选择Edit Node，在弹出的对话框中，选择Mapped Rx Sig.选项卡，单击Add按钮，将信号EngineSpeed添加到其中。\nEnvironment Variable Environment Variable（环境变量）是==ECU、面板和CAPL程序相连接的媒介==。例如，在CAPL程序中，通过改变或监控某一环境变量的值可以触发特定的动作，同样，环境变量的值也可以与面板上控制控件或显示控件相关联。\n在CANdb＋＋的导航区中，右击Environment Variable，选择New命令创建一个名为EnvDoorState的环境变量\n参数解释如下\nAttribute Attribute（属性）定义了Vector CAN工具的通用属性，有预定义属性和用户自定义属性。在CANdb＋＋主界面上，单击工具栏中属性图标进入Attribute Definitions界面，也可以通过View→Attribute Definitions打开。\n双击进去就可以看到各个参数的页面。\n数据库的常见属性\nValue Table Value Table（数值表）用来文字化地指定信号或环境变量的值所代表的含义，例如，前面创建的信号OnOff，0代表Off状态，1代表On状态。 类似于c语言中的宏定义。\nByte Order 数据库中信号Byte Order（字节顺序）分为Motorola和Intel两种数据格式（也称为大端模式和小端模式），两种格式的字节顺序排列如下。\nPANEL设计 点击*==Tools \u0026gt; Panel Designer==*打开设计面板\n面板介绍 控件介绍 和系统变量交互 首先需要新建一个系统变量\n点击*==Environment \u0026gt; System Variable==*新建一个系统变量\n点击左侧的新建按钮\n创建完成系统变量之后就是将系统变量和面板上的控件关联起来。这样才能实现系统变量和面板的交互。\n切换到panel编辑器中，点击控件，首先点击symbol filter，选择variable，之后选择sysmbol中的环境变量即可。\n访问和设置环境变量中CAPL笔记中有相关的读取和设置参数。\n仿真工程编译和调试 为了创建==CBF==（CAPL Binary Format）格式的可执行文件，用户需要使用CAPL编译器对所编写的程序进行编译。用户可以单击工具栏中的Compile图标或者按F9键启动编译命令。如果CAPL程序还未命名，CAPL浏览器会提示用户输入文件名并保存。如果程序已命名，则*.cbf文件的名称将直接来自源文件名。编译成功后，CBF文件会自动保存在与CAPL程序文件相同的文件夹下\n[!TIP]\n提示：CAPL语言基本上和C语言很类似，所以也支持条件编译\n#ifdef #elif #endif CAPL的调试和一般调试相同。\nCAN仿真 整体架构 仿真工程的工作流如下图所示\n工程仿真 创建仿真工程 设计或导入DBC文件 创建相关的系统变量 设计面板，将面板中的控件和系统变量绑定在一起 使用CAPL语言进行编程 完成上述步骤之后就可以开始仿真\nTrace窗口 Trace（追踪）窗口主要用于记录和显示测量过程中的所有活动，包括收发报文、错误帧、系统变量、环境变量和诊断服务等。在已加载了Database的工程文件中，Trace窗口可以解析出每个报文和信号。Trace窗口主要有以下功能。\n预定义过滤器（Predefined Filter）：单击Trace窗口工具栏图标 ，打开预定义过滤器视图。这些不同形式的过滤器可以设置Measurement Setup的过滤器、总线系统事件（Bus Systems）过滤器、系统变量／环境变量过滤器、系统报文（System Messages）过滤器等。 分析过滤器（Analysis Filter）：单击Trace窗口工具栏图标 ，打开分析过滤器视图。用于减少窗口中的显示数据，可以把Trace 中 不 关 心 的 项 拖 曳 到 Stop Filter ， 将 关 心 的 项 拖 曳 到 Pass Filter。 淡出无变化的数据：为了提高查看的便利性，固定时间内没有更新的数据显示将逐渐淡出。单击Trace窗口工具栏图标 ，将删除淡出的事件或数据。 设定marker（标识）：marker可以将指定的事件标识出来，并与对应的时间戳相关联。设定的maker也可以在其他分析窗口中显示（如Graphic窗口）。该功能只能在measurement暂停或停止时设定。 显示统计数据：显示报文、信号、变量等各种信息，包括当前数值、时间戳等，可以详细地以不同形式显示。 日志数据：窗口输出可以部分或全部导出，也可以直接保存到指定的文件中。已保存的日志文件，也可以导入到Trace窗口，进行离线分析。日志数据的设定、导入、导出等相关详细介绍. Graphics窗口 在Graphic（图形）窗口中，信号、变量和诊断参数可以以图形化形式显示（XY图形）。用户可以将X轴配置成时间或其他变量。以下为Graphic窗口支持的主要功能。\n设定marker（标识）：marker可以将指定的事件标识出来，并与对应的时间戳相关联。设定的maker也可以在其他分析窗口中显示。该功能只能在measurement暂停或停止时设定。 显示测量栏：在图例中，每个信号的全局和局部数据的最大值和最小值会自动表示出来，同一类型的信号可以比较数值的差异。 显示数据统计：信号的最小值、最大值、平均值和标准偏差显示在Graphic窗口中。该功能只能在measurement停止时可用。 X/Y mode：在信号列表中右击任何一条信号，都可以设置为X轴的变量。 日志数据：Graphic窗口中的信号可以自动保存到事先定义的log文件中（MDF格式），也可以导入已保存的文件分析signal数据 State Tracker窗口 State Tracker（状态追踪）窗口是用来显示比特值和一些状态值，特别适合显示数字输入量和输出量，以及状态信息，如图4.9所示。该功能适合用于分析状态及状态转换相关的信号和变量。以下为State Tracker窗口支持的主要功能。\n发现错误：基于状态响应时间、信号和状态切换的分析，可以有效地监控相关功能，及时发现错误。 分析信息：不同的信息，如ECU内部通信，总线信号以及I/O口的状态，可以放在一起分析。 设定触发：用户可以定义开始测量后的触发条件。 设定marker：可以用marker标识不同的时间点，两个marker点的时间间隔可以测量出来。 Data窗口 Data（数据）窗口可以显示信号、系统变量和诊断参数的数值、单位等信息，并以不同的方式显示出来。\n显示数值：可以显示数据的原始值（Raw Value）、物理值、单位等信息。可以显示信号在全部或部分时间内的最大值和最小值。 日志数据：测量过程中可记录信号并保存到log文件中（MDF格式）。 Statistics窗口 Statistics（统计）窗口用于统计Measurement Setup窗口运行过程中的总线（CAN、LIN、FlexRay等）活动，可以在Measurement Setup窗口中插入Statistics功能。下图所示为CAN总线活动情况，主要显示的信息包括总线负载（也可基于节点级、报文级）、突发帧、标准帧、扩展帧、远程帧、错误帧和控制器状态等。\n显示各个通道的统计数据：显示数据可以限定在指定的通道，或者配置为针对所有可用通道。\n设定刷新间隔：可以修改刷新间隔修改统计的时间间隔。\n暂停统计：用户可以在Measurement运行过程中暂停统计\nScope窗口 Scope （ 示 波 器 ） 窗 口 需 要 配 置 额 外 的 授 权 选 项 （ CANoe Option.Scope）和对应的硬件接口，可以观察总线电平，用于分析总线协议，可以使用EYE图表评估信号品质。 ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/capl/",
    "title": "CAPL",
    
    "content": " 1 概述 CAPL全称为Communication Access Programming Language，即通信访问编程语言。它是Vector公司专门为CANoe开发环境设计的编程语言，在语法和概念上与C语言类似。借助CAPL，用户可以编写程序并应用到网络的各个节点上，也可以利用CAPL编程加强测量分析功能，以及搭建高效的自动化测试模块。\n2 CAPL开发环境 3 数据类型 3.1 全局变量和局部变量 在CAPL中，全局变量需要被声明在variables部分，同时可以使用直接赋值方法进行初始化。如果没有初始化，编译器会执行自动初始化，默认值为0。全局变量的作用域包括整个CAPL文件以及与此文件有链接的其他CAPL文件。\n与C语言不同，局部变量在CAPL中总是被静态地创建。这意味着初始化只在程序体启动时执行，当再次进入程序时，局部变量被假定是上一次跳出程序时的值。局部变量的作用域，仅限于当前函数体范围内，即该函数的大括号范围内。\n3.2 简单变量 3.2.1 整型 整数就是没有小数部分的数字，如3、201、-3412和0。根据数值的大小不同，CAPL提供了以下几种整型。\n3.2.2 字符 区别于C语言，CAPL未将char类型（长度1B）归类至整型中，这是因为在CANoe中提供了byte类型。如果数据是具体数值则应使用byte，而对于字符，则应用char（字符串使用char数组）。char类型和byte类型之间可以直接转换。\nbyte data1 = 100; char ch1 = \u0026#39;d\u0026#39;; ch1 = 0x62; data1 = \u0026#39;s\u0026#39;; 3.2.3 浮点型 CAPL提供两种浮点型变量：float和double。\n3.3 复合类型 3.3.1 结构体 CAPL中可以简单地按照C语言的方法来声明结构（struct），但结构名在程序中必须是唯一的。简单类型、枚举类型或者其他的结构都可以作为结构的成员。\nstruct b{ struct a a1; enum clolrs c1; int p; long l; } 结构b中包含：一个结构成员a，变量名为a1；一个枚举成员colors，变量名为c1；一个整型变量p；最后还有一个长整型变量l。 用户可以在类型定义时直接声明结构类型的变量，在这种情况下，类型的名称可以省略，也可以直接使用结构的名字来引用类型。\nstruct cost mycost; struct { int chinese; int math; int english; }scores; 关于结构初始化，可以在变量声明期间直接初始化结构成员，不需要单独命名单个成员，编译器将按照结构定义的顺序默认初始化它们。例如：\nstruct Scores myScores = { Chinese = 79, Math = 99, English = 88 }; struct Scores myScores = {79,99,88}; 使 用 “.” 操 作 符 可 以 访 问 结 构 中 的 成 员 ， 例 如 ， myScores.Chinese ＝ 100。另外，结构体可以作为参数传给函数，但不能作为函数的返回值。\n3.3.2 枚举 枚举（enum）类型的声明也与C语言中的语法完全一致，但需要注意的是，枚举的成员名必须唯一，否则将有可能代替隐藏数据库中同名的报文和信号。如果没有在声明枚举的同时对成员进行赋值，编译器将按照成员声明的顺序对成员进行初始化。即第一个成员被初始化为0，往后依次加1。例如：\nenum {Apple, Pear, Banana} Fruit = Apple; enum Colors {Red = 1, Green = 3, Blue = 9}; 3.3.3 数组 数组（Array）作为一种基本的数据结构，也同样被CAPL支持，就像在C语言中一样。但为了方便使用，CAPL支持直接用字符串初始化字符数组的行为。\nint a[3] = {1,2,3}; char b[13] = \u0026#34;Hello World!\u0026#34;; 同 样 ， CAPL 也 支 持 多 维 数 组 ， 并 且 可 以 通 过 内 建 函 数elCount（数组名）来获得数组成员的个数。如果数组的索引超出范围，即小于零或大于等于数组长度，CAPL将会在数组下标前提示错误。例如：\nint v[3][3] = {{1,2,3},{4,5,6},{7,8,9}}; int a[3] = {1,2,3}; int b = elCount(a); 3.3.4 特殊类型 3.3.4.1 报文 报文（CAN/LIN messages）是车载网络最基本的构成部分， CAPL提供了各种网络相对应的报文类。这里主要介绍CAN报文和LIN报文。\n使用关键字message来声明一个报文变量，当使用message声明报文变量时，默认变量为CAN报文变量。当有数据库支撑的时候，一个 完 整 的 声 明 应 该 包 括 message ID 或 者 message name 。 结 合database的例子，使用ID 0xA或者报文名来声明一条数据库中的EngineData报文。例如\nmessage 0xA ml; message 100 m2; message EngineData m3; 以标识符“x”结尾的ID表示这是一个扩展帧ID，例如，100x。而“*”则表明这条报文在声明时还不含有CAN ID。例如：\non message CAN1.* { message *msg; if(this.dir!= rx) return; msg = this; } 切记，使用这种方式声明报文时，一定要指定ID后才能将msg发送出去。\nCAPL提供了一系列的选择器（Selector）以保证用户能够按照自己的意图去修改CAN message的属性。\n例如，如果需要在CAN1网络上发送一条指定的报文，报文名： magicMessage；报文ID：0x252；包含8个字节0x03 3B 40 00 00 00 00 00；可以定义如下。\nmagicMessage.CAN = 1; magicMessage.ID = 0x252; magicMessage.DLC = 8; magicMessage.Byte(0)=0x03; magicMessage.Byte(1)=0x3B; magicMessage.Byte(2)=0x40: magicMessage.Byte(3)=0x00: magicMessage.Byte(4)=0x00; magicMessage.Byte(5)=0x00; magicMessage.Byte(6)=0x00; magicMessage.Byte(7)=0x00; output (magicMessage); 3.3.4.2 诊断报文 CAPL 通 过 诊 断 请 求 （ DiagRequest ） 和 诊 断 响 应（DiagResponse）这两种对象来实现跟ECU之间的诊断服务交互。通常情况下，诊断服务需要首先对Diagnostic对象声明和初始化。\nDiagRequest ServiceQualifier request; DiagResponse ServiceQualifier response; 上述声明语句分别声明了诊断请求对象“request”和诊断响应对象“response”；并通过给出的诊断服务“ServiceQualifier”进行初始化。这种初始化将在节点仿真开始时被执行一次，并在每次诊断目标（DiagTarget）改变时被执行一次。 如果使用*来代替“ServiceQualifier”，诊断对象将被初始化为未添加诊断描述的空对象，但对象的数据必须在发送之前完成设置。\n3.3.4.3 系统变量 系统变量是一种特殊的变量，用来描述某种特殊状态（例如某种事件触发）或者记录测量数据。一般有系统定义和用户自定义两种，它们的作用域都是在各自的命令空间内。\n3.3.4.4 定时器 CAPL 提 供 了 两 种 定 时 器 变 量 ： timer 基 于 秒 的 时 间 单 位 ； msTimer基于毫秒的时间单位，例如：\nmsTimer myTimer;//声明一个毫秒定时器 Timer myTimer1;//声明一个秒定时器myTimer1 4 常见运算 与C语言一样，CAPL也提供了算术、逻辑和位运算的运算符，其用法也与C语言保持一致。\n5 流程控制 5.1 if条件语句 if(表达式) 语句; if(表达式) 语句1; else 语句2; 5.2 switch句 switch(表达式){ case常量表达式1： 语句1; case常量表达式2： 语句2; case常量表达式n: 语句n; default: 语句n+1; } 5.3 while循环语句 whi1e(表达式) 语句; 5.4 do-while循环 do{ 循环体语句; }while(表达式); 6 程序结构 6.1 头文件 CAPL提供了*.cin文件（callback interface file），用户可以通过该文件搭建自定义的测试框架。比如，将基本的函数接口按照不同类型分别定义在各自的*.cin文件中，然后再在不同的*.can文件中包含所需要的*.cin文件，从而形成二层引用结构。同时也可以在*.cin中包含其他的*.cin文件，然后在*.can文件中包含上层*.cin文件，进而形成多层的引用结构，从而达到提高代码复用效率的目的。\n例如，基本诊断服务定义在BaseServices.cin中，基本函数定义在CommonFunctions.cin中，测试用例函数定义在TestFunctions.cin中，将相关的测试用例定义在测试模块文件ECU_01.can中，那么在各个文件中的头文件结构如下。\n在TestFunctions.cin中：\nincludes { #include \u0026#34;CommonFunctions.cin\u0026#34; #include \u0026#34;Baseservices.cin\u0026#34; } 在ECU_01.can中：\nincludes { #include \u0026#34;TestFunctions.cin\u0026#34; } 这样，在ECU_01.can中可以调用三个*.cin文件中的所有函数。如果需要编写另一个测试模块ECU_02，只需要在ECU_02.can中包含TestFunctions.cin即可。\n6.2 全局变量声明 CAPL跟C语言一样，变量的作用域和生命周期仅限于变量声明的函数体（即大括号范围）内。CAPL在每个程序的开始部分提供了variables区域给用户声明全局变量。\nvariables{ int i 0; message 100 msg; msTimer myTimer; byte ECU_SERIAL_NUMBER[3]={0x31,0x32,0x33}: } 在此部分声明的全局变量的生命周期从仿真开始持续到仿真结束，其作用域为整个CAPL文件。而在*.cin文件中声明的全局变量在包含它的*.can或*.cin中视为可见。\n6.3 事件处理 在什么条件下，在什么时间节点，发生了什么样的报文传递，得到了什么样的报文反馈。而这种面向事件的机制是通过event handler来实现的。\n6.3.1 事件起始关键字on on * { 语句; } on后面加某种条件，一旦条件满足则执行下面函数体内的语句。函数体内的语句是实现接下来需要完成的操作。\n6.3.2 关键字this 在can的报文事件或变量事件中，可以使用关键字this访问数据内容\non message 100 { byte byte0; byte0 = this.byte(0); } 这里的this就代表的是message这个报文\n6.3.3 系统事件 系统事件主要用于处理CANoe测量系统的控制功能，主要有on start、on preStart、on stopMeasurement、on preStop、on key＜ newKey＞以及on timer。\n栗子：\non prestart{ write(\u0026#34;Measurement started!\u0026#34;); msg_Count = 0; } on start{ write(\u0026#34;start Node A\u0026#34;); setTimer(cycTimer,20); CallAll0nEnwar(); } on prestop{ message ShutdownReg m; output (m); Deferstop(1000); } on stopMeasurement{ write(\u0026#34;Message 0xx received:\u0026amp;d\u0026#34;,msg.id,msg_Count); } 6.3.4 CAN控制器事件 CAN控制器事件是对硬件接口设备中CAN控制器状态变化事件的响应 。\n栗子：下面的代码在侦测到Bus Off状态时，系统会输出信息到Write窗口，并复位ECU。\non busoff{ //在Bus off状态下复位CAN控制器 Write(\u0026#34;The CAN controller is in Bus off state\u0026#34;); resetCanEx(Channel); } 6.3.5 CAN报文事件 CAN报文事件在CAN总线上有指定的或任意报文出现时被调用。关键字为：on message xxx。例如，下面列出了不同的on message事件。\non message 123\t//对报文123(dec)反应 on message 0x123\t//对报文123(hex)反应 on message MotorData\t//对报文MotorData反应 on message CAN1.123\t//对CAN通道1收到报文123反应 on message *\t//对所有报文反应 on message 100-200\t//对CAN ID在100~200间报文反应 6.3.6 CAN信号事件 CAN信号事件是在CAN总线上出现指定的信号时被调用（需要配合DBC文件使用）。关键字为：on signal xxx或on signal_update xxx。需要注意的是，前者只在指定信号的值发生变化时被调用，后者在每次接收到指定信号时均被调用。\non signal Lightswitch:：Onoff{ STAT1=this; } on signal_update Lightswitch::Onoff{ STAT2=this; } 6.3.7 定时事件 定时器变量可以用来创建一个定时事件，SetTimer函数用来设定时间间隔。当定时器运行到达设定的时间间隔时，将触发该事件，这时on timer函数中的程序块将被执行。需要提醒的是，周期性触发需要在每次触发结束后使用SetTimer复位。若在定时器运行中需要停止计时，可以使用cancelTimer函数来取消计时。\n定时器事件关键字为on timer xxx。以下代码通过定时器事件实现每100ms发送一次报文0x555。\nvariables{ message 0x555 msgl {dlc=1}; msTimer myTimer;\t//将myTimer声明ms为单位的定时器变量 } on start{ setTimer (myTimer,100);\t//将定时值设定为100ms,并启动 } on timer myTimer { setTimer (myTimer,100);\t//不能遗漏，复位定时器 msg1.byte(0) = msg1.byte(0) + 1;\t//更新报文byte(0)数据 output (msg1);\t//输出报文 } 6.3.8 键盘事件 在测量的过程中，通常需要由用户来触发某些事件来模拟实际测试环境的人工操作，例如，开始记录log、改变信号或变量的值、停止测量等。利用CAPL提供的键盘事件可以方便地完成这些操作。键盘事件的关键字为on key xxx。\non key \u0026#39;a\u0026#39;\t//按a键反应 on key \u0026#39; \u0026#39;\t//按空格键反应 on key 0x20\t//按空格键反应 on key F1\t//按F1键反应 on key Ctrl-F12\t//按Ctr1+F12组合键反应 on key PageUp\t//按Page Up键反应 on key Home\t//按Home键反应 on key\t*\t//按所有键反应 on key \u0026#39;s\u0026#39; { Write(\u0026#34;Logging starts\u0026#34;); } 6.3.9 错误帧事件 当总线上出现错误帧或者过载帧时，错误帧处理机制将被调用。下面的代码将输出总线错误码，同时将错误帧的信息输出到Write窗口中。\non errorFrame { const int buffersize 256; char buffer[buffersize]; char cdirection[2][3]{\u0026#34;RX\u0026#34;,\u0026#34;TX\u0026#34;}; int ndir; word ecc; word extInfo; int isProtocolException; ecc = (this.ErrorCode \u0026gt;\u0026gt; 6)\u0026amp;0x3f; extInfo = (this.ErrorCode \u0026gt;\u0026gt;12)\u0026amp;0x3; isProtocolException (this.ErrorCode \u0026amp;(1 \u0026lt;15))!=0; ndir extInfo ==0 extInfo ==2 0:1; //根据extInfo来判断错误帧传输方向：接收或发送 } 6.3.10 环境变量事件 环境变量事件是对环境变量发生变化的响应，关键字为on enVar xxx\non envVar Switch { //声明一个CAN报文变量，用于传输 message Controller msg; //读取环境变量Switch的数值，并赋值给信号Stop msg.Stop = getvalue(this); //发送报文到总线上 output(msg); } 可以使用getValue（）和putValue（）读写环境变量的值\n//读取环境变量Switch的数值，并赋值给变量val val = getvalue (Switch); //将数值0赋值给环境变量Switch putvalue(Switch,0); 6.3.10.1 环境变量事件 与环境变量事件类似，系统变量事件是对系统变量发生变化的响应，关键字为==on sysVar xxx或on sysVar_update xxx==\non sysvar IO::DI_0 { $Gateway:IOValuel = @this; } on sysvar update IO::DI_0 { SGateway::IOValue2 = @this; } 6.3.10.2 诊断事件 诊断事件是在诊断请求或诊断响应发生时产生\non diagRequest ECU.DefaultSession_start { //发生诊断请求事件 Write(\u0026#34;Default Session Switch request received\u0026#34;) } on diagRequestSent ECU.HardReset { //诊断请求发送完成 Write(\u0026#34;HardReset service sent completely,ECU should reset\u0026#34;) } on diagResponse ECU.VehicleIdentification_Number_Read { //收到相应的诊断请求的响应 Write(\u0026#34;VehicleIdentification Number Read response received successfully\u0026#34;) } 6.3.10.3 自定义函数 当返回值类型省略时，被默认解释为void类型。 正如C＋＋一样，允许函数包含一个空的形参列表。 允许重载函数（即同一个函数名，但每个函数的形参列表必须不同，例如，不同的形参类型或者在形参列表中的不同次序）。 函数会对实参进行类型检查，如果类型不同则检查是否能够通过隐式类型转换，如不能，则无法通过编译。 任意维度或大小的数组都可被作为函数参数传递。 大部分CAPL支持的数据类型都可以直接声明为函数参数，例如，整型、浮点型、枚举、结构、定时器以及它们的引用。 但是有一些类型不能被直接声明，而需要加上号（注意该符号并不是C语言中指针的意思）。例 如 ， signal * s 、 envvarInt * ev 、 sysvarFloat * sv 、diagRequest * dr、diagResponse * dr、int matrix［］［］，以及所有来自于database的变量，均需要加上 * 号声明。需要注意的是message类型比较特殊，如果该变量是用户自定义的，那么在函数参数声明时，message和message均可以，但如果该变 量 来 自 database ， 那 么 只 有 message * 可 用 。 7 常用库函数 7.1 通用函数 7.2 计算函数 7.3 字符串函数 7.4 CAN总线函数 7.5 LIN总线函数 7.6 诊断函数 8 变量和信号的访问 8.1 访问信号 signal在CAPL中代表的是总线信号交互层的表示，它不同于message。message是CAPL的数据类型，而signal不是。因此，不能在CAPL中定义一个类型为signal的变量。\n当用户需要访问信号缓冲区并期望读到最后接收到的信号值时，可以使用$符号。\nvalue = $EngineSpeed;\t//读取信号EngineSpeed的值 value = $EngineSpeed.raw;\t//读取信号EngineSpeed的raw数据 $EngineSpeed = 500.0;\t//将信号Enginespeed的值设为500 if ($Enginespeed !=500.0)write(\u0026#34;Unequal!\u0026#34;); 一个工程中可能包含多个相同名称的信号名。所以CAPL中需要增加通道（Channel）、网络（Network）、节点（Node）和报文（Message）的信息。完整的语法格式如下。\n(channel | network):: [dbNode::]node:: [dbMsg::]message:: [dbsig::] signal 栗子：\n$Lightswitch::Onoff\t//Node + signal $Lightswitch::Lightstate::Onoff\t//Node + Message + Signal $CAN1:Gateway:Status\t//Channel + Node + signal $PowerTrain::Gateway::Status\t//Network + Node + Signal $CAN1::Status\t//Channel + Signal 8.2 访问系统变量 可以在CAPL中直接访问系统变量而不需要通过函数调用（例如使用SysGetVariableInt 、SysGetVariableFloat等获取变量值，使用SysSetVariableInt 、SysSetVariableFloat等函数修改变量值），以下是需要采取的语法格式：\n@Namespace:Variable [!CAUTION]\n需要注意的是，对于array或struct类的变量，直接访问方式只能访问单个元素，\nintValue = @Namespacel::Parameter2; @Debug::MotorValues::EngineSpeed = $Enginespeed; intvalue=@Namespacel::ParameterArray[2];\t//访问数组变量的单个成员 @XCP::EcU_2::KL2.Curve2[0]=1.3;\t//访问结构体中的数组变量的单个成员 比 较 通 用 的 访 问 操 作 方 式 是 使 用 以 sysGetVariable 开 头 和sysSetVariable开头的访问函数。\n//字符串修改操作 char demo[20] = {\u0026#39;M\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;g\u0026#39;}: sysSetvariablestring(sysvar::IPC::Music_tag,demo); //long数组类的系统变量读取操作 long 1VarArr[10]; sysGetvariableLongArray(sysvar::MyNamespace::LongArrayvar,lVarArr,elcount(1VarArr)); 8.3 访问环境变量 访问环境变量和系统变量的语法一样，都使用@符号进行访问。比较常用的访问函数为\n//getValue相关操作 int val; float fval; char cBuf [25]; byte bBuf[64]; long copiedBytes; //获取环境变量Switch(整型)的数值并赋值给整数val变量 val = getvalue(Switch); //获取环境变量Temperature(浮点型)的数值并赋值给浮点数fval变量 fval = getvalue(Temperature); //读取环境变量NodeName(字符串型)的数值，赋值给字符串cBuf,返回复制的字符长度 copiedBytes = getvalue(NodeName,cBuf); //读取环境变量DiagData(字符串型)的数值，从32位置赋值给字符串bBuf,返回复制的字符长度 copiedBytes = getvalue(DiagData,bBuf,32); //putValue相关操作 byte dataBuf [64]; //将0赋值给环境变量Switch putvalue(Switch,0); //将22.5赋值给环境变量Temperature putvalue(Temperature,22.5); //将\u0026#34;Master\u0026#34;赋值给环境变量NodeName putvalue (NodeName,\u0026#34;Master\u0026#34;); //复制dataBuf字符串变量中的64个字节给环境变量DiagData putvalue(DiagData,dataBuf,64); ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/configuration-wizard/",
    "title": "Configuration Wizard",
    
    "content": " 参考链接 可视化的Keil工程配置模板，一招提高单片机开发效率-CSDN博客\nKeil5 Configuration Wizard配置向导的使用方法_keil configuration wizard-CSDN博客\n实现 Configuration Wizard可以实现可视化配置宏定义文件。\n首先在官方文档（Keil Product Manuals）中搜索Configuration Wizard（µVision User\u0026rsquo;s Guide (arm.com)）\n网页中的文档描述得非常详细，也提供了一个配置模板，我们只需要照着文档描述写好相应的格式即可生成一个图形化的配置界面。\n[!note]\n注意：Keil并没有那么智能，写完这个模板它并不能立马自动匹配到，需要重新关掉Keil工程再开才能加载成图形配置模板，然后才能够实现即时修改即时响应！！！\n将h文件或者c文件转换为可视化界面是很简单的，只需要在文件的开头和结尾加上以下的标识符即可：\n// \u0026lt;\u0026lt;\u0026lt; Use Configuration Wizard in Context Menu \u0026gt;\u0026gt;\u0026gt; // \u0026lt;\u0026lt;\u0026lt; end of configuration section \u0026gt;\u0026gt;\u0026gt; 然后关掉工程再重新打开，就可以实现可视化界面了\n语法 注释 使用标签i来进行注释\n// \u0026lt;i\u0026gt;这里加上注释 组 使用标签h来控制组\n// \u0026lt;h\u0026gt; 组名 // \u0026lt;/h\u0026gt; 复选框 复选框组 使用标签e来控制复选框组\n// \u0026lt;e\u0026gt;系统信息 // \u0026lt;q\u0026gt; 负载锁定 #define _EPCM_LOAD_LOCK 1 //BIT15; 0：不使能负载锁定; 1：使能负载锁定 // \u0026lt;/e\u0026gt; 复选框 复选框(\u0026lt;c\u0026gt; \u0026lt;/c\u0026gt; or \u0026lt;!c\u0026gt; \u0026lt;/c\u0026gt;：创建一个复选框来取消注释或注释代码。\n\u0026lt;c\u0026gt; \u0026lt;/c\u0026gt;勾选不注释代码，不勾选注释代码。 \u0026lt;!c\u0026gt; \u0026lt;/c\u0026gt;勾选注释代码，不勾选不注释代码。 // \u0026lt;c\u0026gt;复选框1 需要开关的代码段 // \u0026lt;/c\u0026gt; // \u0026lt;!c\u0026gt;复选框2 需要开关的代码段 // \u0026lt;/c\u0026gt; 标志位模式 标志位模式\u0026lt;q\u0026gt;：可以通过复选框设置的位值选项。使用符号.来控制位数\n// \u0026lt;q.0\u0026gt; E2ucID第0位 // \u0026lt;q.1\u0026gt; E2ucID第1位 #define E2ucID 0x00 上述代码中E2ucID初始值为0x00，当我选中q.0的复选框时，E2ucID的第一位就会变为1，变为0x01，当我勾选q.1的时候，E2ucID的值的第二位就会变为1，也就是0x02。以此类推。\n组合框 组合框\u0026lt;o\u0026gt;用于选项与选择或数字的输入。\n// \u0026lt;o\u0026gt;电芯串数 // \u0026lt;7=\u0026gt; 7串 // \u0026lt;6=\u0026gt; 6串 // \u0026lt;5=\u0026gt; 5串 // \u0026lt;4=\u0026gt; 4串 #define EPCM_CELL_NUM 7 这里会展示下拉框，其中选项有4串,5串,6串,7串，当选中其中一个选项之后，EPCM_CELL_NUM的值就会变为相应（尖括号中的）的值。\n字符串输入框 使用标签s来控制字符串输入：可修改包含ASCII字符串条目。\n// \u0026lt;s.12\u0026gt;制造商名称 #define _E2ucMNFName \u0026#34;tenxun\u0026#34;//U8 xdata E2ucMNFName[12] 其中的.12表示字符串的长度是12，初始值是tenxun，当在value中修改值的时候，宏_E2ucMNFName的值就会变为你修改的内容\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/dac/",
    "title": "DAC",
    
    "content": " 参考链接 【STM32】DAC详解_dac12bit-CSDN博客\n简述 DAC,全称：Digital-to-Analog Converter,指数字/模拟转换器\nDAC 模块是 12 位电压输出数模转换器。\nDAC 可以按 8 位或 12 位模式进行配置，并且可与DMA 控制器配合使用。 在 12 位模式下，数据可以采用左对齐或右对齐。 DAC 有两个输出通道，每个通道各有一个转换器。在 DAC 双通道模式下，每个通道可以单独进行转换；当两个通道组合在一起同步执行更新操作时，也可以同时进行转换。可通过一个输入参考电压引脚 V REF+ （与 ADC 共享）来提高分辨率。 [!IMPORTANT]\nADC和DAC是模拟电路和数字电路之间的桥梁\n特性参数 分辨率：表示模拟电压的最小增量，常用二进制位数表示，比如：8、12位等 建立时间：表示将一个数字量转换为稳定模拟信号所需的时间 精度：转换器实际特性曲线与理想特性曲线之间的最大偏差 误差源：比例系统误差、失调误差、非线性误差 原因：元件参数误差、基准电压不稳定、运算放大器零漂等 主要特性 主要特性 F1 F4 F7 H7 DAC输出类型 电压输出型 == == == 分辨率 8/12位 == == == DAC时钟频率 36MHz(APB1) 42MHz(APB1) 45MHz(APB1) 54MHz(APB1) 120MHz(APB1) 建立时间 3us == == 1.7us 供电电压 Vssa : 0V, VpDa : 2.4V~3.6V == == == 参考电压 VReF- : OV, VREE+ 般为3.3V == == == 输出通道 DAC_OUT1(PA4）、DAC_OUT2(PA5) 为了避免寄生电流消耗，PA4和PA5配置为模拟功能 每个通道都有单独的转换器，可同时或单独转换，每个通道都有DMA功能 == == == 两个 DAC 转换器：各对应一个输出通道 12 位模式下数据采用左对齐或右对齐 同步更新功能 生成噪声波 生成三角波 DAC 双通道单独或同时转换 每个通道都具有 DMA 功能 DMA 下溢错误检测 通过外部触发信号进行转换 输入参考电压 V REF+ 工作原理 [!TIP]\n使能 DAC 通道 x 后，相应 GPIO 引脚（ PA4 或 PA5 ）将自动连接到模拟转换器输出(DAC_OUTx) 。为了避免寄生电流消耗，应首先将 PA4 或 PA5 引脚配置为模拟模式 (AIN) 。\n参考电压和模拟电压 名称 信号类型 备注 VREF+ 正模拟参考电压输入 DAC 高/正参考电压，1.8V≤VREF+≤VDDA VDDA 模拟电源输入 模拟电源 VsSA 模拟电源接地输入 模拟电源接地 DAC_OUTx 模拟输出信号 DAC 通道×模拟输出 201040420 数据格式 数据寄存器，是DAC数据转换的来源\n触发源 关闭触发时的转换时序\nDAC_DORx 无法直接写入，任何数据都必须通过加载 DAC_DHRx 寄存器（写入DAC_DHR8Rx、DAC_DHR12Lx、DAC_DHR12Rx、DAC_DHR8RD、DAC_DHR12LD 或DAC_DHR12LD）才能传输到 DAC 通道 x。\n如果未选择硬件触发（DAC_CR 寄存器中的 TENx 位复位），那么经过一个 APB1 时钟周期后，DAC_DHRx 寄存器中存储的数据将自动转移到 DAC_DORx 寄存器。但是，如果选择硬件触发（置位 DAC_CR 寄存器中的 TENx 位）且触发条件到来，将在三个 APB1 时钟周期后进行转移。\n当 DAC_DORx 加载了 DAC_DHRx 内容时，模拟输出电压将在一段时间 t SETTLING 后可用，具体时间取决于电源电压和模拟输出负载。\n源 类型 TSEL[2:0] Timer 6 TRGO event 片上定时器的内部信号 外部引脚 000 Timer 8 TRGO event : 001 Timer 7 TRGO event : 010 Timer 5 TRGO event : 011 Timer 2TRGOevent : 100 Timer 4 TRGO event : 101 EXTI line9 外部引脚 110 SWTRIG 软件控制位 111 DMA请求 每个 DAC 通道都具有 DMA 功能。两个 DMA 通道用于处理 DAC 通道的 DMA 请求。当 DMAENx 位置 1 时，如果发生外部触发（而不是软件触发），则将产生 DAC DMA 请求。DAC_DHRx 寄存器的值随后转移到 DAC_DORx 寄存器。\n在双通道模式下，如果两个 DMAENx 位均置 1，则将产生两个 DMA 请求。如果只需要一个DMA 请求，应仅将相应 DMAENx 位置 1。这样，应用程序可以在双通道模式下通过一个DMA 请求和一个特定 DMA 通道来管理两个 DAC 通道。\n输出电压 经过线性转换后，数字输入会转换为 0 到 V REF+ 之间的输出电压。各DAC通道引脚的模拟输出电压通过以下公式确定：\n这里的4096和256分别是2^12 2^8\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/dma/",
    "title": "DMA",
    
    "content": " 参考链接 【STM32】 DMA原理，步骤超细详解，一文看懂DMA-CSDN博客\n概述 [!IMPORTANT]\nDMA传输无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现过程\n通过硬件为RAM和IO设备开辟一条直接传输数据的通道，使得CPU的效率大大提高\n作用：为CPU减负\n一般而言，DMA控制器将包括一条地址总线、一条数据总线和控制寄存器。高效率的DMA控制器将具有访问其所需要的任意资源的能力，而==无须处理器==本身的介入，它必须能==产生中断==。最后，它必须能在控制器内部计算出地址。\n一个处理器可以包含多个DMA控制器。每个控制器有多个DMA通道，以及多条直接与存储器站(memory bank)和外设连接的总线。在很多高性能处理器中集成了两种类型的DMA控制器：\n第一类通常称为“系统DMA控制器”，可以实现对任何资源(外设和存储器)的访问，对于这种类型的控制器来说，信号周期数是以系统时钟(SCLK)来计数的，以ADI的Blackfin处理器为例，频率最高可达133MHz。 第二类称为内部存储器DMA控制器(IMDMA)，专门用于内部存储器所处位置之间的相互存取操作。因为存取都发生在内部(L1－L1、L1－L2，或者L2－L2)，周期数的计数则以内核时钟(CCLK)为基准来进行，该时钟的速度可以超过600MHz。 graph LR subgraph a[处理器] L1存储器 \u003c--DMA内核总线--\u003e DMA控制器 L2存储器 \u003c--DMA系统总线--\u003e DMA控制器 \u003c--DMA存取总线--\u003e 外设 end DMA控制器 \u003c--DMA外部总线--\u003e L3存储器 DMA的传输方式 DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节，主要涉及四种情况的数据传输，但本质上是一样的，都是从内存的某一区域传输到内存的另一区域（外设的数据寄存器本质上就是内存的一个存储单元）。四种情况的数据传输如下：\n外设到内存 内存到外设 内存到内存 外设到外设 DMA传输参数 数据传输的核心参数：\n数据源地址 数据传输位置的目标地址 传递护具多少的数据传输量 进行多少次传输的传输模式 当用户将参数设置好，主要涉及源地址、目标地址、传输数据量这三个，DMA控制器就会启动数据传输，当剩余传输数据量为0时 达到传输终点，结束DMA传输 ，当然，DMA 还有循环传输模式 当到达传输终点时会重新启动DMA传输。\n[!NOTE]\n也就是说只要剩余传输数据量不是0，而且DMA是启动状态，那么就会发生数据传输。　DMA的主要特征 每个通道都直接连接专用的硬件DMA请求，每个通道都同样支持软件触发。这些功能通过软件来配置；\n在同一个DMA模块上，多个请求间的优先权可以通过软件编程设置（共有四级：很高、高、中等和低），优先权设置相等时由硬件决定（请求0优先于请求1，依此类推）； 独立数据源和目标数据区的传输宽度（字节、半字、全字），模拟打包和拆包的过程。源和目标地址必须按数据传输宽度对齐； 支持循环的缓冲器管理； 每个通道都有3个事件标志（DMA半传输、DMA传输完成和DMA传输出错），这3个事件标志逻辑或成为一个单独的中断请求； 存储器和存储器间的传输、外设和存储器、存储器和外设之间的传输； 闪存、SRAM、外设的SRAM、APB1、APB2和AHB外设均可作为访问的源和目标； 可编程的数据传输数目：最大为65535。 存储器映像 类型 起始地址 存储器 用途 ROM 0x0800 0000 程序存储器Flash 存储C语言编译后的程序代码 : 0x1FFF F000 系统存储器 存储BootLoader，用于串口下载 : 0x1FFF F800 选项字节 存储一些独立于程序代码的配置参数 RAM 0x2000 0000 运行内存SRAM 存储运行过程中的临时变量 : 0x4000 0000 外设寄存器 存储各个外设的配置参数 : 0xE000 0000 内核外设寄存器 存储内核各个外设的配置参数 DMA 系统框图 flash为主闪存，SRAM为运行内存，各个外设可以看作是寄存器，也是一种SRAM存储器，实际上，我们可以将这个框图看作是一个cpu（cortex-M3）和存储器（框图中的所有）\n寄存器是一种特殊的存储器：\n一方面，CPU可以对寄存器进行读写，就像是读写运行内存一样 另一方面，寄存器的每一位背后，都连接了一根导线，这些导线可以控制外设的电路状态，如置引脚高低电平、导通和断开开关、切换数据选择器 在总线矩阵的左端，是主动单元，也就是拥有存储器的访问权，总线矩阵的右端，是被动单元，它们的存储器只能被左边的主动单元读写\n数据流动 在有无DMA时，ADC采集的数据是如何流动的？\n数据流动方向*==ADC数据寄存器-\u0026gt;SRAM==*\n没有DMA\nCPU传输数据需要以内核作为中转站\n内核作为主机通过*==Dcode-\u0026gt;总线矩阵-\u0026gt;AHB从设备中存储的外设ADC采集的数据==*\n内核再通过*==Dcode-\u0026gt;总线矩阵-\u0026gt;SRAM将得到的数据放到SRAM中==*\n有DMA\nDMA传输时外设对DMA控制器（DMA1，DMA2）发送请求\nDMA控制器收到请求，出发DMA工作\nDMA控制器从AHB外设获取的ADC采集的数据，存储到DMA通道中（通道1-7）\nDMA控制器的DMA总线与总线矩阵协调，使用AHB把外设ADC采集的数据经由DMA通道存放到SRAM中，这个数据传输过程中，完全不需要内核参与\nDMA请求 在发生一个事件后，外设向DMA控制器发送一个请求信号。DMA控制器根据通道的优先权处理请求。当DMA控制器开始访问发出请求的外设时，DMA控制器立即发送给它一个应答信号。当从DMA控制器得到应答信号时，外设立即释放它的请求。一旦外设释放了这个请求，DMA控制器同时撤销应答信号。DMA传输结束，如果有更多的请求时，外设可以启动下一个周期。\n总之，每次DMA传送由3个操作组成：\n从外设数据寄存器或者从当前外设/存储器地址寄存器指示的存储器地址取数据，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元； 存数据到外设数据寄存器或者当前外设/存储器地址寄存器指示的存储器地址，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元； 执行一次DMA_CNDTRx寄存器的递减操作，该寄存器包含未完成的操作数目。 DMA通道 DMA资源数量\n对于大容量的STM32芯片有2个DMA控制器 DMA1有七个通道，DMA2有5个通道，每个通道都可以配置一些外设的地址 DMA传输通道\n每个通道都可以有固定地址的外设寄存器和存储器地址之间执行DMA传输，DMA传输的数据量是可编程的，最大可达到65535，包含要传输的数据向数量的寄存器，在每次传输后递减 存储器到存储器模式\nDMA通道的操作可以在没有外设请求的情况下进行，这种操作就是存储器到存储器模式 当设置了DMA_CCRx寄存器中的MEM2MEM位之后，在软件设置了DMA_CCRx寄存器中的EN位启动DMA通道时，DMA传输将马上开始。当DMA_CNDTRx寄存器变为0时，DMA传输结束。存储器到存储器模式不能与循环模式同时使用。 这里要注意仅 DMA2 的外设接口可以访问存储器，所以仅 DMA2 控制器支持存储器到存储器的传输，DMA1 不支持。 存储器到存储器模式不能与循环模式同时使用。 DMA1 control\n从外设（TIMx[x=1、2、3、4]、ADC1、SPI1、SPI/I2S2、I2Cx[x=1、2]和USARTx[x=1、2、3]）产生的7个DMA请求，通过逻辑或输入到DMA1控制器 其中每个通道都对应着具体的外设： 外设 通道1 通道2 通道3 通道4 通道5 通道6 通道7 ADC1 ADC1 SPI/IIS SPI1_RX SPI1_TX SPI/2S2_RX SP/2S2_TX USART USART3_TX USART3_RX USART1_TX USART1_RX USART2_RX USART2_TX IIC 12C2_TX TIM1_TX4 12C2_RX I2C1_TX I2C1_RX TIM1 TIM1_CH1 TIM1_CH2 TIM1_TRIG TIM1_COM TIM1_UP TIM1_CH3 TIM2 TIM2_CH3 TIM2_UP TIM2_CH1 TIM2_CH2 TIM2_CH4 TIM3 TIM3_CH3 TIM3_CH4 TIM3_UP TIM3_CH1 TIM3_TRIG TIM4 TIM4_CH1 TIM4_CH2 TIM4_CH3 TIM4_UP DMA优先级 仲裁器\n仲裁器的作用是确定各个DMA传输的优先级 仲裁器根据通道请求的优先级来启动外设/存储器的访问 DMA优先级\n仲裁器管理DMA通道请求分为两个阶段： 第一阶段（软件阶段）：每个通道的优先级可在DMA_CCRx寄存器中设置，有四个等级：最高、高、中和低优先级。 第二阶段（硬件阶段）：如果两个请求有相同软件优先级，较低偏号的通道比较高偏号的通道有较高的优先级。(大容量芯片中，DMA1控制器拥有高于DMA2控制的优先级) 注意：多个请求通过逻辑或输入到DMA控制器，只能有一个请求有效。 DMA中断 每个DMA通道都可以在DMA传输过半、传输完成和传输错误时产生中断。为应用的灵活性考虑，通过设置寄存器的不同位来打开这些中断。\n中断事件 事件标志位 使能控制位 传输过半 HTIF HTIE 传输完成 TCIF TCIE 传输错误 TEIF TEIE DMA的内存占用 在STM32控制器中，芯片采用Cortex-MX架构，总线结构有了很大的优化，DMA占用另外的地址总线，并不会与CPU的系统总线发生冲突。也就是说，DMA的使用不会影响CPU的运行速度\n但是要注意：\nDMA 控制器和Cortex-M3核共享系统数据总线执行直接存储器数据传输。当CPU和DMA同时访问相同的目标(RAM或外设)时，DMA请求可能会停止 CPU访问系统总线达若干个周期，总线仲裁器执行循环调度，以保证CPU至少可以得到一半的系统总线(存储器或外设)带宽。\n工作过程 实验 DMA寄存器的配置参数包括：通道地址、优先级、数据传输方向、存储器/外设数据宽度、存储器/外设地址是否增量、循环模式、数据传输量。\n配置流程\n在DMA_CPARx寄存器中设置外设寄存器的地址。发生外设数据传输请求时，这个地址将 是数据传输的源或目标。 在DMA_CMARx寄存器中设置数据存储器的地址。发生外设数据传输请求时，传输的数 据将从这个地址读出或写入这个地址。 在DMA_CNDTRx寄存器中设置要传输的数据量。在每个数据传输后，这个数值递减。 在DMA_CCRx寄存器的PL[1:0]位中设置通道的优先级。 在DMA_CCRx寄存器中设置数据传输的方向、循环模式、外设和存储器的增量模式、外 设和存储器的数据宽度、传输一半产生中断或传输完成产生中断。 设置DMA_CCRx寄存器的ENABLE位，启动该通道。 void adc_init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE); RCC_ADCCLKConfig(RCC_PCLK2_Div6); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Pin = ADC_PIN; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(ADC_PORT,\u0026amp;GPIO_InitStruct); ADC_RegularChannelConfig(ADC3,ADC_Channel_4,1,ADC_SampleTime_55Cycles5); //配置规则通道组，填充菜单列表 ADC_InitTypeDef ADC_InitStruct; ADC_InitStruct.ADC_ContinuousConvMode = DISABLE; ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //软件触发 ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; ADC_InitStruct.ADC_NbrOfChannel = 1; ADC_InitStruct.ADC_ScanConvMode = DISABLE; ADC_Init(ADC3,\u0026amp;ADC_InitStruct); ADC_Cmd(ADC3,ENABLE); //开始校准 ADC_ResetCalibration(ADC3); //复位校准 while(ADC_GetResetCalibrationStatus(ADC3) != RESET); //等待复位校准完成 ADC_StartCalibration(ADC3); //开始校准 while(ADC_GetCalibrationStatus(ADC3) == SET);//等待校准完成 } u16 ad_getValue(void) { ADC_SoftwareStartConvCmd(ADC3,ENABLE); while(ADC_GetFlagStatus(ADC3,ADC_FLAG_EOC) == RESET); //等待转换完成，也就是EOC信号 return ADC_GetConversionValue(ADC3); //读取完数据将会自动清除数据位 } u8 data1[] = {0x01, 0x02, 0x03, 0x04}; u8 data2[] = {0, 0, 0, 0}; int main(void){ char str[50]; serial_init(); sprintf(str,\u0026#34;addr1: %x origin 1: %u %u %u %u\\n\u0026#34;,(u32)data1,data1[0],data1[1],data1[2],data1[3]); send_string(str); sprintf(str,\u0026#34;addr2: %x origin 2: %u %u %u %u\\n\u0026#34;,(u32)data2,data2[0],data2[1],data2[2],data2[3]); send_string(str); dma_init((u32)data1,(u32)data2,4); while(1){ data1[0]++; data1[1]++; data1[2]++; data1[3]++; dma_transfer(); sprintf(str,\u0026#34;addr1: %x origin 1: %u %u %u %u\\n\u0026#34;,(u32)data1,data1[0],data1[1],data1[2],data1[3]); send_string(str); sprintf(str,\u0026#34;addr2: %x origin 2: %u %u %u %u\\n\u0026#34;,(u32)data2,data2[0],data2[1],data2[2],data2[3]); send_string(str); dma_init((u32)data1,(u32)data2,4); Delay_s(2); } } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/flash/",
    "title": "Flash",
    
    "content": " 概述 STM32F1系列的FLASH包含程序存储器、系统存储器和选项字节三个部分，通过闪存存储器接口（外设）可以对程序存储器和选项字节进行擦除和编程 读写FLASH的用途： 利用程序存储器的剩余空间来保存掉电不丢失的用户数据 通过在程序中编程(IAP),实现程序的自我更新 在线编程(ln-Circuit Programming-ICP)用于更新程序存储器的全部内容，它通过JTAG、SWD协议或系统加载程序(Bootloader)下载程序 在程序中编程(ln-Application Programming-IAP）可以使用微控制器支持的任一种通信接口下载程序 芯片型号 主频 (MHz) FLASH容量(B) SRAM容量（ (B) STM32F103RCT6 72 256K 48K STM32F103ZET6 72 512K 64K STM32F407ZGT6 168 1024K 192K STM32F429IGT6 180 1024K 256K STM32F76IGT6 216 1024K 512K STM32H7431IT6 480 2048K 1060K STM32F750N8H6 216 64K 320K STM32H750XBH6 400 128K 1060K STM32H750VBT6 480 128K 1060K 内部构成 内部FLASH主要由三部分组成：\n主存储器 信息块 闪存存储器接口寄存器。 闪存模块的子部分 作用 主存储器 用来存放代码和数据常数 （如const类型到的数据） 信息块 分为两个部分：系统存储（启动程序代码）、选项字节（用户选择字节) 闪存存储器接口寄存器 用于控制闪存读写等，是整个闪存模块的控制结构 主存储器：地址范围为0x08000000~0x0807FFFF,分为256页，每页2KB(小/中容量为1K)。当BOOT0接地，系统将从0x08000000地址处开始读取代码（从主存储器启动）。\n信息块：系统存储大小为2KB,用来存储ST自带的启动程序，用来串口下载代码。选项字节大小为16B,一般用于设置内存的写保护、读保护。当BOOT0接VCC,BOOT1接GND(串口下载程序)，系统运行的就是这部分代码。\n基本结构 控制器实际上是闪存的管理员，它可以对程序存储器进行擦除和编程，也可以对选项字节进行擦除和编程，系统存储器是不能擦除和编程的。\n选项字节 一共16个字节，其中有一半的名称前面都带了n，也就是在写入RDP数据的时候，同时要在nRDP中写入数据的反码，如果芯片检测到这两个存储器不是反码的关系，则代表数据无效，有错误，对应的功能就不执行，这是一种安全保障措施\n地址 [31:24] [23:16] [15:8] [7:0] 0x1FFF F800 nUSER USER nRDP RDP 0x1FFF F804 nData1 Data1 nData0 Datao 0x1FFF F808 nWRP1 WRP1 nWRPO WRPO 0x1FFF F80C nWRP3 WRP3 nWRP2 WRP2 RDP:写入RDPRT键(OxO00000A5)后解除读保护 USER：配置硬件看门狗和进入停机/待机模式是否产生复位 Data0/1:用户可自定义使用 WRP0/1/2/3:配置写保护，每一个位对应保护4个存储页（中容量) 选项字节编程 检查FLASH SR的BSY位，以确认没有其他正在进行的编程操作 解锁FLASH CR的OPTWRE位 设置FLASH CR的OPTPG位为1 写入要编程的半字到指定的地址 等待BSY位变为0 读出写入的地址并验证数据 选项字节擦除 检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作 解锁FLASH CR的OPTWRE位 设置FLASH_CR的OPTER位为1 设置FLASH CR的STRT位为1 等待BSY位变为0 读出被擦除的选择字节并做验证 器件电子签名 电子签名存放在闪存存储器模块的系统存储区域，包含的芯片识别信息在出厂时编写，不可更改，使用指针读指定地址下的存储器可获取电子签名\n闪存容量寄存器：\n基地址：0x1FFFF7E0 大小：16位 产品唯一身份标识寄存器：\n基地址：0x1FFFF7E8 大小：96位 读写过程 对FLASH的核心操作就是==读==和==写==。\n[!IMPORTANT]\nFLASH的物理特性：只能写0，不能写1，写1靠擦除。\nFLASH解锁 FPEC共有三个键值：\nRDPRT键=0x000000A5 KEY1 = 0x45670123 KEY2 = 0xCDEF89AB 解锁：\n复位后，FPEC被保护，不能写入FLASH_CR，所以说是默认锁着 在FLASH_KEYR先写入KEY1，再写入KEY2，解锁，这里有两道锁 错误的操作序列会在下次复位前索斯FPEC和FLASH_CR 加锁：\n设置FLASH_CR中的LOCK位所著FPEC和FLASH_CR 使用指针访问存储器 // 使用指针读指定地址下的存储器： uint16 t Data *((__IO uint16_t *)(0x08000000)); // 使用指针写指定地址下的存储器： *((__IO uint16_t*)(0x0800000))=0x1234; // 其中： #define __IO volatile STM32内部的存储器是直接挂载在总线上的，所以这时再读写某个存储器就非常简单了，可以直接使用指针就可以访问\n在数据类型前面加上volatile是一个安全保障措施，就是防止编译器优化\nkeil编译器在默认情况下是最低优化等级，加不加volatile都没有影响，如果提高优化等级，那么程序可能会出现一定的问题\n假设想用变量计数空循环的方式实现延时函数，那么在编译器优化的时候可能会觉得延时函数没有作用，可能会直接将这段代码优化掉，加上volatile之后会告诉编译器，无论对这个变量做什么，都不能优化，需要原封不动的去执行。\n此外，编译器还会利用缓存来加速代码，最常见的优化方式就是把变量转移到高速缓存里来，在stm32内核里，有一个类似缓存的工作组寄存器，这些寄存器的访问速度最快，先将变量放到缓存中，需要读写的时候直接访问缓存即可，用完之后再写回内存。但是如果程序中有多个线程，比如中断函数，在中断函数里，改变某个原始变量，缓存可能并不知道变量已经改变，下次读写的时候，程序还看缓存中的变量，就会造成数据更改不同步的问题，这时，解决的方法是读取变量定义前面加上volatile，告诉编译器这个变量是易变的，每次读取都应该从内存中读取，而不是从缓存中读取\n闪存的读取 直接在通用地址空间直接寻址，任何32位数据的读操作都能访问闪存模块的内容并得到相对应的据。\nCPU运行速度比FLASH快得多，STM32F103的FLASH最快访问速度≤24MHz,CPU频率超过这个速度，得加入等待时间，否则读写FLASH可能出错，导致死机等情况。\n频率范围 等待周期数(LATENCY) 0\u0026lt; SYSCLK \u0026lt;2 24MHz 0个等待周期 24MHz \u0026lt; SYSCLK ≤ 48MHz 1个等待周期 48MHz\u0026lt; SYSCLK≤72MHz 2个等待周期 正确设置好等待周期后，利用指读取据。\n从地址addr,读取数据（字节为8位，半字为16位，字为32位）\n/*读取一个字节数据*/ data = *(volatile uint8 t *)addr; /*读取一个半字数据*/ data *(volatile uint16 t *)addr; /*读取一个字据*/ data *(volatile uint32 t )addr; // 将addr强制转换为uintx_t指针，然后取该指针所指向地址的值，即可获得addr地址的据。 // 注意：在进行写或擦除操作时，不能进行代码或据的读取操作。 // 写操作：*(volatile uint16t)addr=data?并不全是 闪存的写入 闪存编程是由FPEC(闪存编程和擦除控制器)模块处理的。\n写操作有四步：==解锁→擦除→写数据→上锁==\n编程过程 首先读取LOCK位，看看芯片锁没锁 Lock = 1代表被锁，执行解锁过程，在KEYR寄存器中先写入KEY1，再写入KEY2，在库函数中没有判断过程，不管锁没锁都执行解锁操作 首先置控制寄存器中的STRT 为1，STRT为1是触发条件，这个时候芯片才能开始工作。之后将PG位（programming编程）置为1，代表进行的操作是进行写入 在指定的地址写入半字（16位），这时就可以使用指针写入数据，这里只能以半字写入 擦除开始后，程序需要等待一段时间，判断状态寄存器的BSY是否为1，BSY代表芯片是否处于忙状态，BSY为1代表芯片忙 闪存页擦除过程 首先读取LOCK位，看看芯片锁没锁 Lock = 1代表被锁，执行解锁过程，在KEYR寄存器中先写入KEY1，再写入KEY2，在库函数中没有判断过程，不管锁没锁都执行解锁操作 首先置控制寄存器中的STRT 为1，STRT为1是触发条件，这个时候芯片才能开始工作。之后将PER（page erase页擦除）置为1，代表进行的操作是页擦除，在AR地址寄存器中写入需要擦除的页地址 擦除开始后，程序需要等待一段时间，判断状态寄存器的BSY是否为1，BSY代表芯片是否处于忙状态，BSY为1代表芯片忙 闪存全擦除过程 首先读取LOCK位，看看芯片锁没锁 Lock = 1代表被锁，执行解锁过程，在KEYR寄存器中先写入KEY1，再写入KEY2，在库函数中没有判断过程，不管锁没锁都执行解锁操作 首先置控制寄存器中的STRT 为1，STRT为1是触发条件，这个时候芯片才能开始工作。之后将MER（mass erase全擦除）置为1，代表进行的操作是全擦除 擦除开始后，程序需要等待一段时间，判断状态寄存器的BSY是否为1，BSY代表芯片是否处于忙状态，BSY为1代表芯片忙 闪存的擦除和写入 ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/fs/flashdb/",
    "title": "FlashDB",
    
    "content": " 参考链接 FlashDB/README_zh.md at master · armink/FlashDB (github.com)\n基本概念 键值数据库（KVDB）：是一种非关系数据库，它将数据存储为键值（Key-Value）对集合，其中键作为唯一标识符。KVDB 操作简洁，可扩展性强。 时序数据（TSDB） ：时间序列数据库 （Time Series Database , 简称 TSDB），它将数据按照 时间顺序存储 。TSDB 数据具有时间戳，数据存储量大，插入及查询性能高。 时序记录（TSL） ：TSL (Time series log)，是 TSDB 中每条记录的简称。 Blob ：在计算机中，blob 常常是数据库中用来存储二进制文件的字段类型。在 FlashDB 中， KV 和 TSL 都使用 blob 类型来存储，该类型可以兼容任意变量类型。 迭代器（iterator）：它可以让用户透过特定的接口巡访容器中的每一个元素，而不用了解底层的实现。 TSDB 和 KVDB 都支持通过迭代器对数据库进行遍历访问。 KVDB 字符串类型 使用一个名为 \u0026amp;quot;temp\u0026amp;quot; 的 KV 来存储温度值，分别演示了字符串 KV 从 创建-\u0026amp;gt;读取-\u0026amp;gt;修改-\u0026amp;gt;删除 的全过程。大致内容如下：\nvoid kvdb_type_string_sample(fdb_kvdb_t kvdb) { FDB_INFO(\u0026amp;#34;==================== kvdb_type_string_sample ====================\\n\u0026amp;#34;); { /* CREATE new Key-Value */ char temp_data[10] = \u0026amp;#34;36C\u0026amp;#34;; /* It will create new KV node when \u0026amp;#34;temp\u0026amp;#34; KV not in database. */ fdb_kv_set(kvdb, \u0026amp;#34;temp\u0026amp;#34;, temp_data); FDB_INFO(\u0026amp;#34;create the \u0026amp;#39;temp\u0026amp;#39; string KV, value is: %s\\n\u0026amp;#34;, temp_data); } { /* GET the KV value */ …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/git/",
    "title": "Git",
    
    "content": " Git 的基本概念 Git 是一个分布式版本控制系统，广泛用于软件开发中来跟踪代码变更、协作开发和版本管理。以下是 Git 的基本使用指南，涵盖常见的操作和命令。\nRepository（仓库）：存储项目及其版本历史的地方。 Commit（提交）：对文件或目录的快照。 Branch（分支）：代码开发的独立分支。 Merge（合并）：将分支的修改合并到主分支中。 Remote（远程）：存储在服务器上的仓库。 Git 的基本操作 安装 Git Windows：从 Git 官网 下载并安装。 macOS：使用 Homebrew 安装：brew install git Linux：使用包管理器安装，例如 Ubuntu：sudo apt-get install git 配置 Git git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your.email@example.com\u0026#34; 创建一个新的 Git 仓库 mkdir myproject cd myproject git init 克隆一个现有的仓库 git clone https://github.com/username/repository.git 检查仓库状态 git status 添加文件到仓库 git add filename git add . 提交更改 git commit -m \u0026#34;Commit message\u0026#34; 查看提交历史 git log 创建和切换分支 git branch new-branch git checkout new-branch 或者创建并切换到新分支\ngit checkout -b new-branch 合并分支 切换到你要合并到的分支（例如 main）\ngit checkout main git merge new-branch 删除分支 git branch -d new-branch 添加远程仓库 下面的栗子是添加一个远程仓库，远程仓库的名字为origin，url为https://github.com/username/repository.git\ngit remote add origin https://github.com/username/repository.git 推送到远程仓库 首次推送需要先设置公钥\nssh-keygen -t rsa -C \u0026#34;your_email@example.com\u0026#34; 生成密钥之后查看密钥文件中的内容，将密钥文件中的内容复制到github的设置中的SSH中即可开始推送\ncat ~/.ssh/id_rsa.pub 可使用以下命令测试密钥是否配置成功\nssh -T git@github.com 推送的语法为\ngit push [添加的仓库名] [仓库的分支名] 下面的栗子是向origin仓库的branch-name分支推送代码\ngit push origin branch-name 从远程仓库拉取更新 git pull origin branch-name 解决冲突 在合并或拉取过程中，如果有冲突，Git 会提示冲突文件。你需要手动解决冲突并提交解决后的更改。\n常用 Git 命令总结 git init：初始化一个新的 Git 仓库 git clone \u0026lt;repo\u0026gt;：克隆一个远程仓库 git status：查看仓库状态 git add \u0026lt;file\u0026gt;：添加文件到暂存区 git commit -m \u0026quot;message\u0026quot;：提交更改 git log：查看提交历史 git branch：列出分支 git checkout \u0026lt;branch\u0026gt;：切换到分支 git checkout -b \u0026lt;branch\u0026gt;：创建并切换到新分支 git merge \u0026lt;branch\u0026gt;：合并分支 git branch -d \u0026lt;branch\u0026gt;：删除分支 git remote add origin \u0026lt;url\u0026gt;：添加远程仓库 git push origin \u0026lt;branch\u0026gt;：推送分支到远程仓库 git pull origin \u0026lt;branch\u0026gt;：从远程仓库拉取分支更新 通过这些基本的 Git 操作和命令，你可以有效地管理和协作开发项目。\n.gitignore的使用规则 在Git中，.gitignore 文件用于告诉Git哪些文件和目录应该被忽略，不需要被版本控制。.gitignore 文件中的语法规则非常灵活，支持多种模式和通配符。以下是一些常用的语法规则和示例：\n注释：以 # 开头的行是注释。\n# 这是一个注释 忽略文件或目录：直接写文件或目录的名称。\n# 忽略所有 .log 文件 *.log # 忽略名为 temp 的目录 temp/ 通配符 *：匹配零个或多个字符。\n# 忽略所有 .log 文件 *.log # 忽略所有的临时文件 *~ 问号 ?：匹配任意一个字符。\n# 忽略所有扩展名为 .l?g 的文件（例如 .log 和 .l1g） *.l?g 方括号 []：匹配括号内的任意一个字符。\n# 忽略所有扩展名为 .log 或 .lbg 的文件 *.l[ob]g 斜杠 /：用于分隔目录。如果以 / 开头，表示相对于仓库根目录。如果以 / 结尾，表示一个目录。\n# 忽略根目录下的 temp 目录 /temp/ # 忽略所有子目录中的 temp 目录 temp/ 否定模式 !：将某些文件从忽略列表中排除。\n# 忽略所有的 .log 文件 *.log # 但不要忽略特定的 debug.log 文件 !debug.log 双星号 **：匹配任意目录深度。\n# 忽略任何子目录中的 temp 目录 **/temp/ # 忽略所有子目录中的 .log 文件 **/*.log 注释行中的 \\：用于转义字符。\n# 忽略所有以 # 开头的文件 \\#*.log 以下是一个示例 .gitignore 文件，结合了上述规则：\n# 忽略所有的 .log 文件 *.log # 忽略所有的临时文件 *~ # 忽略根目录下的 temp 目录 /temp/ # 忽略任何子目录中的 temp 目录 **/temp/ # 忽略所有子目录中的 .log 文件 **/*.log # 但不要忽略特定的 debug.log 文件 !debug.log 问题 如果使用ssh -T git@github.com命令显示Connection reset by 20.205.243.166 port 22，说明是网络有问题，可以在~/.ssh/config或C:\\Users\\Administrator\\.ssh文件中修改config(没有的话创建一个)内容如下：\nHost github.com Hostname ssh.github.com User git Port 443 IdentityFile ~/.ssh/id_rsa IdentityFile的内容要改为id_rsa的文件路径\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/gpio/",
    "title": "GPIO",
    
    "content": " 是什么 特点 不同型号，IO口数量可能不一样，可通过选型手册快速查询\n快速翻转，每次翻转最快只需要两个时钟周期（F1最高速度可以到50Mhz）\n每个IO口都可以做中断\n支持8种工作模式\n电气特性 基本结构 所有的GPIO都是挂载在APB2外设总线上的（每个GPIO包含16个引脚）\n在GPIO模块中包含寄存器和驱动器 寄存器是一段特殊的存储器，内核可以通过APB2总线对寄存器进行读写，这样就可以完成输出电平和读取电平的功能了，寄存器的每一位对应一个引脚，由于每个GPIO模块上面只有16个引脚，所以寄存器只有低16位用到了，高16位保留。驱动器用来增加信号的驱动能力，寄存器只负责存储数据。 端口的基本结构 保护二极管 对输入电压进行限幅，当电压比3.3v高，那么上方的保护二极管将会导通，电流就直接流到VDD，不会进入内部电路\n施密特触发器 在施密特触发器的箭头前面是数字量，在施密特触发器的后面的是模拟量\nP-MOS管和N-MOS管 输入输出模式 概述 输入输出都相对于ST芯片而言的，比如输入就是从io口进如芯片内部，输出就是信号从芯片到IO引脚\nGPIO八种模式 特点及应用 输入浮空 输入用，完全浮空，状态不定 输入上拉 输入用，用内部上拉，默认是高电平 输入下拉 输入用，用内部下拉，默认是低电平 模拟功能 ADC、DAC 开漏输出 软件IIC的SDA、SCL等 推挽输出 驱动能力强，25mA（max），通用输出 开漏式复用功能 片上外设功能（硬件IIC 的SDA、SCL引脚等） 推挽式复用功能 片上外设功能（SPI 的SCK、MISO、MOSI引脚等） 模式名称 性质 特征 浮空输入 数字输入 可读取引脚电平，若引脚悬空，则电平不确定 上拉输入 数字输入 可读取引脚电平，内部连接上拉电阻，悬空时默认高电平 下拉输入 数字输入 可读取引脚电平，内部连接下拉电阻，悬空时默认低电平 模拟输入 模拟输入 GPIO无效，引脚直接接入内部ADC 开漏输出 数字输出 可输出引脚电平，高电平为高阻态，低电平接VSS 推挽输出 数字输出 可输出引脚电平，高电平接VDD，低电平接VSS 复用开漏输出 数字输出 由片上外设控制，高电平为高阻态，低电平接VSS 复用推挽输出 数字输出 由片上外设控制，高电平接VDD，低电平接VSS 输入浮空 IO-\u0026gt;触发器-\u0026gt;读出\n模拟输入 模拟输入可以说是ADC模数转换器的专属配置\nIo-\u0026gt;模拟输入\n输入上拉 上下拉可以看作是一个弹簧，输入电压的时候就会操纵弹簧使电压为1或0.\n输入下拉 开漏输出 开漏复用输出 推挽输出 推挽复用输出 寄存器介绍 配置步骤 设置需要使用的GPIO外设时钟 设置GPIO模式（八种模式） 初始化GPIO口 int main(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); while (1) { GPIO_ResetBits(GPIOA, GPIO_Pin_0); Delay_ms(500); GPIO_SetBits(GPIOA, GPIO_Pin_0); Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET); Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET); Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)0); Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)1); Delay_ms(500); } } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/iic/",
    "title": "IIC",
    
    "content": " 参考链接 STM32 IIC通讯协议详解—小白入门_stm32 iic速率修改-CSDN博客\n概述 IIC:Inter Integrated Circuit,集成电路总线，是一种同步串行半双工通信总线。\n总线：传输数据的通道\n协议：传输数据的规则\n物理层 物理层描述：\n它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个IIC通信总线中，可连接==多个IIC通信设备==，支持多个通信主机及多个通信从机。 一个IIC总线只使用两条总线线路。 一条双向串行数据线（SDA），数据线用来表示数据 一条串行时钟线（SCL），时钟线用于同步数据的收发。 每个连接到总线的设备都有一个==独立==的地址，主机可以利用这个地址进行不同设备之间的访问。 总线通过上拉电阻接到电源。 当IIC设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态，由上拉电阻把总线拉成高电平。 当总线上开始发送数据，会将总线拉低，所以同一时刻，总线上只能有一条数据 多个主机同时使用总线时，为了防止数据冲突，会利用==仲裁==的方式决定由哪个设备占用总线。 具有三种传输模式： 标准模式传输速率为100kbps 快速模式为400kbps 高速模式可达3.4Mbps，但目前大多IIC设备尚不支持高速模式。 连接到相同总线的IIC设备数量收到总线的最大电容400pF限制。 在一主多从的情况下\n主机拥有SCL的绝对控制权，所以主机的SCL可以配置成推挽输出，所有从机的SCL都配置成浮空输入或者上拉输入，主机发送，从机接收\n由于是半双工的协议，所以主机的SDA在发送的时侯是输出，在接收的时候是输入，同样的，从机的SDA也会在输入和输出之间反复切换，为了协调这一点，==禁止所有设备输出强上拉的高电平，采用外置弱上拉电阻加开漏输出的电路结构==。\n图中的SCLK就是连接的结构图的SCL，SDA同理，所以才规定SCL和SDA都必须配置成==开漏输出==模式\n如果使用的是推挽输出，那么当SDA释放时，输出为强。 上图就是主机内部结构，左边为SCL，右侧为SDA，SCL经过一个施密特触发器对数据进行缓冲，任何设备在任何时候都是可以输入的。 输出低电平时，下管导通，强下拉，输出高电平时，下管断开，但是没有上管了，此时引脚属于浮空的状态，这样的话所有的设备只能输出低电平，而不能输出高电平，为了避免输出出现浮空状态，在外部添加一个上拉电阻（弱上拉），这样做的好处 完全杜绝了电源短路的现象，保证电路的安全 避免了引脚模式的频繁切换，开漏加弱上拉的模式，同时兼具了输入和输出的功能，如果想输出，就去拉杆子或者放手，操作杆子的变化即可，如果想输入，只需要直接放手，然后观察杆子的高低即可 存在线与的现象，只要有一个或者多个设备输出了低电平，总线就处于低电平，只有所有的设备都输出高电平，总线才处于高电平 协议层 基本时序单元 开始\nSCL初始保持高电平也是通过上拉电阻实现的，默认输出高电平\n如果想要开始通讯，就先将SDA拉下来，当从机捕获到SCL高电平且SDA==下降沿==信号时，就会进行自身的复位，等待主机的召唤，主机将SCL拉下来，将SCL拉下来一方面是为了占用这个总线，另外一方面也方便基本单元的拼接\nSCL高电平期间，SDA从高电平切换到低电平\n结束\n和起始相反，结束信号是SCL先放手，SDA再放手，产生一个上升沿，这个上升沿触发终止条件\nSCL高电平期间，SDA从低电平切换到高电平\n发送\n发送一个字节：SCL低电平期间，主机将数据位依次放到SDA线上(高位先行)，然后释放SCL,从机将在SCL高电平期间读取数据位所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节\n[!NOTE]\nI2C是高位先行，也就是先发送最高位B7，串口是低位先行。SCL低电平期间，允许改变SDA电平，也就是说在低电平期间，SDA可以切换1或0。当SCL变成高电平时，从机读取SDA，所以高电平期间，SDA不允许变化，一般都是在上升沿这个时刻，从机就已经完成了读取。从图中可以看出，主机基本上不用着急数据的存放读取，因为主机有时钟的主导权，但是从机就必须要尽快的读取和存放数据.可以理解为所有设备和从机都始终处于输入模式。当主机需要发送的时候，就可以主动去拉低SDA，而主机在被动接收的时候，就必须先释放SDA\n发送应答：主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答\n接收\n接收一个字节：SCL低电平期间，从机将数据位依次放到SDA线上(高位先行)，然后释放SCL,主机将在SCL高电平期间读取数据位所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA)\n[!TIP]\n要理解一旦有一个设备为低电平，整个总线都为低电平。当主机将SDA松开时（发送完一个字节的数据之后），如果没有设备下拉为低电平，那么整条总线就为高电平，说明没有设备给予应答，但是一旦有设备下拉SDA，就说明有设备收到数据，且给出应答\n接收应答：主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA)\n基本读写过程 S 表示由主机的 I2C 接口产生的传输起始信号(S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。 起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号(SLAVE_ADDRESS)。在 I2C 总线上，每个设备的地址都是唯一的（每个从机地址码不同，如果相同，可以通过调整从机上的引脚改变从机地址） 当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7 位或 10 位。 七位地址就是第一个字节就是地址+读写方向 十位地址就是使用两个字节作为地址，其中前面是标志位，表示使用10位地址，即11110+地址+读写方向。 在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。 从机接收到匹配的地址后，主机或从机会返回一个应答(ACK)或非应(NACK)信号，只有接收到应答信号后，主机才能继续发送或接收数据。 写数据\n若配置的方向传输位为“写数据”方向，广播完地址，接收到应答信号后，一般设备都会向从机发送一个寄存器的地址，用于目标寄存器，当收到应答时，主机开始正式向从机传输数据(DATA)，数据包的大小为 8位，主机每发送完一个字节数据，都要等待从机的应答信号(ACK)，重复这个过程，可以向从机传输 N 个数据，这个 N 没有大小限制。当数据传输结束时，主机向从机发送一个停止传输信号§，表示不再传输数据。\n读数据 若配置的方向传输位为“读数据”方向，广播完地址，接收到应答信号后:\n未指定地址读 主机立马就开始读取数据，但是没有指定寄存器地址，那么从机是读的哪里的数据呢？ 实际上在从机中，所有的寄存器被分配到了一个线性区域中，并且有一个单独的指针变量。指示其中一个寄存器，这个指针上电默认指向0地址，并且没写入或者读取一个字节后，这个指针就会自动自增一次，移动到下一个位置。 所以当主机要读取数据时，主机没有指定读取哪个地址，从机就会返回当前指针指向的寄存器中的值。 指定地址读 主机会发送一个写操作，接收到应答之后，主机会再次发送一个字节，用来指定需要读的地址，当从机接收到这个地址之后就会将寄存器指针改写为接收到的地址。这个时候我们就要切换成读数据模式了，所以要重新发送一个起始信号，重新开始读 从机开始向主机返回数据(DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号(ACK)，重复这个过程，可以返回 N 个数据，这个 N 也没有大小限制。当主机希望停止接收数据时，就向从机返回一个非应答信号(NACK)，则从机自动停止数据传输。\n读和写数据\n除了基本的读写，I2C 通讯更常用的是复合格式，该传输过程有两次起始信号(S)。一般在第一次传输中，主机通过SLAVE_ADDRESS 寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与 SLAVE_ADDRESS 的区别)；在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。\n数据的有效性\nIIC 使用 SDA 信号线来传输数据，使用 SCL 信号线进行数据同步。SDA数据线在 SCL 的每个时钟周期传输一位数据。传输时，SCL 为高电平的时候 SDA 表示的数据有效，即此时的 SDA 为高电平时表示数据“1”，为低电平时表示数据“0”。当 SCL为低电平时，SDA 的数据无效，一般在这个时候 SDA 进行电平切换，为下一次表示数据做好准备。\n地址和数据方向\nI2C 总线上的每个设备都有自己的独立地址，主机发起通讯时，通过 SDA 信号线发送设备地址(SLAVE_ADDRESS)来查找从机。I2C 协议规定设备地址可以是 7 位或 10 位，实际中 7 位的地址应用比较广泛。紧跟设备地址的一个数据位用来表示数据传输方向，它是数据方向位(R/W)，第 8 位或第 11 位。数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写数据。\n响应\nI2C 的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。作为数据接收端时，当设备(无论主从机)接收到 I2C 传输的一个字节数据或地址后，若希望对方继续发送数据，则需要向对方发送“应答(ACK)”信号，发送方会继续发送下一个数据；若接收端希望结束数据传输，则向对方发送“非应答(NACK)”信号，发送方接收到该信号后会产生一个停止信号，结束信号传输。\n完整的传输过程 IIC架构 通信引脚 I2C 的所有硬件架构都是根据图中左侧 SCL 线和 SDA 线展开的(其中的SMBA 线用于SMBUS 的警告信号，I2C 通讯没有使用)。STM32 芯片有多个 I2C 外设，它们的 I2C 通讯信号引出到不同的 GPIO 引脚上，使用时必须配置到这些指定的引脚。\n时钟的控制逻辑 SCL 线的时钟信号，由 I2C 接口根据时钟控制寄存器(CCR)控制，控制的参数主要为时钟频率。配置 I2C 的 CCR 寄存器可修改通讯速率相关的参数：可选择 I2C 通讯的“标准/快速”模式，这两个模式分别 I2C 对应 100/400Kbit/s 的通讯速率。\n在快速模式下可选择 SCL 时钟的占空比，可选 Tlow/Thigh=2 或Tlow/Thigh=16/9模式，我们知道 I2C 协议在 SCL 高电平时对 SDA 信号采样，SCL 低电平时 SDA准备下一个数据，修改 SCL 的高低电平比会影响数据采样，但其实这两个模式的比例差别并不大，若不是要求非常严格，这里随便选就可以了。\nCCR 寄存器中还有一个 12 位的配置因子 CCR，它与 I2C 外设的输入时钟源共同作用，产生 SCL 时钟，STM32 的 I2C 外设都挂载在 APB1 总线上，使用 APB1 的时钟源 PCLK1，SCL 信号线的输出时钟公式如下：\n$$ Thigh = CCR*TPCKL1 \\\\ Tlow = CCR*TPCLK1 $$$$ Thigh = CCR*TPCKL1 \\\\ Tlow = 2*CCR*TPCKL1 $$$$ Thigh = 9*CCR*TPCKL1 \\\\ Tlow = 16*CCR*TPCKL1 $$ 例如，我们的 PCLK1=36MHz，想要配置 400Kbit/s 的速率，计算方式如下：\nPCLK 时钟周期： TPCLK1 = 1/36000000\n目标 SCL 时钟周期： TSCL = 1/400000\nSCL 时钟周期内的高电平时间： THIGH = TSCL/3\nSCL 时钟周期内的低电平时间： TLOW = 2TSCL/3\n计算 CCR 的值： CCR = THIGH/TPCLK1 = 30\n计算结果得出 CCR 为 30，向该寄存器位写入此值则可以控制 IIC 的通讯速率为400KHz，其实即使配置出来的 SCL 时钟不完全等于标准的 400KHz，IIC 通讯的正确性也不会受到影响，因为所有数据通讯都是由 SCL 协调的，只要它的时钟频率不远高于标准即可。\n数据控制逻辑 I2C 的 SDA 信号主要连接到数据移位寄存器上，数据移位寄存器的数据来源及目标是数据寄存器(DR)、地址寄存器(OAR)、PEC 寄存器以及 SDA 数据线。\n当向外发送数据的时候，将一个字节的数据写入到数据寄存器（DR）中，数据移位寄存器以“数据寄存器”为数据源，把数据一位一位地通过 SDA 信号线发送出去。这时，置状态寄存器的TEX位为1，表示发送寄存器为空；\n当从外部接收数据的时候，数据移位寄存器把 SDA 信号线采样到的数据一位一位地存储到移位寄存器中，当一个字节的数据收齐之后，数据就整体从移位寄存器转到数据寄存器中，同时置RXNE，表示接收寄存器非空。\n若使能了数据校验，接收到的数据会经过 PEC 计算器运算，运算结果存储在“PEC 寄存器”中。\n当 STM32 的 I2C 工作在从机模式的时候，接收到设备地址信号时，数据移位寄存器会把接收到的地址与 STM32 的自身“I2C 地址寄存器”的值作比较，以便响应主机的寻址。STM32 的自身 I2C 地址(自定义地址)可通过修改“自身地址寄存器”修改，支持同时使用两个 I2C 设备地址，两个地址分别存储在 OAR1 和 OAR2 中，当有主机广播从机地址时，通过比较器比较，发现相同，则会作为从机响应外部主机的召唤。\n整体逻辑控制 整体控制逻辑负责协调整个 I2C 外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1/CR2)”的参数而改变。在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器(SR1 和 SR2)”，我们只要读取这些寄存器相关的寄存器位，就可以了解 I2C的工作状态。除此之外，控制逻辑还根据要求，负责控制产生 I2C 中断信号、DMA 请求及各种 I2C 的通讯信号(起始、停止、响应信号等)。\n通信过程 使用 I2C 外设通讯时，在通讯的不同阶段它会对“状态寄存器(SR1 及 SR2)”的不同数据位写入参数，我们通过读取这些寄存器标志来了解通讯状态。\n主发送器 主发送器发送流程及事件说明如下：\n(1) 控制产生起始信号(S)，当发生起始信号后，它产生事件“EV5”，并会对 SR1 寄存器的“SB”位置 1，表示起始信号已经发送；\n(2) 紧接着发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”及“EV8”，这时 SR1 寄存器的“ADDR”位及“TXE”位被置 1，ADDR 为 1 表示地址已经发送，TXE 为 1 表示数据寄存器为空；\n(3) 以上步骤正常执行并对 ADDR 位清零后，我们往 I2C 的“数据寄存器 DR”写入要发送的数据，这时 TXE 位会被重置 0，表示数据寄存器非空，I2C 外设通过SDA 信号线一位位把数据发送出去后，又会产生“EV8”事件，即 TXE 位被置 1，重复这个过程，就可以发送多个字节数据了；\n(4) 当我们发送数据完成后，控制 I2C 设备产生一个停止信号§，这个时候会产生EV8_2 事件，SR1 的 TXE 位及 BTF 位都被置 1，表示通讯结束。\n主接受器 主接收器接收流程及事件说明如下：\n(1) 同主发送流程，起始信号(S)是由主机端产生的，控制发生起始信号后，它产生事件“EV5”，并会对 SR1 寄存器的“SB”位置 1，表示起始信号已经发送；\n(2) 紧接着发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”这时SR1 寄存器的“ADDR”位被置 1，表示地址已经发送。\n(3) 从机端接收到地址后，开始向主机端发送数据。当主机接收到这些数据后，会产生“EV7”事件，SR1 寄存器的 RXNE 被置 1，表示接收数据寄存器非空，我们读取该寄存器后，可对数据寄存器清空，以便接收下一次数据。此时我们可以控制 I2C 发送应答信号(ACK)或非应答信号(NACK)，若应答，则重复以上步骤接收数据，若非应答，则停止传输；\n(4) 发送非应答信号后，产生停止信号§，结束传输。\n在发送和接收过程中，有的事件不只是标志了我们上面提到的状态位，还可能同时标志主机状态之类的状态位，而且读了之后还需要清除标志位，比较复杂。我们可使用STM32 标准库函数来直接检测这些事件的复合标志，降低编程难度。\n实验 软件实现 简介 EEPROM是一种掉电后据不丢失的储存器，常用来存储一些配置信息，在系统重新上电时就可以加载。\nAT24C02是一个2Kbit的EEPROM存储器，使用IIC通信方式。\n详细参数 AT24Cxx **容量（**bit） 页数 页内字节数 数据地址(占用bit数) AT24C01 1K bit (128 B) 16 8 Byte 7bit AT24C02 2K bit (256 B) 32 8 Byte 8bit AT24C04 4K bit (512 B) 32 16 Byte 9bit AT24C08 8K bit (1024 B) 64 16 Byte 10bit AT24C16 16K bit (2048 B) 128 16 Byte 11bit AT24C32 32K bit (4096 B) 128 32 Byte 12bit AT24C64 64K bit (8192 B) 256 32 Byte 13bit AT24C128 128K bit (16384 B) 256 64 Byte 14bit AT24C256 256K bit (32768 B) 512 64 Byte 15bit AT24C512 512K bit (65535 B) 512 128 Byte 16bit 通讯地址 通讯地址的高位一般都是由厂家设置好的，用户只可调整低位\n读写时序 写操作：\nAT24C02支持字节写模式和页写模式。 字节写模式就是一个地址一个数据进行写入。 页写模式就是连续写入数据。只需要写一个地址，连续写入据时地址会自增，但存在页的限制，超出一页时，超出数据覆盖原先写入的数据。但读会自动翻页。 读操作：\nAT24C02支持当前地址读模式，随机地址读模式和顺序读模式。 当前读模式是基于上一次读/写操作的最后位置继续读出数据。 随机地址读模式是指定地址读出数据。 顺序读模式是连续读出数据。 软件和硬件实现的区别 IIC 用法 速度 稳定性 管脚 硬件IIC 比较复杂 快 较稳定 需使用特定管脚 软件IIC 操作过程比较清晰 较慢 稳定 任意管脚，比较灵活 代码 void SCL_set(u8 bitValue) { GPIO_WriteBit(SCL_PORT,SCL_PIN,(BitAction)bitValue); Delay_us(10); } void SDA_set(u8 bitValue) { GPIO_WriteBit(SDA_PORT,SDA_PIN,(BitAction)bitValue); Delay_us(10); } u8 SDA_read(void) { u8 bitValue; bitValue = GPIO_ReadInputDataBit(SDA_PORT,SDA_PIN); Delay_us(10); return bitValue; } void myi2c_init(void) { GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(IIC_CLK,ENABLE); GPIO_InitStruct.GPIO_Pin = SCL_PIN | SDA_PIN; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(SCL_PORT,\u0026amp;GPIO_InitStruct); GPIO_SetBits(SCL_PORT,SCL_PIN | SDA_PIN); //将SCL和SDA都释放 } void myi2c_start(void) { //首先先释放SCL和SDA SDA_set(1); SCL_set(1); //起始信号开始,先拉低SDA，之后再拉低SCL SDA_set(0); SCL_set(0); } void myi2c_stop(void) { //为了确保SDA出现上升沿，我们需要先将SDA拉低，然后再释放 SDA_set(0); SCL_set(1); SDA_set(1); } void myi2c_sendByte(u8 data) { //保证发送完毕后使得SCL为低 for(u8 i = 0;i \u0026lt; 8; i++){ SDA_set(data \u0026amp; (0x80 \u0026gt;\u0026gt; i)); SCL_set(1); SCL_set(0); } } u8 myi2c_receiveByte() { u8 data = 0x00; SDA_set(1); //主机释放SDA，这个时候从机就可以开始任意写数据了 for(u8 i = 0; i \u0026lt; 8; i++){ SCL_set(1); //主机释放SCL，主机开始从SDA读取数据，此时SCL不能改变 if(SDA_read() == 1){ data |= (0x80 \u0026gt;\u0026gt; i); } SCL_set(0); } return data; } void myi2c_sendAck(u8 ACKbit) { SDA_set(ACKbit); SCL_set(1); SCL_set(0); } u8 myi2c_receiveAck() { u8 ACKbit = 0x00; SDA_set(1); //主机释放SDA，这个时候从机就可以开始任意写数据了 SCL_set(1); //主机释放SCL，主机开始从SDA读取数据，此时SCL不能改变 ACKbit = SDA_read(); SCL_set(0); return ACKbit; } void eeprom_writeReg(u8 address,u8 data) { myi2c_start(); myi2c_sendByte(EEPROM_ADDRESS); myi2c_receiveAck(); myi2c_sendByte(address); myi2c_receiveAck(); myi2c_sendByte(data); myi2c_receiveAck(); myi2c_stop(); //由于eeprom写入较慢，所以需要延迟10ms才能生效 Delay_ms(10); } u8 eeprom_readReg(u8 address) { u8 data; myi2c_start(); myi2c_sendByte(EEPROM_ADDRESS); myi2c_receiveAck(); myi2c_sendByte(address); myi2c_receiveAck(); myi2c_start(); myi2c_sendByte(EEPROM_ADDRESS | 0x01); myi2c_receiveAck(); data = myi2c_receiveByte(); myi2c_sendAck(1); myi2c_stop(); return data; } int main(void){ char str[50]; u8 data = 0x00; myi2c_init(); serial_init(); eeprom_writeReg(0x19,0x55); data = eeprom_readReg(0x19); sprintf(str,\u0026#34;get the data: %x\\n\u0026#34;,data); send_string(str); while(1){ } } 硬件实现 主机发送\n当起始信号来临时，会产生一个EV5事件，可以将这些EV事件看作是标志位\n主机接收 代码 void hareWare_myi2c_init() { RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2,ENABLE); RCC_APB2PeriphClockCmd(HARDWARE_IIC_CLK,ENABLE); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Pin = HARDWARE_IIC_SCL_PIN | HARDWARE_IIC_SDA_PIN; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(HARDWARE_IIC_PORT,\u0026amp;GPIO_InitStruct); I2C_InitTypeDef I2C_InitStruct; I2C_InitStruct.I2C_Ack = I2C_Ack_Enable; I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; I2C_InitStruct.I2C_ClockSpeed = 50000; I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;\t//只有在时钟频率大于100KHz的情况下才有用，在小于100KHz的情况下，低电平时间比高电平时间约为1：1 I2C_InitStruct.I2C_Mode = I2C_Mode_I2C; I2C_InitStruct.I2C_OwnAddress1 = 0x00; I2C_Init(I2C2,\u0026amp;I2C_InitStruct); I2C_Cmd(I2C2,ENABLE); } //防止等待不到事件而出现卡死状态 void waitEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT) { u32 timeout = 10000; while(I2C_CheckEvent(I2Cx,I2C_EVENT) != SUCCESS){ timeout--; if(timeout == 0) return; } } void hardware_eeprom_writeReg(u8 address,u8 data) { I2C_GenerateSTART(I2C2,ENABLE); waitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);\t//相较于软件的阻塞型的通信，硬件I2C需要每次检查事件（EV5）是否发生 I2C_Send7bitAddress(I2C2,EEPROM_ADDRESS,I2C_Direction_Transmitter); waitEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);\t//这里就不需要等待ACK了，只需要检查事件（EV6）是否发生即可 I2C_SendData(I2C2,address); waitEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING);\t//等待发送事件（EV8），如果想要连续发送，只需要每次发送完等待EV8即可 I2C_SendData(I2C2,data); waitEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED);\t//发送结束后，我们需要等待EV8_2事件，标志传输结束 I2C_GenerateSTOP(I2C2,ENABLE); } u8 hardware_eeprom_readReg(u8 address) { u8 data; I2C_GenerateSTART(I2C2,ENABLE); waitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);\t//相较于软件的阻塞型的通信，硬件I2C需要每次检查事件（EV5）是否发生 I2C_Send7bitAddress(I2C2,EEPROM_ADDRESS,I2C_Direction_Transmitter); waitEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);\t//这里就不需要等待ACK了，只需要检查事件（EV6）是否发生即可 I2C_SendData(I2C2,address); waitEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED);\t//这里等待的事件可以是TRANSMITTING，也可以是TRANSMITED I2C_GenerateSTART(I2C2,ENABLE); waitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);\t//重复起始条件 I2C_Send7bitAddress(I2C2,EEPROM_ADDRESS,I2C_Direction_Receiver); waitEvent(I2C2,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);\t//设置读取模式 I2C_AcknowledgeConfig(I2C2,DISABLE);\t//在接收最后一个字节之前，就需要提前将ack置零，同时设置停止位STOP,对应于EV6_1事件，EV6_1事件仅用于等待接收一个字节的情况 I2C_GenerateSTOP(I2C2,ENABLE); waitEvent(I2C2,I2C_EVENT_MASTER_BYTE_RECEIVED);\t//等待事件EV7 data = I2C_ReceiveData(I2C2);\t//该函数可以读取DR中的数值 I2C_AcknowledgeConfig(I2C2,ENABLE);\t//这里是为了程序收多个字节 return data; } int main(void){ char str[50]; u8 data = 0x00; hareWare_myi2c_init(); serial_init(); hardware_eeprom_writeReg(0x19,0x66); Delay_ms(20); //注意，写完之后一定要延时20ms，因为eeprom写入较慢，所以如果不延时20ms的话将会卡死 data = hardware_eeprom_readReg(0x19); sprintf(str,\u0026#34;get the data: %x\\n\u0026#34;,data); send_string(str); while(1){ } } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/jyyslide/",
    "title": "JyySlide",
    
    "content": " 下载、安装 参考链接 sunnysky29/jyy-slides: jyy OS PPT (github.com)\n工具的安装 首先需要安装python，python版本需要在3.10及以上\n安装poetry\npip install poetry 克隆库\ngit clone https://github.com/zweix123/jyyslide-md.git cd jyyslide-md 安装第三方库\npoetry install 转换 转换可以使用两种方法：\n使用虚拟环境\npoetry shell python main.py 需要转换的文件地址 直接转换\npoetry run python main.py 需要转换的文件地址 windows的快捷转换：\n首先需要先给md文件设置一个右键命令\n按下 Win + R 打开“运行”窗口，输入 regedit，然后按回车进入注册表编辑器。\n导航到以下路径：\n复制代码 HKEY_CLASSES_ROOT\\*\\shell 右键点击 shell 文件夹，选择“新建” \u0026gt; “项”，将其命名为 Convert to HTML。\n在 Convert to HTML 项下，右键点击右侧窗格中的 (默认)，选择“修改”，将“数值数据”设置为你希望显示的右键菜单项的名称，比如“Convert Markdown to HTML”。\n右键点击 Convert to HTML 项，选择“新建” \u0026gt; “项”，将其命名为 command。\n选择 command 项，然后右键点击右侧窗格中的 (默认)，选择“修改”。在“数值数据”中输入以下内容：\n\u0026#34;D:\\jyyPPT\\md2html.bat\u0026#34; \u0026#34;%1\u0026#34; 请确保路径替换为你实际的批处理文件路径。\n这个时候右键的时候就能发现已经创建成功了\n设置一个bat文件\n@echo off cd /d \u0026#34;D:\\jyyPPT\\jyyslide-md\\\u0026#34; poetry run python main.py \u0026#34;%1\u0026#34; pause 语法 水平分割使用---\n垂直分割使用----\n渐变垂直使用++++\n在同一张幻灯片中依次出现的页面使用-- 作者信息页使用+++++，语法格式使用json或yaml\n{ \u0026#34;author\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;蒋炎岩\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ics.nju.edu.cn/~jyy/\u0026#34; }, \u0026#34;departments\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34; 南京大学 \u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.nju.edu.cn/main.htm\u0026#34;, \u0026#34;img\u0026#34;: \u0026#34;./img/nju-logo.jpg\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;计算机科学与技术系\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://cs.nju.edu.cn/main.htm\u0026#34;, \u0026#34;img\u0026#34;: \u0026#34;./img/njucs-logo.jpg\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;计算机软件研究所\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.nju.edu.cn/main.htm\u0026#34;, \u0026#34;img\u0026#34;: \u0026#34;./img/ics-logo.png\u0026#34; } ] } author: name: 蒋炎岩 url: https://ics.nju.edu.cn/~jyy/ departments: - name: \u0026#34; 南京大学 \u0026#34; url: https://www.nju.edu.cn/main.htm, img: ./img/nju-logo.jpg - name: 计算机科学与技术系 url: https://cs.nju.edu.cn/main.htm, img: ./img/njucs-logo.jpg - name: 计算机软件研究所 url: https://www.nju.edu.cn/main.htm, img: ./img/ics-logo.png ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/kconfig/",
    "title": "Kconfig",
    
    "content": " 参考链接 从零到一搭建Kconfig配置系统-CSDN博客\n安装 由于在window上使用Kconfig需要依赖Curses，所以要先安装window-curses，但是curses本身是应用在Linux平台上的，所以想要安装在window上，就需要使用whl包进行安装。\ncurses的下载地址：windows-curses · PyPI\n在安装的时候需要检查一下安装的python版本，然后根据python版本安装相应的whl文件\npython --version ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/latex/",
    "title": "Latex",
    
    "content": " 公式 公式基本语法 行内公式：用 $...$ 包围公式。 块级公式：用 $$...$$ 或 \\[...\\] 包围公式。 数学符号 基本符号 描述 符号 LaTeX 代码 加号 $+$ + 减号 $-$ - 正负号 $\\pm$ \\pm 乘号 $\\times$ \\times 除号 \\ \\ 根号 $\\sqrt{x}$ \\sqrt{} 分数 $\\frac{a}{b}$ \\frac{a}{b} 等于 $=$ = 约等于 $\\approx$ \\approx 不等于 $\\neq$ \\neq 小于 $\u003c$ \u0026lt; 大于 $\u003e$ \u0026gt; 小于等于 $\\leq$ \\leq 大于等于 $\\geq$ \\geq 向下取整 $\\lfloor x \\rfloor$ \\lfloor\\rfloor 向上取整 $\\lceil x \\rceil$ \\lceil\\rceil 集合符号 描述 符号 LaTeX 代码 属于 $\\in$ \\in 不属于 $\\notin$ \\notin 包含（真子集） $\\subset$ \\subset 包含等于 $\\subseteq$ \\subseteq 并集 $\\cup$ \\cup 交集 $\\cap$ \\cap 空集 $\\emptyset$ \\emptyset 所有实数集合 $\\mathbb{R}$ \\mathbb{R} 所有自然数集合 $\\mathbb{N}$ \\mathbb{N} 所有整数集合 $\\mathbb{Z}$ \\mathbb{Z} 运算符 描述 符号 LaTeX 代码 求和 $\\sum$ \\sum 积分 $\\int$ \\int 重积分 $\\iint$ \\iint 极限 $\\lim$ \\lim 微分 $\\frac{dy}{dx}$ \\frac{dy}{dx} 逻辑符号 描述 符号 LaTeX 代码 与 $\\land$ \\land 或 $\\lor$ \\lor 非 $\\neg$ \\neg 蕴含 $\\implies$ \\implies 等价 $\\iff$ \\iff 希腊字母 描述 符号 LaTeX 代码 α (Alpha) $\\alpha$ \\alpha β (Beta) $\\beta$ \\beta γ (Gamma) $\\gamma$ \\gamma Δ (Delta) $\\Delta$ \\Delta π (Pi) $\\pi$ \\pi Ω (Omega) $\\Omega$ \\Omega 上下标 描述 符号 LaTeX 代码 上标（幂） $x^2$ x^2 下标 $x_i$ x_i 同时有上标和下标 $x_i^2$ x_i^2 顶部加^ $\\hat{a}$ \\hat{1} 顶部加横线 $\\overline{a}$ \\overline{a}$ 顶部加波浪线 $\\widetilde{a}$ \\widetilde{a} 顶部加点 $\\dot{a}$ \\dot{a} 顶部加两点 $\\ddot{a}$ \\ddot{a}$ 顶部加箭头 $\\vec{a}$ \\vec{a} 大括号 为了表示一组内容，可以使用 \\left 和 \\right，配合不同类型的括号：\n$$ \\left( \\frac{a}{b} \\right) $$ 也可以使用 \\{ \\} 来显示大括号：\n$$ \\{ x \\mid x \u003e 0 \\} $$ 矩阵 使用 \\begin{matrix} ... \\end{matrix}，或者带括号的 \\begin{pmatrix} ... \\end{pmatrix}：\n$$ \\begin{matrix} a \u0026 b \\\\ c \u0026 d \\end{matrix} $$$$ \\begin{pmatrix} a \u0026 b \\\\ c \u0026 d \\end{pmatrix} $$ 方程组 $$ \\left\\{ \\begin{array}{l} x + y = 1 \\\\ x - y = 2 \\end{array} \\right. $$",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/linux/",
    "title": "Linux",
    
    "content": " 安装 首先从下载Ubuntu桌面系统 | Ubuntu上下载镜像文件，下载完成之后，下载启动盘制作工具的软件，使用Rufus - 轻松创建 USB 启动盘或者UltraISO软碟通中文官方网站 - 光盘映像文件制作/编辑/转换工具。准备一个8G以上的U盘，==注意，U盘一定要先格式化，文件系统格式为FAT32==。\n制作启动盘请参考UltralSO 软碟通制作U盘启动盘（图解详细 完美避坑）_软碟通怎么制作u盘启动盘-CSDN博客或Windows10怎么使用Rufus制作USB启动盘？ - 知乎 (zhihu.com)\n制作好启动盘之后，重启电脑的时候，等待出现电脑的Logo的时候，按住进入BISO的按键（华硕是F2），拖动启动顺序（Boot）\nhttps://cn.linux-terminal.com/?p=7582\n基础工具 apt apt是包管理工具,常用命令如下：\napt 常用的命令有：\n更新本地包列表：\nsudo apt update 升级所有已安装的软件包：\nsudo apt upgrade 安装新的软件包：\nsudo apt install \u0026lt;package_name\u0026gt; 删除已安装的软件包：\nsudo apt remove \u0026lt;package_name\u0026gt; 完全删除软件包（包括配置文件）：\nsudo apt purge \u0026lt;package_name\u0026gt; 清理系统不再需要的包：\nsudo apt autoremove 显示有关包的信息：\napt show \u0026lt;package_name\u0026gt; zsh 参考链接\nZsh 安装与配置，使用 Oh-My-Zsh 美化终端 | Leehow的小站 (haoyep.com)\n安装及使用zsh\nsudo apt install git sudo apt install zsh wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh chsh -s /usr/bin/zsh 这里的chsh命令是将shell设置为zsh，如果想要换回bash，首先要查看有哪些shell\ncat /etc/shells 换回去只需要再使用chsh即可\nchsh -s /bin/bash 安装主题\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 安装字体\nsudo apt-get install fonts-powerline 更新源\nsource ~/.zshrc 之后按下CTRL + SHIFT + r更新\ni3wm 参考链接 桌面应用|i3 窗口管理器终极定制指南 (linux.cn)\n默认的快捷键 按键绑定 描述 Mod + Enter 打开终端。 Mod + ← 切换到左侧窗口。 Mod + → 切换到右侧窗口。 Mod + ↑ 切换到上方窗口。 Mod + ↓ 切换到下方窗口。 Mod + Shift + ← 将窗口移动到左侧。 Mod + Shift + → 将窗口移动到右侧。 Mod + Shift + ↑ 将窗口移动到上方。 Mod + Shift + ↓ 将窗口移动到下方。 Mod + f 将焦点窗口切换到全屏模式。 Mod + v 下一个窗口将垂直放置。 Mod + h 下一个窗口将水平放置。 Mod + s 启用堆叠式窗口布局。 Mod + w 启用选项卡式窗口布局。 Mod + Shift + Space 启用浮动窗口（针对焦点窗口）。 Mod + 鼠标左键单击 使用鼠标拖动整个窗口。 Mod + 0-9 切换到另一个工作区。 Mod + Shift + 0-9 将窗口移动到另一个工作区。 Mod + d 打开应用程序启动器（D 菜单）。 Mod + Shift + q 关闭焦点窗口。 Mod + Shift + c 重新加载 i3 配置文件。 Mod + Shift + r 重启 i3 窗口管理器。 Mod + Shift + e 退出 i3 窗口管理器。 定制i3wm 安装壁纸插件\nsudo apt install feh 打开i3wm配置文件\nvim ~/.config/i3/config 在config文件后面添加以下命令设置壁纸\nexec_always feh --bg-fill /path/to/wallpaper 小工具 操作 工具名称 网址 代替man的工具 Npm install -g Tldr GitHub - tldr-pages/tldr: 📚 Collaborative cheatsheets for console commands 安装tldr需要先安装 nodejs、npm 这里可能需要重启虚拟机才能生效 对脚本文件进行错误提示 shellcheck 可以最大化利用terminal Tmux 编辑器之神 Vim 代替find fd GitHub - sharkdp/fd: A simple, fast and user-friendly alternative to \u0026lsquo;find\u0026rsquo; 代替grep rg github.com 文件夹工具，可以对文件夹的切换进行优化 fasd GitHub - clvv/fasd: Command-line productivity booster, offers quick access to files and directories, inspired by autojump, z and v. 模糊文件查找 Ctrlp 文件浏览器 nerdtree GitHub - preservim/nerdtree: A tree explorer plugin for vim. 代码联想 Youcompleteme YouCompleteMe 安装配置方法 - 简书 (jianshu.com) 文件层级 Yggdroot/indentLine: A vim plugin to display the indention levels with thin vertical lines (github.com) 图床工具 PicList https://github.com/Kuingsmile/PicList ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/makefile/",
    "title": "Makefile",
    
    "content": " 参考链接 跟我一起写Makefile — 跟我一起写Makefile 1.0 文档 (seisman.github.io)\n概述 targets: prerequisites commands targets:prerequisties;commands targets\n可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。 targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。 prerequisites\n目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。 commands\n该target要执行的命令（任意的shell命令）。 commands是命令行，如果其不与“target:prerequisites”在一行，那么，必须以 Tab 键开头。 如果和prerequisites在一行，那么可以用分号做为分隔。（见上） 如果命令太长，可以使用反斜杠（ \\ ）作为换行符。make对一行上有多少个字符没有限制。 [!NOTE]\n这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:\n==prerequisites中如果有一个以上的文件比target文件要新的话，commands所定义的命令就会被执行。==\n[!IMPORTANT]\n注意：makefile有着严格的缩进格式，命令前面需要使用tab键对齐\n下面将会按照以下的例子来介绍相关知识：\nedit : main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/map%E6%96%87%E4%BB%B6/",
    "title": "Map文件",
    
    "content": " 参考链接 KEIL MDK .map文件分析(必学知识点) - 正点原子倾力打造！-OpenEdv-开源电子网\n充分理解Linux GCC 链接生成的Map文件 - 知乎 (zhihu.com)\n[!important]\n可以使用AMAP可视化map文件\nGCC平台 Archives linked 一般位于map文件的第一行\nArchive member included to satisfy reference by file (symbol) /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc_nano.a(lib_a-exit.o) /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/crt0.o (exit) 上面的文件信息格式如下：\nThe archive file location (compilation unit) The compilation unit referencing the archive (symbol called) 上面内容的意思是crt0这个文件中会调用exit函数，exit函数在exit.o这个目标文件中，exit.o目标文件是被链接在libc_nano.a这个库文件里的。\nMemory configuration Map文件中最直接的信息是实际的内存区域，这些区域具有位置、大小和访问权限:\nMemory Configuration Name Origin Length Attributes FLASH 0x0000000000001000 0x00000000000ff000 xr RAM 0x0000000020000008 0x000000000003fff8 xrw *default* 0x0000000000000000 …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/markdown/",
    "title": "MarkDown",
    
    "content": " 语法 Markdown 是一种轻量级标记语言，使用简单的文本格式来创建格式化的文档。以下是常用的 Markdown 语法命令：\n标题 使用 # 来创建标题，# 的数量表示标题的级别。\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 [!note]\n需要注意的是，在#符号后面需要加一个空格，这样markdown才能知道是标题\n字体样式 使用 ** 或 __ 包围文本表示粗体\n使用 * 或 _ 包围文本表示斜体。\n使用==包围为高亮\n使用~~包围的为删除线\n使用包围为下划线\n**这是粗体文本** __这是粗体文本__ *这是斜体文本* _这是斜体文本_ ==这是高亮文本== ~~这是删除线~~ \u0026amp;lt;u\u0026amp;gt;这是下划线\u0026amp;lt;/u\u0026amp;gt; 列表 无序列表使用 *、- 或 + 表示，有序列表使用数字加点表示。\n* 项目 1 * 项目 2 * 子项目 2.1 * 子项目 2.2 1. 项目 1 2. 项目 2 3. 项目 3 链接和图片 图片使用 ![替代文本](图片URL)。\n![这是一个图片](https://www.example.com/image.jpg)\t网络图片 ![这是一个图片](../image.jpg)\t本地图片 链接使用 [显示文本](URL)。\n[这是一个链接](https://www.example.com) 网络链接 [将要链接的标题](#一级标题名)\t链接到本文中的标题，需要注意的是，这里几级标题就要写几个#号 [将要链接的标题](##二级标题名) \u0026amp;lt;a id=\u0026amp;#34;test\u0026amp;#34;\u0026amp;gt;\u0026amp;lt;/a\u0026amp;gt;\t使用HTML的标签功能方便引用 ![图片1](../image.jpg)\t正常使用图片 [点击这里跳转图片1](#test)\t注意，当想要引用图片时，只需要使用1个#号，#号后面跟的是id号 引用块 使用 \u0026amp;gt; 表示引用\n使用多个\u0026amp;gt;表示区块以此表示层级效果，在typora中，回车会自动添加\u0026amp;gt;符号\n\u0026amp;gt; 这是一个引用。 \u0026amp;gt; 区块引用 \u0026amp;gt;\u0026amp;gt; 二级区块 \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; 三级区块 区块引用\n二级区块\n三级区块\n代码 单行代码使用 `` 包围，多行代码使用三个反引号 ```。 …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/matlab/",
    "title": "Matlab",
    
    "content": " 参考链接 MATLAB 快速入门 - MathWorks 中国\n语言基础知识 输入命令 在 MATLAB 中工作时，您可发出创建变量和调用函数的命令。有关介绍，请参阅在命令行窗口中输入语句。\n函数 操作 注释 ans 最近计算的答案 clc 清空命令行窗口 diary 将命令行窗口文本记录到日志文件中 format 设置输出显示格式 home 发送光标复位 iskeyword 确定输入是否为 MATLAB 关键字 more 控制命令行窗口中的分页输出 commandwindow 选择命令行窗口 commandhistory 打开命令历史记录窗口 对象 操作 注释 DisplayFormatOptions 命令行窗口中的输出显示格式 (自 R2021a 起) 数组和矩阵 创建和合并数组 要创建每行包含四个元素的数组，请使用逗号 (,) 或空格分隔各元素。\na = [1 2 3 4] 这种数组为==行向量==。要创建包含多行的矩阵，请使用分号分隔各行。\na = [1 3 5; 2 4 6; 7 8 10] 函数 备注 zeros 创建全零数组 ones 创建全部为 1 的数组 rand 均匀分布的随机数 true 逻辑值 1（真） false 逻辑 0（假） eye 单位矩阵 diag 创建对角矩阵或获取矩阵的对角元素 blkdiag 分块对角矩阵 cat 串联数组。 horzcat 水平串联数组 vertcat 垂直串联数组 repelem 重复数组元素副本 repmat 重复数组副本 combinations 生成数组的所有元素组合 (自 R2023a 起) 创建网格 函数、参数 备注 linspace 生成线性间距向量 logspace 生成对数间距向量 freqspace 频率响应的频率间距 meshgrid 二维和三维网格 ndgrid N 维空间中的矩形网格 确定大小和排序 函数、参数 备注 length 最大数组维度的长度 size 数组大小 ndims 数组维度数目 numel 数组元素的数目 isscalar 确定输入是否为标量 isvector 确定输入是否为向量 ismatrix 确定输入是否为矩阵 isrow 确定输入是否为行向量 iscolumn 确定输入是否为列向量 isempty 确定数组是否为空 issorted 确定数组是否已排序 issortedrows 确定矩阵或表的行是否已排序 isuniform Determine if vector is uniformly spaced (自 R2022b 起) 调整大小 函数、参数 备注 head 获取数组或表的顶行 tail 获取数组或表的底行 resize Resize data by adding or removing elements (自 R2023b 起) paddata Pad data by adding elements (自 R2023b 起) trimdata Trim data by removing elements (自 R2023b 起) 重构 函数、参数 备注 permute 置换数组维度 ipermute 逆置换数组维度。 shiftdim 移动数组维度 reshape 通过重新排列现有元素来重构数组 squeeze 删除长度为 1 的维度 重新排序 函数、参数 备注 sort 对数组元素排序 sortrows 对矩阵行或表行进行排序 flip 翻转元素顺序 fliplr 将数组从左向右翻转 flipud 将数组从上向下翻转 rot90 将数组旋转 90 度 transpose 转置向量或矩阵 ctranspose 复共轭转置 circshift 循环平移数组 索引 函数、参数 备注 colon 向量创建、数组下标和 for 循环迭代 end 终止代码块或指示最大数组索引 ind2sub 将线性索引转换为下标 sub2ind 将下标转换为线性索引 ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/pwr/",
    "title": "PWR",
    
    "content": " 概述 PWR(Power Control)电源控制，PWR负责管理STM32内部的电源供电部分，可以实现可编程电压监测器和低功耗模式的功能\n可编程电压监测器(PVD)可以监控VDD电源电压，当VDD下降到PVD阀值以下或上升到PVD阀值之上时，PVD会触发中断，用于执行紧急关闭任务\n低功耗模式包括：\n睡眠模式(Sleep) 停机模式(Stop) 待机模式(Standby) 可在系统空闲时，降低STM32的功耗，延长设备使用时间\n电源系统结构 VDDA供电区域，主要负责模拟部分的供电，包括AD转换、温度传感器、复位模块PLL。这些电路供电正极是VDDA，负极是VSSA，其中AD转换器还有两个参考电压引脚，分别为VREF+和VREF- 由两部分组成，左边部分是VDD供电区域，包括IO电路、待机电路、唤醒电路及看门狗，右边部分是VDD通过电压调节器，降压至1.8V，1.8v区域包括CPU核心、存储器和内置数字外设，stm32内部的关键电路，CPU、存储器和外设其实都是以1.8V的低电压运行的。当这些电路想要和外界进行交流时，才会通过IO电路转换到3.3v。==使用低电压运行的主要目的是为了降低功耗，电压越低，内部电路运行的功耗就相对越低== VBAT后备供电区域，其中包括LSE晶体震荡器、后备寄存器、RCC BDCR寄存器和RTC，其中有一个低电压检测开关，VDD有电时，由VDD供电，VDD没电时，由VBAT供电 电源监控 电源监控即对某些电源电压(VDD/VDDA/VBAT)进行监控。POR/PDR监控器、PVD监控器、BOR监控器、AVD监控器、VBAT阈值、温度阈值\nPOR/PDR(power on/down reset):上电/掉电复位 PVD(programmable voltage detector)):监控VDD电压 BOR(brown out reset):欠压复位 AVD(analog voltage detector)：监控VDDA电压 VBAT阈值(battery voltage thresholds)：监控VBAT电池电压 温度阈值(temperature thresholds):监控结温 注意：不同芯片包括的电源监控功能不同\n上电/掉电复位 当VDD或者VDDA电压过低时，内部电路会直接产生复位，让stm32复位，不能乱操作\n在POR和PDR之间设置了一个40mV的迟滞电压，大于POR产生复位，小于PDR时保持复位，设置两个阈值的作用就是防止电压在某个阈值附近波动时，造成输出也来回抖动\n电压检测器 PVD阈值电压可以使用程序指定，可以自定义调节\nPVD的输出信号可以去申请中断，这个中断申请是由外部中断实现的\n低功耗 STM32具有运行、睡眠、停止和待机四种工作模式。\n上电后默认是在运行模式，当内核不需要继续运行时，可以选择后面三种低功耗模式。\n睡眠模式 通过两个库函数进入睡眠模式：WFI和WFE，WFI和WFE是内核的指令\nWFI：wait for interrupt 等待中断，当中断发生，醒来之后的第一件事就是处理中断 WFE: wait for event 等待事件，这个事件可以事外部中断配置为事件模式，也可以是使能了中断，但是没有配置NVIC，调用的WFE进入的睡眠模式，产生唤醒事件时会立即醒来，醒来之后一般不需要进入中断函数，直接从睡眠的地方继续运行 停止模式 ==只有外部中断才能唤醒，其他中断唤醒不了。==\n当进入待机模式之后，将会关闭1.8v的时钟，也就是说CPU和外设均不可运行。定时器正在定时的会暂停，串口收发数据也会暂停，但是没有关闭电源，所以CPU和外设的寄存器数据都是维持原状的\n待机模式 只有几个指定的信号才能唤醒：\nWKUP引脚的上升沿 RTC闹钟事件 NRST引脚上的外部复位：也就是按下复位键也是可以唤醒的 IWDG复位 由于这里的电源关了，所以CPU和外设中的寄存器数据都是不能保持的\n低功耗模式表 从上到下功耗越来越低，且越来越难唤醒\n低功耗的启动方法就是关闭CPU时钟和关闭电源（电压调节器）\n模式 进入 唤醒 对内核电路时钟 影响 对VDD区 域时钟的影 响 电压调节器 睡眠 (立即休眠或 退出时休眠) WFI 、WFE 任意中断 唤醒事件 CPU时钟关，对 其他时钟或模拟 时钟源无影响 无 开 停止 PDDS和LPDS位 +SLEEPDEEP位 +WFI或WFE 任意外部中断（在外 部中断寄存器中设置) 关闭所有内核电 路时钟 HS和HSE 定) 的振荡器关闭 开启或处于低功 耗模式（依据电 源控制寄存器 PWR_CR的设 待机 PDDS位 +SLEEPDEEP位 +WFI或WFE WKUP引脚的上升沿、 RTC闹钟(唤醒/入侵/ 时间戳)事件、NRST 引脚上的外部复位、 IWDG复位 ： ： 关 三种模式下的功耗 同等条件下(T=25°C,VDD=3.3V,系统时钟72MHz)\n模式 主要影响 唤醒时间 供应电流(典型值) 正常模式 所有外设正常工作 0 51mA 睡眠模式 CPU时钟关闭 1.8us 29.5mA 停止模式 1.8V区域时钟关闭，电压调节器低功耗 5.4us 35uA 待机模式 1.8V区域时钟关闭，电压调节器关闭 50us 3.8uA 模式的选择 WFI和WFE是待机的触发条件，后面所有的寄存器配置都要在这两条指令之后。\n执行WFI(Wait For Interrupt)或者WFE(Vait For Event)指令后，STM32进入低功耗模式。\n睡眠模式 执行完WFI、WFE指令后，STM32进入睡眠模式，程序暂停运行，唤醒后程序从暂停的地方继续运行 SLEEPONEXIT位决定STM32执行完WFI或WFE后，是立刻进入睡眠，还是等STM32从最低优先级的中断处理程序中退出时进入睡眠 在睡眠模式下，所有的/○引脚都保持它们在运行模式时的状态 WFI指令进入睡眠模式，可被任意一个NVIC响应的中断唤醒 WFE指令进入睡眠模式，可被唤醒事件唤醒 停止模式 执行完WFI/WFE指令后，STM32进入停止模式，程序暂停运行，唤醒后程序从暂停的地方继续运行 1.8V供电区域的所有时钟都被停止，PLL、HSI和HSE被禁止，SRAM和寄存器内容被保留下来 在停止模式下，所有的/O引脚都保持它们在运行模式时的状态 当一个中断或唤醒事件导致退出停止模式时，HS被选为系统时钟 当电压调节器处于低功耗模式下，系统从停止模式退出时，会有一段额外的启动延时 WFI指令进入停止模式，可被任意一个EXTI中断唤醒 WFE指令进入停止模式，可被任意一个EXT事件唤醒 待机模式 执行完WFI/WFE指令后，STM32进入待机模式，唤醒后程序从头开始运行\n整个1.8V供电区域被断电，PLL、HSI和HSE也被断电，SRAM和寄存器内容丢失，只有备份的寄存器和待机电路维持供电\n在待机模式下，所有的/O引脚变为高阻态（浮空输入）\nWKUP引脚的上升沿、RTC闹钟事件的上升沿、NRST引脚上外部复位、IWDG复位退出待机模式\n实验 修改主频 [!TIP]\n注意，由于stm32处于低功耗的状态，所以下载的时候，需要先按住复位键，然后点击下载，松开复位键，这时候就能下载成功了\n首先需要修改文件夹(包含时钟的c文件)的属性，从只读变为可读可写\n睡眠模式 u8 rxData; int main(void){ serial_init(); Led_Init(); serial_printf(\u0026#34;SYSCLK: %d\\n\u0026#34;,SystemCoreClock); while(1){ if(serial_getRxFlag() == 1){ rxData = serial_getRxData(); serial_printf(\u0026#34;receive the data: %x\\n\u0026#34;,rxData); } Led_On(); //如果设备不处于睡眠模式，将会led将会一闪一闪，否则led就灭 Delay_s(1); Led_Off(); Delay_s(1); __WFI(); //实际上是一条汇编指令，睡眠模式只需要使用这一个代码即可 } } 停止模式 int main(void){ serial_init(); redRation_Init(); Led_Init(); Led_Off(); RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE); //开启PWR时钟 while(1){ Led_On(); Delay_s(1); Led_Off(); Delay_s(1); PWR_EnterSTOPMode(PWR_Regulator_ON,PWR_STOPEntry_WFI); //使用WFI模式进入停止模式，这个函数将会将所有的寄存器都配置好 SystemInit(); //由于从停止模式唤醒之后，系统将会启动HSI内部时钟，所以当唤醒时，我们需要调用该函数重新配置系统时钟 } } 待机模式 int main(void){ serial_init(); myrtc_init(); u32 alarm = RTC_GetCounter() + 10; RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE);\t//开启PWR时钟 RTC_SetAlarm(alarm);\t//设置闹钟值 serial_printf(\u0026#34;the alarm is %d\\n\u0026#34;,alarm); while(1){ serial_printf(\u0026#34;the counter is %d\\n\u0026#34;,RTC_GetCounter());\t//获取实时时钟计数值 serial_printf(\u0026#34;the alrf is %d\\n\u0026#34;,RTC_GetFlagStatus(RTC_FLAG_ALR));\t//获取闹钟产生的信号 PWR_EnterSTANDBYMode();\t//进入待机模式 } } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/pyqt/",
    "title": "PyQT",
    
    "content": " 参考链接 Python 小白从零开始 PyQt5 项目实战（8）汇总篇（完整例程）_pyqt项目实战教程-CSDN博客\n免费学习编程 - Python、JavaScript、Java、Git 等 (freecodecamp.org)\nUI fluent-widgets 参考链接：快速上手 - PyQt-Fluent-Widgets\nsilicon 参考链接：ChinaIceF/PyQt-SiliconUI: A powerful and artistic UI library based on PyQt5，基于 PyQt5 的UI框架，灵动、优雅而轻便 (github.com)\n安装 安装python\n从官网下载：Welcome to Python.org\nIDE的选择\n==VSCODE==（❤❤❤）：Visual Studio Code - Code Editing. Redefined ==Cursor==(AI级选手，面向自然语言编程，amazing❗❗❗)：Cursor ==Pycharm==（python专用工具）：PyCharm: the Python IDE for data science and web development (jetbrains.com) python包管理工具PIP\npip 是 Python 包管理工具，用于安装和管理 Python 库和依赖。通过 pip，你可以方便地从 Python Package Index (PyPI) 下载和安装第三方库，并自动解决依赖问题。\n常见的 pip 使用命令：\n安装包：pip install 包名 卸载包：pip uninstall 包名 查看已安装的包：pip list 升级包：pip install --upgrade 包名 查看包信息：pip show 包名 例如，安装 NumPy 库的命令是：\npip install numpy 安装Pyqt5\n使用PIP来安装pyqt\npip install pyqt5 -i https://mirrors.aliuyun.com/pypi/simple [!tip]\n建议先不换源下载试试，如果不可以在使用-i参数换源\n安装QtTool\nQt Tools 包含：\n图形界面设计工具 Qt Designer，用于设计图形界面，生成 .ui文件， …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/",
    "title": "Python",
    
    "content": " Python基础 [!IMPORTANT]\nPython语言有着严格的缩进模式，同一个Tab表示在同一个作用域（和Makefile同样的Tab控制）\n在Python中的缩进相当于是C语言中的{}，用于控制作用域\n注意缩进❗❗❗❗❗❗\n否则会导致程序报错或者出现很多奇奇怪怪的bug🙉\n数据类型 在Python中无需定义变量的数据类型，编译器会自动解析当前定义的变量是什么数据类型。\n整数 (int) 定义：表示整数值。\n基本用法：\n# 定义整数 age = 25 print(age) # 输出：25 # 基本运算 sum = age + 5 print(sum) # 输出：30 浮点数 (float) 定义：表示带小数的数字。\n基本用法：\n# 定义浮点数 temperature = 36.6 print(temperature) # 输出：36.6 # 基本运算 area = 3.14 * (5 ** 2) print(area) # 输出：78.5 字符串 (str) 定义：表示文本数据，使用单引号或双引号包裹。\n基本用法：\n# 定义字符串 name = \u0026#34;Alice\u0026#34; print(name) # 输出：Alice # 字符串拼接 greeting = \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34; print(greeting) # 输出：Hello, Alice! # 字符串方法 upper_name = name.upper() print(upper_name) # 输出：ALICE 布尔值 (bool) 定义：表示真或假，只有两个值：True 和 False。\n基本用法：\n# 定义布尔值 is_student = True print(is_student) # 输出：True # 布尔运算 has_passed = True is_adult = False print(has_passed and is_adult) # 输出：False 列表 (list) 定义：有序可变集合，可以存储不同类型的元素。（C++中的vector）\n基本用法：\n# 定义列表 fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] print(fruits) # 输出：[\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] # 访问元素 first_fruit = fruits[0] print(first_fruit) # 输出：apple # 添加元素 fruits.append(\u0026#34;orange\u0026#34;) print(fruits) # 输出：[\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;orange\u0026#39;] # 删除元素 fruits.remove(\u0026#34;banana\u0026#34;) print(fruits) # 输出：[\u0026#39;apple\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;orange\u0026#39;] 元组 (tuple) 定义：有序不可变集合，类似于列表，但不能修改元素。\n基本用法：\n# 定义元组 coordinates = (10.0, 20.0) print(coordinates) # 输出：(10.0, 20.0) # 访问元素 x = coordinates[0] print(x) # 输出：10.0 字典 (dict) 定义：无序可变集合，用键值对存储数据。（C++中的hash map）\n基本用法：\n# 定义字典 person = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} print(person) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30} # 访问值 name = person[\u0026#34;name\u0026#34;] print(name) # 输出：Alice # 添加新键值对 person[\u0026#34;city\u0026#34;] = \u0026#34;New York\u0026#34; print(person) # 输出：{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} 集合 (set) 定义：无序不重复元素的集合，适用于需要唯一性的数据。（C++中的set）\n基本用法：\n# 定义集合 unique_numbers = {1, 2, 3, 3} print(unique_numbers) # 输出：{1, 2, 3} # 添加元素 unique_numbers.add(4) print(unique_numbers) # 输出：{1, 2, 3, 4} # 删除元素 unique_numbers.remove(2) print(unique_numbers) # 输出：{1, 3, 4} 控制结构 条件语句 条件语句用于根据特定条件执行不同的代码块。\nif 语句 # 定义变量 score = 85 # 使用 if 语句 if score \u0026gt;= 90: print(\u0026#34;优秀\u0026#34;) elif score \u0026gt;= 80: print(\u0026#34;良好\u0026#34;) elif score \u0026gt;= 70: print(\u0026#34;中等\u0026#34;) else: print(\u0026#34;需要努力\u0026#34;) 其他条件语句 短路条件：\nis_pass = True is_registered = True if is_pass and is_registered: print(\u0026#34;可以参加考试\u0026#34;) 条件表达式 (三元运算符，行迭代器)：\nage = 18 status = \u0026#34;成人\u0026#34; if age \u0026gt;= 18 else \u0026#34;未成年人\u0026#34; print(status) # 输出：成人 循环语句 循环语句用于重复执行特定代码块，直到满足退出条件。\nfor 循环 用于遍历序列（如列表、字符串等）。\n# 遍历列表 fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) # 使用 range 函数 for i in range(5): print(i) # 输出：0, 1, 2, 3, 4 while 循环 在满足条件时重复执行代码块。\ncount = 0 while count \u0026lt; 5: print(count) count += 1 # 输出：0, 1, 2, 3, 4 跳转语句 跳转语句用于改变程序的执行顺序。\nbreak 用于立即退出循环。\nfor i in range(10): if i == 5: break print(i) # 输出：0, 1, 2, 3, 4 continue 用于跳过当前循环的剩余部分，进入下次迭代。\nfor i in range(5): if i == 2: continue print(i) # 输出：0, 1, 3, 4 pass 用于占位，表示一个空的代码块，通常用于结构体。\nif True: pass # 这里什么都不做，但可以保持代码结构完整 函数是组织和重用代码的基本构件，允许你将特定的任务封装成一个可重复调用的块。Python 中的函数可以有参数和返回值。以下是函数的详细介绍：\n函数 定义函数 使用 def 关键字来定义函数。\ndef greet(name): print(f\u0026#34;Hello, {name}!\u0026#34;) 调用函数 定义函数后，可以通过函数名和括号调用它。\ngreet(\u0026#34;Alice\u0026#34;) # 输出：Hello, Alice! 函数参数 函数可以接受参数，支持位置参数和关键字参数。\n位置参数 def add(a, b): return a + b result = add(3, 5) print(result) # 输出：8 关键字参数 可以在调用时指定参数名称。\ndef describe_pet(animal_type, pet_name): print(f\u0026#34;I have a {animal_type} named {pet_name}.\u0026#34;) describe_pet(animal_type=\u0026#34;dog\u0026#34;, pet_name=\u0026#34;Buddy\u0026#34;) 默认参数 可以为参数指定默认值，如果调用时不传入该参数，则使用默认值。\ndef power(base, exponent=2): return base ** exponent print(power(4)) # 输出：16 print(power(4, 3)) # 输出：64 可变参数 使用 *args 和 **kwargs 来处理不确定数量的参数。\n*args 接收任意数量的位置参数。\ndef sum_all(*args): return sum(args) print(sum_all(1, 2, 3)) # 输出：6 **kwargs 接收任意数量的关键字参数。\ndef print_info(**kwargs): for key, value in kwargs.items(): print(f\u0026#34;{key}: {value}\u0026#34;) print_info(name=\u0026#34;Alice\u0026#34;, age=30) 返回值 使用 return 语句返回值。如果没有 return，函数默认返回 None。\ndef multiply(x, y): return x * y result = multiply(4, 5) print(result) # 输出：20 文档字符串 可以为函数添加文档字符串，用于描述函数的功能。\ndef factorial(n): \u0026#34;\u0026#34;\u0026#34;计算 n 的阶乘\u0026#34;\u0026#34;\u0026#34; if n == 0: return 1 else: return n * factorial(n - 1) print(factorial.__doc__) # 输出：计算 n 的阶乘 函数作为对象 函数是第一类对象，可以赋值给变量，作为参数传递，或者作为返回值。\ndef square(x): return x * x def apply_function(func, value): return func(value) result = apply_function(square, 5) print(result) # 输出：25 面向对象编程 类与对象 类是对象的蓝图或模板，定义了一组属性和方法。 对象是类的实例，包含类定义的属性和方法的具体值。 定义类 class Dog: # 属性 species = \u0026#34;Canis lupus familiaris\u0026#34; def __init__(self, name, age): self.name = name # 实例属性 self.age = age # 方法 def bark(self): return f\u0026#34;{self.name} says Woof!\u0026#34; 创建对象 my_dog = Dog(\u0026#34;Buddy\u0026#34;, 3) print(my_dog.name) # 输出：Buddy print(my_dog.bark()) # 输出：Buddy says Woof! 属性 属性是对象的特征，分为实例属性和类属性。\n实例属性：特定于某个对象的属性。 类属性：属于类本身的属性，所有对象共享。 print(my_dog.species) # 输出：Canis lupus familiaris 方法 方法是定义在类中的函数，用于执行与对象相关的操作。\nclass Circle: pi = 3.14 # 类属性 def __init__(self, radius): self.radius = radius # 实例属性 def area(self): return Circle.pi * (self.radius ** 2) # 方法访问类属性 继承 继承是面向对象编程的重要特性，可以创建一个新类，从现有类继承属性和方法。\nclass Labrador(Dog): # 继承自 Dog 类 def fetch(self): return f\u0026#34;{self.name} is fetching!\u0026#34; my_lab = Labrador(\u0026#34;Rex\u0026#34;, 2) print(my_lab.fetch()) # 输出：Rex is fetching! 多态 多态允许不同类的对象以相同的方式调用相同的方法，具体的行为由对象的类型决定。\nclass Cat: def bark(self): return \u0026#34;Meow!\u0026#34; def make_sound(animal): print(animal.bark()) make_sound(my_dog) # 输出：Buddy says Woof! make_sound(Cat()) # 输出：Meow! 封装 封装是将对象的状态（属性）与行为（方法）结合在一起，限制外部直接访问对象的内部状态。可以通过命名约定和 getter/setter 方法实现。\nclass BankAccount: def __init__(self, balance=0): self.__balance = balance # 私有属性 def deposit(self, amount): if amount \u0026gt; 0: self.__balance += amount def get_balance(self): return self.__balance account = BankAccount() account.deposit(100) print(account.get_balance()) # 输出：100 好的，下面是关于Python中模块和包的详细说明：\n模块 定义：模块是一个包含Python代码的文件，文件名以.py结尾。模块可以包含函数、类和变量，方便代码的组织和重用。\n导入模块：\n使用import语句导入模块，例如： import math print(math.sqrt(16)) # 输出 4.0 使用from ... import ...导入特定的函数或变量，例如： from math import pi print(pi) # 输出 3.141592653589793 模块的创建：创建模块只需将相关的函数和变量写入一个.py文件中。例如，创建一个名为mymodule.py的文件，内容如下：\ndef greet(name): return f\u0026#34;Hello, {name}!\u0026#34; 模块的作用域：模块内的变量和函数具有模块作用域，避免与其他模块的命名冲突。\n包 定义：包是一个包含多个模块的文件夹，用于组织相关模块。包通过__init__.py文件标识，可以是空文件，也可以包含包的初始化代码。\n创建包：创建一个包只需创建一个文件夹并在其中添加模块和一个__init__.py文件。例如，创建一个名为mypackage的文件夹，里面有module1.py和module2.py，并添加一个空的__init__.py文件。\n导入包：\n导入整个包： import mypackage 导入包中的特定模块： from mypackage import module1 导入包中的特定函数或类： from mypackage.module1 import my_function 命名空间：包提供了命名空间，可以避免模块之间的命名冲突。\n示例 假设我们有如下目录结构：\nmypackage/ __init__.py module1.py module2.py 在module1.py中：\ndef func1(): return \u0026#34;Function 1 from module 1\u0026#34; 在module2.py中：\ndef func2(): return \u0026#34;Function 2 from module 2\u0026#34; 在主程序中使用包：\nfrom mypackage import module1, module2 print(module1.func1()) # 输出 \u0026#34;Function 1 from module 1\u0026#34; print(module2.func2()) # 输出 \u0026#34;Function 2 from module 2\u0026#34; ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/qac/",
    "title": "QAC",
    
    "content": " 相关基础知识 评估标准 缺陷数量：报告中列出的所有缺陷和警告的数量。 缺陷严重性：缺陷的等级分类（如严重、中等、轻微），帮助优先处理高风险问题。 代码复杂度：圈复杂度等度量，反映代码的复杂程度。 代码规范违例：违反编码标准和最佳实践的数量和类型。 代码覆盖率：静态分析所覆盖的代码比例，评估代码的全面性。 重复代码：检测到的重复代码块的数量。 安全漏洞：识别的安全问题和潜在的漏洞。 性能警告：关于性能问题的警告和建议。 规则 在 QAC（Quality Assurance C）中，规则 是一组编码标准或检查项，用于静态代码分析。它们的主要作用是自动检测源代码中的潜在错误、不符合编码规范的地方，以及可能导致软件漏洞或性能问题的代码。具体来说，QAC中的规则主要有以下几个作用：\n编码标准一致性：确保代码符合编码标准（例如MISRA-C标准），提升代码的一致性和可维护性。 错误检测：帮助识别常见的编程错误，如空指针引用、数组越界、未初始化的变量等。 代码质量提高：通过检测潜在的错误和坏习惯，提升代码的整体质量和可读性。 安全性增强：识别可能导致安全漏洞的代码，如未正确处理用户输入、内存泄漏等。 减少调试时间：在代码早期阶段检测并修复问题，减少后期调试和修复的工作量。 符合行业规范：某些行业（如汽车、医疗设备）对软件安全性和可靠性要求很高，QAC的规则有助于确保代码符合这些行业规范。 检测原理 代码解析（Parsing）\n词法分析和语法分析：QAC 首先对源代码进行词法分析，将代码分解成标记（tokens），然后进行语法分析，构建语法树（Abstract Syntax Tree, AST）。这一步确保代码的语法结构正确，并为后续的分析提供基础。 语义分析：在语法树基础上，QAC 进行语义分析，理解代码的实际含义，包括变量类型、作用域、函数调用等信息。 规则应用（Rule Application）\n预定义规则：QAC 内置了大量的规则，这些规则可能基于行业标准（如 MISRA-C、CERT C）或最佳编码实践。这些规则涵盖了代码风格、潜在错误、安全漏洞等多个方面。 自定义规则：用户可以根据项目需求定义自有规则，进一步细化代码检查标准。 规则匹配：QAC 将解析后的代码与这些规则进行匹配，识别出不符合规范或存在潜在问题的代码片段。 控制流和数据流分析（Control Flow and Data Flow Analysis）\n控制流分析：QAC 分析代码中的控制结构（如条件分支、循环、跳转等），识别复杂或不合理的控制流模式，预防死循环、未定义行为等问题。 数据流分析：通过追踪变量的定义、使用和传递，QAC 检测未初始化变量、变量覆盖、内存泄漏、数据竞争等问题。 抽象语法树（AST）和中间表示（Intermediate Representation）\nAST 构建：通过构建 AST，QAC 能够深入理解代码的结构和层次关系，支持复杂的代码模式识别。 中间表示：QAC 可能将代码转换为中间表示，以便进行更高效和全面的分析，如路径分析、依赖分析等。 错误检测与报告（Error Detection and Reporting）\n错误分类：QAC 将检测到的问题按照严重性、类型进行分类，如警告、错误、建议等。 详细报告：生成详细的报告，指出问题所在的具体位置（文件、行号）、问题描述以及可能的解决建议，帮助开发人员快速定位和修复问题。 集成与自动化（Integration and Automation）\n集成开发环境（IDE）支持：QAC 可以集成到各种 IDE 中，实时反馈代码问题，提高开发效率。 持续集成（CI）支持：与持续集成工具集成，实现自动化的代码检查，确保每次代码提交都符合质量标准。 增量分析与优化（Incremental Analysis and Optimization）\n增量分析：QAC 支持对代码的增量分析，只分析发生变化的部分，提高分析效率。 性能优化：通过优化算法和数据结构，QAC 能在保证分析深度和准确性的同时，提高分析速度。 总结\nQAC 通过全面的静态代码分析方法，包括语法和语义解析、规则匹配、控制流和数据流分析，结合预定义和自定义的规则集，实现对代码质量、安全性和规范性的多维度检查。其自动化、集成化的特点，使得开发团队能够在早期阶段发现并修复潜在问题，提升软件的整体质量和可靠性。\n操作流程 QAC工程构成\nproject ├─prqa │\t├─configs │\t│ └─Initial │\t│ ├─cip │\t│ ├─config │\t│ ├─logs │\t│ ├─output │\t│ └─reports │\t├─unified │\t└─upgrade ├─prqaproject.xml ├─src └─lib prqaproject.xml：文件保存工程相关信息 config：包含工程各配置文件，如 cct、 acf、 rcf 等。 output：按照代码层次创建文件夹，保存分析后输出文件。 reports： 保存生成的报告文件 src\\lib…：相关代码文件夹， 可手动或通过同步导入（保持其结构） 新建工程 点击 Create New Project 按钮，或点击 Project 菜单下的 Create New Project，创建新工程 在弹出对话框设置工程基本信息 。 通过 Project Location 右侧按钮选择工程根目录， Project Name 栏以根目录名作为工程名。通过右侧按钮选择工程根目录，以根目录名作为工程名， 选好目录后可以进行修改，修改后重新创建工程目录， 工程名称根据选定的工程路径自动生成。\n根据工程需要在下拉菜单选择配置文件。（初始选择 default.acf 和 default.en_US.rcf 即可）\n[!TIP]\n注意，这里不能勾选AUTO CTT，否则就不能next\n点击 Next， 进行相应编译器的选择，先选择 C，在选择 C++，如果只用是 C 或者只是C++的代码，则另外一种 CCT（Compiler Compatibility Template， 编译器兼容模板） 可以任意选择。\n[!NOTE]\n建议选择与实际编译器匹配或接近的 CCT 文件，没有匹配的编译器时选择Helix_Generic_C 或 Helix_Generic_C++ 。\n设置完毕后，点击 Finish， 则可在弹出的窗口进行工程详细设定（可暂时不进行详细设定）。\n在files卡片中会显示相关工程的组成结构\n[!IMPORTANT]\nReprise License Manager（服务器端） 在每次使用 QAC 前都要启动， 并在QAC 使用期间保持打开。\n添加源码 手动导入\n手动添加代码可选择添加单一文件，或添加文件夹。\n可通过右键resource，选择add file来添加源码文件\n同步方式\n同步方式需要跟踪编译过程， 因此 QAC 客户端电脑具备编译环境时才可使用此方式， 主要适用于以下情况：\n分析一个已经成功编译的完整工程\nLinux 环境下的测试，尤其是使用了 Linux 下的交叉编译环境，由于调用路径纷繁不好追踪， “同步”这种半自动化方式可以协助解决此类问题\n步骤如下：\n点击 project-\u0026gt;synchronize\n在弹出的窗口中填写调用的编译环境，并点击 Synchronize，进行调用。一般可有如下两种模式：\n“Enter Build Command”直接填写编译环境调用的命令，如“.\\Keil_v5\\UV4\\UV4.exe”，则“Optional Working Directory”中无需填写任何路径，该种情况下，点击“Synchronize”按钮之后，会自动调用对应的 keil 编译环境，直接在编译器界面对待测试工程进行build 手动操作，即可实现 QAC 的源码同步\n“Enter Build Command”填写的是跟踪待测工程的编译命令，如“ make clean \u0026amp;\u0026amp;make”， 则必须在“Optional Working Directory”中指明 make 指令执行的 makefile文件的路径，否则无法实现跟踪\n[!NOTE]\n需要注意， 两种模式均需保证工程编译之前是 clean 的状态\n这里以keil为例，在synchronize的页面的entre build command的输入框中输入keil的运行程序exe文件\n此时等待 QAC 自动调起 keil。切换到自己需要进行静态分析的工程,对该工程 clean再进行 build 一次，等待 build 完成。在编译环境 build 过程中， QAC 客户端窗口会显示一些文件逐步 File-added\nbuild 完成后， 手动关闭 keil，可以在 QAC 中发现刚刚编译的文件已经添加进来\n打开所创建的 QAC 工程目录，一级目录下有文件 prqaproject.xml 文件，文本格式打开可以看到加载进去的所有源码文件,以及源码对应的一些头文件或宏定义信息。\n工程配置 点击 Project -\u0026gt; Project Properties，打开工程属性页面。\nAnalysis 用于分析配置。从 Component Option 中选择配置选项，在对应 Argument 窗口（界面右下角）中进行对应设置。\n-d：进行必要的宏定义添加\n-threshold 度量元检测值定义\nmetric{\u0026lt; 或 \u0026lt;= 或 = 或 \u0026gt; 或 \u0026gt;=}value[:msq no]\neg.STCYC\u0026gt;10.6000\n-i：添加需要的头文件路径\n-quiet：屏蔽对头文件的扫描\n-warncall 调用函数设置警告\nfunction[=msq no]\neq:open=6001\n-maxerrors\n指定最大错误数\nRule Configuration 用于消息设定 ：在 Rule Configuration 可查看变更 Message 以及规则组\nAnalysis 界面中添加 M3CM 组件（弹出的窗口点击 Yes）\n点击完确认之后，会显示产生的相关文件\n根据 QAC 版本选择对应的 m3cm 规则集进行导入。点击保存即可\n执行分析 分析方法有两种：\n方式一： 通过菜单栏 Analysis-\u0026gt;File-Based Analysis，选择对当前工程、所选文件或勾选指定文件进行静态分析。\n也可以直接点击快捷键进行分析 方式二： 可在工程文件列表中， 选择相应文件夹/文件，右键 Analyse selected file(s)，对其进行分析。\n分析结果查看 当分析完成文件之后，将会显示源代码，在源代码的左侧会显示行代码是否有问题\n违反消息处有叹号标记 Analysis Results/Diagnostics 中罗列当前选中文件中违反的消息信息。点击具体 ID 查看 Message 帮助文件，点击 Rule，查看规则详细信息，双击消息内容，在代码中高亮显示违反部分代码。可以通过窗口上方叹号标记筛选显示不同级别消息。筛选同时作用于源代码上的标记。 红色标记： Error message 黄色标记： Warning message 绿色标记： User message 蓝色标记： Information message 点击“Rule” 下规则条目， 可通过悬浮窗可查看每个违反消息的帮助文档 消息索引：Files、 Rule Groups、 Message Levels 导出报告 点击*==菜单\u0026gt;Report\u0026gt;选择生成工程或单独文件的报告。==*\n可生成 7 种相关报告：\nCode Review Report：生成 html类型文件，显示文件相关度量结果和分析状态（未被抑制的违反规则数） Metrics Data Report：点击生成 Metrics Data Report，将生成 xml 文件，存储相关度量指标数据。 Rule Compliance Report：生成 html 类型文件，显示文件详细的违反规则数。 Suppression Report：生成 xml 文件，显示被抑制的消息信息。 HIS Metrics Report：生成 html 文件，显示 HIS 度量报告。 Standards Compliance Report： 生成 html 文件， 根据项目所选的规则集显示项目关于该规则集的合规性报告。 MISRA Compliance Report： 生成 html 文件， 显示 MISRA 合规性报告。 Dashboard相关操作 上传项目 服务器端 Perforce -\u0026gt; Helix QAC Dashboard server ， 保持 Dashboard server 开启状态\n打开 Helix QAC， 点击*==Portals \u0026gt; Dashboard \u0026gt; connect to Dashboard Sever==*，设置 URL、用户名及密码后，连接到相应的 Dashboard Sever。（注意：首行 Dashboard URL 的填写格式为“Dashboard server 端 IP 地址:8080”）\n默认登录 Username 和 Password 均为 admin。\n也可以使用快捷按键\n连接成功后页面右下角显示： Dashboard Connection Status:Connected to 192.168.3.224:8080\n点击 ==Portals \u0026gt; Dashboard \u0026gt; Upload Results==，选择上传文件或工程分析结果到 Dashboard。\n在弹出窗口填写相关信息：\n注意： Upload Source 选择 All， 可以将源码以及诊断消息全部上传到 dashboard 上，默认只上传诊断消息。\nSnapshot Nam填写当前测试的版本\n[!WARNING]\n注意：这里需要查看是否上传完成\n需要关掉翻墙软件，防止出现ip地址不明的情况\n查看项目 在打开的 IE 浏览器输入http://服务器地址：端口号（比如 http://localhost:8080）\n输入用户名和密码，都是 admin，进入 Dashboard 界面：\n从主面板进入工程界面，选中上传之后的项目之后可以对项目做以下的操作： Web Message Browser Diagnostic Summary Measurement Analysis Reports **Web Message Browser 界面 **\n会展示所有的相关消息\n也可以根据消息的严重程度来筛选所要展示的消息\n在不同的区域右键会出现不同的相关信息\n在消息上右键出现Message 菜单： 鼠标右键点击某一条消息会弹出此菜单（消息号、消息帮助链接、严重等级、对应行号、所属消息组、抑制选项等信息） 在源码上右键出现Source Code 菜单： 鼠标右键点击某一行代码会弹出此菜单（行号、所在函数名、文件及函数度量信息、抑制选项等）\n在消息组上右键出现Message Group 菜单： 鼠标右键点击某一个消息组会弹出此菜单（主要用来设置抑制选项）\n**Diagnostic Summary 界面 **\n显示了工程代码的结构：选择任意文件夹或者文件可以查看所选粒度的诊断信息， 可生成固定报告模板。\n**Measurement Analysis 界面 **\n显示质量度量指标的发展趋势：可以根据快照名称或者快照的日期来查看趋势。\n[!IMPORTANT]\n以下是度量标准相关释义：\nSTCAL（Static Complexity Analysis）：评估代码的整体复杂性，通常基于控制流和数据流分析。 STM29（Module Complexity Analysis）：分析模块的复杂性，关注模块的功能和结构。 STCYC（Static Cyclomatic Complexity）：基于控制流图的分支和循环结构，衡量代码的复杂性。 STPFL（Static Path Length）：评估执行路径的长度，反映程序的复杂性。 STVFL（Static Variable Flow）：分析变量在程序中的使用和流动，关注数据依赖性。 STFAN（Static Fan-in/Fan-out Analysis）：评估模块之间的调用关系，关注模块的耦合度。 STCLO（Static Closure Analysis）：衡量代码的封闭性，反映模块的独立性和可重用性。 STNFC（Static Nested Function Complexity）：测量嵌套函数的复杂性，关注其对可读性的影响。 STMAX（Static Maximum Depth）：评估程序中嵌套结构的最大深度，反映复杂性。 STDDM（Static Data Dependency Measurement）：分析数据依赖关系，关注变量间的影响。 STRED（Static Redundancy Measurement）：测量代码中冗余部分的复杂度。 STMFC（Static Module Function Complexity）：评估模块内函数的复杂性。 STDEC（Static Depth of Execution Complexity）：评估执行路径的深度。 STWMC（Static Weighted Method Complexity）：考虑权重的函数复杂度度量。 STLCC（Static Lines of Code Complexity）：基于代码行数的复杂度评估。 STLOP（Static Logic Operation Complexity）：评估逻辑操作的复杂性。 STCFG（Static Control Flow Graph Complexity）：分析控制流图的复杂度。 STCAI（Static Call Instruction Complexity）：评估调用指令的复杂性。 STBFC（Static Branch Frequency Complexity）：分析分支频率对代码复杂性的影响。 STABI（Static Abstraction Complexity）：评估代码的抽象层次。 STMPI（Static Module Performance Indicator）：评估模块的性能指标。 STTDC（Static Type Dependency Complexity）：分析类型依赖关系的复杂性。 STEXT（Static Execution Trace Complexity）：评估执行轨迹的复杂度。 STHWC（Static Hardware Complexity）：评估代码与硬件交互的复杂性。 生成报告 自定制报告，点击 Report，进入自定制报告界面\n在界面右上角，点击 Add Report Object，进行报告自定制， 支持 HTML、 PDF 或者XML 格式。\n用户管理 Dashboard 最多可同时登录 5 个用户，默认用户为 admin。创建新用户的步骤如下：\n在 Dashboard 主界面（Project Dashboard），点击“User Management”按钮。\n进入 User Management 界面，点击左上角“Add New User”按钮；填写新用户信息（用户名和密码）， 点击“Save”。\n选中新建用户，使能权限。点击 Edit permissions，在用户权限界面可依实际需求进行选择，点击 Toggle All Tickboxes 可使能全部权限。 可能出现的问题及解决方案 对于rlm软件打开一会自动关闭的情况，解决方法如下：\n在打开rlm软件的情况下，访问localhost:5054\n在用户和密码位置键入账号和密码（首次登陆的账号和密码均是admin）\n点击change passward，修改密码为yxd12345（自定义）\n重启rlm即可\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/rtc/",
    "title": "RTC",
    
    "content": " 时间戳 概述 Unix时间戳(Unix Timestamp)定义为从UTC/GMT的1970年1月1日0时0分0秒开始所经过的秒数，不考虑闰秒\n时间戳存储在一个秒计数器中，秒计数器为32位/64位的整型变量\n世界上所有时区的秒计数器相同，不同时区通过添加偏移来得到当地时间\nGMT和UTC GMT(Greenwich Mean Time)格林尼治标准时间是一种以地球自转为基础的时间计量系统。它将地球自转一周的时间间隔等分为24小时，以此确定计时标准\nUTC(Universal Time Coordinated)协调世界时是一种以原子钟为基础的时间计量系统。它规定铯133原子基态的两个超精细能级间在零磁场下跃迁辐射9,192,631,770周所持续的时间为1秒。当原子钟计时一天的时间与地球自转一周的时间相差超过0.9秒时，UTC会执行闰秒来保证其计时与地球自转的协调一致\n时间戳转换 函数 作用 time_t time(time_t*); 获取系统时钟 struct tm* gmtime(const time_t*); 秒计数器转换为日期时间（格林尼治时间） struct tm* localtime(const time_t*); 秒计数器转换为日期时间（当地时间） time_t mktime(struct tm*); 日期时间转换为秒计数器（当地时间） char* ctime(const time_t*); 秒计数器转换为字符串（默认格式） char* asctime(const struct tm*); 日期时间转换为字符串（默认格式） size_t strftime(char*, size_t, const char*, const struct tm*); 日期时间转换为字符串（自定义格式） [!TIP]\n需要引入time.h才可以使用上述函数\n实验：时间戳转换\n#include\u0026lt;time.h\u0026gt; time_t time_cnt; //秒计数器 struct tm time_date; //日期时间数据类型 char* time_str; //字符串数据类型 int main(void){ time_cnt = time(NULL); //这里的time_cnt实际上就是一个长整秒，int64类型的 time(\u0026amp;time_cnt); //和上面的代码作用一样 time_date = *gmtime(\u0026amp;time_cnt); //加上*就可以取结构体的内容，将长整秒转换为伦敦时间，也就是格林尼治时间 time_date.tm_year += 1900; //由于时间的基准是1900年，所以需要加上1900 time_date.tm_mon += 1; time_date = *localtime(\u0026amp;time_cnt); //转换长整秒为当地时间，该函数会将时间转换为当地时间 time_cnt = mktime(\u0026amp;time_date); //是转换的逆过程，也就是将日期时间转换为长整秒 time_str = ctime(\u0026amp;time_cnt); //将长整秒转换为字符串 time_str = asctime(\u0026amp;time_date); //将数据类型转换为字符串类型 char t[50]; strftime(t,50,\u0026#34;%H-%M-%S\u0026#34;,\u0026amp;time_date); //类似于printf函数，将数据类型字符串化，可以自定义输出 } RTC 实时时钟(Real Time Clock,RTC),本质是一个计数器，计数频率常为秒，专门用来记录时间。\n[!NOTE]\n普通定时器拿来作时钟可行吗？\n普通定时器无法掉电运行！\nRTC特性\n能提供时间（秒钟数） 能在MCU掉电后运行 低功耗 RTC有以下特点及功能\nRTC是一个独立的定时器，可为系统提供时钟和日历的功能 RTC和时钟配置系统处于后备区域，系统复位时数据不清零，VDD(2.0 ~ 3.6V)断电后可借助VBAT（1.8~3.6V)供电继续走时 32位的可编程计数器，可对应Unix时间戳的秒计数器 20位的可编程预分频器，可适配不同频率的输入时钟 可选择三种RTC时钟源： HSE时钟除以128（通常为8MHz/128) LSE振荡器时钟（通常为32.768KHz) LSI振荡器时钟(40KHz) 常见的解决方案 对比因素 内部RTC 外置RTC 信息差异 提供秒/亚秒信号 提供秒信号和日历 功耗 功耗高 功耗低 体积 不用占用额外体积 体积大 成本 成本低 成本高 [!TIP]\n一般都需要设计RTC外围电路； 一般都可以给RTC设置独立的电源； 多数RTC的寄存器采用BCD码存储 框图 RTC时钟来源：\n接高速晶振，一般接主晶振（8MHz），通过128分频，可以产生RTCCLK时钟。为了在RTC的时钟为1Hz，所以使用高速时钟的时候需要先进行128倍分频 接低速晶振，可以直接给RTCCLK，OSC32的晶振是内部RTC的专用时钟，这个晶振的值不是随便选的，一般和RTC有关的，都是统一的数值，就是32.768KHz（2的次方数15次方），需要注意的是，只有OSC32这个时钟在设备断电后是由VBAT提供电源，其他的LSI和HSE都不接VBAT，所以最好使用OSC32 [!NOTE]\n框图中的组件：\nRTC预分频器 32位可编程计数器 待机唤醒 RTC控制寄存器与APB1接口 3个时钟源：\nHSE/128 LSI 40kHz LSE 32.768kHz RTC预分频器： 一般来说RTCCLK进来都不是1MHz的，所以需要进行分频，这个分频器由两个寄存器组成重装载寄存器（RTC_PRL）和余数寄存器（RTC_DIV）。\n我们在RTC_PRL中写入6，则代表7分频，因为是从零开始的。\nRTC_DIV实际上就是一个计数器，当计数记到7时，自然溢出，产生一个时钟，这就是分频的原理，这里的div是一个递减计数器，每来一个输入时钟，DIV的值就自减一次，当自减为0时，再来一个输入时钟，产生一个溢出信号，同时DIV从PRL获取重装值，继续自减。\n32位可编程计数器 我们可以将这个计数器看作是unix时间戳的秒计数器，所以我们可以使用time.h头文件中的函数读取并且转换时间\n此外，这里还有一个RTC_ALR闹钟寄存器，32位寄存器，在ALR中写入一个秒数，设置一个闹钟，当CNT的值和闹钟值相等时，这时就会产生RTC_Alarm闹钟信号，通往右边的中断系统，在中断函数中就可以执行相应的操作了，同时，这个闹钟还可以让STM32退出待机模式\n待机唤醒 闹钟信号和wake up引脚都可以唤醒设备\n中断系统 将会产生三个中断：\nRTC_Second（秒中断）：每秒进入一次中断 RTC_Overflow（溢出中断）：32位的计数器记满溢出，将会产生一个中断 RTC_Alarm（闹钟中断）：当计数器和闹钟值相等时，将会产生一个中断 简易框图 注意事项 执行以下操作将使能对BKP和RTC的访问： 设置RCC APB1ENR的PWREN和BKPEN,使能PWR和BKP时钟 设置PWR CR的DBP,使能对BKP和RTC的访问 若在读取RTC寄存器时，RTC的APB1接口曾经处于禁止状态，则软件首先必须等待RTC CRL寄存器中的RSF位（寄存器同步标志）被硬件置1 必须设置RTC CRL寄存器中的CNF位，使RTC进入配置模式后，才能写入RTC_PRL、RTC_CNT、RTC_ALR寄存器 对RTC任何寄存器的写操作，都必须在前一次写操作结束后进行。可以通过查询RTC_CR寄存器中的RTOFF,状态位，判断RTC寄存器是否处于更新中。仅当RTOFF状态位是1时，才可以写入RTC寄存器 BKP BKP(Backup Registers)是备份寄存器\nBKP可用于存储用户应用程序数据。当VDD(2.0-3.6V)电源被切断，他们仍然由VBAT(1.8~3.6V)维持供电。当系统在待机模式下被唤醒，或系统复位或电源复位时，他们也不会被复位\nTAMPER引脚产生的侵入事件将所有备份寄存器内容清除\nRTC引脚输出RTC校准时钟、RTC闹钟脉冲或者秒脉冲\n存储RTC时钟校准寄存器\n用户数据存储容量：20字节（中容量和小容量)/84字节（大容量和互联型)\n[!tip]\n橙色部分就是后备区域，当VDD主电源掉电时，后备区域仍然可以由VBAT的备用电池供电，当VDD主电源上电时，后备区域供电就会由VBAT切换到VDD\n实验 测试备份数据寄存器 int main(void){ serial_init(); RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE); PWR_BackupAccessCmd(ENABLE); //备份访问控制 // BKP_WriteBackupRegister(BKP_DR1,0x1234); serial_printf(\u0026#34;the backup value is %x\\n\u0026#34;, BKP_ReadBackupRegister(BKP_DR1)); } 实时时钟 u16 myRtc_time[] = {2023,1,1,23,59,59}; //注意在写数据时最好不要在前面随便补零，因为c语言中的0代表了八进制 void myrtc_init(void) { RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE); PWR_BackupAccessCmd(ENABLE); //备份访问控制 if(BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5){ //当系统完全断电时，BKP_DR1必定为0，所以将会执行以下代码,复位bkp的寄存器也不会为0 // RCC_LSEConfig(RCC_LSE_ON); //配置外部时钟 // while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET); //LSE并不是说启动就能启动的，所以需要等待标志位变为1 // RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE); //选择LSE作为时钟源 RCC_LSICmd(ENABLE); //当LSE起振不了将会一直卡在读取标志位的地方，可以采用LSI while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET); RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI); RCC_RTCCLKCmd(ENABLE); RTC_WaitForSynchro(); //等待同步 RTC_WaitForLastTask(); //等待上次写入操作完成 // RTC_SetPrescaler(32768 - 1); //设置分频系数，我们选择的是LSE，LSE的晶振频率为32.768Khz，也就是32768HZ，如果想要变成1hz，那么就要32768分频 RTC_SetPrescaler(40000 - 1); RTC_WaitForLastTask(); //等待写入完成 myrtc_setTime(); BKP_WriteBackupRegister(BKP_DR1,0xA5A5); //第一次启动完毕之后，将这个标志位置为0xA5A5 }else{ RTC_WaitForSynchro(); //等待同步 RTC_WaitForLastTask(); //等待上次写入操作完成 } } void myrtc_setTime(void) { time_t time_cnt; struct tm time_date; time_date.tm_year = myRtc_time[0] - 1900; //需要先设置一个初始化时间 time_date.tm_mon = myRtc_time[1] - 1; time_date.tm_mday = myRtc_time[2]; time_date.tm_hour = myRtc_time[3]; time_date.tm_min = myRtc_time[4]; time_date.tm_sec = myRtc_time[5]; time_cnt = mktime(\u0026amp;time_date); //将日期数据类型转换为长整秒 // time_cnt = time_cnt - 8 * 60 * 60; //适应于北京时间 RTC_SetCounter(time_cnt); RTC_WaitForLastTask(); } void myrtc_readTime(void) { time_t time_cnt; struct tm time_date; time_cnt = RTC_GetCounter(); // time_cnt = time_cnt + 8 * 60 * 60; //这样就可以计算出北京时间了，也就是在小时的位加上8 time_date = *localtime(\u0026amp;time_cnt); myRtc_time[0] = time_date.tm_year + 1900; //需要先设置一个初始化时间 myRtc_time[1] = time_date.tm_mon + 1; myRtc_time[2] = time_date.tm_mday; myRtc_time[3] = time_date.tm_hour; // myRtc_time[4] = time_date.tm_min; myRtc_time[5] = time_date.tm_sec; } int main(void){ serial_init(); myrtc_init(); while(1){ myrtc_readTime(); serial_printf(\u0026#34;date: %d-%d-%d\\n time: %d-%d-%d\\n\u0026#34;,myRtc_time[0],myRtc_time[1],myRtc_time[2],myRtc_time[3],myRtc_time[4],myRtc_time[5]); } } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/",
    "title": "Rust",
    
    "content": " 参考链接 进入 Rust 编程世界 - Rust语言圣经(Rust Course)\n编程环境：\nVscode rust（vscode插件） rust-analyzer（vscode插件，用于rust） Even Better TOML（vscode插件，用于toml文件） Cargo cargo 提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为 Rust 项目的管理提供尽可能完整的手段。同时，与 Rust 语言及其编译器 rustc 紧密结合，可以说用了后就忘不掉，如同初恋般的感觉。\n使用cargo创建一个项目\ncargo new world_hello cd world_hello 上述命令创建了一个cargo项目，该项目由cargo管理，创建好的项目结构如下\n$ tree . ├── .git ├── .gitignore ├── Cargo.toml └── src └── main.rs 运行 运行cargo程序有两种方法\ncargo run 手动运行 cargo run\ncargo run Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello) Finished dev [unoptimized + debuginfo] target(s) in 0.43s Running `target/debug/world_hello` Hello, world! 手动运行\n编译\ncargo build Finished dev [unoptimized + debuginfo] target(s) in 0.00s 运行\n./target/debug/world_hello Hello, world! 当我们使用使用上面两种方法运行的时候，，编译速度会非常快，但是运行速度就很慢，因为是在debug模式下，所以我们可以使用--release命令\ncargo run --release cargo build --release Cargo check cargo check 是我们在代码开发过程中最常用的命令，它的作用很简单：快速的检查一下代码能否编译通过。因此该命令速度会非常快，能节省大量的编译时间\ncargo check Checking world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello) Finished dev [unoptimized + debuginfo] target(s) in 0.06s Cargo的配置文件 Cargo.toml 和 Cargo.lock 是 cargo 的核心文件，它的所有活动均基于此二者。\nCargo.toml 是 cargo 特有的项目数据描述文件。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 Cargo.toml。 Cargo.lock 文件是 cargo 工具根据同一项目的 toml 文件生成的项目依赖详细清单，因此我们一般不用修改它，只需要对着 Cargo.toml 文件撸就行了。 什么情况下该把 Cargo.lock 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 Cargo.lock，如果是一个依赖库项目，那么请把它添加到 .gitignore 中。\n现在用 VSCode 打开上面创建的\u0026quot;世界，你好\u0026quot;项目，然后进入根目录的 Cargo.toml 文件，可以看到该文件包含不少信息：\npackage 配置段落 package 中记录了项目的描述信息，典型的如下：\n[package] name = \u0026#34;world_hello\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; name 字段定义了项目名称，version 字段定义当前版本，新项目默认是 0.1.0，edition 字段定义了我们使用的 Rust 大版本。因为本书很新（不仅仅是现在新，未来也将及时修订，跟得上 Rust 的小步伐），所以使用的是 Rust edition 2021 大版本，详情见 Rust 版本详解\n定义项目依赖 使用 cargo 工具的最大优势就在于，能够对该项目的各种依赖项进行方便、统一和灵活的管理。\n在 Cargo.toml 中，主要通过各种依赖段落来描述该项目的各种依赖项。引入依赖项有三种方法：\n基于 Rust 官方仓库 crates.io，通过版本说明来描述 基于项目源代码的 git 仓库地址，通过 URL 来描述 基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述 这三种形式具体写法如下：\n[dependencies] rand = \u0026#34;0.3\u0026#34; hammer = { version = \u0026#34;0.5.0\u0026#34;} color = { git = \u0026#34;https://github.com/bjz/color-rs\u0026#34; } geometry = { path = \u0026#34;crates/geometry\u0026#34; } 变量的绑定与解构 ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/",
    "title": "Shell",
    
    "content": " 参考链接 第十章、认识与学习BASH | 鸟哥的 Linux 私房菜：基础学习篇 第四版 (gitbooks.io)\n课程概览与 shell · the missing semester of your cs education (missing-semester-cn.github.io)\n第十二章、学习 Shell Scripts | 鸟哥的 Linux 私房菜：基础学习篇 第四版 (gitbooks.io)\nBASH ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/simulink/",
    "title": "Simulink",
    
    "content": " 参考链接 Simulink 快速入门 - MathWorks 中国\nSimulink Simulink 是 MATLAB 环境中的一个扩展工具，用于多领域动态系统的建模、仿真和分析。它提供了一个图形化的用户界面，使用户能够通过拖放各种模块和连接它们来构建模型。Simulink 特别适用于以下几个领域：\n控制系统设计：用户可以设计和仿真复杂的控制系统，包括 PID 控制、模糊控制、鲁棒控制等。 信号处理：Simulink 提供了广泛的信号处理工具箱，可以用于滤波、调制、解调等操作。 通信系统：可以建模和仿真通信系统，包括发射机、接收机、调制解调器等。 物理系统建模：可以建模机械、电气、热力、液压等物理系统，通过物理建模工具箱（如 Simscape）进行仿真。 嵌入式系统：可以设计嵌入式控制器，生成 C/C++ 代码，并将其部署到嵌入式硬件上。 Simulink 的主要功能包括：\n图形化建模：通过图形化界面，用户可以拖放和连接各种模块来构建系统模型。 仿真：可以对构建的模型进行仿真，分析系统的动态行为。 模块化设计：支持模块化设计，可以将复杂系统分解为多个子系统，进行分层次建模。 自动代码生成：可以自动生成 C、C++ 或 HDL 代码，方便在嵌入式系统中实现和部署。 与 MATLAB 的集成：Simulink 和 MATLAB 无缝集成，可以使用 MATLAB 脚本控制 Simulink 仿真，或者在 Simulink 模型中调用 MATLAB 函数。。 Simulink 模块图 Simulink® 是动态系统的图形建模和仿真环境。可以创建模块图，用模块表示系统的各个组成部分。模块可以表示物理组件、小型系统或函数。输入/输出关系则完整描述了模块特征。请思考下面这些示例：\n一个水龙头往一个水桶里注入水 - 水以一定的流速进入水桶，水桶变重。模块可以表示水桶，水的流速为输入，水桶的重量为输出。 您用扩音器传递声音 - 扩音器一端产生的声音在另一端被放大。扩音器是模块，输入是声源的声波，输出是您听到的声波。 您推动购物车使它移动 - 购物车是模块，您施加的力是输入，购物车的位置是输出。 只有定义了输入和输出，模块的定义才算完成，并且此模型定义任务需与建模目的相关。例如，如果建模目的不涉及购物车的位置，则会自然选择购物车的速度作为输出。\nSimulink 提供了一些模块库， …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/spi/",
    "title": "SPI",
    
    "content": " 参考链接 SPI协议详解（图文并茂+超详细） - 知乎 (zhihu.com)\n串口 因为UART没有时钟信号，无法控制何时发送数据，也无法保证双方按照完全相同的速度接收数据。因此，双方以不同的速度进行数据接收和发送，就会出现问题。\n如果要解决这个问题，UART为每个字节添加额外的起始位和停止位，以帮助接收器在数据到达时进行同步；\n双方还必须事先就传输速度达成共识（设置相同的波特率，例如每秒9600位）。\n传输速率如果有微小差异不是问题，因为接收器会在每个字节的开头重新同步。相应的协议如下图所示：\n[!NOTE]\n图中的11001010不等于0x53。这是因为串口协议通常会首先发送最低有效位，因此最小位在最左边LSB。低四位字节实际上是0011 = 0x3，高四位字节是0101 = 0x5。\n串口先发送低位，后发送高位\n异步串行工作得很好，但是在每个字节发送的时候都需要额外的起始位和停止位以及在发送和接收数据所需的复杂硬件方面都有很多开销。\n不难发现，如果接收端和发送端设置的速度都不一致，那么接收到的数据将是垃圾（乱码）。\n因为UART没有时钟信号，无法控制何时发送数据，也无法保证双方按照完全相同的速度接收数据。因此，双方以不同的速度进行数据接收和发送，就会出现问题。\n于是我们想有没有更好一点的串行通讯方式；相比较于UART，SPI的工作方式略有不同。\nSPI是一个同步的数据总线，也就是说它是用单独的数据线和一个单独的时钟信号来保证发送端和接收端的完美同步。 时钟是一个振荡信号，它告诉接收端在确切的时机对数据线上的信号进行采样。 产生时钟的一侧称为主机，另一侧称为从机。总是只有一个主机（一般来说可以是微控制器/MCU），但是可以有多个从机（后面详细介绍）； 数据的采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低）。 介绍 SPI:串行外设设备接口(Serial Peripheral Interface),是一种高速的、全双工、同步的通信总线。\n功能说明 SPI总线 IIC总线 通信方式 同步串行全双工 同步串行半双工 总线接口 MOSI、MISO、SCL、CS SDA、SCL 拓扑结构 一主多从/一主一从 多主从 从机选择 片选引脚选择 SDA上设备地址片选 通信速率 般50MHz以下 100kHz、400kHz、3.4MHz 数据格式 8位/16位 8位 传输顺序 MSB/LSB MSB SP接口主要应用在存储芯片、AD转换器以及LCD中。\n[!IMPORTANT]\n输出引脚配置为推挽输出，输入引脚配置为浮空或者上拉输入，推挽输出高低电平都有着很强的驱动能力，和i2c不同，i2c电平下降快，上升缓慢，而SPI电平不仅上升快，下降也快\n主机一个输入引脚，这个引脚将会接收来自多个从机传输的数据，这势必会产生冲突，所以SPI规定，当从机未被选中时，MISO引脚必须切换为高阻态（相当于引脚断开，不输出任何电平）\n原理 基本收发电路就是一个==移位模型==\nSPI主机中有一个8位移位寄存器，SPI从机中也有一个8位的移位寄存器，移位寄存器有一个时钟输入端，SPI一般都是==高位==先行的，每来一个时钟，移位寄存器都会向左进行移位，从机中的移位寄存器也是同理。移位寄存器的时钟源由主机提供（波特率发生器），它产生的时钟驱动主机的移位寄存器进行移位，同时，这个时钟也通过SCK引脚进行输出给到从机的移位寄存器中，主机移位寄存器左边移出去的数据，通过MOSI输入到从机移位寄存器的右边，从机移位寄存器左边移出去的数据，通过MISO输入到主机移位寄存器的右边\n如果是主机只是发送（只是接收），那么还是和上面同时收发一样，只是从机会随便发送一串数据（一般会给0xff或0x00），只要将数据置换出来即可，主机不会关注接收到的数据\n特性 框架图 信号线 MISO：Master input slave output 主机输入，从机输出（数据来自从机）； MOSI：Master output slave input 主机输出，从机输入（数据来自主机）； SCLK ：Serial Clock 串行时钟信号，由主机产生发送给从机； SS：Slave Select 片选信号，由主机发送，以控制与哪个从机通信，通常是低电平有效信号。 时钟极性 除了配置串行时钟速率（频率）外，SPI主设备还需要配置时钟极性。\n根据硬件制造商的命名规则不同，时钟极性通常写为CKP或CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据；\nCKP可以配置为1或0。这意味着您可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。您必须参考设备的数据手册才能正确设置CKP和CKE。\nCKP = 0：时钟空闲IDLE为低电平 0； CKP = 1：时钟空闲IDLE为高电平1； 时钟相位 除配置串行时钟速率和极性外，SPI主设备还应配置时钟相位（或边沿）。根据硬件制造商的不同，时钟相位通常写为CKE或CPHA；\n顾名思义，时钟相位/边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；\nCKE = 0：在时钟信号SCK的第一个跳变沿采样； CKE = 1：在时钟信号SCK的第二个跳变沿采样； 如何确定数据的有效性：\n时钟极性(CPOL)：没有数据传输时时钟线的空闲状态电平\n0:SCK在空闲状态保持低电平 1：SCK在空闲状态保持高电平 时钟相位(CPHA):时钟线在第几个时钟边沿采样数据\n0:SCK的第一（奇数）边沿进行数据位采样，据在第一个时钟边沿被锁存 1：SCK的第二（偶数边沿进行数据位采样，数据在第二个时钟边沿被锁存 SPI工作模式 CPOL CPHA SCL空闲状态 采样边沿 采样时刻 0 0 0 低电平 上升沿 奇数边沿 1 0 1 低电平 下降沿 偶数边沿 2 1 0 高电平 下降沿 奇数边沿 3 1 1 高电平 上升沿 偶数边沿 SPI协议也需要MCU和芯片使用相同的时钟相位和极性来进行数据通信，比如芯片使用0状态进行通信，那么MCU就不能配置1/2/3状态进行通信，所以配置MCU需要看芯片手册支持什么时钟\n数据传输过程 基本时序单元 起始条件 SS从高电平切换到低电平\n终止条件 SS从低电平切换到高电平\n交换一个字节的数据传输过程 模式0\nCPOL=0:空闲状态时，SCK为低电平\nCPHA=0:SCK第一个边沿移入数据，第二个边沿移出数据\n模式1\nCPOL=O:空闲状态时，SCK为低电平\nCPHA=1:SCK第一个边沿移出数据，第二个边沿移入数据\n模式2\nCPOL=1:空闲状态时，SCK为高电平\nCPHA=0:SCK第一个边沿移入数据，第二个边沿移出数据\n模式3\nCPOL=1:空闲状态时，SCK为高电平\nCPHA=1:SCK第一个边沿移出数据，第二个边沿移入数据\n整体数据传输过程 数据的传输分为以下几个步骤：\n主机先将NSS信号拉低，这样保证开始接收数据； 当接收端检测到时钟的边沿信号时，它将立即读取数据线上的信号，这样就得到了一位数据（1bit）; 由于时钟是随数据一起发送的，因此指定数据的传输速度并不重要，尽管设备将具有可以运行的最高速度（稍后我们将讨论选择合适的时钟边沿和速度）。 主机发送到从机时：主机产生相应的时钟信号，然后数据一位一位地将从MOSI信号线上进行发送到从机； 主机接收从机数据：如果从机需要将数据发送回主机，则主机将继续生成预定数量的时钟信号，并且从机会将数据通过MISO信号线发送； [!NOTE]\n注意，SPI是“全双工”（具有单独的发送和接收线路），因此可以在同一时间发送和接收数据，另外SPI的接收硬件可以是一个简单的移位寄存器。这比异步串行通信所需的完整UART要简单得多，并且更加便宜；\n多从机模式 多NSS 通常，每个从机都需要一条单独的SS线。\n如果要和特定的从机进行通讯，可以将相应的NSS信号线拉低，并保持其他NSS信号线的状态为高电平；如果同时将两个NSS信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条MISO线上传输数据，最终导致接收数据乱码。\n菊花链 在数字通信世界中，在设备信号（总线信号或中断信号）以串行的方式从一 个设备依次传到下一个设备，不断循环直到数据到达目标设备的方式被称为菊花链。\n菊花链的最大缺点是因为是信号串行传输，所以一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了； 另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况； 具体的连接如下图所示；\n实验 Flash FLASH是常用的用于储存数据的半导体器件，它具有容量大，可重复擦写、按“扇区/块”擦除、掉电后数据可继续保存的特性。\nFLASH是有一个物理特性：只能写0，不能写1，写1靠擦除。\nFLASH:主要有NOR FIash和NAND FIash两种类型，NOR和NAND是两种数字门电路。\n类型 特点 应用举例 NOR FLASH 基于字节读写，读取速度快，独立地址/数据线，无坏块，支持XIP 25Qxx、程序ROM NAND FLASH 基于块读写，读取速度稍慢，地址数据线共用，有坏块，不支持XIP EMMC、SSD、U盘等 芯片简介 NM25Q18\nNM25Q128,串行闪存器件，属于N0 R FLASH中的一种，容量为128Mb。擦写周期可达10W次，可以将数据保存达20年之久。\nSPI数据传输时序:支持模式0(CPOL=0,CPHA=0)和模式3(CPOL=1,CPHA=1) 数据格式:数据长度8位大小，先发高位，再发低位 传输速度:支持标准模式104 M bit/s NM25Q18存储结构 存储器的地址范围为0x000000 ~0xFFFFFF\n那么一个模块大存储大小 = 256 * 16 * 16 * 256 = 2^24 = 0xFFFFFF\n一般将一个flash分为多个模块来使用？\n例如：使用0x00 ~ 0x0000ff作为文件系统使用\n使用0x0000ff~0x00ffff作为文件存储使用等等\n[!IMPORTANT]\n当我们使用的时候只需要往分配好的模块写入或者读出数据即可\n擦除只能擦除最小单元，比如页擦除、扇区擦除及整个芯片擦除，擦除的时间比写入的时间要更长\n写入不能跨页，但是读可以跨页\n常用命令 NOR FLASHE的指令总数比较多，但是如果只需要实现基本操作，还是比较简单的\n一般我们只需要5条指令即可完成对NOR FLASH的基本使用\n指令 (HEX) 名称 作用 0X06 写使能 写入数据/擦除之前，必须先发送该指令 0X05 读SR1 判定FLASH是否处于空闲状态，擦除用 0X03 读数据 用于读取NOR FLASH数据 0X02 页写 用于写入NOR FLASH数据，最多写256字节 0X20 扇区擦除 扇区擦除指令，最小擦除单位 （4096字节) 写使能06H\n执行Page Program（页写），Sector Erase（扇区擦除），Block Erase（块擦除），Chip Erase（片擦除），Write Status Register（写状态寄存器）等指令前，都需要写使能\n读状态寄存器05H\n读时序03H\n页写时序02H\n页写命令最多可以向FLASH传输256个字节的数据\n扇区擦除时序20H\n写入数据前，检查内存空间情况是否满足，不满足需擦除\n[!NOTE]\nFLASH初始化的时候，数据全为1，当我们想要写入零时，可以直接将1写为0，但是我们将0写为1时，就不能直接写，一般flash都是先擦除后写入，也就是写入0的过程\n状态寄存器表\n状态寄存器 Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bito 状态寄存器1 SPR RV TB BP2 BP1 BPO WEL BUSY 状态寄存器2 SUS CMP LB3 LB2 LB1 (R) QE SRP1 状态寄存器3 HOLD/RST DRV1 DRVO (R) (R) WPS ADP ADS SR寄存器：跟踪芯片的状态\nBUSY位指示当前状态：\n0:空闲状态（硬件自动清除） 1:当前处于忙碌状态 WEL位：\n执行Write Enable指令该位为1，可以页写/扇区or块or片擦除/写状态寄存器 0:写禁止，不能页编程/扇区or块or片擦除/写状态寄存器 软件模拟 void myspi_ss_set(u8 bitValue) { GPIO_WriteBit(SPI_PORT,SPI_SS,(BitAction)bitValue); } void myspi_sck_set(u8 bitValue) { GPIO_WriteBit(SPI_PORT,SPI_SCK,(BitAction)bitValue); } void myspi_si_set(u8 bitValue) { GPIO_WriteBit(SPI_PORT,SPI_SI,(BitAction)bitValue); } u8 myspi_so_get() { return GPIO_ReadInputDataBit(SPI_PORT,SPI_SO); } void myspi_init(void) { GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(SPI_CLK,ENABLE); GPIO_InitStruct.GPIO_Pin = SPI_SS | SPI_SCK | SPI_SI; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = SPI_SO; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); myspi_ss_set(1); myspi_sck_set(0); } void myspi_start(void) { myspi_ss_set(0); } void myspi_stop(void) { myspi_ss_set(1); } u8 myspi_swapByte(u8 data) { u8 receiveData = 0x00; for(u8 i = 0; i \u0026lt; 8 ; i++){ myspi_si_set(data \u0026amp; (0x80 \u0026gt;\u0026gt; i)); //模式0，先移除最高位，发送数据 myspi_sck_set(1); //第一个上升沿来临 if(myspi_so_get() == 1){ receiveData |= (0x80 \u0026gt;\u0026gt; i); //接收数据 } myspi_sck_set(0); //下降沿来临 } return receiveData; } void w25q_init(void) { myspi_init(); } void w25q_readId(u8* MID,u16* DID) { myspi_start(); myspi_swapByte(GET_W25Q_ID); //发送读取flash的制造商ID和设备ID的指令号9f *MID = myspi_swapByte(SPI_DUMMY); //接收从机返回来的数据，为了交换数据，我们任意给一个数据ff，ff的目的就是将对面有意义的数据置换过来 *DID = myspi_swapByte(SPI_DUMMY); //读取高八位 *DID \u0026lt;\u0026lt;= 8; *DID |= myspi_swapByte(SPI_DUMMY); //读取低八位，注意需要使用| myspi_stop(); } void w25q_writeEnable(void) { myspi_start(); myspi_swapByte(W25Q_WRITEENABLE); myspi_stop(); } void w25q_waitBusy() { u32 timeOut = 100000; myspi_start(); myspi_swapByte(W25Q_READ_REGISTER_1); while((myspi_swapByte(SPI_DUMMY) \u0026amp; 0x01) == 0x01){ //判断芯片是否空闲，使用掩码取出最低位，最低位为busy位，1为繁忙，0为空闲 timeOut--; if(timeOut == 0){ break; } } myspi_stop(); } void w25q_pageProgram(u32 address,u8* dataArray,u16 count)//页只能写0-256，如果超过256，则后续的页将会覆盖之前的页 { w25q_writeEnable(); myspi_start(); myspi_swapByte(W25Q_PAGEPROGRAM); //发送指令 myspi_swapByte(address \u0026gt;\u0026gt; 16); //发送地址，先发送高字节 myspi_swapByte(address \u0026gt;\u0026gt; 8); myspi_swapByte(address); for(u16 i = 0; i \u0026lt; count; i++){ myspi_swapByte(dataArray[i]); } myspi_stop(); w25q_waitBusy(); } //擦除扇区 void w25q_sectorErase(u32 address) { w25q_writeEnable(); myspi_start(); myspi_swapByte(W25Q_SECTOR_EARSE_4KB); //发送指令 myspi_swapByte(address \u0026gt;\u0026gt; 16); //发送地址，先发送高字节 myspi_swapByte(address \u0026gt;\u0026gt; 8); myspi_swapByte(address); myspi_stop(); w25q_waitBusy(); } void w25q_readData(u32 address,u8* dataArray,u16 count) { myspi_start(); myspi_swapByte(W25Q_READ_DATA); //发送指令 myspi_swapByte(address \u0026gt;\u0026gt; 16); //发送地址，先发送高字节 myspi_swapByte(address \u0026gt;\u0026gt; 8); myspi_swapByte(address); for(u32 i = 0; i \u0026lt; count; i++){ dataArray[i] = myspi_swapByte(SPI_DUMMY); } myspi_stop(); } int main(void){ char str[50]; char str_tmp[50]; u8 arrayWrite[] = {0x01,0x02,0x03,0x04}; u8 arrayRead[4]; w25q_init(); serial_init(); w25q_sectorErase(0x000000); w25q_pageProgram(0x000000,arrayWrite,4); w25q_readData(0x000000,arrayRead,4); sprintf(str,\u0026#34;write: %u %u %u %u\\n \u0026#34;,arrayWrite[0],arrayWrite[1],arrayWrite[2],arrayWrite[3]); send_string(str); sprintf(str_tmp,\u0026#34;read: %u %u %u %u\\n \u0026#34;,arrayRead[0],arrayRead[1],arrayRead[2],arrayRead[3]); send_string(str_tmp); while(1){ } } 硬件部分 主模式全双工连续传输\n使用模式3：\n非连续传输：\n代码\nvoid hardware_myspi_init() { GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(SPI_CLK,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE); GPIO_InitStruct.GPIO_Pin = SPI_SS; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = SPI_SCK | SPI_SI; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Pin = SPI_SO; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_Init(SPI_PORT,\u0026amp;GPIO_InitStruct); SPI_InitTypeDef SPI_InitStruct; SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128; SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge; SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low; SPI_InitStruct.SPI_CRCPolynomial = 7; SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b; //8bit SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex; SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB; //高位先行 SPI_InitStruct.SPI_Mode = SPI_Mode_Master; SPI_InitStruct.SPI_NSS = SPI_NSS_Soft; SPI_Init(SPI2,\u0026amp;SPI_InitStruct); SPI_Cmd(SPI2,ENABLE); myspi_ss_set(1); } u8 hardware_myspi_swapData(u8 data) { while(SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_TXE) != SET); //等待TEX变为1，发送寄存器为空，如果发送寄存器不为空，则需要等待 SPI_I2S_SendData(SPI2,data); //传入data之后，将会写入到TDR中，之后TDR将会自动转入移位寄存器。由于使用非连续传输，所以在传入数据的这一时间段，下一个数据不会转移到TDR中 while(SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_RXNE) != SET);//在发送的同时，MISO还会接收，发送和接收是同步的，也就是说接收移位完成也代表发送移位完成，接收数据完成后，会置RXNE标志位，所以只需要等待RXNE出现即可 return SPI_I2S_ReceiveData(SPI2); } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/stateflow/",
    "title": "Stateflow",
    
    "content": " 参考链接 Stateflow 快速入门 - MathWorks 中国\nStateflow简介 Stateflow是MATLAB和Simulink中的一个工具，用于设计和实现状态机和流程图。它非常适合用于建模逻辑系统，如控制逻辑、任务调度和事件驱动系统。Stateflow通过图形化的方式使复杂的逻辑系统更容易理解和实现。以下是一些关于Stateflow的基本概念和操作指南：\nStateflow基本概念 状态（State）： 表示系统在某一特定时间的情况或条件。每个状态可以包含子状态、图表和动作（如进入和退出动作）。 转换（Transition）：\n用箭头表示，描述从一个状态到另一个状态的条件。转换可以包含条件、动作和事件。 事件（Event）：\n触发状态转换的信号。事件可以是外部事件（来自Simulink模型）或内部事件（在Stateflow图表中定义）。 条件（Condition）：\n在方括号内定义的逻辑表达式，用于决定状态转换是否发生。 动作（Action）：\n在状态或转换中定义的操作，可以在进入、退出状态时或在转换时执行。 基本命令 Stateflow是MATLAB和Simulink中的一个工具，用于设计和模拟状态机和逻辑系统。以下是一些基本的Stateflow命令和操作：\n创建和编辑图表 创建Stateflow图表:\nsfnew 打开现有图表:\nsfopen 保存图表:\nsfsave 添加状态和转换 添加状态:\n在图表中右键点击并选择“Add State”，或者使用工具栏中的“Add State”按钮。 添加转换:\n在两个状态之间绘制一条线，或者右键点击一个状态并选择“Add Transition”。 设置状态属性 设置状态名称:\n双击状态，并在对话框中输入名称。 设置进入动作（Entry）:\n双击状态，选择“Actions”选项卡，并在“Entry”框中输入代码。 设置退出动作（Exit）:\n双击状态，选择“Actions”选项卡，并在“Exit”框中输入代码。 设置转换条件 添加条件:\n双击转换线，并在对话框中输入条件，如 [condition]. 添加动作:\n在条件后面添加动作，如 [condition]{action}. 仿真和调试 运行仿真:\n点击Simulink工具栏中的“Run”按钮。 设置断点:\n在图表中右键点击状态或转换，并选择“Set …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/tessy/",
    "title": "Tessy",
    
    "content": " 如何评判 代码覆盖率：\n语句覆盖率（Statement Coverage）：检查是否每个代码语句都被执行过。 分支覆盖率（Branch Coverage）：测试代码中每个条件的所有分支是否都被执行。 路径覆盖率（Path Coverage）：所有可能的执行路径是否都被测试。 边界值分析：\n测试输入参数和输出值的边界，确保程序在极端条件下（如最大值、最小值、空值）能够正常运行。 缺陷率（Defect Rate）：\n代码中的缺陷数量与代码总行数或模块的比例。通过动态测试发现的缺陷越少，代码质量通常越高。 执行时间与性能（Execution Time and Performance）：\n测试代码在不同输入情况下的运行时间，确保其满足性能要求，特别是在嵌入式系统中。 内存使用率（Memory Usage）：\n测试代码的内存使用情况，确保在不同输入条件下不会发生内存溢出或过度使用内存。 代码复杂度（Cyclomatic Complexity）：\n动态测试可以帮助你识别高复杂度的代码部分，复杂度越高的代码更容易出错，因此测试应重点关注这些区域。 错误检测与修复率（Defect Detection and Fix Rate）：\n通过动态测试发现并修复的错误数量与整体代码中发现错误的比率，修复率越高，代码质量越好。 功能正确性（Functional Correctness）：\n确保代码的功能行为与预期一致，动态测试会运行各种输入并验证输出结果是否正确。 术语表 缩写 全称 具体含义 TO Test Object 被测试的代码单元，通常是函数或模块，TESSY 对其进行测试。 TC Test Case 测试用例，指在特定条件下对某个测试对象执行的具体测试，包含输入、预期输出和结果判定。 TF Test Frame 测试执行环境，包含测试所需的输入数据、预期结果及其他资源和配置。 TS Test Step 测试过程中执行的小步骤或操作，用于分步完成复杂的测试任务。 TR Test Report 测试结果报告，包含执行情况、测试结果和代码覆盖率等详细信息。 TD Test Data 输入到测试对象中的数据集，用于验证功能是否符合预期。 TSP Test Specification 测试说明文件，描述测试对象、测试条件、输入输出数据和预期结果等。 Stub Stub 用于替代未实现或不适合在测试中执行的功能，模拟系统中某部分的行为。 Driver Driver 测试驱动程序，调用测试对象并提供必要的输入，常用于嵌入式系统测试。 Cov Test Coverage 测试覆盖率，指测试执行过程中涉及的代码行数或分支数。常见指标有语句覆盖率和分支覆盖率。 TH Test Harness 测试框架或工具，用于自动化测试，包括驱动、桩和测试数据。 RT Regression Test 回归测试，针对修改后的代码进行，确保改动未引入新错误。 CA Code Access 代码通过 CR Coverage Review 覆盖评审 CV Coverage Viewer 覆盖视图 CC Code Complexity 代码复杂度 单元测试 单元测试（Unit Testing）是软件测试中的一种方法，用来验证代码中的最小可测试单元（通常是一个函数、方法或类）的功能正确性。每个单元测试通常只测试代码中的一个小部分，确保其在特定的输入下产生预期的输出。\n单元测试的特点：\n独立性：单元测试应当独立进行，测试代码的每个部分不应该依赖于其他部分，以便能够单独运行和验证。 小范围测试：单元测试的目标是代码的最小单元，如函数或方法，而不是整个系统或大型模块。 自动化：单元测试通常是自动化的，使用测试框架（如JUnit、xUnit、pytest等）可以轻松重复执行测试。 早期检测错误：单元测试有助于在开发的早期阶段发现问题，节省后续集成或系统级别调试的时间。 单元测试的好处：\n提高代码质量：通过测试代码的每个部分，可以在开发过程中及早发现并修复错误。 便于维护：随着软件的发展，单元测试能够帮助验证新代码的正确性，确保修改或新增的代码不会破坏原有功能。 简化调试：当一个测试失败时，开发人员可以快速定位到具体的单元，减少调试范围。 测试步骤 创建项目 导入代码 选择测试对象 生成测试框架 创建测试用例 设置测试环境 执行测试 分析结果 记录和保存测试结果 重复测试 新建工程 新建及导入 新建：点击*==file-\u0026gt;New Project==*:\nName:给项目命名 Project Root：项目路径地址 选择刚刚建立的工程，打开 选择\u0026amp;导入：点击*==file\u0026gt;Select Project==*打开相应的工程\n导入源码 将待测的工程复制到TESSY创建工程的目录下，使得待测工程文件与TESSY工程处于同一目录\nRoot/ ├── tessy工程 └── 待测项目 └── test.c 当移动待测文件之后，刷新一下\n打开创建的 TESSY 工程，在 *Test Cockpit *视图下选中需要的测试工程右键并点击 New Modules 在 General 界面选择编译器 Environment 选择 GNU GCC Eclipse CDT (Default)， Test Type 选择 *Unit Test*后点击 OK\n在 Test Project 视图下会自动创建测试集合和自动导入代码并进行代码分析\n在 Test Cockpit 视图下会自动分析 CA覆盖情况，将鼠标悬停在需要测试的*modules*上\n在 CV 页面下的 CR (依次点击*==CV\u0026gt;CR==*)支持处理无法访问的源代码行， 在 CV 页面选中待测的代码，不可达的代码会标记为黄色\n在 CR（Coverage, Review）视图下选中代码不可达的原因进行提交后，不可达代码标记为蓝色且 CA 覆盖率变为 100%，最终提交的原因会在 Summary Report 中显示\n这里相当于是忽略没有覆盖到的代码,然后解释一下为什么没有覆盖\n创建依次点击*==CR\u0026gt;印章形状(新建CR)\u0026gt;添加代码不可达的原因==*\n需要手动输入不可达的代码行号，并且提交时comment部分必须要写\n导入宏和头文件 如果待测工程涉及到头文件，需要在 TESSY 中加入头文件的路径信息， TESSY 提供了两种方式进行头文件路径添加\n自动创建测试集合==前==\n导入头文件：在 Test Cockpit 视图下选中待测工程右键点击 New Modules 在 Create Modules 窗口下选中 Includes 后，将头文件路径信息进行添加，点击图标 ，可以指定头文件路径\n定义宏：在create new modulues窗口下选择*Defines*，点击加号即可定义宏\n自动创建测试集合==后==\n在 Test Project 视图下选中待测的模块，在 Sources 页面点击 Include ，导入头文件或者手动定义宏 修改相关参数 当一切准备就绪之后，可以点击Tessy解析出来的函数，点击函数就可以看见该函数的相关配置，步骤为：\n选中被测函数 点击 TIE 界面，可以看到 TESSY 自动识别出来的输入和输出接口， 如果需要进行改动，可在想要修改的位置修改测试对象接口 设计测试用例 新建测试用例 测试步骤如下：\n点击TDE页面 选择需要测试的单元项目 选择测试test item页面 新建一个测试用例 填入测试用例的相关参数 保存 点击运行，查看用例的通过情况\n设置覆盖度 点击测试执行绿色按钮右边的下拉小三角 ，选择 Edit Test Execution Settings . . . ，可以对覆盖度进行设置，保存后执行\n首先需要选择是否需要覆盖：\nNone：表示不计算任何覆盖度\nTest object only ：表示只计算当前被测函数的覆盖度\nTest object and called functions： 表示计算被测函数和调用函数的覆盖度\n单元测试时，选Test object only，覆盖度选C0， C1， MC/DC（注意，自定义选择时需要将Use preselected coverage选项关掉） 集成测试时，选Test object and called functions，覆盖度选CPC和FC 当配置好单元测试之后，就可以在Test project选项卡中看到代码的通过情况了\n[!IMPORTANT]\n测试的覆盖度（Coverage）是指在测试过程中，代码被执行和验证的程度。覆盖度衡量了测试用例对代码的覆盖范围，反映了代码被测试的全面性。以下是一些常见的覆盖度类型：\n语句覆盖（Statement Coverage）\n也叫行覆盖。衡量测试用例是否执行了程序中的每一条语句，确保每个代码行至少被执行一次。 示例：在 if 语句中，即使条件不成立导致某些分支未执行，语句覆盖也可能被视为已满足。 分支覆盖（Branch Coverage）\n衡量测试用例是否执行了程序中的每一个分支路径。每个条件判断的真和假路径都必须被执行。 示例：对于 if (x \u0026gt; 0)，必须测试 x \u0026gt; 0 为真和 x \u0026gt; 0 为假的两种情况。 条件覆盖（Condition Coverage）\n每个布尔条件都必须在测试中至少有一次为真和一次为假。它比分支覆盖更详细。 示例：if (A \u0026amp;\u0026amp; B)，需要测试 A 和 B 各自为真和假的情况。 路径覆盖（Path Coverage）\n测试用例应执行代码中所有可能的独立路径。路径覆盖比分支覆盖更复杂，尤其是当代码中存在多重嵌套和循环时，路径数量会快速增加。 函数覆盖（Function Coverage）\n确保程序中每个函数都被至少调用一次。 MC/DC（Modified Condition/Decision Coverage，修正条件/判定覆盖）\n一种严格的覆盖度标准，确保每个条件可以独立影响判定结果。它需要测试每个条件在不影响其他条件的情况下独立为真或假。 这是航空、汽车等高安全性领域常用的覆盖度标准。 点击 CV 界面可查看覆盖度情况， 在 Statement(C0) Coverage 视图下能看到测试的 C0 覆盖情况\n可以通过切换不同的视图，查看不同测试图形化\n[!TIP]\n在切换视图的时候可以看到测试用例分支的覆盖情况\n双击图中的分支在下方的源代码视图中会显示相关分支所对应的代码\n插入需求 打开 Requirement Management 界面，右键选择Import\n[!NOTE]\n导入的文件可以为csv、tsv、txt、vxv、xml、reqif格式\n使用txt格式时，Tessy会认为一行文字为一条需求\n提交：提交时可以选中一个提交，也可以提交全部\n将需求和测试用例链接：依次点击*==TDE\u0026gt;Requirements coverage==*\n[!NOTE]\n这里使用可视化页面链接测试用例和需求，通过在需求项下勾选测试用例，从而达到链接测试用例的功能\n测试用例与需求链接完成后，在 TDE 界面的TEST item页面中选中对应的测试用例，在 Test Definition 标签下可以查看链接到该测试用例的需求\n导出测试报告 点击 下拉小三角可选择导出测试报告， 点击 Edit Test Details Report Settings…可设置报告选项和报告存放路径， 击 Generate Test Detail Report 可按默认设置生成详细测试报告\n可以生成以下几种报告：\nTest Detail Report，详细测试报告 Test Overview Report，概要测试报告 Planning Coverage Report ：计划需求覆盖报告（需要需求文件） Execution Coverage Report：需求执行覆盖率报告（需要需求文件） 组件测试 创建工程 新建工程和单元测试相同，导入源码与单元测试部分基本相同，不同之处在于新建测试集合的时候 Test Type 选择 Component Test\n配置好编译器、头文件、宏定义等其他选项后， 点击 OK，此时 Test Project视图会自动创建测试集合并分析代码。 与单元测试不同的是，组件测试分析完成后不会列出所有源码文件中的函数列表，而是只显示 Scenarios 一个测试对象\n可根据被测对象功能以及对外接口，在 TIE 界面中进行接口设置\n对于一些依赖或者外部函数，可以使用*桩函数进行模拟（这里的桩函数是LightOff和LightOn），选择需要打桩的函数，右键，点击create stub*\n[!IMPORTANT]\n在 TESSY 中，桩函数（Stub Function）是一种用于替代实际函数的测试工具，通常在被测代码（单元）依赖于其他模块或函数，但这些模块或函数尚未实现、不可用或不便在测试中使用时，使用桩函数来模拟其行为。桩函数可以控制依赖的输入和输出，以便对单元进行隔离测试，确保测试环境的独立性和稳定性。\n桩函数的作用：\n隔离测试单元：\n在单元测试中，测试的目的是针对某个具体的函数或模块进行验证。如果该函数依赖于其他未实现的模块或外部库，使用桩函数可以避免实际依赖的复杂性，确保测试的集中性和独立性。 模拟外部依赖：\n桩函数可以模拟外部依赖（如硬件接口、数据库访问、网络调用等），并且可以根据测试用例设置返回值，确保不同场景下被测单元的行为能够被充分验证。 控制测试环境：\n桩函数提供了对外部依赖行为的完全控制，这样可以模拟异常情况、边界条件或极端场景（例如硬件故障、超时等），而不必实际依赖外部系统。 提高测试效率：\n使用桩函数可以加速测试执行，因为它避免了对外部资源（如硬件设备或网络）的依赖，从而使测试更加快速和稳定。 TESSY 中的桩函数实现步骤：\n识别依赖函数：\n首先确定在被测试的模块中哪些函数是依赖外部模块的，这些函数是需要替换为桩函数的目标。 自动生成桩函数：\nTESSY 支持自动生成桩函数的基本框架。被测单元中的依赖函数可以由 TESSY 自动创建对应的桩函数。 配置桩函数行为：\n在 TESSY 中，可以手动配置桩函数的行为。例如，你可以为桩函数设定不同的返回值，或模拟异常返回，以便测试被测单元在各种情况下的响应。 执行测试：\n使用配置好的桩函数执行测试，确保被测单元在隔离的环境中正常运行。 分析测试结果：\n测试完成后，TESSY 会提供详细的报告，包括桩函数调用的次数、输入参数、返回值等信息，帮助开发人员分析测试结果。 使用桩函数的典型场景：\n硬件接口的模拟：当软件依赖硬件设备时，无法直接在测试中访问这些设备，可以使用桩函数模拟硬件行为。 尚未实现的功能：如果依赖的某些模块尚未开发完成，桩函数可以临时替代这些模块，确保其他部分的代码可以正常测试。 外部库或服务调用：对于依赖于外部服务或库的代码，桩函数可以模拟服务的行为，避免实际调用外部系统。 导入源码 typedef enum { closed, open } co_states; typedef enum { off, on } oo_states; co_states sensor_door, state_door; oo_states sensor_ignition, state_light; extern void LightOn(void); extern void LightOff(void); void init(void) { sensor_door = open; sensor_ignition = off; state_door = open; state_light = off; } void set_sensor_ignition(oo_states i) { sensor_ignition = i; } void set_sensor_door(co_states d) { sensor_door = d; } static void iLightOn(void) { if (on == state_light) return; else { state_light = on; LightOn(); } } static void iLightOff(void) { if (off == state_light) return; else { state_light = off; LightOff(); } } void tick() { static int Timer = 0; if ((state_door == open) \u0026amp;\u0026amp; (sensor_door == closed)) { //Door was closed ---\u0026gt; start timer! Timer = 500; // 5 seconds = 500 cycles of 10 ms iLightOn(); } else if (on == sensor_ignition) { iLightOff(); } if (Timer \u0026gt; 0) Timer--; if (0 == Timer) iLightOff(); // Store current value for next tick state_door = sensor_door; } 设计测试用例 针对本示例工程设计如下测试用例：当关闭车门时(set_sensor_door = closed)，内部照明灯点亮； 当有打火动作时(set_sensor_ignition = on)，照明灯立即熄灭。\n设计步骤如下：\n设置入口函数。 进入 SCE 界面，选中组件函数 tick()，点击 ，设置为 work task（入口函数选取条件：==void 类型且没有形参==）\n同时需要设置该函数的开始时间及循环周期\n在 SCE 界面下的选中 Test Data 后鼠标放在在 Test Items 空白处点击创建测试用例\n首先选择刚刚新建的测试用例，点击 Insert Time Step 添加时间节点\n按照需要将组件函数拖到指定时间节点（鼠标左键按住函数可拖动到时间节点相应位置），搭建场景。 具体场景为： 在 30ms 时关闭车门，则 40ms 时车灯会亮； 在 70ms 时将发动机点火，则 80ms 时车灯会灭\n选中 set_sensor_door()函数，在 Properties 界面设置其参数值 d=closed。set_sensor_ignition()函数同理，设置 i=on\n将function call页面中的 LightOn()、 LightOff()和静态函数 iLgihtOn()、 iLightOff()拖到指定时间节点，用于监控车灯变化情况。 设置外部函数和静态函数预估调用时间（在 10ms内预计调用一次）。选中 LightOn()函数， 在 Properties 界面设置 Time Frame 为 10。iLightOn()、 LightOff()、 iLightOff()同理\n[!NOTE]\n注意：这里的两个静态函数iLightOn()和iLightOff()函数分别调用了两个外部函数（桩函数）\n从function call中拖拽函数是用来监控该函数是否被调用及调用次数和从component function中拖拽是不一样的\n编写测试用例\n设置测试需要的参数\n点击运行按钮，查看测试运行的结果\n点击 CV 界面的 Called Functions 视图和 Call Pair Coverage 视图下可查看函数覆盖和调用覆盖的情况\n桩函数 普通桩 以下四种情况通常可以打普通桩：\n函数没有返回值、 没有形参 函数不影响后续实现以及变量 函数本身有返回值但无需使用 函数有形参， 栗子：\nSTUB_1()在当前.c 文件中没有定义， 如果直接执行测试用例会报未定义错误 。\ntypedef unsigned char hirain_u8; extern void STUB 1(); extern hirain u8 STUB 2(); void test_fun_stub_1(void){ STUB_1(); } 只需要在 TIE 界面将其打普通桩， 并点击保存， 解决报错\n高级桩 以下两种情况建议打高级桩：\n使用到桩函数的返回值\n如果函数有形参，并且需要接口传参检测\n栗子1：\n被测函数中用到了 STUB_2()函数的返回值，如果对 STUB_2()函数打普通桩会报无返回值的错误\ntypedef unsigned char hirain_u8; extern void STUB_1(); extern hirain u8 STUB_2(); hirain_u8 test_fun_stub_2(void){ hirain_u8 temp=STUB_2(); return temp; } 在 TIE 界面将其打高级桩并保存，并在 TDE 界面设置其预期返回值\n[!NOTE]\n注意：这里设置的IN是相较于被测函数来说是IN，如果传参数的话，那么passing应该设置为out，因为对于被测函数来说，形参是输出\n栗子2：\n对 STUB_3()函数进行传参检测，需要给该函数打高级桩，第一个接口为返回值，其余为形参接口\ntypedef unsigned char hirain_u8; extern void STUB_1(); extern hirain_u8 STUB_2(); static hirain_u8 STUB_3(hirain_u8 temp) { return temp*temp; } hirain_u8 test_fun_stub_4(hirain_u8 temp) { hirain_u8 tem STUB_3(temp); return tem; } 手写桩 如果需要让桩函数有额外的功能，如： 传参检测、局部数据处理、多传参检测、函数实现变更等，可以进行手写桩。\n栗子：\ntypedef unsigned char hirain_u8; extern hirain_u8 STUB_3(hirain_u8 temp); hirain_u8 loop_test3(hirain_u8 temp){ for(hirain_u8 i=0;i\u0026lt;temp;i++) { STUB_3(i); } return 1; } 想要监控对 STUB_3()函数每一次参数传递是否正确，可以对其打普通桩，通过手写桩函数实现传参检测。步骤如下：\n在test cockpit页面选中待测函数，然后在 TIE 界面点击新建变量，输入 name 选择类别为普通变量， 新建一个数组并在Type 设置为对应的变量类型，示例为 unsigned char 类型\n对 STUB_3()打普通桩并保存\n设置创建的全局变量数组为 OUT\n[!NOTE]\n注意：当修改被测函数之后，工程的接口就需要变更，在TDE页面就会显示接口变更\n然后切换到IDA页面，双击变更的函数，将会展示新旧之间的对比（Tessy只列出相关属性，需要测试工程师自己匹配是否正确）\n​\t然后在TDE 的 Stub Functions 界面手写桩函数的代码\n[!NOTE]\n注意：这里的桩函数填写时，需要先在右边的usercode Outline页面，选中该桩函数的作用域，可以不同的用例使用不同的桩函数，写在顶层会导致所有的测试用例都使用该桩函数\nTDE 界面选中新建的全局变量数组右键选择 Show All Array Elements 显示所有数组元素，然后对 new_array 数组输入预期值，检查测试结果\n点击运行即可查看相关测试结论\n指针相关测试 [!IMPORTANT]\n带有指针的测试不可以直接给指针赋值，而需要使指针指向数组或变量，给数组和变量赋值才可以使用\n指针 与指针有关的测试要点在于构建合适的对象，将地址传入指针接口。\ntypedef unsigned char hirain_u8; typedef int hirain_32; typedef struct{ hirain_32 str1; hirain_32 str2; }STR; hirain_u8 a; void TS_FUN_PON_2(hirain_u8 *p,STR *p1) { //p++s a=*p; p1-\u0026gt;str2 = p1-\u0026gt;str1; } 在 TIE 界面设置输入输出接口，根据不同的测试需求进行设置，示例的输入输出接口如下：\n在 TDE 界面创建测试用例后， 设置指针的具体指向，赋值后执行测试\n[!NOTE]\n注意：这里需要选中测试用例之后，才能右键创建指针指向的目标值\n当在测试过程中，使用了字符串的指针，需要先设置一个目标数组，然后将需要测试的指针指向这个数组\n[!NOTE]\n需要注意的是，在字符指针所要指向的数组中不可以直接填写字符，需要填写字符所要对应的ASSIC码，并且字符串的结尾需要以\\0结尾\n函数指针 与函数指针有关的测试要点在于构建与函数指针类型相同的函数对象，并将地址传入指针接口\ntypedef int hirain_32; typedef unsigned int hirain_u32; hirain_u32 (*T_pon)(hirain_u32 i); hirain_u32 hirain_stuv_4(hirain_u32 temp2){ int temp=T_pon(temp2); return temp; } 在 TIE 界面设置函数指针的输入输出接口\n在 TDE 的 Declarations/Definition 界面实现函数的声明和定义（注意要与函数指针类型一致），并让函数指针指向这个函数，赋值后执行测试\nvoid型指针 typedef unsigned char hirain_u8; hirain_u8 a; hirain_u8 TS_FUN_PON_1(int *p,void *p1){ hirain_u8 temp =0; int *temp1 = p1; a=*p; return *temp1; } 需要在 TIE 界面新建一个有类型的全局变量并根据不同的测试需求设置输入或输出，然后保存，在TDE页面 右键void类型指针，选择 set pointer target，当鼠标变成带有瞄准框的样式，选中你想要指向的变量\n然后在 TDE 界面将指针指向该变量，将变量地址传入指针接口，设置测试数据并运行\n故障注入 在单元测试过程中可能会遇到死循环、 先写后读等特殊情况下的代码， 无法正常实施测试或无法达到相应的触发条件，满足不了覆盖要求。 对于这种类型函数的测试，可以利用故障注入的方式进行测试（这里以死循环为例）\ntypedef unsigned char hirain_u8; hirain_u8 loop_test2(){ while(1) { } } 对于上述示例待测函数，若直接在 TDE 界面运行测试用例， TESSY 会一直处于执行测试过程\n此时需要建立故障注入的测试用例来进行测试，首先在 TDE 界面的 Test Items 视图下鼠标右键选中 New Fault Injection Test Case 建立故障注入的测试用例\n然后跳转至 CV 界面，在测试函数的框图处选择死循环的部分，然后鼠标双击会弹出故障注入的窗口，输入对应的故障注入代码并保存\n最后跳转至 TDE 界面根据不同的测试需求设计测试用例，执行测试用例\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/timer/",
    "title": "Timer",
    
    "content": " 定时器概述 定时器分类 定时器类型 主要功能 基本定时器 没有输入输出通道，常用作时基，即定时功能 通用定时器 具有多路独立通道，可用于输入捕获/输出比较，也可用作时基 高级定时器 除具备通用定时器所有功能外，还具备带死区控制的互补信号输出、刹车输入等功能（可用于电机控制、数字电源设计等） 特性表 滴答定时器 SystemCoreClock / 1000 表示配置 SysTick 定时器以 1ms 的间隔触发中断。具体来说，SysTick 定时器是一个递减计数器，当计数器递减到零时会触发中断，然后自动重新加载初始值继续计数。通过设置初始值为 SystemCoreClock / 1000，我们可以使 SysTick 定时器每经过 1ms 触发一次中断。\n解释 SystemCoreClock 是系统核心时钟频率，单位是 Hz。它表示每秒钟内系统时钟的震荡次数。例如，如果 SystemCoreClock 是 84MHz（84,000,000 Hz），则表示每秒钟系统时钟震荡 84,000,000 次。\nSysTick_Config(SystemCoreClock / 1000) 将 SysTick 定时器的重装载值（reload value）设置为 SystemCoreClock / 1000。重装载值是 SysTick 计数器从这个值开始递减的初始值。\n为什么是 1ms：\n假设 SystemCoreClock 是 84MHz。 SystemCoreClock / 1000 等于 84,000,000 / 1000 = 84,000。 这意味着 SysTick 计数器从 84,000 开始递减，每个时钟周期递减一次。 因为系统时钟频率是 84MHz，即每秒钟有 84,000,000 个时钟周期，所以每 1,000 个时钟周期表示 1ms（1,000,000 / 1,000 = 1ms）。 当 SysTick 计数器从 84,000 递减到 0 时，刚好经过了 1ms，然后触发中断，并重新加载为 84,000 继续递减。 SysTick_Config 函数 SysTick_Config 是一个方便的函数，用于配置 SysTick 定时器并启用中断。其原型通常如下：\nuint32_t SysTick_Config(uint32_t ticks); 参数 ticks 是重装载 …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/uds/",
    "title": "UDS",
    
    "content": " 参考链接 《UDS协议从入门到精通（UDS速查手册）》（完结撒花版）_obdonuds-CSDN博客\n简介 UDS (Unified Diagnostic Services) 是一种标准化的==车辆诊断协议==，广泛应用于汽车电子控制单元（ECU）的诊断和维修。它是ISO 14229标准的一部分，主要用于车辆诊断、故障排除、软件更新和其他与车辆维护相关的服务。\nUDS协议栈 UDS（Unified Diagnostic Services）协议栈是实现UDS协议功能的分层架构，确保汽车电子控制单元（ECU）与诊断工具之间的通信。UDS协议栈通常包括以下几层：\n应用层（Application Layer）：应用层是UDS协议栈的最高层，负责实现具体的诊断服务。它定义了各种诊断服务，如读取数据、清除故障码、重置ECU等。这一层的功能由==ISO 14229标准==规定。 传输层（Transport Layer）：传输层负责数据的分段、重组和流量控制。UDS协议通常使用ISO 15765-2（CAN TP）作为其传输层协议。传输层处理较大的诊断消息，通过将它们分成较小的帧进行传输，然后在接收端重组这些帧。 网络层（Network Layer）：网络层管理数据包的寻址和路由。在UDS协议中，网络层通常依赖于ISO 15765-3标准，这一标准定义了如何在CAN网络上传输诊断信息。网络层确保诊断消息能够正确到达目标ECU。 数据链路层（Data Link Layer）：数据链路层负责物理网络上的数据帧传输和错误检测。在UDS协议中，数据链路层通常基于CAN（Controller Area Network）协议，由ISO 11898标准定义。数据链路层处理数据帧的发送和接收，并提供基本的错误检测和恢复机制。 物理层（Physical Layer）：物理层定义了实际的硬件接口和信号传输特性。在UDS协议中，物理层通常是基于CAN总线的物理层，由ISO 11898标准定义。这一层包括信号的电气特性、连接器和传输介质（如电缆）的规范。 不同层的数据格式 物理层：比特（Bit）：物理层传输的是原始的二进制数据，即 0 和 1 的比特流。\n数据链路层：帧（Frame）：数据链路层的 PDU 是帧，它包括数据包的开始和结束标志、帧同步信息、地址信息、控制信息以及实际的数据负载。\n网络层： …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/usart/",
    "title": "USART",
    
    "content": " 数据通信基础 串行/并行通信 单工/半双工/全双工通信 同步/异步通信 波特率 常见通信接口 名称 引脚 双工 时钟 电平 设备 USART TX、RX 全双工 异步 单端 点对点 I2C SCL、SDA 半双工 同步 单端 多设备 SPI SCLK、MOSI、MISO、CS 全双工 同步 单端 多设备 CAN CAN_H、CAN_L 半双工 异步 差分 多设备 USB DP、DM 半双工 异步 差分 点对点 串口 概念 RS232 VS CMOS/TTL 串口参数及时序 RS232通信 USB通信 电平的区别 USART 简介 主要特征 框图 串口数据低位先行\n框图简化版 数据帧 这里的字长就是数据位长度，空闲帧和断开帧是局域网协议用的，我们的串口用不到\n停止位分别为1、1.5、2、0.5，意思就是0.5个时长\n要保证在采样的时候，数据在时钟边沿的中间，这样可以保证数据的可靠性\n当输入电路侦测到一个数据帧的起始位后，就会以波特率的频率，连续采样一帧数据，同时，从起始位置开始，采样位置就要对齐到位的正中间\n首先数据的部分电路对采样的时钟进行了细分，他会以波特率的16倍进行采样，也就是说，在一位的时间内，可以进行16次采样，采样策略为\n最开始，空闲状态高电平，采样一直为1，在某个位置突然采样采到一个0，就说明出现了下降沿，这个时候在理想情况下应该就要开始采样了，在起始位，会进行16次连续采样，没有噪声的话，那么这16次采样应该都为0，因为串口协议的起始就是检测到下降沿，实际电路还是会出现一点噪声的，所以即使出现下降沿，后续也要再采样几次，以防万一， 设置波特率 波特率的产生实际上就是一个预分频的过程，这里的16就是上面的内部还有一个16倍的采样时钟\n数据模式 实验 简单的发送数据 void serial_init() { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStruct.GPIO_Pin = SERIAL_TX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); USART_InitTypeDef USART_InitStruct; USART_InitStruct.USART_BaudRate = 115200; USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStruct.USART_Mode = USART_Mode_Tx; USART_InitStruct.USART_Parity = USART_Parity_No; USART_InitStruct.USART_StopBits = USART_StopBits_1; USART_InitStruct.USART_WordLength = USART_WordLength_8b; USART_Init(USART2,\u0026amp;USART_InitStruct); USART_Cmd(USART2,ENABLE); } void serial_sendByte(u8 byte) { USART_SendData(USART2,byte); while(USART_GetFlagStatus(USART2,USART_FLAG_TXE) == RESET); } void serial_sendArray(u8 *array,u16 length) { for(u16 i = 0; i \u0026lt; length; i++){ serial_sendByte(array[i]); } } void serial_sendString(char *str) { for(u8 i = 0;str[i] != \u0026#39;\\0\u0026#39;;i++){ serial_sendByte(str[i]); } } u32 serial_pow(u32 x, u32 y) { u32 result = 1; while(y--){ result *= x; } return result; } //将数字以字符的样式发送 void serial_sendNum(u32 number, u8 length) { for(u8 i = 0; i \u0026lt; length; i++){ serial_sendByte(number / serial_pow(10,length - i -1) % 10 + \u0026#39;0\u0026#39;); } } int main(void){ char str[50]; u8 test[] = {0x42,0x43,0x44,0x45}; serial_init(); serial_sendArray(test,4); serial_sendNum(12345,5); while(1){ // sprintf(str,\u0026#34;%x: %hu %hu\\n\u0026#34;,(u32)adValue,adValue[0],adValue[1]); // send_string(str); } } printf重定向 如果想要使用printf函数，需要先使用microlib库\n注意需要引入stdio头文件，还需要重写fputc\n//重写这个函数用于重定向printf函数，这个函数是printf的底层函数，printf在打印的时候就是不断调用这个函数来一个一个打印的 int fputc(int ch, FILE *file) { serial_sendByte(ch); return ch; } 重写完这个函数就可以正常使用printf函数了\n如果想要让printf使用多个串口，那么就需要sprintf函数\nsprintf(str,\u0026#34;%x: %hu %hu\\n\u0026#34;,(u32)adValue,adValue[0],adValue[1]); serial_sendString(str); 为了方便，我们也可以封装sprintf函数，在封装sprintf的时候需要引入头文件stdarg.h头文件。\nvoid serial_printf(char *format, ...) { char string[100]; va_list arg; va_start(arg,format); vsprintf(string,format,arg); va_end(arg); serial_sendString(string); } 解决汉字乱码的情况，如果使用的编码格式为utf-8，则需要先设置编译参数\u0026ndash;no-multibyte-chars\n接收数据 需要修改初始化函数，分为查询式和中断式\n//查询式 void serial_init() { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStruct.GPIO_Pin = SERIAL_TX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStruct.GPIO_Pin = SERIAL_RX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); USART_InitTypeDef USART_InitStruct; USART_InitStruct.USART_BaudRate = 115200; USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; USART_InitStruct.USART_Parity = USART_Parity_No; USART_InitStruct.USART_StopBits = USART_StopBits_1; USART_InitStruct.USART_WordLength = USART_WordLength_8b; USART_Init(USART2,\u0026amp;USART_InitStruct); USART_Cmd(USART2,ENABLE); } int main(void){ u8 rxData; serial_init(); while(1){ if(USART_GetFlagStatus(USART2,USART_FLAG_RXNE) == SET){ rxData = USART_ReceiveData(USART2); serial_printf(\u0026#34;receive: %x\\n\u0026#34;,rxData); } } } //中断式 void serial_init() { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE); GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStruct.GPIO_Pin = SERIAL_TX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStruct.GPIO_Pin = SERIAL_RX_PIN; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(SERIAL_PORT,\u0026amp;GPIO_InitStruct); USART_InitTypeDef USART_InitStruct; USART_InitStruct.USART_BaudRate = 115200; USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; USART_InitStruct.USART_Parity = USART_Parity_No; USART_InitStruct.USART_StopBits = USART_StopBits_1; USART_InitStruct.USART_WordLength = USART_WordLength_8b; USART_Init(USART2,\u0026amp;USART_InitStruct); USART_ITConfig(USART2,USART_IT_RXNE,ENABLE); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitTypeDef NVIC_InitStruct; NVIC_InitStruct.NVIC_IRQChannel = USART2_IRQn; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1; NVIC_Init(\u0026amp;NVIC_InitStruct); USART_Cmd(USART2,ENABLE); } u8 serial_rxData,serial_rxFlag; void USART2_IRQHandler(void) { if(USART_GetFlagStatus(USART2,USART_IT_RXNE) == SET){ serial_rxData = USART_ReceiveData(USART2); serial_rxFlag = 1; USART_ClearITPendingBit(USART2,USART_IT_RXNE); } } u8 serial_getRxFlag(void) { if(serial_rxFlag == 1){ serial_rxFlag = 0; return 1; } return 0; } u8 serial_getRxData(void) { return serial_rxData; } int main(void){ u8 rxData; serial_init(); while(1){ if(serial_getRxFlag() == 1){ rxData = serial_getRxData(); serial_printf(\u0026#34;receive %x\\n\u0026#34;,rxData); } } } 数据包的收发 HEX数据包 文本数据包 实验代码 void serial_sendPacket(void) { serial_sendByte(0xFF); serial_sendArray(serial_txPacket,4); serial_sendByte(0xFE); } u8 serial_rxData,serial_rxFlag; u8 serial_txPacket[4],serial_rxPacket[4]; void USART2_IRQHandler(void) { static u8 rxState = 0; static u8 counter = 0; if(USART_GetFlagStatus(USART2,USART_IT_RXNE) == SET){ u8 rxData = USART_ReceiveData(USART2); if(rxState == 0){ if(rxData == 0xff){ rxState = 1; counter = 0; } }else if(rxState == 1){ serial_rxPacket[counter++] = rxData; if(counter \u0026gt;= 4){ rxState = 2; } }else if(rxState == 2){ if(rxData == 0xfe){ rxState = 0; serial_rxFlag = 1; } } } } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/vim/",
    "title": "Vim",
    
    "content": " 启动 Vim 在终端中输入 vim 启动 Vim，或者输入 vim filename 打开特定文件。\nvim vim filename 基本模式 Vim 有三种主要模式：\nNormal 模式：默认模式，用于执行命令。 Insert 模式：用于编辑文本。 Visual 模式：用于选择文本。 切换模式\nNormal 模式：启动 Vim 后默认进入 Normal 模式。按 Esc 可以从其他模式切换到 Normal 模式。 Insert 模式：在 Normal 模式下，按 i 进入 Insert 模式，按 Esc 退出到 Normal 模式。 Visual 模式：在 Normal 模式下，按 v 进入 Visual 模式，按 Esc 退出到 Normal 模式。 常用命令 Normal 模式命令 移动光标：\nh：左移 j：下移 k：上移 l：右移 w：移动到下一个单词的开头 b：移动到前一个单词的开头 0：移动到行首 $：移动到行尾 编辑文本：\ni：在光标前插入 a：在光标后插入 o：在当前行下方插入新行 dd：删除当前行 d$：删除从光标到行尾的内容 x：删除光标下的字符 yy：复制当前行 p：粘贴 u：撤销 Ctrl + r：重做 保存和退出：\n:w：保存文件 :q：退出 Vim :wq 或 ZZ：保存并退出 :q!：不保存退出 Insert 模式命令 在 Insert 模式下，你可以像普通文本编辑器一样输入文本。 使用 Esc 返回到 Normal 模式。 Visual 模式命令 v：进入 Visual 模式并选择字符 V：进入 Visual 模式并选择行 Ctrl + v：进入 Visual 模式并选择块 在 Visual 模式下，你可以使用 y 复制，d 删除，p 粘贴选中的内容。 键位图 搜索和替换 搜索：\n/pattern：向下搜索 pattern ?pattern：向上搜索 pattern n：跳到下一个匹配 N：跳到上一个匹配 替换：\n:%s/old/new/g：全局替换所有 old 为 new :s/old/new/g：替换当前行所有 old 为 new :s/old/new/gc：替换当前行所有 old 为 new，并确认每次替换 配置 Vim 你可以通过编辑 ~/.vimrc 文件来配置 Vim。例如：\nsyntax on \u0026#34; 启用语法高亮 set number \u0026#34; 显示行号 set tabstop=4 \u0026#34; 设置 Tab 长度为 4 set shiftwidth=4 \u0026#34; 设置自动缩进为 4 set expandtab \u0026#34; 将 Tab 转换为空格 插件管理 Vim 有丰富的插件生态，可以使用插件管理器来安装和管理插件。常见的插件管理器有：\nVundle：在 ~/.vimrc 中添加插件配置，然后运行 :PluginInstall。 set nocompatible \u0026#34; 必须 filetype off \u0026#34; 必须 \u0026#34; 设置 runtime path set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin \u0026#39;VundleVim/Vundle.vim\u0026#39; \u0026#34; 在这里添加更多的插件 Plugin \u0026#39;tpope/vim-sensible\u0026#39; call vundle#end() \u0026#34; 必须 filetype plugin indent on \u0026#34; 必须 Pathogen：将插件克隆到 ~/.vim/bundle/ 目录。 mkdir -p ~/.vim/autoload ~/.vim/bundle \u0026amp;\u0026amp; \\ curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 在 ~/.vimrc 中添加：\nexecute pathogen#infect() syntax on filetype plugin indent on 通过这些基本操作，你可以高效地使用 Vim 进行文本编辑和代码开发。随着使用经验的增加，你可以进一步探索 Vim 的高级功能和插件生态，提升工作效率。\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/vscode/",
    "title": "Vscode",
    
    "content": " 快捷键 常用快捷键 打开命令面板：Ctrl+Shift+P 或 F1 快速打开文件：Ctrl+P 打开设置：Ctrl+, 编辑快捷键 剪切行：Ctrl+X 复制行：Ctrl+C 粘贴：Ctrl+V 撤销：Ctrl+Z 重做：Ctrl+Y 或 Ctrl+Shift+Z 查找：Ctrl+F 替换：Ctrl+H 全选：Ctrl+A 导航快捷键 跳转到行：Ctrl+G 跳转到定义：F12 查找所有引用：Shift+F12 打开最近使用的文件：Ctrl+R 下一个光标位置：Ctrl+U 多光标和选择快捷键 插入光标：Alt+Click 添加下一个匹配项到选择：Ctrl+D 跳过下一个匹配项：Ctrl+K Ctrl+D 全部选中匹配项：Ctrl+Shift+L 移除当前光标位置：Ctrl+U 调试快捷键 开始/继续调试：F5 停止调试：Shift+F5 单步跳过：F10 单步跳入：F11 单步跳出：Shift+F11 窗口管理快捷键 新建窗口：Ctrl+Shift+N 关闭窗口：Ctrl+Shift+W 拆分编辑器：Ctrl+\\ 切换编辑器组：Ctrl+1，Ctrl+2，Ctrl+3 终端快捷键 新建终端：`Ctrl+Shift+`` 切换终端面板：Ctrl+Shift+5 关闭终端：Ctrl+Shift+W 插件 插件名称 功能描述 Better Align 用于对齐变量名和参数 Better Comments 实时显示错误 Code Spell Checker 用于检查代码的拼写错误 Code Translate 鼠标悬停可以查看相关翻译 Error Lens 高亮显示错误 Fitten Code 超强AI编程 Git Graph 用于Git的可视化 GitLens Git的拓展 Hex Editor 十六进制文件查看器 LeetCode 力扣的练习 MarkMap 用于将markdown文件转化为思维导图 offic viewer 用于实时渲染markdown文件 Project Manager 用于保存常用项目 Todo Tree 可用于标记代码中的代办项 Vim vscode中的vim插件 VSCode Animations 实现丝滑动画效果 Apc Customize UI++ 配合VSCode Animations使用实现丝滑动画 C/C++ snippets 用于生成代码分割符 IAR linker Configuration File Syntax 用于显示IAR的icf文件 Arm Assembly 汇编代码 iar build iar官方插件 iar ： Platform IO 嵌入式替代开发插件 wakatime 编程时间及行为跟踪统计 codeTour 回放代码演示思路 koroFileHeader 生成文件头注释 [!tip]\n配置 C/C++ snippets { \u0026#34;MainPage Table\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;.table\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;\u0026#34;, \u0026#34;/**@mainpage\u0026#34;, \u0026#34; *\u0026lt;table\u0026gt;\u0026#34;, \u0026#34; *\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;项目名称 \u0026lt;td\u0026gt;\u0026#34;, \u0026#34; *\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;设计负责人 \u0026lt;td\u0026gt;\u0026#34;, \u0026#34; *\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;版权 \u0026lt;td\u0026gt;xxxx科技有限公司\u0026#34;, \u0026#34; \u0026lt;/table\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34; @section \u0026#34;, \u0026#34; * \u0026#34;, \u0026#34;\u0026#34;, \u0026#34; @section \u0026#34;, \u0026#34; * \u0026#34;, \u0026#34;\u0026#34;, \u0026#34; @section \u0026#34;, \u0026#34; * \u0026#34;, \u0026#34; */\u0026#34;, \u0026#34;\u0026#34;, ], \u0026#34;description\u0026#34;: \u0026#34;MainPage Table\u0026#34; }, \u0026#34;resource files\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;.chinit\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;/*******************************************************************************\u0026#34;, \u0026#34;** Revision Control History **\u0026#34;, \u0026#34;********************************************************************************\u0026#34;, \u0026#34;Version Date User Comment\u0026#34;, \u0026#34;********************************************************************************\u0026#34;, \u0026#34; 0.1 2024-10-01 ryf - xxx xxx\u0026#34;, \u0026#34;*******************************************************************************/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= Includes =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= Defines \u0026amp; Macros for General Purpose =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= Constants \u0026amp; Types =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= Global variables =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= Local variables =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= Global Function =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= Local Function =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= Function Implement List =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, ], \u0026#34;description\u0026#34;: \u0026#34;use to c files\u0026#34; }, \u0026#34;header files\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;.hhinit\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;#ifndef ${1:${TM_FILENAME/(.*)\\\\.h$/${1:/upcase}_H/i}}\u0026#34;, \u0026#34;#define $1\u0026#34;, \u0026#34;\\n${2:#ifdef __cplusplus\u0026#34;, \u0026#34;extern \\\u0026#34;C\\\u0026#34;{\u0026#34;, \u0026#34;#endif}\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*******************************************************************************\u0026#34;, \u0026#34;** Revision Control History **\u0026#34;, \u0026#34;********************************************************************************\u0026#34;, \u0026#34;Version Date User Comment\u0026#34;, \u0026#34;********************************************************************************\u0026#34;, \u0026#34; 0.1 2024-10-01 ryf - xxx xxx\u0026#34;, \u0026#34;*******************************************************************************/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= INCLUDES =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= DEFINES \u0026amp; MACROS FOR GENERAL PURPOSE =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= CONSTANTS \u0026amp; TYPES =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= EXPORTS =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;/*==============================================================================\u0026#34;, \u0026#34;======= PROTOTYPES OF PUBLIC FUNCTIONS =======\u0026#34;, \u0026#34;==============================================================================*/\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;#ifdef __cplusplus\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;#endif\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;#endif\\t/* $1 */\\n\u0026#34; ], \u0026#34;description\u0026#34;: \u0026#34;Avoid Repetition\u0026#34; }, \u0026#34;line\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;.line\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;/*************************************** ****************************************/\u0026#34;, ], \u0026#34;description\u0026#34;: \u0026#34;Avoid Repetition\u0026#34; } } iar工程配置 IAR 9.32.1版本 用自安装版本的jlink驱动替代IAR下自带版本下载驱动_iar安装jlink驱动-CSDN博客\nIAR VScode 扩展_插件_官方版 | IAR\nhttps://blog.csdn.net/luobeihai/article/details/127044565\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/wdg/",
    "title": "WDG",
    
    "content": " WDG 简介 IWDG VS WWDG IWDG独立看门狗 WWDG窗口看门狗 复位 计数器减到0后 计数器T[5:0]减到0后、过早重装计数器 中断 无 早期唤醒中断 时钟源 LSI（40KHz） PCLK1（36MHz） 预分频系数 4、8、32、64、128、256 1、2、4、8 计数器 12位 6位（有效计数） 超时时间 0.1ms~26214.4ms 113us~58.25ms 喂狗方式 写入键寄存器，重装固定值RLR 直接写入计数器，写多少重装多少 防误操作 键寄存器和写保护 无 用途 独立工作，对时间精度要求较低 要求看门狗在精确计时窗口起作用 溢出时间计算原理 计算步骤如下\n首先需要知道看门狗的时钟频率，假设是60kHz 设置分频系数，现在设置为8分频，那么分完频之后的时钟就是60_000Hz / 8=75_00Hz,也就是1s跳动7500次 如果想要设置溢出时间为0.5s的话，那么就是用0.5*7500=3750，就是设置为3750 IWDG 概述 作用 工作原理 框图 实际上就是一个递减计数器，在程序运行期间，适当的提高计数值就可以避免出现复位，手动重装重装载寄存器的操作就是喂狗,递减计数器是12位的，所以最大的计数是 $2 ^ {12}-1 = 4095$。\n当递减计数器自减到0时，会产生一个IWDG的复位信号\n当我们在重装载寄存器中写好值之后，在键寄存器里写一个特定的数据，控制电路进行喂狗，这个时候重装值就会将数值赋给当前计数器\n下图分为上下两部分，上面部分工作在1.8v电压下，下面部分工作在VDD电压下\n键寄存器 由于IWDG_SR是写保护的，所以不用担心该寄存器被干扰，为了防止另外两个寄存器受到干扰，使用键寄存器对寄存器进行写保护，一旦两个寄存器写入之后会被再次保护起来\n配置寄存器 计算溢出时间 WWDG 概述 作用 工作原理 中断产生在复位的前一刻，复位产生时间0x3f，中断产生时刻0x40\n框图 这里的WDGTB和上面的PSC都是一个东西，都是预分频器\n从T6-T0一共七个位，但是却是6位递减计数器，实际上只有T5-T0是计数器，T6用作溢出标志位，T6位为1时，表示计数器未溢出，T6位为0时，表示计数器溢出\n假设我们初始时写入111_1111,依次递减111_1110-\u0026gt;111_1101……直到减到100_0000（0x40）时，如果再向下减，T6位将会变为0，T6将会产生一个信号去往或门\nWDGA是激活位，也就是使能位，WDGA写入1，启用窗口看门狗\n计算最早界限计数值\nW6-W0中是最早界限计数值，这些值写入之后是固定不变的，一旦执行写入CR操作时，与门打开，写入CR其实就是写入计数器，也就是喂狗\n喂狗时，比较器开始工作，当前计数器T6-0 \u0026gt; 窗口值W6-0，比较结果为1，通过或门，产生复位信号\n也就是说喂狗的时候，把当前计数值和预设的窗口计数值进行比较，如果发现狗的余粮还比较充足，但是喂的很频繁，那必定是存在问题的，所以会产生一个复位信号\n工作特性 计算溢出时间 乘以4096的原因是在LSI时钟信号后面有一个固定的4096分频\n实验 IWDG int main(void){ serial_init(); key_init(); if(RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET){ serial_printf(\u0026#34;IWDG RST!\\n\u0026#34;); RCC_ClearFlag(); }else{ serial_printf(\u0026#34;RST!\\n\u0026#34;); } IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); //解除写使能，可以往键寄存器中写入数据 IWDG_SetPrescaler(IWDG_Prescaler_16); //设置预分频，现设置超时时间为1s，那就要求喂狗时间不能超过1s，需要查看手册，选择合适的分频系数 IWDG_SetReload(2499); //设置重装值，通过公式计算，重装值计算：rlr = 1 * 40000 / 16 = 2500 IWDG_ReloadCounter(); //先喂一次狗 IWDG_Enable(); //启动看门狗 while(1){ getKey(); IWDG_ReloadCounter(); //喂狗 serial_printf(\u0026#34;FEED!\\n\u0026#34;); Delay_ms(300); serial_printf(\u0026#34;\\n\u0026#34;); Delay_ms(300); } } WWDG int main(void){ serial_init(); key_init(); if(RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET){ serial_printf(\u0026#34;WWDG RST!\\n\u0026#34;); RCC_ClearFlag(); }else{ serial_printf(\u0026#34;RST!\\n\u0026#34;); } RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG,ENABLE); //wwdg和iwdg不同，wwdg的时钟来源是APB1 WWDG_SetPrescaler(WWDG_Prescaler_8); //设置预分频,我们想要设置超时时间为50ms，T = 0.05 * 36000000 /4096/ 2^3 = 54.93164 = 55,所以T[5:0] = 54 WWDG_SetWindowValue(21 | 0x40); //设置窗口值，我们窗口时间设置为30ms，窗口时间W = 54 - 0.03 * 36000000 / 4096/2^3 = 54 - 33 = 21 WWDG_Enable(54 | 0x40); //这里使用|0x40的目的是为了让T[6]=1 while(1){ getKey(); serial_printf(\u0026#34;FEED!\\n\u0026#34;); Delay_ms(10); serial_printf(\u0026#34;\\n\u0026#34;); Delay_ms(20); WWDG_SetCounter(54 | 0x40); //喂狗，这里不能再WWDG_ENABLE后面直接喂狗，因为执行时间太短，在非窗口期喂狗是会复位的 } } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/wireshark/",
    "title": "WireShark",
    
    "content": " 蓝牙抓包 参考链接 实测对比Wireshark利用nRF52832 Sniffer和Packet Sniffer 利用CC2540 Dongle 抓包使用体验_usb nrf sniffer 指定 mac-CSDN博客\n蓝牙\u0026mdash;-wireshark抓包查看蓝牙通信过程_蓝牙抓包-CSDN博客\n低功耗蓝牙协议栈入门（四）空中抓包 （WireShark + nRF Sniffer） | BalanceTWK的博客\nnRF Sniffer for Bluetooth LE User Guide v4.0.0 (nordicsemi.com)\n安装 使用wireShark抓包，需要使用专用硬件nRF来抓，首先先到Wireshark · Go Deep网站下载wireShark，然后再去nRF Sniffer for Bluetooth LE - nordicsemi.com下载nRF sniffer插件。在ble-sniffer command overview (nordicsemi.com)上有软件使用手册。\n[!tip]\nnRF sniffer是wireShark的一个插件，相当于是安装了nRF sniffer插件，就可以使用wireshark抓蓝牙包了\n安装wireshark的时候，一直下一步就行，下面介绍nRF sniffer的安装：\n在安装之前需要确保安装了wireshark v3.41及以上版本和python v3.6及以上版本\n[!note]\n一般来说，商家都会烧录好固件，一些支持二次开发的设备可以自己烧录hex程序以支持nRF connect或Wireshark\n打开下载好sniffer插件文件夹，打开nrf_sniffer_for_bluetooth_le_4.1.1\\extcap文件夹，打开cmd，可以在地址栏中输入cmd用来直接启动\n在cmd中输入以下命令安装依赖包（注意，这必须在安装了python的前提下）：\npip3 install -r requirements.txt 安装完成之后，打开wireshark，在菜单的tab中依次打开*==帮助\u0026gt;关于wireshark\u0026gt;文件夹\u0026gt;personal Extcap==,将 Sniffer_Software/extcap/ 文件夹的内容复制到此文件夹中。之后开始配置wireshark，在菜单的tab中依次打开==帮助\u0026gt;关于wireshark\u0026gt;文件夹\u0026gt;personal configuration==*，将 profile 文件夹 Sniffer_Software/Profile_nRF_Sniffer_Bluetooth_LE 复制到此文件夹的 profiles 子文件夹中。\n最后在 Wireshark 中，选择 Edit \u0026gt; Configuration Profiles，选择 Profile_nRF_Sniffer_Bluetooth_LE 并单击 OK。\n使用 在使用之前，电脑上需要插上硬件设备：\n打开wireshark，在捕获界面会出现nRF sniffer设备：\n可以点击设备左侧的小齿轮按钮，会弹出相关设置：\n上面的选项的含义如下：\n仅广播数据包：仅嗅探给定设备的广播数据包。建立新连接后，RF嗅探器会忽略它。 仅传统广播数据包：仅嗅探给定设备的旧式广告数据包。RF嗅探器不会在辅助广播数据包的扩展广播数据包中查找广告商的设备地址。 查找扫描响应数据：在嗅探所有广播设备时跟踪扫描请求和扫描响应。此选项可用于在扫描响应数据中查找广播商的名称。 查找辅助指针数据：在嗅探所有广播设备时，跟随辅助指针获取其他数据。此选项可用于在辅助广播数据中查找广告主的地址和名称。 扫描和跟踪LE Coded PHY上的设备：在嗅探所有广播设备和特定设备时，嗅探LE编码PHY。nRF Sniffer会跟踪它使用的任何PHY上的连接。要同时对LE1MPHY和LE编码PHY进行嗅探，请使用多个嗅探器。 nRF嗅探器有两种工作模式：\n监听所有广播频道，从尽可能多的设备中获取尽可能多的数据包。这是默认模式。 跟踪一个特定设备，并尝试捕获发送到该特定设备或从该特定设备发送的所有数据包。此模式捕获所有： 从设备发送的通告和扫描响应 扫描请求和连接到设备的请求 连接中的数据包在连接中的两个设备之间发送 软件界面提供控制nRF Sniffer操作的命令和选项。 可以使用sniffer的过滤器进行筛选：\n其中的含义如下：\n硬件接口：此列表显示了可用的硬件接口。如果您有多个连接了nRF Sniffer固件的DK或加密狗，您可以使用工具栏选择要控制的一个。要同时使用多个硬件接口。 设备列表：此列表显示附近正在进行广播的设备。当您开始嗅探时，将选中All advertising devices。从列表中选择一个设备以嗅探该特定设备。当您在连接中选择其他设备时，当前连接将丢失。如果未发现要嗅探的设备，您可以手动将其添动加到列表中。 输入键和值：使用此字段可为嗅探器提供无法单独从空中交通捕获的输入信息。为此，请从下拉菜单中选择输入键，然后在输入字段中输入相应的值。以下输入键可用： 旧版密钥：如果您的设备要求您提供密钥，请在密钥文本字段中键入6位数的密钥，然后按Eter。然后在设备中输入密钥。 旧版OOB数据：如果您的设备使用带有16字节带外（○0B)密钥的传统配对过程，请以十六进制格式提供（以0x开头，大端)。您必须在设备进入加密状态之前执行此操作。如果输入的键短于16字节，则前面用0填充。 旧版LTK：如果您的设备具有使用引旧版长期密钥(LTK)的现有绑定，请以十六进制格式提供（以0x开头，大端)。您必须在设备进入加密状态之前执行此操作。如果输入的键短于16字节，则前面用0填充 SC LTK：如果您的设备具有使用LE Secure Connections LTK的现有绑定，请以十六进制格式提供（以0x开头，大端)。您必须在设备进入加密状态之前执行此操作。如果输入的键短于16字节，则前面用0填充。 SC私钥：如果您的设备使用LE安全连接配对，并且两个设备均未处于调试模式（使用Dbug私钥），请以十六进制格式（以Ox开头，大端）提供设备的32字节Diffie-.Hellman私钥。您必须在设备开始配对过程之前执行此操作。如果输入的键短于32字节，则前面用0填充。 LE地址：如果要嗅探的设备当前未发布，因此未被发现，请使用此字段将其LE地址添加到设备列表中。输入完整的6字节LE地址，用冒号分隔每个字节，并附加地址类型(“public”或“random”)。例如57:25:B0:81:eb:E5随机 广播信道：您可以更改nRF Sniffer在跟踪设备时切换广告频道的顺序。使用逗号分隔的通道号定义顺序，例如37,38,39。完成后按Enter。 使用默认配置，RF嗅探器等待通道37上的数据包。在通道37上收到数据包后，它会转换为在通道38上嗅探。当它在通道38上收到数据包时，它会转换为在通道39上嗅探。当它在通道39上收到数据包时，它开始在通道37上嗅探，并重复该操作。 在捕获完数据之后，会通过不同的区域展示：\n也可以使用wireshark自带的筛选功能，并且nRF sniffer也提供了相关包：\n显示筛选器 描述 btle.length ! = 0 仅显示低功耗蓝牙数据包的length字段不为零的数据包的过滤器，这意味着它会隐藏空数据包。 btle.advertising_address 仅显示具有广播地址的数据包（广播数据包）的筛选器。 btle 显示所有低功耗蓝牙数据包的协议筛选器。 BTATT、BTSMP、BTL2CAP 分别用于 ATT、SMP 和 L2CAP 数据包的协议过滤器。 nordic_ble.channel\u0026lt;37 Fiter仅显示在数据通道上接收的数据包。 [!tip]\n注意：这里可以的逻辑符号可以使用\u0026amp;\u0026amp; || == != !，并且可以使用.来看一个包下面有那些参数，如btle.，键入.之后就会出现它下面的参数\n当然，有时候为了方便对比数据，可以将一个数据放到列上，首先先选中需要查看的列，右键，选择应用为列即可。\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/",
    "title": "编程规范",
    
    "content": " 参考链接 C语言 | 嵌入式C语言编程规范_函数名开头加uc-CSDN博客\n[!tip]\n以下文件排版将会按照自顶向下的方式进行编排，==文件夹 \u0026amp;gt; 文件名 \u0026amp;gt; 排版 \u0026amp;gt; 函数 \u0026amp;gt; 变量==\n文件架构 缩写 该项目文件树参考AUTOSAR结构，为了便于理解，此处展示部分缩写的全称：\n缩写 全称 描述 AUTOSAR AUTomotive Open System ARchitecture 汽车开放系统架构，是汽车软件开发的标准框架。 ASW Application Software 应用软件，主要负责实现特定功能的业务逻辑。 BSW Basic Software 基础软件，负责底层硬件控制和通用服务的实现。 BSP Board Support Package 板级支持包，包含硬件初始化、驱动和相关工具。 HAL Hardware Abstraction Layer 硬件抽象层，提供对硬件的抽象访问接口。 MCAL Microcontroller Abstraction Layer 微控制器抽象层，提供对芯片外设的直接访问接口。 RTE Run-Time Environment 运行时环境，负责 ASW 与 BSW 的通信管理。 UDS Unified Diagnostic Services 统一诊断服务协议（ISO 14229），用于 ECU 的诊断通信。 Dcm Diagnostic Communication Manager 诊断通信管理模块，实现 UDS 服务的解析和处理。 Dem Diagnostic Event Manager 诊断事件管理模块，负责故障码存储和管理。 PduR Protocol Data Unit Router 协议数据单元路由模块，负责数据路由。 CanTp CAN Transport Protocol CAN 传输协议模块，用于实现 UDS 消息的传输。 NvM Non-Volatile Memory Manager 非易失性内存管理模块，负责数据的持久化存储。 SoAd Socket Adapter 套接字适配器，用于实现基于 TCP/IP 的通信协议（如 DoIP）。 ECU Electronic Control Unit 电子控制单元，是汽车的嵌入式控制器。 GPIO General Purpose …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BE%BF%E6%8D%B7%E5%B7%A5%E5%85%B7/",
    "title": "便捷工具",
    
    "content": " 系统类工具 windows软件 美化工具 软件名称 软件功能 相关链接 oh-my- posh cmd终端美化神器 oh-my-posh - 终端个性化工具 - 美化PowerShell / cmd - 好物分享，真香~-CSDN博客 TranslucentTB Dock栏透明 TranslucentTB - Free download and install on Windows Rocketdock Dock栏美化 Win10极简风最全美化指南！(桌面文件+任务栏透明+dock栏+磁贴_游戏软件_什么值得买 (smzdm.com) xPlorer 文件夹管理 Releases · kimlimjustin/xplorer (github.com) sigma 文件夹管理 aleksey-hoffman/sigma-file-manager: \u0026ldquo;Sigma File Manager\u0026rdquo; is a free, open-source, quickly evolving, modern file manager (explorer / browser) app for Windows and Linux. (github.com) Sapphire 桌面增强工具 hymnly133/Sapphire-EnhancedDesktop: Windows桌面取代软件 (github.com) Fence 桌面分类 Stardock Fences(桌面图标管理工具) v5.88 中文破解版-绿软小站 DeskGo 桌面整理工具（注意要点击下载独立版） 桌面整理_桌面整理软件_一键桌面整理工具-腾讯电脑管家官网 (qq.com) 桌面时钟 桌面时钟 桌面时钟 更多软件在公众号：吾优.exe - 蓝奏云 (lanzouj.com) glazewm window版平铺式桌面 glzr-io/glazewm: GlazeWM is a tiling window manager for Windows inspired by i3wm. (github.com) Clover 资源管理器的tab拓展 Clover给资源管理器加上类似Chrome的标签 易捷科技 EJIE Technology 便捷工具 软件名称 软件功能 相关链接 listary window文件查找工具 Listary – Free File Search Tool \u0026amp; App Launcher anyTxt 根据文件内容搜索 下载最佳免费桌面全文搜索工具 snipaste 截图工具 Snipaste - 截图 + 贴图 PicGO 图片上传工具 PicGo screentogif 屏幕录制转gif ScreenToGif - Record your screen, edit and save as a gif, video or other formats BandView 图片查看神器 Honeyview · 免费图像查看器 · 下载和功能说明 (bandisoft.com) Pointfix 屏幕虚拟荧光笔 Pointofix - Herunterladen - 下载 utools window小工具 uTools官网 - 新一代效率工具平台 PowerToys 微软工具箱 Microsoft PowerToys Ditto 高级粘贴工具 Ditto clipboard manager (sourceforge.io) tinyTask PC自动化应用程序 TinyTask - Download QuickLook 快速预览 Releases · QL-Win/QuickLook (github.com) f.lux 护眼神器 f.lux: software to make your life better (justgetflux.com) deskFlow 一个键鼠控制多台设备 deskflow/deskflow: Deskflow lets you share one mouse and keyboard between multiple computers on Windows, macOS and Linux. It\u0026rsquo;s like a software KVM (but without video). (github.com) Quicker 鼠标右键工具 Quicker软件 您的指尖工具箱 - Quicker (getquicker.net) Ditto 复制粘贴用 Ditto clipboard manager (sourceforge.io) Gopeed 现代化的下载器 Gopeed - 一款现代化的下载器 NDM IDM平替 Neat Download Manager for Mac and Windows (Free Internet Download Manager Mac \u0026amp; Windows ) wechatDownload 公众号文章下载工具 qiye45/wechatDownload: 微信公众号文章批量下载工具，支持图片、评论下载，支持保存html/mhtml/md/pdf/docx文件 (github.com) Geek 彻底卸载软件神器 Geek Uninstaller - the best FREE uninstaller SpaceSniffer 查看磁盘组成 SpaceSniffer(磁盘空间分析工具)官方下载_SpaceSniffer(磁盘空间分析工具)最新版免费下载_3DM软件 (3dmgame.com) Dropshelf 文件中转站 Dropshelf - Free download and install on Windows DropPoint 文件中转站 Releases · GameGodS3/DropPoint (github.com) localsend 跨平台发送 localsend/localsend: An open-source cross-platform alternative to AirDrop (github.com) Audio sharre 音频流分享 mkckr0/audio-share: Audio Share can share Windows/Linux computer\u0026rsquo;s audio to Android phone over network, so your phone becomes the speaker of computer. (You needn\u0026rsquo;t buy a new speaker😄.) (github.com) spaceDesk 将平板成为拓展屏 spacedesk clash 翻墙软件 clashdownload (github.com)Linux Clash 最速安装使用 - 知乎 (zhihu.com) office tool plus office安装软件 Office Tool Plus 一键部署 Office 笔记类软件 软件名称 软件功能 相关链接 obsidian markdown笔记软件 Obsidian - Sharpen your thinking Typora markdown笔记软件 Typora 1.7.6最新破解、激活！亲测有效！ - 哔哩哔哩 (bilibili.com) Vlook typora炫酷主题 MadMaxChow/VLOOK: VLOOK™ 是优雅好用的 Typora/Markdown 主题包和增强插件。 VLOOK™ is an elegant and practical theme package × enhancement plugin for Typora/Markdown. (github.com) WaveDrom 绘制时序图 WaveDrom - Digital timing diagram everywhere NotePad\u0026ndash; NotePad++国产版 ndd 发行版 - Gitee.com 其他 软件名称 软件功能 相关链接 memoryStory 软件商店 MemoryStory (cnxiaobai.com) 绿软小站 盗版软件免费下载网站 绿软小站 - 分享绿色软件、免费软件、最新资讯！ ChatGpt gtp注册流程 AI人工智能gpt注册流程-CSDN博客 无限邮箱 使用一个邮箱号可以申请多个邮箱 2925邮箱-无限邮 Pake 将网页打包为app tw93/Pake: 🤱🏻 Turn any webpage into a desktop app with Rust. 🤱🏻 利用 Rust 轻松构建轻量级多端桌面应用 (github.com) 浏览器工具 Edge拓展 拓展名称 功能 AdGuard 广告拦截器 Bookmark cleaner 无效书签检测 Dualsub 生成字幕 gobal speed 控制视频速度 simple allow copy 任意复制文字 沉浸式翻译 英语翻译 浮图秀 用于展示大图 简悦 沉浸式看博客 Sweezy Cursors 鼠标样式改变 油猴脚本 脚本名称 功能 相关链接 User script+ 推荐当前站点可用的油猴脚本 Magic Userscript+ ：显示站点所有 UserJS (greasyfork.org) 知乎美化 美化知乎页面 知乎美化 (greasyfork.org) 东方永页机 搜索结果自动翻页拼合 东方永页机 (greasyfork.org) 计时器掌控者 可以跳过视频的广告 计时器掌控者 编程类工具 软件名称 软件功能 相关链接 cursor 交互式编程 Cursor ImHex 十六进制数据查看器 WerWolv/ImHex: 🔍 A Hex Editor for Reverse Engineers, Programmers and people who value their retinas when working at 3 AM. (github.com) vscode 地表最强编辑器 Visual Studio Code - Code Editing. Redefined Vim 文字类效率开发神器 welcome home : vim online Amap 用于解析Gcc生成的Map文件 Amap - Sergey Sikorskiy Multsim 电路仿真 multisim14.2汉化破解版下载-ni multisim 14.2中文破解版下载 - 多多软件站 (ddooo.com) WireShark 网络抓包工具 Wireshark · Download ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/",
    "title": "操作系统基础",
    
    "content": " 参考链接 操作系统：设计与实现 (2024 春季学期) (jyywiki.cn)\n应用视角下的操作系统 构造一个最小程序 要理解操作系统首先要理解程序,下面是一个最简单的程序：\nint main() { printf(\u0026#34;Hello world!\u0026#34;); } 当生成输出文件之后，可以使用以下的命令来查看生成的可执行文件\nobjdump 工具可以查看对应的汇编代码 gcc --verbose 可以查看所有编译选项 (真不少)printf 变成了 puts@plt gcc -Wl,--verbose 可以查看所有链接选项 (真不少)原来链接了那么多东西还解释了 end 符号的由来 gcc -static 会链接 libc (大量的代码) 当使用以上工具查看生成的main的可执行文件时，发现可执行文件内容较多。编译链接的过程会链接库文件导致可执行文件变大。\n那么我们可以尝试着手动的去链接可定位文件，可以先生成一个main.o文件，然后将这个mian.o试着手动链接编译的文件\n直接用 ld 链接失败：因为ld 不知道怎么链接 printf\n所以只能不调用 printf ，将程序改为以下内容\nint main() { } 运行时出现 Segmentation Fault ，调试时发现在return时出现错误\n如果改成以下代码\nint main() { while(1); } 运行时会卡在死循环中，说明我们的程序时可以运行的\n[!NOTE]\n为什么会出现Segmention falut？\n当函数在renturn时，程序会从内存的rsp寄存器中取出地址给PC，作为下一条执行指令的地址，然后rsp+8,栈（rsp存在栈中）是向下生长的\n当执行完错误的return语句之后，PC的地址变为了1\n这意味着在执行return之前，内存中的rsp指向运行代码的地址，也就是上面的1，所以出现了问题\n程序 程序实际上是一个状态机：\nstruct CPUState { uint32_t regs[32], csrs[CSR_COUNT]; uint8_t *mem; uint32_t mem_offset, mem_size; }; 处理器：无情的、执行指令的状态机\n从 𝑀[𝑃𝐶]中取出一条指令 执行它 循环往复 程度的退出 程序自己是不能 “停下来” 的!\n指令集里==没有一条关闭计算机的指令==，那么操作系统是如何在关闭所有软件后，切断计算机的电源的？ 只能借助操作系统\nmovq $SYS_exit, %rax # exit( movq $1, %rdi # status=1 syscall # ); 把 “系统调用” 的参数放到寄存器中 执行==syscall==，操作系统接管程序 操作系统可以任意改变程序状态 (甚至终止程序) [!TIP]\nsyscall是一条特殊指令，由操作系统提供。\n当main函数退出时，可以使用syscall指令告诉操作系统，程序即将退出，然后等待syscall的回应，此时一个系统调用就完成了。\n[!TIP]\n在操作系统之下是电路，实际上在下面的电路也可以看成有一个小型的操作系统，当上层操作系统向底层的操作系统发送指令之后（通过ACPI（高级配置和电源接口）进行交互），底层的操作系统会向它所管理的元器件发送高低电平，从而达到关机的效果\n此时就可以构造最小的程序\n==mininal.S==\n#include // The x86-64 system call Application Binary Interface (ABI): // System call number: RAX // Arguments: RDI, RSI, RDX, RCX, R8, R9 // Return value: RAX // See also: syscall(2) syscalls(2) #define syscall3(id, a1, a2, a3) \\ movq $SYS_##id, %rax; \\ movq $a1, %rdi; \\ movq $a2, %rsi; \\ movq $a3, %rdx; \\ syscall #define syscall2(id, a1, a2) syscall3(id, a1, a2, 0) #define syscall1(id, a1) syscall2(id, a1, 0) .globl _start _start: syscall3(write, 1, addr1, addr2 - addr1) syscall1(exit, 1) addr1: .ascii \u0026#34;\\033[01;31mHello, OS World\\033[0m\\n\u0026#34; addr2: 使用以下指令运行上面的汇编程序\ngcc -g -S minimal.S minimal.s as minimal.s -o minimal.o ld -o minimal minimal.o ./minimal echo $status #使用该行指令打印出RAX中的值 程序 = 状态机 ==Everything（二进制文件）= 状态机==\n状态\ngdb 内可见的内存和寄存器 初始状态\n由 ABI 规定 (例如有一个合法的 %rsp) 状态迁移\n执行一条指令 gdb 可以单步观察状态机的执行 syscall 指令: 将状态机 “完全交给” 操作系统 [!IMPORTANT]\n状态 = 变量数值 + 栈 初始状态 = main 的第一条语句 状态迁移 = 执行一条语句中的一小步 拆解程序 操作系统上有很多不同种类的程序\nCore Utilities (coreutils)\nStandard programs for text and file manipulation\n系统中默认安装的是 GNU Coreutils\n系统/工具程序\nbash,binutils, apt, ip, ssh, vim, tmux, gcc, python, ffmpeg, \u0026hellip;\n原理不复杂 (例如 apt 是 dpkg 的套壳)，但琐碎 All-in-one 工具合集：busybox, toybox\n其他各种应用程序\nVscode、OBS-Studio、浏览器、音乐播放器：它们在各种工具程序基础上建立起来 (例：ffmpeg) 追踪一个程序\n工具程序代表：编译器 (gcc):\nstrace -f gcc a.c #(gcc 会启动其他进程) 可以管道给编辑器 vim -\n编辑器里还可以\n%!grep 对于开发者来说，工具的组合是非常重要的 图形界面程序代表：编辑器 (xedit):\nstrace xedit 图形界面程序和 X-Window 服务器按照 X11 协议通信 虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host 任何程序 = minimal.S = 状态机\n程序在操作系统上的执行过程：\n总是从被操作系统加载开始 通过另一个进程执行 execve 设置为初始状态 经历状态机执行 (计算 + syscalls) 进程管理：fork, execve, exit, \u0026hellip; 文件/设备管理：open, close, read, write, \u0026hellip; 存储管理：mmap, brk, \u0026hellip; 最终调用 _exit (exit_group) 退出 ==应用程序 = 计算 + 操作系统 API==\n窗口管理器 能直接管理屏幕设备 (read/write/mmap)\n能画一个点，理论上就能画任何东西 能够和其他进程通信 (send, recv)\n任务管理器 能访问操作系统提供的进程对象 (M1 - pstree) 杀毒软件 文件静态扫描 (read)、主动防御 (ptrace) ==操作系统的职责：提供令应用程序舒适的抽象 (对象 + API)==\n编译器 既然说 “任何程序” 都和 minimal.S 是一样的\n为什么我们没有在 C 代码里看到系统调用？ C 代码是如何变成二进制文件的？ 到底编译器什么优化能做、什么优化不能做？ 如果说程序就是一个状态机，那么如何写一个C语言代码的解释器？\n在写C语言的解释器的时候，我们首先需要将C代码简化，将C 代码改写成 SimpleC，将C转化为SimpleC需要遵循以下规则：\n成每条语句至多一次运算 (函数调用也是运算) 条件语句中不包含运算 真的有这种工具 (C Intermediate Language) 和解释器 (暂时假设没有指针和内存分配) Everything (C 程序) = 状态机\n状态 = 变量数值 + 栈 初始状态 = main 的第一条语句 状态迁移 = 执行一条语句中的一小步 状态机\n“状态机” 是拥有严格数学定义的对象。这意味着你可以把定义写出来，并且用数学严格的方法理解它 —— 形式化方法\n状态：\n[StackFrame, StackFrame, \u0026hellip;] + 全局变量\n实际上一个状态就是一个栈帧\n初始状态：\n仅有一个 StackFrame(main, argc, argv, PC=0) 全局变量全部为初始值 每个栈帧中都有一个PC值，用来保存当前的执行指针 状态迁移：\n执行 frames[-1].PC 处的简单语句 什么是编译器\n编译器的输入\n高级语言 (C) 代码 = 状态机 编译器的输出\n汇编代码 (指令序列) = 状态机 编译器 = 状态机之间的翻译器\nSimpleC的直接翻译\n运算：\n把操作数 load 到寄存器、执行运算、store 写回结果 分支/循环：\n使用条件跳转分别执行代码 函数调用：\n专门留一个寄存器给栈 (SP, Stack Pointer) 将 Stack frame 的信息保存在内存里 通过 SP 可以访问当前栈帧的变量、返回地址等 所以，==C 被称为高级汇编语言==\n存在 C 代码到指令集的直接对应关系 状态机和迁移都可以 “直译” 于是计算机系统里多了一个抽象层 (“一生二、二生三、三生万物”) 更 “高级” 的语言就很难了 C++ virtual void foo(); Python [1, 2, 3, *rest] Javascript await fetch(...) 编译优化\nC 语言编译器在进行代码优化时，遵循的基本准则是在不改变程序的==语义== (即程序的行为和输出结果) 的前提下，提高程序的执行效率和/或减少程序的资源消耗\nint foo(int x) { int y = x + 1; return y - 1; } 一些 “不改变语义” 的例子 (编译优化中最重要的 “三板斧”)：\n函数内联：将函数调用替换为函数体本身的内容 常量传播：在编译时计算常量表达式的值并替换 死代码消除：删除永远不会被执行到的代码 例子\n==编译优化前==\nint compute(int x) { int y = x + 1; return y - 1; } ==编译优化前==\nint compute(int x) { if(true) { x = 1; } else { } return x; } ==编译优化后==\nint compute(int x) { return x; } ==编译优化后==\nint compute(int x) { //if(true) 死代码消除 //{ // x = 1; 常量传播 //} //else 死代码消除 //{ //} //return x; return 1; //常量传播 } 编译的正确性\n系统调用是使程序计算结果可见的唯一方法\n不改变语义 = 不改变可见结果 状态机的视角：满足C/汇编状态机生成的所有 syscall 序列完全一致，任何优化都是允许的 C 代码中的不可优化部分\nExternal function calls (链接时才能确定到底是什么代码) 未知的代码可能包含系统调用 因此不可删除、移出循环等，且要保证参数传递完全一致 编译器提供的 “不可优化” 标注 volatile [load | store | inline assembly] 硬件视角下的操作系统 reset之后执行firmware\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/",
    "title": "测试基础",
    
    "content": " 测试指标 测试覆盖率 测试覆盖率(（Test Coverage)是测试用例执行时，系统或代码的覆盖程度。它反映了测试是否覆盖了系统的各个方面，包括功能、代码、路径等。\n不同的测试覆盖率指标提供了对测试的不同层面的检查。一般来说：\n语句覆盖率和分支覆盖率是最常用的基础覆盖率，适用于大多数场景。 路径覆盖率和多条件覆盖率适用于复杂的系统，特别是那些有大量分支和复杂条件的系统。 函数覆盖率、调用路径覆盖率等适用于验证系统中的函数调用和路径的完整性。 功能覆盖率 $$\r功能覆盖率 = （已执行的功能点数量 / 总功能点数量）× 100\\%\r$$ 应用场景：\n适用于验证系统是否实现了所有设计或需求文档中的功能。 适合功能测试，确保所有业务流程、用例和需求都已测试。 语句覆盖率 $$\r语句覆盖率 = （已执行的语句数量 / 总语句数量）× 100\\%\r$$ 应用场景：\n适用于测试代码是否执行过每一行，特别是代码逻辑简单且不复杂时。 分支覆盖率 $$\r分支覆盖率 = （已执行的分支数量 / 总分支数量）× 100\\%\r$$ 应用场景：\n适用于检查条件语句（如if、else）的所有可能结果是否都被覆盖。 比语句覆盖率更精细，因为它考虑了条件的所有可能分支。 条件覆盖率 $$\r条件覆盖率 = （已执行的条件数量 / 总条件数量）× 100\\%\r$$ 应用场景：\n适用于对单个条件进行验证，特别是在复合条件语句中，确保每个条件都独立地进行了验证。 路径覆盖率 $$\r路径覆盖率 = （已执行的路径数量 / 总路径数量）× 100\\%\r$$ 应用场景：\n适用于对复杂的程序进行全面的验证，尤其是涉及多分支、循环的代码块。 条件-决策覆盖率 $$\r条件-决策覆盖率 = （已执行的条件-决策点数量 / 总条件-决策点数量）× 100\\%\r$$ 应用场景：\n适用于确保测试用例对条件和决策的覆盖面都全面。 循环覆盖率 循环覆盖率（Loop Coverage）是指测试用例覆盖程序中的循环结构的程度。它确保每个循环的进入、退出及重复执行都被测试过。\n$$\r循环覆盖率 = （已执行的循环次数 / 总循环次数）× 100\\%\r$$ 应用场景：\n适用于存在循环结构的程序（如for、while循环），确保循环条件和边界情况都得到充分验证。 函数覆盖率 $$\r函数覆盖率 = （已执行的函数数量 / 总函数数量）× 100\\%\r$$ 应用场景：\n适用于对软件系统中的函数或方法进行验证，确保每个函数都有被调用到。 调用路径覆盖率 $$\r调用路径覆盖率 = （已调用的函数路径数量 / 总函数路径数量）× 100\\%\r$$ 应用场景：\n适用于复杂系统中函数之间的调用关系验证，确保系统的功能通过各个函数调用得到了执行。 多条件覆盖率 $$\r多条件覆盖率 = （已测试的条件组合数量 / 总条件组合数量）× 100\\%\r$$ 应用场景：\n适用于具有多个条件组合的系统，确保每种组合的可能性都被验证。 缺陷密度 缺陷密度（Defect Density）指的是每千行代码（KLOC）中发现的缺陷数量。它是衡量软件质量的一个重要指标。评估标准为：\n缺陷密度越高，说明软件质量越差，可能存在很多隐藏的缺陷。 一般来说，在不同阶段的缺陷密度有所不同，开发阶段缺陷密度较高，测试阶段和发布前缺陷密度较低。 通过标准：\n一般来说，低于0.5个缺陷/千行代码（KLOC）为良好的质量标准，但具体要求会根据项目的复杂性和行业标准有所不同。 缺陷发现率 缺陷发现率（Defect Discovery Rate）是指每单位时间内（如每日、每周、每月）发现的缺陷数量。它能够帮助评估测试进度和测试的效率。评估标准为：\n高缺陷发现率可能意味着测试阶段的有效性较高。 如果缺陷发现率急剧下降，可能意味着大部分缺陷已经被发现，或者测试没有覆盖到关键的功能区域。 通过标准：\n随着测试进度的推进，缺陷发现率应该逐渐降低，测试结束前如果没有新的严重缺陷被发现，说明测试已经接近完成。 缺陷修复率 缺陷修复率（Defect Fix Rate）是指在发现缺陷后，修复缺陷的速度和效率。它可以反映开发团队对缺陷的响应速度和处理能力。评估标准为：\n高修复率表示开发团队对缺陷的及时响应和高效修复。 修复率过低可能表明问题没有及时得到处理，或者缺陷修复的质量不高。 通过标准：\n理想的缺陷修复率应该接近100%，即所有发现的缺陷都应得到修复，尤其是高优先级缺陷。 测试执行率 测试执行率（Test Execution Rate）是指在给定时间内，实际执行的测试用例数量与计划测试用例总数之间的比例。评估标准为：\n高执行率表示测试团队按照计划执行测试，测试进度顺利。 低执行率可能意味着测试工作滞后，测试覆盖不全面。 通过标准：\n测试执行率通常期望达到100%，即所有计划的测试用例都应在测试阶段执行完毕。 测试缺陷重开率 缺陷重开率（Defect Reopen Rate）是指已经标记为解决的缺陷，在后续的测试中再次被发现或被测试人员重新标记为有效缺陷的比例。评估标准为：\n如果缺陷重开率较高，表明缺陷修复不彻底，或者修复后的回归测试没有有效执行。 较低的重开率通常意味着缺陷修复彻底，解决方案有效。 通过标准：\n理想情况下，缺陷重开率应尽可能低。如果重开率较高，可能需要对缺陷修复过程进行审查，并提高修复质量。 回归测试通过率 回归测试通过率（Regression Test Pass Rate）是指回归测试过程中通过的测试用例占总回归测试用例的比例。评估标准为：\n高回归测试通过率表明系统的修改不会破坏现有的功能，系统在修复或新增功能后仍然稳定。 如果回归测试通过率较低，可能意味着修改引入了新的缺陷或不兼容的改变。 通过标准：\n一般来说，回归测试通过率应接近100%，特别是在关键功能区域。 测试效率 测试效率（Test Efficiency）是指测试用例执行中发现缺陷的比例。它帮助评估测试用例设计和执行的质量。评估标准为：\n高测试效率表示测试用例设计得当，能够有效地找到软件中的缺陷。 低测试效率可能意味着测试用例不够全面，或测试覆盖不到关键路径。 通过标准：\n理想情况下，测试效率应较高，至少达到20%-30%，即每执行3-5个测试用例，能发现1个缺陷。 用户验收测试（UAT）通过率 定义：用户验收测试通过率是指用户验收测试过程中，符合用户需求的测试用例通过的比例。评估标准为：\n高通过率意味着软件满足用户的预期需求和业务需求。 低通过率可能表明软件与用户需求存在较大差距。 通过标准：\n用户验收测试通过率通常期望达到100%，即系统完全符合用户的需求。 测试方法 黑盒测试 定义：不关注内部代码，只测试功能。 方法： 等价类划分：将输入数据分为有效和无效类。 边界值分析：测试输入范围的边界值。 决策表测试：基于条件组合设计测试用例。 状态转换测试：测试系统在不同状态下的行为。 用例测试：根据用户场景设计测试。 白盒测试 定义：基于代码内部结构设计测试。 方法： 语句覆盖：确保每条语句至少执行一次。 分支覆盖：确保每个分支至少执行一次。 路径覆盖：测试所有可能的执行路径。 条件覆盖：确保每个条件的所有可能结果都被测试。 灰盒测试 定义：结合黑盒和白盒测试，部分了解内部结构。 方法： 集成测试：测试模块间的交互。 回归测试：确保新代码不影响现有功能。 手动测试 定义：人工执行测试用例。 方法： 探索性测试：无预设用例，自由探索。 用户验收测试：由最终用户验证系统是否符合需求。 自动化测试 定义：使用工具或脚本自动执行测试。 方法： 单元测试：测试单个代码单元。 集成测试：测试多个模块的交互。 性能测试：评估系统性能。 负载测试：测试系统在高负载下的表现。 压力测试：测试系统在极限条件下的表现。 性能测试 定义：评估系统在不同条件下的性能。 方法： 负载测试：模拟多用户或高数据量。 压力测试：测试系统在极限条件下的表现。 容量测试：确定系统能处理的最大负载。 安全测试 定义：评估系统的安全性。 方法： 漏洞扫描：查找已知漏洞。 渗透测试：模拟攻击测试系统防护。 安全代码审查：检查代码中的安全漏洞。 兼容性测试 定义：测试系统在不同环境下的兼容性。 方法： 跨浏览器测试：测试不同浏览器的兼容性。 跨平台测试：测试不同操作系统或设备的兼容性。 可用性测试 定义：评估系统的用户体验。 方法： 用户测试：让真实用户使用并提供反馈。 A/B测试：比较不同设计或功能的效果。 回归测试 定义：确保新代码不影响现有功能。 方法： 自动化回归测试：使用自动化工具执行回归测试。 手动回归测试：人工执行回归测试。 测试用例的设计方法 等价类划分法 等价类划分是一种通过将输入数据划分为不同的等价类来减少测试用例数量的方法。每个等价类中的数据被认为是等价的，即他们在程序中会被系统地处理为相同的方式。\n主要步骤为：\n输入划分：根据输入数据的特性，划分出有效等价类和无效等价类。 有效等价类：程序应该正常处理的输入范围。 无效等价类：程序应该拒绝或抛出错误的输入范围。 测试用例选择：从每个等价类中选择一个代表性测试用例。 适用场景：\n当输入数据范围很大时，等价类划分帮助测试者选择具有代表性的测试数据，避免不必要的重复测试。 边界值分析法 边界值分析法（Boundary Value Analysis）是等价类划分的一个扩展，着重于测试输入数据的边界条件，因为边界值往往是程序出错的地方。\n主要步骤为：\n对于每个等价类，选取边界值作为测试用例（包括边界值的上限和下限）。 对于无效等价类，也应该测试边界值附近的数据。 适用场景：\n特别适用于存在明显边界的输入数据，例如数组的索引、数字范围、日期等。 决策表测试法 决策表测试法（Decision Table Testing）通过构建决策表来表达输入条件与对应行为之间的关系。它用于描述系统在不同输入条件组合下的行为，帮助识别所有的逻辑路径。\n主要步骤：\n列出所有输入条件，并考虑每种输入条件可能的状态（如\u0026quot;真\u0026quot;或\u0026quot;假\u0026quot;、\u0026ldquo;开\u0026quot;或\u0026quot;关\u0026rdquo;）。 通过决策表排列条件组合，并标明每个组合下的预期输出。 基于决策表设计测试用例。 适用场景：\n适用于复杂的逻辑条件，如多条件决策，尤其当输入条件的组合多且复杂时。 状态转换测试法 状态转换测试法（State Transition Testing）用于测试系统在不同状态下的行为。系统会根据不同的输入从一个状态转移到另一个状态，因此需要根据状态转换图来设计测试用例。\n主要步骤：\n绘制系统的状态转换图，列出所有可能的状态及其之间的转换。 设计测试用例以覆盖状态转换过程，包括合法的状态转换和非法的状态转换。 适用场景：\n适用于具有多种状态（如状态机系统、用户登录状态、订单处理等）的系统。 因果图法 因果图法（Cause-Effect Graphing）是基于逻辑关系的测试用例设计方法。通过因果图表示输入条件与输出结果之间的因果关系，进而构建测试用例。\n主要步骤：\n绘制因果图，列出系统的输入条件及其导致的输出结果。 从因果图中提取最小的有效测试用例集合。 将因果图转换为决策表，进行具体的测试设计。 适用场景：\n适用于复杂的条件与结果之间存在因果关系的系统，尤其是需要通过多个输入条件组合来触发某个输出的场景。 错误推测法 错误推测法（Error Guessing）是基于测试人员的经验，通过预测系统可能出现错误的地方来设计测试用例。这种方法主要依赖于测试人员对系统的理解和直觉。\n主要步骤：\n根据历史缺陷、系统复杂性或对系统的熟悉，推测可能的缺陷区域。 基于推测设计测试用例，重点关注可能的错误点。 适用场景：\n适用于经验丰富的测试人员，能够基于对系统的理解和过往经验，推测出潜在的错误区域。 组合测试法 组合测试法（Combinatorial Testing）通过测试输入条件的不同组合来找出可能的缺陷。这种方法适用于输入条件之间存在复杂的交互关系的系统。\n主要步骤：\n确定测试的输入条件和它们的取值范围。 使用数学模型（如覆盖每对条件组合的二阶组合、三阶组合）来设计最小化的测试用例集，确保覆盖所有可能的条件组合。 适用场景：\n适用于系统中存在多个输入条件且条件之间有复杂交互关系的情况。 随机测试法 随机测试法（Random Testing）通过随机选择输入数据来设计测试用例。这种方法没有固定规则，完全依赖于随机选择的输入。\n主要步骤：\n随机选择输入数据，并使用这些数据作为测试用例。 测试通过随机选择的输入数据来验证系统是否能处理各种未预见的情况。 适用场景：\n适用于快速探索系统，或者没有明确需求和设计文档的系统。 ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/",
    "title": "单片机的启动过程",
    
    "content": " 参考链接 mcu 启动流程_mcu启动过程-CSDN博客\n嵌入式开发系列教程（二） MCU启动过程 - 简书 (jianshu.com)\n启动流程 MCU启动方式 MCU有三种启动方式：\nflash启动（最常用）：stm32的flash能够擦写数十万次，用户通过JTAG或SWD模式，将程序下载至此，重新启动从此处启动 sytem memory （系统存储器启动）：系统存储器是芯片内的一块特定的区域，系统存储器中预置了一段bootloader,bootloder将程序下载到flash区，通过flash启动 内嵌SRAM启动：从内存中直接启动代码，避免因小修改反复擦写flash内存，一般用于高速调试 MCU程序启动执行过程 对于CortexM3来说，启动过程如下：\n从0x0000 0000地址处取出MSP的初始值 从0x0000 0004地址处取得PC指针初始值，然后执行用户代码。 Vector Table指的是中断向量表，Reset Handler指的是复位向量。从图中我们看出Reset Handler不过是0x0000 0004地址的一个别名，他其中放置的便是==CPU上电后要执行的第一条用户代码指令的地址。将这个值加载到PC指针上，cpu跳转执行用户代码。== [!important]\n程序运行的第一条地址放在了Reset Handler中\n以下是stm32f103的启动方式调用：\nBoot Space是对一段内存空间的别名，根据不同的启动条件，映射到不同的存储设备上，但是访问地址一定是0x0000 0000 - 0x0005 FFFF这个区间\n当从SRAM启动时，Boot Space映射到SRAM上，即0x0000 0000和0x2000 0000两个地址是指的同一块空间 当从Flash启动时，Boot Space映射到Flash上 当从System Memory启动（即bootloader）时，Boot Space映射到st公司保留的System Memory上，这是一段ROM，烧写有st的bootloader代码 以上，假设单片机从flash启动，则\n从0x0000 0000 -\u0026gt; 0x08000 0000地址处取出MSP的初始值 从0x0000 0004 -\u0026gt; 0x08000 0004地址处取出PC指针初始值，然后执行用户代码 中断向量 中断执行过程如下：\n主循环（main)的代码和中断代码都是CPU执行的 中断随时可能发生 CPU在执行主循环指令序列时，如果产生了中断，CPU便会记录当前PC指针，装载中断入口地址，执行中断代码，中断代码执行结束后，手动调用返回指令，CPU便会加载上一次记录的地址（中断前），继续执行原指令序列 手动调用返回指令，在单片机C语言编码过程中，编译器已经帮我们做了，我们感觉不到 我们的主循环代码，中断代码都是烧写到了单片机的flash中的。\ncpu跳转到中断处理函数，必然要先知道中断处理函数的入口地址。而我们不可能控制主函数的代码长度。这样的话，中断处理函数的入口地址是无法固化的。那么如何让CPU找到正确的中断入口函数呢？\n这时候就需要使用中断向量表了：\ninterrupt vector table即为中断向量表\n我们重述一下启动过程\n从0x0000 0000地址处取出MSP的初始值 从0x0000 0004地址处，即中断向量表中第一个元素，复位向量处取得PC指针初始值，然后执行用户代码 复位向量其实就是0x0000 0004地址单元，放的就是用户代码首地址 当中断发生时，CPU会根据中断号，去中断向量表中找对应的中断入口地址，然后执行中断代码，这样的话，这个表结构，记录了所有的中断入口地址。\n不同IDE的启动过程 IAR ICF文件 启动过程 在IAR的启动文件中会定义一个__iar_program_start的handler，这个handler实际上就是Reset Handler。\n__vector_table DCD sfe(CSTACK) ; Top of Stack DCD __iar_program_start ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler 当程序启动时，会从0x0000_0000中读取读取msp的值，向后偏移4得到PC的值，此时开始从PC值开始运行。\n在调试过程中__iar_program_start中存放了启动地址,也就是0x00004725。\nDisassembly 0x0:\t0x18\tDC8\t24 _vector_table: 0x1:\t0x13\tDC8\t19 0x2:\t0x2000\tDC16\t8192 0x4:\t0x00004725\tDC32\t__iar_program_start 0x8:\t0x00003981\tDC32\tNMI Handler 0x0c:\t0x000025ff\tDC32\tACMPO_IRQHandler 接下来跳转到0x00004725的位置\n__iar_program_start: 0x4724:\t0xbf00\tNOP 0x4726:\t0xbf00\tNOP 0x4728:\t0xbf00\tNOP 0x472a:\t0xbf00\tNOP 0x472c:\t0xf7ff 0xffbe\tBL ?main 0x4730:\t0x50\tDC8\t80 0x4731:\t0x30\tDC8\t48 0x4732:\t0x01\tDC8\t_vector_table 0x4733:\t0xf4\tDC8\t244 0x4734:\t0x01\tDC8\t_vector_table 0x4735:\t0xf4\tDC8\t244 0x4736:\t0x00\tDC8\t0 0x4737:\t0x00\tDC8\t0 Keil MAP文件 MAP文件是MDK编译代码后，产生的集程序、数据及IO空间的一种映射列表文件，简单说就是包括了：各种.c文件、函数、符号等的地址、大小、引用关系等信息，分析各.c文件占用FLASH和RAM的大小，方便优化代码。\n文件类型 简介 .o 可重定向对象文件，每个.c/.s文件都对应一个.o文件 .axf 可执行对象文件，由.o文件链接生成，仿真的时候需要用到此文件 .hex INTEL Hex格式文件，用于下载到MCU运行，由.axf转换而来 .map 连接器生成的列表文件，对分析程序存储占用情况非常有用 其他 .crf、.d、.dep、.lnp、.lst、.htm、.build_log.htm等一般用不到 map文件的组成部分 组成部分 简介 程序段交叉引用关系 描述各文件之间函数调用关系 删除映像未使用的程序段 描述工程中未用到而被删除的冗余程序段(函数/数据) 映像符号表 描述各符号（程序段/数据）在存储器中的地址、类型、大小等 映像内存分布图 描述各个程序段（函数）在存储器中的地址及占用大小 映像组件大小 给出整个映像代码（*.o）占用空间汇总信息 ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/",
    "title": "二进制文件",
    
    "content": " Bin BIN文件是纯二进制文件，没有固定的结构或元数据。==当想要将二进制文件烧录进单片机时，不需要再对数据进行处理==，也就是说，我们使用ImHex打开的原始数据是什么样的，那么我们查看Flash中的内容就是什么样的。\nHex Hex 全称 (Intel HEX)文件是由一行行符合Intel HEX文件格式的文本所构成的ASCII文本文件。\n在Intel HEX文件中，每一行包含一个HEX记录。\n[!note]\n注意：我们使用txt文件打开的时候显示的是ASCII表示，也就是一个字符串。实际上一行数据的原始数据如下图左侧所示，使用txt打开的如右图所示。\n下面会用源数据表示左侧的数据，用ASCII表示右侧数据。\n参考链接 单片机烧录用的hex文件，文件格式解析（转载）_.hex用什么软件打开-CSDN博客\nIntel Hex Format\n行结构 一行Hex数据由以下结构组成：\n[Start code][Byte count][Address][Record type][Data][Checksum] 参数 长度 说明 Start code - 每行都由冒号开头，这是固定的 Byte count 1 字节 本行数据的长度,最大值是255 (0xFF). 16 (0x10) 和32 (0x20)是最常用的 Address 2字节 Memory数据开始16-bit地址偏移。物理地址通常是有这个偏移加上基地址 Record type 1 字节 表示不同数据段的含义 Data 可变长度 具体数据 N Byte ，表示本行中数据字节的数量 Checksum 1 字节 校验值 [!tip]\nChecksum的计算方法为：\n如0300300002337A1E,数据和为：03 + 00 + 30 + 00 + 02 + 33 + 7A = E2 这个E2的补码是 1E ，即这个数据record的补码\n[!note]\n注意：上表的长度是ASCII的长度，也就是假设txt显示:1010，那么10就是一个字节，但是在源数据中，这就是两个字节0x31 0x30\n==Record type的选取==\n数值 数据类型详（Record type） 00 表示后面记录的是数据 01 表示文件结束，放在文件的最后，标识HEX文件的结尾 02 表示扩展段地址 03 表示开始段地址 04 表示扩展线性地址 05 表示开始线性地址 [!important]\n这里需要注意的是Bin文件和Hex文件的区别：\nBin文件中的数据内容可以直接烧录进入Flash中\nHex文件中的数据内容（指的是源数据）是经过改变之后才可以放入Flash中的\n一般我们通过txt文件看到的都是ASCII表示，并不是文件源数据，我们需要将ASCII的数据当成16进制的数据，也就是我们看见的:1010转换为0x10 0x10。此时他们的源数据就改变了。源数据从0x3A 0x31 0x30 0x31 0x30变成0x10 0x10 0x10 0x10\n地址解读 因为HEX的地址段只有两个字节表示，只能寻址到16位,显然是不够的，所以就有了拓展地址，相关解释请参考Intel Hex Format。\n地址分为16位和32位或8位。\n8位和32位：==数据记录中的数据字节在内存中的绝对地址为线性地址==。 16位：==数据字节的绝对地址是分段地址==。 $$\r实际物理地址=基地址+偏移地址\r$$ 地址类型 Record type 地址解读 线性基地址 0x04 得到的数据左移16位 段基地址 0x02 得到的数据左移4位 偏移地址 0x00 得到的数据 [!tip]\n选择不同类型的基地址（0x02和0x04）对应着不同位长的系统。\n==指定程序入口==\n$$\r实际入口地址=（代码段地址\u003c\u003c4）+指令指针地址\r$$ 地址类型 Record type 地址解读 代码段地址（CS） 0x03 得到的数据的高2字节 指令指针地址（IP） 0x03 得到的数据的低2字节 记录：:0400000300003800C1 数据字段：00003800。 CS = 0x0000。 IP = 0x3800。 实际入口地址 = (0x0000 \u0026lt;\u0026lt; 4) + 0x3800 = 0x03800。 开始线性入口：可以直接使用数据字段的值。\n记录：:04000005000000CD2A 数据字段：000000CD。 实际入口地址 = 0x000000CD。 ==示例==\n以下是一个包含扩展地址记录的HEX文件示例：\n复制\n:020000021200EA :10000000AABBCCDDEEFF00112233445566778899F1 :10001000ABCDEF0123456789ABCDEF0123456789B2 :00000001FF 第一行（类型02）： 数据字段：1200（段地址）。 基地址 = 0x1200 \u0026lt;\u0026lt; 4 = 0x12000。 第二行（类型00）： 偏移地址：0000。 实际地址 = 0x12000 + 0x0000 = 0x12000。 数据字段：AABBCCDDEEFF00112233445566778899。 第三行（类型00）： 偏移地址：0010。 实际地址 = 0x12000 + 0x0010 = 0x12010。 数据字段：ABCDEF0123456789ABCDEF0123456789。 第四行（类型01）： 文件结束记录。 实现 以下使用CAPL语言实现：\nvariables { struct Block { dword BlockStartAddr; //数据开始的地址 dword BlockDataLength; //数据的长度 byte dataBuffer[0x020FFFF]; //数据区域(单块数据的Buffer，如果hex文件很大，则需要把次参数调大) }; struct Block hexfile[5]; //创建5个数据块(主要根据HEX文件进行调整，hex有几个数据块就需要设置几个) int HexBlockTotalNumber = 0; //数据块总数 dword t1; //计算解析所用的时间 } /********************************************************************************* *Function: //char2byte * Description： //把单个字符转换为Byte的函数 *Input: //ch：ASCII编码字符，取值为0到F *Return: //val，为byte类型 **********************************************************************************/ byte char2byte(char ch) { byte val; val = 0; if ( ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { val = ch - \u0026#39;0\u0026#39;; } if ( ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;f\u0026#39;) { val = (ch - \u0026#39;a\u0026#39;) + 10; } if ( ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;F\u0026#39;) { val = (ch - \u0026#39;A\u0026#39;) + 10; } return val; } /********************************************************************************* *Function: //Read_hexFile * Description： //解码HEX文件，只支持0x00，0x04，0x01类型 *Input: //Filename：需要解码的文件名 *Output: //hexfile *Return: //void **********************************************************************************/ //读取HEXFILE void Read_hexFile(char Filename[]) { long file_handle; char RowData[128]; //逐行读取,每行数据缓存，当每行数据大于128时，需要将其调整 dword i; dword RowDataByte;\t//单块数据块字节数 qword OffsetAddress;\t//扩展线性地址 qword ReAddr;\t//上一数据行起始地址 dword Len;\t//HEX每行有效数据字节数 dword ReLen;\t//HEX前一次数据长度 dword Addr;\t//HEX每行起始地址 dword Type;\t//HEX每行类型，有00，01，04四种类型 RowDataByte = 0;i = 0;Len = 0;ReLen = 0;Addr=0;Type = 0;ReAddr = 0; file_handle = OpenFileRead(Filename,0); HexBlockTotalNumber = 0; if(file_handle!=0) { // Read all lines while ( fileGetStringSZ(RowData,elcount(RowData),file_handle)!=0 ){ //判断首字符是否为:号 if(RowData[0] == \u0026#39;:\u0026#39;){ Len = (char2byte(RowData[1])*0x10+char2byte(RowData[2])); Addr = char2byte(RowData[3])*0x1000+char2byte(RowData[4])*0x100+char2byte(RowData[5])*0x10+char2byte(RowData[6]); Addr |= (OffsetAddress \u0026lt;\u0026lt; 16); Type = char2byte(RowData[7])*0x10+char2byte(RowData[8]); //以下为打印解析的过程，打印解析时候的变量 //write(\u0026#34;RowData:%s,HexBlockTotalNumber:%d,ReLen:%X,ReAddr:%X,Addr:%X,RowDataByte:%X\u0026#34;,RowData,HexBlockTotalNumber,ReLen,ReAddr,Addr,RowDataByte); switch(Type){ case 0x00:\t//数据 if (Addr \u0026gt; (ReLen + ReAddr)){ //判断为新数据块 if(RowDataByte == 0)\t//是否为首行数据字节数 { hexfile[HexBlockTotalNumber].BlockStartAddr = Addr; //记录新数据块的起始地址 } else\t//不是首行 { hexfile[HexBlockTotalNumber].BlockDataLength = RowDataByte; //数据长度 RowDataByte = 0;\t//重新开始计数 hexfile[HexBlockTotalNumber].BlockStartAddr = Addr;\t//记录新数据块的起始地址 HexBlockTotalNumber++; } } for(i = 0; i\u0026lt; Len ; i++) { //储存buffer，注意没有对crc进行校验。 hexfile[HexBlockTotalNumber].dataBuffer[RowDataByte++]=(char2byte(RowData[2*i+9])*0x10+char2byte(RowData[2*i+10])); } ReAddr = Addr;\t//保存当前地址,下一次使用 ReLen = Len;\t//保存当前长度,下一次使用 break; case 0x04:\t//扩展线性地址记录 OffsetAddress = char2byte(RowData[9])*0x1000+char2byte(RowData[10])*0x100+char2byte(RowData[11])*0x10+char2byte(RowData[12]);\t//偏移地址\tbreak; case 0x01:\t//地址,结束 hexfile[HexBlockTotalNumber].BlockDataLength = RowDataByte; //数据长度 HexBlockTotalNumber++; break; } } } write(\u0026#34;Hex文件读取成功, 数据分块:%d\u0026#34;,HexBlockTotalNumber); for(i = 0; i \u0026lt; HexBlockTotalNumber; i++) { write(\u0026#34;数据块:%d, 起始地址:0x%X, 结束地址:0x%X, 数据长度:%6d字节\\r\\n\u0026#34;, i+1, hexfile[i].BlockStartAddr, hexfile[i].BlockStartAddr + hexfile[i].BlockDataLength - 1, hexfile[i].BlockDataLength); } fileClose(file_handle); } else{ write(\u0026#34;OpenFileRead,error occurs\u0026#34;); } } on key \u0026#39;f\u0026#39; { t1 = timeNow(); Read_hexFile(\u0026#34;test.hex\u0026#34;); write(\u0026#34;%d\u0026#34;,t1-timeNow()); write(hexfile[0].dataBuffer); } write (byte v[]) { int i; for (i=0; i\u0026lt;48; i++) write(\u0026#34;dataBuffer:%x\u0026#34;,hexfile[0].dataBuffer[i]); } Elf ELF（Executable and Linkable Format，可执行与可链接格式）是一种用于可执行文件、目标文件、共享库和核心转储的标准文件格式。它广泛应用于类Unix系统（如Linux、BSD）以及嵌入式系统中。\nELF文件的结构 ELF文件由以下几个主要部分组成：\nELF头 程序头表 节头表 段和节 ELF头（ELF Header） 作用：描述文件的基本信息，如文件类型、目标架构、程序入口地址等。 重要字段： e_ident：魔数（Magic Number），标识文件为ELF格式。 e_type：文件类型（如可执行文件、共享库等）。 e_machine：目标架构（如x86、ARM）。 e_entry：程序入口地址。 e_phoff：程序头表偏移。 e_shoff：节头表偏移。 程序头表（Program Header Table） 作用：描述段（Segment）信息，用于加载可执行文件。 重要字段： p_type：段类型（如可加载段、动态链接信息）。 p_offset：段在文件中的偏移。 p_vaddr：段在内存中的虚拟地址。 p_filesz：段在文件中的大小。 p_memsz：段在内存中的大小。 节头表（Section Header Table） 作用：描述节（Section）信息，用于链接和调试。 重要字段： sh_name：节名称（在字符串表中的索引）。 sh_type：节类型（如代码节、数据节）。 sh_addr：节在内存中的地址。 sh_offset：节在文件中的偏移。 sh_size：节的大小。 段（Segments）和节（Sections） 段：用于加载和执行，通常包含代码、数据等。 节：用于链接和调试，通常包含符号表、字符串表等。 ELF文件的类型 ELF文件可以分为以下几种类型：\n可执行文件（Executable）：可以直接运行的程序。 共享库（Shared Library）：动态链接库（如.so文件）。 目标文件（Relocatable File）：编译生成的中间文件（如.o文件）。 核心转储（Core Dump）：程序崩溃时的内存转储。 ELF文件的工具 以下工具可以用于分析和操作ELF文件：\nreadelf：查看ELF文件的详细信息。 示例：readelf -h \u0026lt;file\u0026gt;（查看ELF头）。 objdump：反汇编和查看ELF文件内容。 示例：objdump -d \u0026lt;file\u0026gt;（反汇编代码段）。 nm：查看ELF文件的符号表。 示例：nm \u0026lt;file\u0026gt;。 strip：删除ELF文件的符号表和调试信息。 示例：strip \u0026lt;file\u0026gt;。 ELF文件的加载和执行 当ELF可执行文件被加载到内存中时，操作系统会执行以下步骤：\n解析ELF头，确定文件类型和入口地址。 根据程序头表，将段加载到内存中。 设置程序的堆栈和环境变量。 跳转到入口地址，开始执行程序。 ELF文件的示例解析 以下是一个简单的ELF文件解析示例：\n查看ELF头 readelf -h hello 输出示例：\nELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2\u0026#39;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x400430 Start of program headers: 64 (bytes into file) Start of section headers: 6936 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 28 查看程序头表 readelf -l hello 输出示例：\nElf file type is EXEC (Executable file) Entry point 0x400430 There are 9 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x00000000000006fc 0x00000000000006fc R E 200000 LOAD 0x0000000000000700 0x0000000000600700 0x0000000000600700 0x0000000000000230 0x0000000000000238 RW 200000 ... 查看节头表 readelf -S hello 输出示例：\nThere are 31 section headers, starting at offset 0x1b18: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000400238 00000238 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 00000254 0000000000000020 0000000000000000 A 0 0 4 ... ELF文件的常见节 .text：代码段，包含程序的指令。 .data：已初始化的全局变量和静态变量。 .bss：未初始化的全局变量和静态变量。 .rodata：只读数据（如字符串常量）。 .symtab：符号表。 .strtab：字符串表。 .dynamic：动态链接信息。 ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/",
    "title": "链接文件",
    
    "content": " LD LD 文件是 GNU 工具链（如 GCC）使用的链接器脚本，用于指定如何将程序的各个部分（如代码段、数据段等）放置到目标设备的内存中。LD 脚本的语法非常灵活，支持详细的内存区域分配、段定义以及符号管理。\n基本结构 LD 链接脚本主要由以下几部分组成：\n全局声明和变量：设置内存区域和段的分配。 段定义（SECTIONS）：定义程序的各个段（如 .text, .data, .bss 等）在内存中的位置。 符号管理：可以设置一些符号（如 __start、__end）的地址。 内存区域定义 使用 MEMORY 关键字来定义目标设备的内存区域。每个内存区域指定起始地址（ORIGIN）和长度（LENGTH）。\nMEMORY { FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 1M RAM (rw) : ORIGIN = 0x20000000, LENGTH = 128K } FLASH 区域指定为可读 (r) 和可执行 (x)。 RAM 区域指定为可读 (r) 和可写 (w)。 段定义 SECTIONS 用来定义程序的各个段及其如何映射到内存中。每个段由其名称（如 .text、.data 等）定义，并可以指定要放置的内存区域。\nSECTIONS { .text : { *(.text) // 所有 .text 段的内容 } \u0026amp;gt; FLASH // 放置到 FLASH 区域 .data : { *(.data) // 所有 .data 段的内容 } \u0026amp;gt; RAM // 放置到 RAM 区域 .bss : { *(.bss) // 所有 .bss 段的内容 } \u0026amp;gt; RAM // 放置到 RAM 区域 .stack : { *(.stack) // 堆栈区域 } \u0026amp;gt; RAM // 放置到 RAM 区域 } *() 用于包含所有具有相应段名的输入部分。例如，*(.text) 包含所有 .text 段的内容。 \u0026amp;gt; MEMORY_REGION 用于将段放置到指定的内存区域。 特殊符号定义 可以在链接器脚本中定义特殊符号，来标记某些特定的位置（如段的开始和结束）。\nSECTIONS { .text : { __text_start = .; // 定义一个符号，表示 .text 段的开始 *(.text) …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
    "title": "软件ji'chu",
    
    "content": " 参考链接 这些嵌入式知识助 你秋招，也助你进阶 (qq.com)\nAUTOSAR架构 AUTOSAR（Automotive Open System Architecture）是一个用于开发汽车电子系统的软件架构标准。它通过标准化的架构提高了软件的可重用性和可移植性，减少了开发时间和成本。以下是AUTOSAR架构的详细描述：\nAUTOSAR架构概述 AUTOSAR架构由多个层次组成，包括应用软件层（Application Layer）、运行时环境（Runtime Environment, RTE）和基础软件层（Basic Software, BSW）。这些层次共同工作，提供完整的汽车电子系统解决方案。\nAUTOSAR层次结构 Application Layer（应用层，ASW）\n包含所有的应用程序组件，这些组件定义了具体的功能，如传感器数据处理、控制算法等。 应用组件通过接口与RTE进行通信，而不是直接与硬件交互。 Runtime Environment (RTE)（运行时环境）\n作为应用层和基础软件层之间的抽象层，提供标准化的接口。 管理应用组件之间以及应用组件与基础软件之间的通信。 确保组件的独立性，使得应用软件能够在不同的硬件平台上运行。 Basic Software (BSW)（基础软件层）\n包含所有的基础服务和驱动程序，为应用软件提供硬件无关的标准化服务。 BSW进一步划分为四个主要部分： Microcontroller Abstraction Layer (MCAL)（微控制器抽象层）：提供对微控制器和外设的抽象接口。 ECU Abstraction Layer（ECU抽象层）：实现ECU级别的硬件抽象，提供对外围设备的访问。 Service Layer（服务层）：提供系统服务，如操作系统、存储管理、诊断服务等。 Complex Device Drivers（复杂设备驱动）：处理复杂的硬件设备，不适合通过MCAL和ECU抽象层实现。 AUTOSAR架构图示 --------------------------------- | Application Layer | | (ASW) | --------------------------------- | Runtime Environment (RTE) | …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/%E6%97%B6%E9%92%9F/",
    "title": "时钟",
    
    "content": " 参考链接 【STM32】时钟_stm32f405 定时器时钟-CSDN博客\n时钟相关缩写 RCC - Reset and Clock Control（复位与时钟控制） RTC - Real-Time Clock（实时时钟） BKP - Backup Registers（备份寄存器） PWR - Power Control（电源控制） HCLK - AHB Clock（AHB总线时钟） USBCLK - USB Clock（USB时钟） LSCO - Low Speed Clock Output（低速时钟输出） MSI - Multi-Speed Internal Clock（多速内部时钟） CSS - Clock Security System（时钟安全系统） LPTIM - Low Power Timer（低功耗定时器） WDG - Watchdog Timer（看门狗定时器） HSE - High-Speed External Clock（高速外部时钟） HSI - High-Speed Internal Clock（高速内部时钟） LSE - Low-Speed External Clock（低速外部时钟） LSI - Low-Speed Internal Clock（低速内部时钟） PLL - Phase-Locked Loop（锁相环） SYSCLK - System Clock（系统时钟） PCLK - Peripheral Clock（外设时钟） APB - Advanced Peripheral Bus（高级外设总线） AHB - Advanced High-performance Bus（高级高性能总线） 概念 简单来说，时钟是具有周期性的脉冲信号，最常用的是占空比50%的方波\n时钟是单片机的脉搏，搞懂时钟走向及关系，对单片机使用至关重要！\n时钟树 可以使用三种不同的时钟源来驱动系统时钟：\nHSI振荡器时钟 HSE振荡器时钟 主PLL（PLL）时钟 器件有以下两个次级时钟源：\n低速内部 RC (LSI RC)，该 RC 用于驱动独立看门狗，也可选择提供给 RTC 用于停机/待机模式下的自动唤醒。 低速外部晶振（LSE 晶振），用于驱动 RTC 时钟 (RTCCLK)对于每个时钟源来说，在未使用时都可单独打开或者关闭，以降低功耗 时钟源：\n时钟源名称 频率 材料 用途 高速外部振荡器(HSE) 4~16MHz 晶体/陶瓷 SYSCLK/RTC 低速外部振荡器(LSE) 32.768KH Z 晶体/陶瓷 RTC（实时时钟） 高速内部振荡器(HSI) 8MHz RC SYSCLK 低速内部振荡器(LSI) 40KHz RC RTC/IWDG [!TIP]\nH：high L：low S：speed I：internal E：external\n时钟控制器为应用带来了高度的灵活性，用户在运行内核和外设时可选择使用外部晶振或者使用振荡器，既可采用最高的频率，也可为以太网、USB OTG FS 以及 HS、I2S 和 SDIO等需要特定时钟的外设保证合适的频率。\n可通过多个预分频器配置 ==AHB 频率==、==高速 APB (APB2)== 和==低速 APB (APB1)==。\nAHB 域的最大频率为 168 MHz。 高速 APB2 域的最大允许频率为 84 MHz。 低速 APB1 域的最大允许频率为 42 MHz。 除以下时钟外，所有外设时钟均由系统时钟 (SYSCLK) 提供：\n来自于特定 PLL 输出 (PLL48CLK) 的 USB OTG FS 时钟 (48 MHz)、基于模拟技术的随机数发生器 (RNG) 时钟 (\u0026lt;=48 MHz) 和 SDIO 时钟 (\u0026lt;=48 MHz)。\nI2S 时钟\nSTM32F405xx/07xx 和 STM32F415xx/17xx 的定时器时钟频率由硬件自动设置。分为两种情况：\n如果 APB 预分频器为 1，定时器时钟频率等于 APB 域的频率。 否则，等于 APB 域的频率的两倍 (×2)。 配置时钟：==使能时钟 \u0026gt; 调用SystemInit()函数（在system_stm32xxx.c中定义）\u0026gt; 选择时钟源，配置PLL \u0026gt; 选择系统时钟源，配置总线分频器 \u0026gt; 配置扩展外设时钟==\n代码\n#include \u0026#34;stm32f10x.h\u0026#34; void RCC_Configuration(void) { // 1. 开启HSE时钟 RCC_HSEConfig(RCC_HSE_ON); ErrorStatus HSEStartUpStatus = RCC_WaitForHSEStartUp(); if (HSEStartUpStatus == SUCCESS) { // 2. 配置PLL，HSE为PLL输入源，9倍频 RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9); RCC_PLLCmd(ENABLE); // 等待PLL稳定 while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET); // 3. 选择PLL作为系统时钟源 RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); while (RCC_GetSYSCLKSource() != 0x08); // 4. 配置时钟分频 RCC_HCLKConfig(RCC_SYSCLK_Div1); // AHB时钟 RCC_PCLK1Config(RCC_HCLK_Div2); // APB1时钟 RCC_PCLK2Config(RCC_HCLK_Div1); // APB2时钟 // 5. 配置Flash存储器等待状态 FLASH_SetLatency(FLASH_Latency_2); } } HSE时钟 高速外部时钟信号（HSE）有两个时钟源\nHSE外部用户时钟 HSE外部晶振/陶瓷谐振器 外部源（HSE 旁路） 在此模式下，必须提供外部时钟源。此模式通过将 RCC 时钟控制寄存器 (RCC_CR) 中的HSEBYP 和 HSEON 位置 1 进行选择。必须使用占空比约为 50% 的外部时钟信号（方波、正弦波或三角波）来驱动 OSC_IN 引脚，同时 OSC_OUT 引脚应保持为高阻态 (hi-Z)。\n外部晶振/ 陶瓷谐振器（HSE 晶振） HSE 的特点是精度非常高。\nRCC 时钟控制寄存器 (RCC_CR) 中的 HSERDY 标志指示高速外部振荡器是否稳定。在启动时，硬件将此位置 1 后，此时钟才可以使用。如在 RCC 时钟中断寄存器 (RCC_CIR) 中使能中断，则可产生中断。\nHSE 晶振可通过 RCC 时钟控制寄存器 (RCC_CR) 中的 HSEON 位打开或关闭。\n负载电容(起振电容)必须==尽可能的靠近振荡器==/谐振器的引脚，以尽量减小输出失真和起振稳定时间，负载电容值必须根据所选振荡器的不同做适当的调整\n[!TIP]\n晶振（晶体振荡器）：\n利用石英晶体的压电效应来生成稳定的振荡频率。\n主要用于为电路提供一个高精度的时钟信号，如微控制器、电脑等。\n协振器（谐振器）：\n可以是LC电路或陶瓷谐振器，依靠电感、电容或物理振动来产生共振。\n它与晶振相似，可以用于生成振荡信号，但通常精度较低，稳定性也比晶振差。\nHSI时钟 HSI 时钟信号由内部 16 MHz RC（电阻电容） 振荡器生成，可直接用作系统时钟，或者用作 PLL 输入。HSI RC 振荡器的优点是成本较低（无需使用外部组件）。此外，其启动速度也要比 HSE 晶振块，但即使校准后，其精度也不及外部晶振或陶瓷谐振器。\nSTM32中的HSI（High-Speed Internal）内部时钟是指芯片内部产生的高速时钟信号。HSI是STM32微控制器系列的一部分，通常用作系统时钟的一个选项。HSI时钟信号由芯片内部的振荡器产生，其频率通常为16 MHz（具体数值可能因STM32系列而异）。\nHSI时钟通常用于以下用途：\n启动和初始化：在STM32芯片上电后，通常会首先使用HSI时钟来启动和初始化系统，然后再切换到外部时钟源（如HSE）。\n低功耗模式：当系统需要进入低功耗模式时，可以选择将时钟切换回HSI，以减少功耗。\n内部模块时钟：一些内部模块，如看门狗定时器（WDT）和RTC（实时时钟），可能使用HSI时钟。\n频率可选性：HSI时钟通常具有多个频率选项，可以根据应用的需求进行配置。\n需要注意的是，HSI时钟通常比外部时钟源（如HSE，高速外部）的精度和稳定性较差，因此在要求高精度的应用中，通常会选择外部时钟源作为系统时钟。但在许多应用中，HSI时钟足够满足要求，并且可以在降低功耗或简化设计时提供灵活性。\nPLL F4芯片有两个PLL：\n主PLL由HSE和HSI振荡器提供时钟信号，并具有两个不同的输出时钟\n用于生成告诉系统时钟（最高达168MHz）\n输出用于生成USB OTG FS的时钟（48Mhz）、随机数发生器的时钟（\u0026lt;=48MHz）和SDIO时钟（\u0026lt;=48MHz）\n专用PLL（PLLI2S）用于生成精确时钟，从而在I2S接口实现高品质的音频性能\n由于在 PLL 使能后主 PLL 配置参数便不可更改，所以建议先对 PLL 进行配置，然后再使能（选择 HSI 或 HSE 振荡器作为 PLL 时钟源，并配置分频系数 M、N、P 和 Q）。\nPLLI2S 使用与 PLL 相同的输入时钟（PLLM[5:0] 和 PLLSRC 位为两个 PLL 所共用）。但是，PLLI2S 具有专门的使能/禁止和分频系数（N 和 R）配置位。在 PLLI2S 使能后，配置参数便不能更改。\n当进入停机和待机模式后，两个 PLL 将由硬件禁止；如将 HSE 或 PLL（由 HSE 提供时钟信号）用作系统时钟，则在 HSE 发生故障时，两个 PLL 也将由硬件禁止。RCC PLL 配置寄存器 (RCC_PLLCFGR) 和RCC 时钟配置寄存器 (RCC_CFGR) 可分别用于配置 PLL 和 PLLI2S。\nPLL 主要用于以下几个方面：\n时钟生成和同步：PLL 可以用于生成一个稳定的时钟信号，将其锁定到外部参考时钟，从而使系统中的各个部分能够以相同的时间基准运行。这在数字系统、通信系统、计算机系统和许多其他应用中非常重要。\n频率合成：PLL 可以将一个低频率的参考信号合成为高频率的输出信号。这对于需要高频率时钟信号的应用非常有用，如通信设备、射频电路和数字信号处理器。\n时钟恢复：在通信系统中，接收到的信号通常会被传输过程中的噪声和时延所影响。PLL 可以用于从接收到的信号中恢复出其原始时钟，以便正确解码和处理数据。\n频率调制和解调：在调制和解调过程中，PLL 可以用于调整信号的频率，以便将信息嵌入到载波中（调制）或从载波中提取出信息（解调）。\n时钟多路复用：PLL 可以用于将多个输入时钟信号多路复用到一个输出时钟上，以满足复杂系统中的时钟要求。\n频率锁定：PLL 可以用于锁定一个振荡器或电路的输出频率到一个稳定的参考频率，以确保输出频率与所需频率匹配。\nLSE时钟 LSE 晶振是 32.768 kHz 低速外部 (LSE) 晶振或陶瓷谐振器，可作为实时时钟外设 (RTC) 的时钟源来提供时钟/日历或其它定时功能，具有功耗低且精度高的优点。\nLSE 晶振通过 RCC 备份域控制寄存器 (RCC_BDCR) 中的 LSEON 位打开和关闭。\nRCC 备份域控制寄存器 (RCC_BDCR) 中的 LSERDY 标志指示 LSE 晶振是否稳定。在启动时，硬件将此位置 1 后，LSE 晶振输出时钟信号才可以使用。如在 RCC 时钟中断寄存器(RCC_CIR) 中使能中断，则可产生中断。\n外部源（LSE旁路） 在此模式下，必须提供外部时钟源，最高频率不超过 1 MHz。此模式通过将 RCC 备份域控制寄存器 (RCC_BDCR) 中的 LSEBYP 和 LSEON 位置 1 进行选择。必须使用占空比约为 50%的外部时钟信号（方波、正弦波或三角波）来驱动 OSC32_IN 引脚，同时 OSC32_OUT 引脚应保持为高阻态 (Hi-Z)。\nLSI LSI RC 可作为低功耗时钟源在停机和待机模式下保持运行，供独立看门狗 (IWDG) 和自动唤醒单元 (AWU) 使用。时钟频率在 32 kHz 左右。\nLSI RC 可通过 RCC 时钟控制和状态寄存器 (RCC_CSR) 中的 LSION 位打开或关闭。\nRCC 时钟控制和状态寄存器 (RCC_CSR) 中的 LSIRDY 标志指示低速内部振荡器是否稳定。在启动时，硬件将此位置 1 后，此时钟才可以使用。如在 RCC 时钟中断寄存器 (RCC_CIR) 中使能中断，则可产生中断。\nSYSCLK 在系统复位后，默认系统时钟为 HSI。在直接使用 HSI 或者通过 PLL 使用时钟源来作为系统时钟时，该时钟源无法停止。\n只有在目标时钟源已就绪时（时钟在启动延迟或 PLL 锁相后稳定时），才可从一个时钟源切换到另一个。如果选择尚未就绪的时钟源，则切换在该时钟源就绪时才会进行。RCC 时钟控制寄存器 (RCC_CR) 中的状态位指示哪个（些）时钟已就绪，以及当前哪个时钟正充当系统时钟。\nSYSTICK SysTick（滴答）定时器被捆绑在NVIC中，用于产生SYSTICK异常（异常号：15）。\n在以前，大多操作系统需要一个硬件定时器来产生操作系统需要的滴答中断，作为整个系统的==时基==。\n例如，为多个任务许以不同数目的时间片，确保没有一个任务能霸占系统；或者把每个定时器周期的某个时间范围赐予特定的任务等，还有操作系统提供的各种定时功能，都与这个滴答定时器有关。因此，需要一个定时器来产生周期性的中断，而且最好还让用户程序不能随意访问它的寄存器，以维持操作系统“心跳”的节律。\nSystick定时器就是系统滴答定时器，一个24 位的倒计数定时器，计到0 时，将从RELOAD 寄存器中自动重装载定时初值。只要不把它在SysTick 控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作。\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%AE%97%E6%B3%95/",
    "title": "算法",
    
    "content": " 参考链接 Hello 算法 (hello-algo.com)\n复杂度分析 迭代 迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。\nfor循环 for 循环是最常见的迭代形式之一，适合在预先知道迭代次数时使用。\n以下函数基于 for 循环实现了求和 1+2+⋯+𝑛 ，求和结果使用变量 res 记录。需要注意的是，Python 中 range(a, b) 对应的区间是“左闭右开”的，对应的遍历范围为 𝑎,𝑎+1,…,𝑏−1 ：\n/* for 循环 */ int forLoop(int n) { int res = 0; // 循环求和 1, 2, ..., n-1, n for (int i = 1; i \u0026lt;= n; i++) { res += i; } return res; } 此求和函数的操作数量与输入数据大小 𝑛 成正比，或者说成“线性关系”。实际上，时间复杂度描述的就是这个“线性关系”。\nwhile循环 与 for 循环类似，while 循环也是一种实现迭代的方法。在 while 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。\n下面我们用 while 循环来实现求和 1+2+⋯+𝑛 ：\n/* while 循环 */ int whileLoop(int n) { int res = 0; int i = 1; // 初始化条件变量 // 循环求和 1, 2, ..., n-1, n while (i \u0026lt;= n) { res += i; i++; // 更新条件变量 } return res; } while 循环比 for 循环的自由度更高。在 while 循环中，我们可以自由地设计条件变量的初始化和更新步骤。\n例如在以下代码中，条件变量 𝑖 每轮进行两次更新，这种情况就不太方便用 for 循环实现：\n/* while 循环（两次更新） */ int whileLoopII(int n) { int res = 0; int i = 1; // 初始化条件变量 // 循环求和 1, 4, 10, ... while (i \u0026lt;= n) { res += i; // 更新条件变量 i++; i *= 2; } return res; } 总的来说，for 循环的代码更加紧凑，while 循环更加灵活，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。\n嵌套循环 我们可以在一个循环结构内嵌套另一个循环结构，下面以 for 循环为例：\n/* 双层 for 循环 */ char *nestedForLoop(int n) { // n * n 为对应点数量，\u0026#34;(i, j), \u0026#34; 对应字符串长最大为 6+10*2，加上最后一个空字符 \\0 的额外空间 int size = n * n * 26 + 1; char *res = malloc(size * sizeof(char)); // 循环 i = 1, 2, ..., n-1, n for (int i = 1; i \u0026lt;= n; i++) { // 循环 j = 1, 2, ..., n-1, n for (int j = 1; j \u0026lt;= n; j++) { char tmp[26]; snprintf(tmp, sizeof(tmp), \u0026#34;(%d, %d), \u0026#34;, i, j); strncat(res, tmp, size - strlen(res) - 1); } } return res; } 在这种情况下，函数的操作数量与 $n^2$ 成正比，或者说算法运行时间和输入数据大小 𝑛 成“平方关系”。\n我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。\n递归 递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。\n递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。 归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。 而从实现的角度看，递归代码主要包含三个要素。\n终止条件：用于决定什么时候由“递”转“归”。 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。 返回结果：对应“归”，将当前递归层级的结果返回至上一层。 观察以下代码，我们只需调用函数 recur(n) ，就可以完成 1+2+⋯+𝑛 的计算：\n/* 递归 */ int recur(int n) { // 终止条件 if (n == 1) return 1; // 递：递归调用 int res = recur(n - 1); // 归：返回结果 return n + res; } 虽然从计算角度看，迭代与递归可以得到相同的结果，但它们代表了两种完全不同的思考和解决问题的范式。\n迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。 递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。 以上述求和函数为例，设问题 𝑓(𝑛)=1+2+⋯+𝑛 。\n迭代：在循环中模拟求和过程，从 1 遍历到 𝑛 ，每轮执行求和操作，即可求得 𝑓(𝑛) 。 递归：将问题分解为子问题 𝑓(𝑛)=𝑛+𝑓(𝑛−1) ，不断（递归地）分解下去，直至基本情况 𝑓(1)=1 时终止。 调用栈 递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。\n函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。 在触发终止条件前，同时存在 𝑛 个未返回的递归函数，递归深度为 𝑛 。\n在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。\n尾递归 有趣的是，如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。\n普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。 以计算 1+2+⋯+𝑛 为例，我们可以将结果变量 res 设为函数参数，从而实现尾递归：\n/* 尾递归 */ int tailRecur(int n, int res) { // 终止条件 if (n == 0) return res; // 尾递归调用 return tailRecur(n - 1, res + n); } 对比普通递归和尾递归，两者的求和操作的执行点是不同的。\n普通递归：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。 尾递归：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。 [!tip]\n请注意，许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。\n递归树 当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。\n问题：\n给定一个斐波那契数列0,1,2,3,4\u0026hellip;\u0026hellip;,求该数列的第n个数字\n设斐波那契数列的第 𝑛 个数字为 𝑓(𝑛) ，易得两个结论。\n数列的前两个数字为 𝑓(1)=0 和 𝑓(2)=1 。 数列中的每个数字是前两个数字的和，即 𝑓(𝑛)=𝑓(𝑛−1)+𝑓(𝑛−2) 。 按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。调用 fib(n) 即可得到斐波那契数列的第 𝑛 个数字：\n/* 斐波那契数列：递归 */ int fib(int n) { // 终止条件 f(1) = 0, f(2) = 1 if (n == 1 || n == 2) return n - 1; // 递归调用 f(n) = f(n-1) + f(n-2) int res = fib(n - 1) + fib(n - 2); // 返回结果 f(n) return res; } 观察以上代码，我们在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。这样不断递归调用下去，最终将产生一棵层数为 𝑛 的递归树（recursion tree）。\n从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。\n从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。 时间复杂度 运行时间可以直观且准确地反映算法的效率。如果我们想准确预估一段代码的运行时间，应该如何操作呢？\n确定运行平台，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。 评估各种计算操作所需的运行时间，例如加法操作 + 需要 1 ns ，乘法操作 * 需要 10 ns ，打印操作 print() 需要 5 ns 等。 统计代码中所有的计算操作，并将所有操作的执行时间求和，从而得到运行时间。 例如在以下代码中，输入数据大小为 𝑛 ：\n// 在某运行平台下 void algorithm(int n) { int a = 2; // 1 ns a = a + 1; // 1 ns a = a * 2; // 10 ns // 循环 n 次 for (int i = 0; i \u0026lt; n; i++) { // 1 ns printf(\u0026#34;%d\u0026#34;, 0); // 5 ns } } $$ 1+1+10+(1+5)×𝑛=6𝑛+12 $$ 但实际上，统计算法的运行时间既不合理也不现实。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。\n统计时间增长趋势 时间复杂度分析统计的不是算法运行时间，==而是算法运行时间随着数据量变大时的增长趋势==。\n“时间增长趋势”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 𝑛 ，给定三个算法 A、B 和 C ：\n// 算法 A 的时间复杂度：常数阶 void algorithm_A(int n) { printf(\u0026#34;%d\u0026#34;, 0); } // 算法 B 的时间复杂度：线性阶 void algorithm_B(int n) { for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d\u0026#34;, 0); } } // 算法 C 的时间复杂度：常数阶 void algorithm_C(int n) { for (int i = 0; i \u0026lt; 1000000; i++) { printf(\u0026#34;%d\u0026#34;, 0); } } 三个函数的时间复杂度为：\n算法 A 只有 1 个打印操作，算法运行时间不随着 𝑛 增大而增长。我们称此算法的时间复杂度为“常数阶”。 算法 B 中的打印操作需要循环 𝑛 次，算法运行时间随着 𝑛 增大呈线性增长。此算法的时间复杂度被称为“线性阶”。 算法 C 中的打印操作需要循环 1000000 次，虽然运行时间很长，但它与输入数据大小 𝑛 无关。因此 C 的时间复杂度和 A 相同，仍为“常数阶”。 相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？\n时间复杂度能够有效评估算法效率。例如，算法 B 的运行时间呈线性增长，在 𝑛\u0026gt;1 时比算法 A 更慢，在 𝑛\u0026gt;1000000 时比算法 C 更慢。事实上，只要输入数据大小 𝑛 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势的含义。 时间复杂度的推算方法更简便。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。 时间复杂度也存在一定的局限性。例如，尽管算法 A 和 C 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 B 的时间复杂度比 C 高，但在输入数据大小 𝑛 较小时，算法 B 明显优于算法 C 。对于此类情况，我们时常难以仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。 函数渐进上界 给定一个输入大小为n的函数：\nvoid algorithm(int n) { int a = 1; // +1 a = a + 1; // +1 a = a * 2; // +1 // 循环 n 次 for (int i = 0; i \u0026lt; n; i++) { // +1（每轮都执行 i ++） printf(\u0026#34;%d\u0026#34;, 0); // +1 } } $$ 𝑇(𝑛)=3+2𝑛 $$ 𝑇(𝑛) 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。\n我们将线性阶的时间复杂度记为 𝑂(𝑛) ，这个数学符号称为大 𝑂 记号（big-𝑂 notation），表示函数 𝑇(𝑛) 的渐近上界（asymptotic upper bound）。\n时间复杂度分析本质上是计算“操作数量 𝑇(𝑛)”的渐近上界，它具有明确的数学定义。\n[!TIP]\n若存在正实数 𝑐 和实数 𝑛0 ，使得对于所有的 𝑛\u0026gt;𝑛0 ，均有 𝑇(𝑛)≤𝑐⋅𝑓(𝑛) ，则可认为 𝑓(𝑛) 给出了 𝑇(𝑛) 的一个渐近上界，记为 𝑇(𝑛)=𝑂(𝑓(𝑛)) 。\n计算渐近上界就是寻找一个函数 𝑓(𝑛) ，使得当 𝑛 趋向于无穷大时，𝑇(𝑛) 和 𝑓(𝑛) 处于相同的增长级别，仅相差一个常数项 𝑐 的倍数。\n推算方法 渐近上界的数学味儿有点重，如果你感觉没有完全理解，也无须担心。我们可以先掌握推算方法，在不断的实践中，就可以逐渐领悟其数学意义。\n根据定义，确定 𝑓(𝑛) 之后，我们便可得到时间复杂度 𝑂(𝑓(𝑛)) 。那么如何确定渐近上界 𝑓(𝑛) 呢？总体分为两步：首先统计操作数量，然后判断渐近上界。\n统计操作数量 针对代码，逐行从上到下计算即可。然而，由于上述 𝑐⋅𝑓(𝑛) 中的常数项 𝑐 可以取任意大小，因此操作数量 𝑇(𝑛) 中的各种系数、常数项都可以忽略。根据此原则，可以总结出以下计数简化技巧。\n忽略 𝑇(𝑛) 中的常数项。因为它们都与 𝑛 无关，所以对时间复杂度不产生影响。 省略所有系数。例如，循环 2𝑛 次、5𝑛+1 次等，都可以简化记为 𝑛 次，因为 𝑛 前面的系数对时间复杂度没有影响。 循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用第 1. 点和第 2. 点的技巧。 给定一个函数，我们可以用上述技巧来统计操作数量：\nvoid algorithm(int n) { int a = 1; // +0（技巧 1） a = a + n; // +0（技巧 1） // +n（技巧 2） for (int i = 0; i \u0026lt; 5 * n + 1; i++) { printf(\u0026#34;%d\u0026#34;, 0); } // +n*n（技巧 3） for (int i = 0; i \u0026lt; 2 * n; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { printf(\u0026#34;%d\u0026#34;, 0); } } } $$ T(n)=2n(n+1)+(5n+1)+2=2n^2+7n+3\\\\ T(n)=n^2+n $$ 判断渐近上界 时间复杂度由 𝑇(𝑛) 中最高阶的项来决定。这是因为在 𝑛 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。\n下表展示了一些栗子，其中一些夸张的值是为了强调“系数无法撼动阶数”这一结论。当 𝑛 趋于无穷大时，这些常数变得无足轻重。\n操作数量T(n) 时间复杂度 O(f(n)) 100000 O(1) 3n+2 O(n) 2$n^2$+ 3n + 2 O($n^2$) $n^2$+10000$n^2$ O(n) $2^n+10000n^{10000}$ O($2^n$) 常见类型 $$ O(1)",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E6%A0%91%E7%BB%93%E6%9E%84/",
    "title": "项目文件树",
    
    "content": " 缩写 该项目文件树参考AUTOSAR结构，所以为了便于理解，此处展示部分缩写的全称：\n缩写 全称 描述 AUTOSAR AUTomotive Open System ARchitecture 汽车开放系统架构，是汽车软件开发的标准框架。 ASW Application Software 应用软件，主要负责实现特定功能的业务逻辑。 BSW Basic Software 基础软件，负责底层硬件控制和通用服务的实现。 BSP Board Support Package 板级支持包，包含硬件初始化、驱动和相关工具。 HAL Hardware Abstraction Layer 硬件抽象层，提供对硬件的抽象访问接口。 MCAL Microcontroller Abstraction Layer 微控制器抽象层，提供对芯片外设的直接访问接口。 RTE Run-Time Environment 运行时环境，负责 ASW 与 BSW 的通信管理。 UDS Unified Diagnostic Services 统一诊断服务协议（ISO 14229），用于 ECU 的诊断通信。 Dcm Diagnostic Communication Manager 诊断通信管理模块，实现 UDS 服务的解析和处理。 Dem Diagnostic Event Manager 诊断事件管理模块，负责故障码存储和管理。 PduR Protocol Data Unit Router 协议数据单元路由模块，负责数据路由。 CanTp CAN Transport Protocol CAN 传输协议模块，用于实现 UDS 消息的传输。 NvM Non-Volatile Memory Manager 非易失性内存管理模块，负责数据的持久化存储。 SoAd Socket Adapter 套接字适配器，用于实现基于 TCP/IP 的通信协议（如 DoIP）。 ECU Electronic Control Unit 电子控制单元，是汽车的嵌入式控制器。 GPIO General Purpose Input/Output 通用输入输出，硬件外设的一种。 UART Universal Asynchronous Receiver-Transmitter 通用异步收发器，用于串行通信。 SPI Serial Peripheral Interface 串行外设接口，用于高性能串行通信。 I2C Inter-Integrated Circuit 一种常用的两线串行通信协议。 CAN Controller Area Network 控制器局域网，是汽车通信总线的一种。 FlexRay Flexible Ray 一种高速汽车通信协议，用于安全关键应用。 LIN Local Interconnect Network 局域互连网络，低成本汽车通信协议。 DoIP Diagnostics over Internet Protocol 基于 IP 协议的诊断通信。 OS Operating System 操作系统，提供任务调度和资源管理功能。 SWC Software Component 软件组件，用于实现应用逻辑，是 ASW 层的核心构成模块。 概览 ├─.vscode ├─ASW\t此处存放与硬件平台无关代码 ├─BSW\t存放与硬件相关代码，所以子文件夹需要区分不同芯片型号 ├─BOOT\t存放BOOT相关代码 ├─Documents\t存放项目相关的文档，为了方便使用，最好将使用的芯片的手册放于此处 ├─OS\t存放和系统相关的，如文件系统、操作系统、调度系统等等 ├─Output\t存放输出文件，请在设置Keil和IAR等软件时，选用输出到此文件夹，方便管理，并且增强Project中的整洁性 └─Project\t存放和工程相关的文件树，如KEIL、IAR、SOURCEINSIGHT、TSMATSER、CANoe、JFLASH，与项目相关的工程请放置此处 [!important]\n不知道要将代码放在哪个文件夹中需要参考以下准则：\n与硬件无关的请存放于ASW，也就是逻辑相关 与硬件有关的请存放于BSW，也就是对接硬件平台 OS中存放系统相关，如文件系统、操作系统、调度系统 BOOT中存放和BOOT相关的文件，采用的协议文件，如UDS、OSI [!note]\n为了保持风格的一致性，高两级的文件夹请使用开头大写（ASW、OS、User、Components等），再低级的文件夹就使用小写（inc、src、cfg等）\nASW ├─.vscode ├─ASW\t此处存放与硬件平台无关代码 │ ├─SWC\t此处存放APP相关组件代码，如门窗控制器组件等等 │ │ └─btdm\t此级文件夹下的文件树可以按照自己的喜好存放，如可以将c和h文件放在一起，也可按照不同的文件后缀对文件树进行构建 │ │ ├─inc\t存放头文件 │ │ ├─lib\t存放lib库文件 │ │ └─src\t存放c文件 │ │ └─cfg\t存放cfg文件 │ ├─Scripts\t存放脚本相关文件，如sct、icf、bat、py，和工程相关的脚本文件请都放至此处。在Keil中如果使用可视化宏文件请放置此处 │ ├─User\t一般用于存放main函数和相关app操作函数，一般来说main函数尽量不要有太多的内容，使用函数调用，方便在此基础上修改 │ └─Utils\t存放工具文件，如delay、RTT、coreMark等工具。 [!note]\n注意，ASW中存放和硬件无关的代码，所以在写其中的代码，我们应该要尽量减少和硬件有关的代码，使用抽象代码，如使用定死的函数名访问，我们并不需要知道它下面是怎么实现的，我们只需要调用。（使用定死的函数名方便进行抽象）\n[!important]\n‼‼‼在ASW中写代码，一定要有抽象的概念‼‼‼\n例如SWC是组件的意思，也就意味着，当你写好一个组件，那么我下次使用别的平台的时候可以直接调用你的组件，而不需要再修改很多东西，如定义一个宏开关来控制。\n对于一个组件来说，我只需要知道你的组件的输入和输出即可，所以其中的代码尽量写的抽象，减少重复造轮子。\nBSW ├─BSW\t存放与硬件相关代码，所以需要区分不同芯片型号 │ ├─Bsp\t存放供应商和用户的接口函数 │ │ └─FR3032D\t注意，这里需要定义到芯片的具体型号 │ │ ├─inc │ │ └─src │ ├─Cmsis\t这里存放和芯片内核文件，如core_cm3.h、cmsis_compile.h等等类似文件 │ │ └─FR3032D │ ├─Diagnostics\t这里存放诊断相关文件，如UDS │ │ └─UDS │ ├─Drivers\t这里存放驱动文件 │ │ └─FR3032D │ └─StartUp\t这里存放启动文件，如startUp.s等文件 │ └─FR3032D [!tip]\n需要考虑的是，是否要增加芯片厂商的文件夹，如ZX/FR3032D，如果要制定芯片厂商，请和plm等保持一致的缩写，如ZX代表智芯\nBOOT ├─BOOT │ └───BootLoader\t存放Boot相关的代码，如控制启动流程等 │ ├─inc │ └─src\tDocuments ├─Documents\t存放和项目相关的手册、点检表、变更履历表，如果要存放过多的文件，请使用文件夹分类，便于查阅 │ └─FR3032D\tOS ├─OS\t│ ├─FlashDB\t文件系统 │ │ ├─inc │ │ └─src │ └─FreeRTOS\t操作系统 │ ├─inc │ └─src Output ├─Output │ ├─Listings\t存放链接文件和映射文件，注意该文件夹是软件生成的，在Keil或IAR中设置即可 │ ├─Objects\t存放中间文件，如o文件、obj文件，该文件夹也是软件自动生成的，需要配置 [!note]\n请务必在工程中设置output和listing以保证项目树的整洁性\nProject └─Project ├─KEIL │ └─RTE │ └─_blueTooth ├─SOURCEINSIGHT │ └─blueTooth.si4project │ ├─Backup │ └─cache │ └─parse └─VSCODE [!important]\n和项目相关的工程请存放至此，我们常用的工程有：\nKeil IAR SourceInsight Vscode TSMaster Canoe ZLG JFLash QAC Tessy [!note]\nQAC和Tessy的测试输出报告请不要放置Document中，需要存放在Project下的相关文件夹中\nReadMe ReadMe文件中用来存放和项目相关教程，如Flash、Ram分布，如何使用函数，当使用的时候需要修改哪些等等。\n",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%A0%A1%E9%AA%8C/",
    "title": "校验",
    
    "content": " 校验和 (Checksum) 参考链接 CheckSum算法\u0026amp;ndash;又名累加和校验算法 - 皮卡成球 - 博客园\n原理及步骤 **校验和（Checksum）**是网络协议使用的数据错误检测方法，并且被认为比LRC（纵向冗余校验，Longitudinal Redundancy Check，LRC），VRC和CRC（循环冗余校验（Cyclic Redundancy Codes，CRC））更可靠。此方法在发送方使用校验和生成器，在接收方使用校验和校验器。\n累加和校验算法的实现\n发送方：对要数据累加，得到一个数据和，对和求反，即得到我们的校验值。然后把要发的数据和这个校验值一起发送给接收方。\n接受方：对接收的数据（包括校验和）进行累加，然后加1，如果得到0，那么说明数据没有出现传输错误。\n注意，此处发送方和接收方用于保存累加结果的类型一定要一致，否则加1就无法实现溢出从而无法得到0，校验就会无效。\n步骤：\n校验数据以16bit为单位进行累加求和，校验数据需为偶字节数（不然无法以16bit为累加单位），奇字节数末尾填充0变为偶字节数； 累加和超过16bit，产生进位，将进位当作高16bit，其他数为低16bit，进行相加； 循环步骤2，直到没有进位产生为止，得到sum值 累加和取反得到校验和，即checksum值，存入数据的checksum字段即可。 [!important]\nCheckSum取反主要原理是：\n==原码+反码+1 = 0==\n栗子 八位保存累加和：\n需要发送数据(8bit 2进制)： 10101001 00111001 00001010\n奇字节补0:10101001 00111001 00001010 00000000 10101001 + 00111001 + 00001010 + 00000000 = 11101100(sum值) ~11101100 = 00010011(checksum值) 所以发送的数据就是： 10101001 00111001 00001010 00010011 接收方接收到的数据是： 10101001 00111001 00001010 00010011 10101001 + 00111001 + 00001010 + 00010011 = 11111111(sum值) ~11111111 = 00000000(结果是0， …",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/%E4%B8%AD%E6%96%AD/",
    "title": "中断",
    
    "content": " 概述 打断CPU执行正常的程序，转而处理紧急程序，然后返回原暂停的程序继续运行，就叫中断\n中断的作用和意义 实时控制:在确定时间内对相应事件作出响应，如：温度监控 故障处理:检测到故障，需要第一时间处理，如：电梯门夹人了 数据传输:不确定数据何时会来，如：串口数据接收 [!IMPORTANT]\n中断的意义：高效处理紧急程序，不会一直占用CPU资源\n中断的外部简图 执行流程 NVIC 基本概念 用于统一分配中断优先级和管理中断的\n==Nested vectored interrupt controller==,嵌套向量中断控制器，属于内核(M3/4/7)\nNVIC支持：256个中断(16内核+240外部)，支持：256个优先级，允许裁剪！\nSTM32型号 内核中断 外部中断 中断优先级 STM32F103xx 10 60 16 STM32F407xx 10 82 16 STM32F429xx 10 91 16 STM32F750xx 10 98 16 STM32F767xx 10 110 16 STM32H743xx 10 150 16 STM32H750xx 10 150 16 中断向量表 定义一块固定的内存，以字节对齐，存放各个==中断服务函数程序的首地址==。\n中断向量表定义在==启动文件中==，当发生中断，CPU会自动执行对应的中断服务函数\n相关寄存器 NVIC相关寄存器 位数 寄存器个数 备注 中断使能寄存器（ISER) 32 8 每个位控制一个中断 中断除能寄存器（ICER) 32 8 每个位控制一个中断 应用程序中断及复位控制寄存器（AIRCR) 32 1 位[10:8]控制优先级分组 中断优先级寄存器 （IPR) 8 240 8个位对应一个中断，而 STM32只使用高4位 NVIC还有：中断挂起，解挂，激活标志等非常用功能。\n基本结构 NVIC是一个内核外设，是CPU的小助手\n下图为外部中断，其中的n代表一个外设可能同时占用多个中断通道，所以有n条线\nNVIC只有一个输出口，NVIC根据每个中断的优先级分配中断的先后顺序，通过一个输出口告诉CPU应该处理哪个中断\n中断优先级 ==抢占优先级==(pre):高抢占优先级可以打断正在执行的低抢占优先级中断 ==响应优先级==(sub):当抢占优先级相同时，响应优先级高的先执行，但是不能互相打断 抢占和响应都相同的情况下，自然优先级越高的，先执行 ==自然优先级==：中断向量表的优先级 数值越小，表示优先级越高 [!IMPORTANT]\n抢占优先级 \u0026gt; 响应优先级 \u0026gt; 自然优先级\nNVIC的中断优先级由优先级寄存器的4位(0~15)决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队\n优先级分组 AIRCR[10:8] IPRx bit[7:4]分 配 分配结果 0 111 None : [7:4] 0位抢占优先级，4位响应优先级 1 110 [7] : [6:4] 1位抢占优先级，3位响应优先级 2 101 [7:6] : [5:4] 2位抢占优先级，2位响应优先级 3 100 [7:5] : [4] 3位抢占优先级，1位响应优先级 4 011 [7:4] : None 4位抢占优先级，0位响应优先级 [!note]\n特别提示：一个工程中，一般只设置一次中断优先级分组。\n编号 自然优先级 对应外设 抢占 响应 执行顺序 3 10 RTC 2 1 2 6 13 EXTI0 3 0 4 7 14 EXTI1 2 0 1 -1 6 Systick 3 0 3 [!note]\nEXTI1和RTC可以打断：EXTIO和Systick的中断，获得优先执行！\nEXTI External(Extended)interrupt/event Controller,外部（扩展）中断事件控制器包含20个产生事件/中断请求的边沿检测器，即总共：20条EXTI线(F1)\n中断和事件的理解：\n中断：要进入NVIC,有相应的中断服务函数，需要CPU处理 事件：不进入NVIC,仅用于内部硬件自动控制的，如：TIM、DMA、ADC 产生的中断和事件都会有他们的响应函数\n中断响应申请中断，让CPU执行中断函数 事件响应，外部中断信号不会通向CPU,而是通向其他外设，用来触发其他外设的操作(ADC转换、DMA等) EXTI(Extern Interrupt)外部中断\nEXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序 支持的触发方式：上升沿/下降沿/双边沿/软件触发 支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断 通道数：16个GPIO Pin,外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒 触发响应方式：中断响应/事件响应 [!tip]\n当有多个中断引脚的时候，我们需要选择不同PIN的引脚，比如PA10和PB10就不能同时作为中断引脚\n事件请求表 中断线 F1 F4 F7 H7 EXTI线015：对应GPIO PIN 015 ✔ ✔ ✔ ✔ EXTI线16：PVD输出 ✔ ✔ ✔ 参考H7参考手册（中文版）657页 EXTI线17：RTC闹钟事件 ✔ ✔ ✔ EXTI线18：USB OTG FS唤醒事件 ✔ ✔ ✔ EXTI线19：以太网唤醒事件 ✔ ✔ EXTI线20：USB OTG HS唤醒事件 ✔ ✔ EXTI线21：RTC 入侵和时间戳事件 ✔ ✔ EXTI线22：RTC 唤醒事件 ✔ ✔ EXTI线23：LPTIM1 异步事件 ✔ … 整体结构 每个GPIO端口有16个引脚，而EXTI实际上只有16个通道，所以==每个端口只能有一个中断引脚==，GPIO口加上PVD、RTC、USB、ETH等一共20个信号。\n[!TIP]\n注意，EXTI 5 ~ 9使用同一个中断函数，EXTI 10 ~ 15使用一个中断函数，所以在写中断函数的时候，我们需要根据标志位来区分是哪个中断\n到其他外设的20个信号是事件触发时的信号\n信号方向：==输入线 \u0026gt; 边沿检测电路（用于上升沿触发或者下降沿触发）\u0026gt; 检测上升沿、下降沿、双边沿及软件触发 \u0026gt; 出现分支==\n中断：==如果请求挂起寄存器置1 \u0026gt; NVIC中断控制器== 事件：通过事件屏蔽寄存器做一个开关的作用 -\u0026gt; 脉冲发生器，给一个电平脉冲，用来触发其他外设的动作 AFIO Alternate Function IO,即复用功能lO,主要用于重映射和外部中断映射配置\n调试I○配置：AFIO MAPR[26:24],配置JTAG/SWD的开关状态\n重映射配置：AFIO MAPR,部分外设IO重映射配置\n外部中断配置：AFIO EXTICR1 ~ 4,配置EXTI中断线0 ~ 15对应具体哪个1O口\n[!NOTE]\n特别注意：配置AFIO寄存器之前要使能AFIO时钟，方法如下： HAL RCC AFIO CLK ENABLE(); 对应RCC APB.2ENR寄存器位0\nAFIO主要完成两个任务：\n复用功引脚重映射 中断引脚选择 如将GPIO A PIN1引脚作为TIM1的引脚\nEXTI和IO的对应关系 这里可以看出来一条线只能对应一个口，如不能同时使用PA0和PB0，只能从P[A~K]0中选一个\n中断配置 中断配置步骤：\n使能GPIO时钟：使能GPIO时钟 设置GPIO输入模式：上/下拉/浮空输入 使能AFIO/SYSCFGI时钟：设置AFIO/SYSCFGE时钟开启寄存器 设置EXTI和IO对应关系 设置EXTI屏蔽，上/下：设置EXTI对应通道前的屏蔽和上升沿/下降沿确发，IMR、RTSR/FTSR沿 设置NVIC：分3步：设置优先级分组、设置优先级、使能中断 设计中断服务函数：编写对应中断的中断服务函数！清中断标志！ 实验 void GPIO_init(){\t//配置GPIO和AFIO时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //配置GPIO GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB,\u0026amp;GPIO_InitStructure); //配置AFIO GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource9); //配置EXTI EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line = EXTI_Line9; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(\u0026amp;EXTI_InitStructure); //配置NVIC NVIC_InitTypeDef NVIC_InitStruct; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); NVIC_InitStruct.NVIC_IRQChannel = EXTI9_5_IRQn; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 3; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 3; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(\u0026amp;NVIC_InitStruct); } void EXTI9_5_IRQHandler(void){ if(EXTI_GetITStatus(EXTI_Line9) == SET){ EXTI_ClearITPendingBit(EXTI_Line9); } } ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
  , 
  {
    "objectID": "1740787200",
    "permalink": "/post/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6/%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/",
    "title": "最小系统",
    
    "content": " 是什么 最小系统是保障MCU正常工作的最小电路的组成单元\nblock-beta\rcolumns 3\rMCU:2\rblock\rcolumns 1\r电源电路\r晶振电路\rend\r下载调试电路\rBOOT启动电路\r复位电路\r其他电路:3\r管脚定义 类型 引脚名称 说明 电源 VDD/VSS 电源正（VDD）/负（VSS）引脚，给STM32供电 VDDA/VSSA 模拟部分电源正/负引脚，给STM32内部模拟部分供电 参考电压正/负引脚，给STM32内部ADC/DAC提供参考电压 VREF+/VREF- 100脚及以上的STM32F103型号才有这两个脚 VBAT RTC\u0026amp;后备区域供电引脚，给RTC和后备区域供电。一般VBAT 接电池，用于断电维持RTC工作，如不需要，直接将VBAT 接VDD即可 复位 NRST 复位引脚，用于复位STM32，低电平复位 启动选择引脚，一般这两个脚各接一个下拉电阻即可 启动 BOOT0/BOOT1 其他启动配置说明详见后续分析 晶振 OSC_IN/ OSC_OUT 外部HSE晶振引脚，用于给STM32提供高精度系统时钟 如果使用内部HSI能满足使用需求，这两个脚可以不接晶振 OSC32_IN / OSC32_OUT 外部LSE晶振引脚，用于给STM32内部RTC提供时钟 如果使用内部LSI能满足使用需求，这两个脚可以不接晶振 调试 SWCLK/SWDIO SWD调试引脚，用于调试STM32程序，同时STM32还支持 JTAG调试，不过我们不推荐使用！因为SWD省IO！ 电源电路 在GND和POWER之间一般会连接一个滤波电容，该电容==保证供电电压的稳定性==，一般遇到供电都会加上滤波电容\nBAT一般使用纽扣电池，备用电池是给RTC和备份寄存器服务的，如果不需要这些则可以不使用纽扣电池，VBAT可以直接接POWER或者直接悬空\n复位电路 手动复位：当按下复位按键，NRST直接接地，变成低电平开始复位，反之，则为高电平\n上电复位：当芯片开始上电的时候，vcc将会给电容充电，电容相当于短路，这时NRST与地直接相连，变成低电平开始复位，当电容充满电时，将会变成高电平，实现了上电复位的功能\n电容==充电==过程：当电容开始充电时，它的两极板之间存在电势差，电路中的电流开始流动，电容逐渐储存电荷。刚充电时，电容像是==导线==。\n电容==充满==电时：当电容两端的电压与电源电压相等时，电容停止继续储存电荷，电流也随之停止。此时，电容器相当于==开路==，因为没有电流流过它。\nBOOT启动电路 通过连接引脚或者开关就可以配置BOOT的高低电平，比如接13，BOOT0就变成了高电平\n晶振电路 在晶振的两侧还需要接两个电容作为==起振电容==，如果需要RTC功能，那么还需要额外接一个晶振，OSC32就是32.768KHz（32768为2的15次方），内部RTC电路通过2的15次方分频就可以生成1秒的时间信号了\n[!TIP]\n起振电容的==作用==：\n稳定振荡频率：起振电容与晶振一起形成一个谐振电路（通常是并联谐振电路），用于确定晶振的振荡频率。通过调整电容的值，可以细微调整振荡频率，使其符合预期的设计。\n辅助启动振荡：起振电容为晶体提供适当的相移，使得反馈回路中的正反馈条件满足，从而启动振荡。它们在起振过程中的作用是提供合适的相位补偿，使得振荡可以迅速建立。\n起振电容的==原理==：\n与晶振和回路形成谐振回路：晶体具有一定的等效电感和电容，外部的起振电容与其一起形成谐振回路，决定晶体的工作频率。外部的起振电容值越大，振荡频率会略微降低；电容值越小，频率会略微升高。\n实现正反馈：振荡电路的基本工作条件是需要正反馈，即输入信号和反馈信号的相位相同或相差整数倍的360°。起振电容通过提供适当的相移，使晶体振荡器电路的正反馈得以满足，从而维持振荡。常见的振荡器电路，如Pierce振荡器，正是依赖这些电容来实现所需的相移。\n稳定电路工作状态：晶振电路中的负载电容可以起到稳定电压和电流的作用，避免电路因高频信号波动而产生不稳定的振荡。\n下载和调试电路 串口一键下载电路 ",
    
    "date": "2025-03-01 00:00:00",
    "updated": "2025-03-01 00:00:00"
  }
  
]